{"seed": "// UnaliasFields returns SearchAttributes struct where each search attribute alias is replaced with field name.\n// If no replacement where made, it returns nil which means that original SearchAttributes struct should be used.\nfunc UnaliasFields(\n\tmapperProvider MapperProvider,\n\tsearchAttributes *commonpb.SearchAttributes,\n\tnamespaceName string,\n) (*commonpb.SearchAttributes, error) {\n\tmapper, err := mapperProvider.GetMapper(namespace.Name(namespaceName))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(searchAttributes.GetIndexedFields()) == 0 || mapper == nil {\n\t\treturn nil, nil\n\t}\n\n\tnewIndexedFields := make(map[string]*commonpb.Payload, len(searchAttributes.GetIndexedFields()))\n\tmapped := false\n\tfor saName, saPayload := range searchAttributes.GetIndexedFields() {\n\t\tif !IsMappable(saName) {\n\t\t\tnewIndexedFields[saName] = saPayload\n\t\t\tcontinue\n\t\t}\n\n\t\tfieldName, err := mapper.GetFieldName(saName, namespaceName)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif fieldName != saName {\n\t\t\tmapped = true\n\t\t}\n\t\tnewIndexedFields[fieldName] = saPayload\n\t}\n\n\t// If no alias was mapped, return nil to save on clone operation on caller side.\n\tif !mapped {\n\t\treturn nil, nil\n\t}\n\n\treturn &commonpb.SearchAttributes{IndexedFields: newIndexedFields}, nil\n}", "id": 0, "concepts": ["map iteration", "map cloning", "map value assignment", "error handling (errors.Is)", "standard library usage"], "_raw_llm_output": "map iteration, map cloning, map value assignment, error handling (errors.Is), standard library usage"}
{"seed": "// Returns the initialization vector (for encryption) for the given file.\n// We store the initialization vector as a hex-encoded property in the\n// file so that we don't need to download the file's contents to find the\n// IV.\nfunc getInitializationVector(driveFile *drive.File) ([]byte, error) {\n\tivhex, err := getProperty(driveFile, \"IV\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tiv, err := hex.DecodeString(ivhex)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(iv) != aes.BlockSize {\n\t\treturn nil, fmt.Errorf(\"unexpected length of IV %d\", len(iv))\n\t}\n\treturn iv, nil\n}", "id": 1, "concepts": ["hex encoding", "hex decoding", "property storage", "file manipulation"], "_raw_llm_output": "hex encoding, hex decoding, property storage, file manipulation"}
{"seed": "// ReadStringList reads a full StringList structure from the database based on the supplied row object\nfunc ReadStringList(row *sql.Row, a *StringList) error {\n\terr := row.Scan(&a.SLID, &a.BID, &a.Name, &a.CreateTS, &a.CreateBy, &a.LastModTime, &a.LastModBy)\n\tSkipSQLNoRowsError(&err)\n\treturn err\n}", "id": 9, "concepts": ["sql.Row", "sql.Scan", "sql.ErrNoRows", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql"], "_raw_llm_output": "sql.Row, sql.Scan, sql.ErrNoRows, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql"}
{"seed": "// NewControllerServiceAPI instantiates a new ControllerServiceAPI object\n// This constructor will assign default values to properties that have it defined,\n// and makes sure properties required by API are set, but the set of arguments\n// will change when the set of required properties is changed\nfunc NewControllerServiceAPI() *ControllerServiceAPI {\n\tthis := ControllerServiceAPI{}\n\treturn &this\n}", "id": 17, "concepts": ["constructor", "object instantiation", "property assignment"], "_raw_llm_output": "constructor, object instantiation, property assignment"}
{"seed": "// NewQueryFirewallFieldsParamsWithTimeout creates a new QueryFirewallFieldsParams object\n// with the ability to set a timeout on a request.\nfunc NewQueryFirewallFieldsParamsWithTimeout(timeout time.Duration) *QueryFirewallFieldsParams {\n\treturn &QueryFirewallFieldsParams{\n\t\ttimeout: timeout,\n\t}\n}", "id": 21, "concepts": ["timeout handling", "standard library usage"], "_raw_llm_output": "timeout handling, standard library usage"}
{"seed": "// NewClient instantiates and returns a new instance of *Client, with the given\n// lifecycle.\n//\n// If no lifecycle is given, a HttpLifecycle is used by default.\nfunc NewClient(lifecycle Lifecycle) *Client {\n\tif lifecycle == nil {\n\t\tlifecycle = NewHttpLifecycle(config.Config)\n\t}\n\n\treturn &Client{lifecycle: lifecycle}\n}", "id": 22, "concepts": ["struct definition", "struct initialization", "method definition", "method invocation", "interface definition", "interface implementation", "pointer usage"], "_raw_llm_output": "struct definition, struct initialization, method definition, method invocation, interface definition, interface implementation, pointer usage"}
{"seed": "// MapInt16Float64Ptr takes two inputs -\n// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list\nfunc MapInt16Float64Ptr(f func(*int16) *float64, list []*int16) []*float64 {\n\tif f == nil {\n\t\treturn []*float64{}\n\t}\n\tnewList := make([]*float64, len(list))\n\tfor i, v := range list {\n\t\tnewList[i] = f(v)\n\t}\n\treturn newList\n}", "id": 25, "concepts": ["function definition", "function pointer", "function composition", "function composition with function pointer"], "_raw_llm_output": "function definition, function pointer, function composition, function composition with function pointer"}
{"seed": "// VSpherePlatformNodeNetworkingApplyConfiguration constructs an declarative configuration of the VSpherePlatformNodeNetworking type for use with\n// apply.\nfunc VSpherePlatformNodeNetworking() *VSpherePlatformNodeNetworkingApplyConfiguration {\n\treturn &VSpherePlatformNodeNetworkingApplyConfiguration{}\n}", "id": 29, "concepts": ["declarative configuration", "VSpherePlatformNodeNetworking type", "apply function"], "_raw_llm_output": "declarative configuration, VSpherePlatformNodeNetworking type, apply function"}
{"seed": "// Splits a document up into a slice of lines.\nfunc splitLines(document []byte) []string {\n\tlines := strings.Split(string(document), \"\\n\")\n\t// Skip trailing empty string from Split-ing\n\tif len(lines) > 0 && lines[len(lines)-1] == \"\" {\n\t\tlines = lines[:len(lines)-1]\n\t}\n\treturn lines\n}", "id": 44, "concepts": ["string manipulation", "string splitting", "slice iteration (range loop)", "basic function definition"], "_raw_llm_output": "string manipulation, string splitting, slice iteration (range loop), basic function definition"}
{"seed": "// NewStakingTokenTransactor creates a new write-only instance of StakingToken, bound to a specific deployed contract.\nfunc NewStakingTokenTransactor(address common.Address, transactor bind.ContractTransactor) (*StakingTokenTransactor, error) {\n\tcontract, err := bindStakingToken(address, nil, transactor, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &StakingTokenTransactor{contract: contract}, nil\n}", "id": 46, "concepts": ["bind package usage", "contract binding", "contract deployment"], "_raw_llm_output": "bind package usage, contract binding, contract deployment"}
{"seed": "// sortNameRoles returns a list of name/role pairs, sorted by name.\n// Timeout messages are always sorted towards the end.\nfunc sortNameRoles(names message.NameRoles) []pair {\n\tsorted := make([]pair, 0, len(names))\n\n\tfor n, r := range names {\n\t\tsorted = append(sorted, pair{n, r})\n\t}\n\n\tsort.Slice(sorted, func(i, j int) bool {\n\t\tpi := sorted[i]\n\t\tpj := sorted[j]\n\n\t\tif pi.Role == message.TimeoutRole && pj.Role != message.TimeoutRole {\n\t\t\treturn false\n\t\t}\n\n\t\treturn pi.Name.String() < pj.Name.String()\n\t})\n\n\treturn sorted\n}", "id": 50, "concepts": ["slice sorting", "slice iteration (range loop)", "string comparison", "struct definition", "struct field access", "anonymous function", "sort.Slice"], "_raw_llm_output": "slice sorting, slice iteration (range loop), string comparison, struct definition, struct field access, anonymous function, sort.Slice"}
{"seed": "// ValidateBackupBucket validates a BackupBucket object.\nfunc ValidateBackupBucket(bb *extensionsv1alpha1.BackupBucket) field.ErrorList {\n\tallErrs := field.ErrorList{}\n\tallErrs = append(allErrs, apivalidation.ValidateObjectMeta(&bb.ObjectMeta, true, apivalidation.NameIsDNSSubdomain, field.NewPath(\"metadata\"))...)\n\tallErrs = append(allErrs, ValidateBackupBucketSpec(&bb.Spec, field.NewPath(\"spec\"))...)\n\n\treturn allErrs\n}", "id": 58, "concepts": ["struct definition", "struct field validation", "field.ErrorList", "field.NewPath"], "_raw_llm_output": "struct definition, struct field validation, field.ErrorList, field.NewPath"}
{"seed": "// Namespace retrieves and returns the namespace of current pod.\n// Note that this function should be called in kubernetes pod.\nfunc Namespace() string {\n\treturn gfile.GetContents(kubernetesNamespaceFilePath)\n}", "id": 60, "concepts": ["kubernetes", "file system", "file reading"], "_raw_llm_output": "kubernetes, file system, file reading"}
{"seed": "// Isindex represents the HTML element 'isindex'.\n// For more information visit https://www.w3schools.com/tags/tag_isindex.asp.\nfunc Isindex(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"isindex\", Attributes: attrs, Children: children}\n}", "id": 63, "concepts": ["HTML generation", "HTML element definition", "HTML attribute definition", "HTML child definition"], "_raw_llm_output": "HTML generation, HTML element definition, HTML attribute definition, HTML child definition"}
{"seed": "// CreateSecureScoreControlProfileFromDiscriminatorValue creates a new instance of the appropriate class based on discriminator value\nfunc CreateSecureScoreControlProfileFromDiscriminatorValue(parseNode i878a80d2330e89d26896388a3f487eef27b0a0e6c010c493bf80be1452208f91.ParseNode)(i878a80d2330e89d26896388a3f487eef27b0a0e6c010c493bf80be1452208f91.Parsable, error) {\n    return NewSecureScoreControlProfile(), nil\n}", "id": 67, "concepts": ["interface implementation", "struct definition", "basic function definition", "interface usage"], "_raw_llm_output": "interface implementation, struct definition, basic function definition, interface usage"}
{"seed": "// NicknameHasPrefix applies the HasPrefix predicate on the \"nickname\" field.\nfunc NicknameHasPrefix(v string) predicate.User {\n\treturn predicate.User(sql.FieldHasPrefix(FieldNickname, v))\n}", "id": 73, "concepts": ["predicate.User", "sql.FieldHasPrefix"], "_raw_llm_output": "predicate.User, sql.FieldHasPrefix"}
{"seed": "// HeroRepeatNotIn applies the NotIn predicate on the \"hero_repeat\" field.\nfunc HeroRepeatNotIn(vs ...uint) predicate.User {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.User(func(s *sql.Selector) {\n\t\t// if not arguments were provided, append the FALSE constants,\n\t\t// since we can't apply \"IN ()\". This will make this predicate falsy.\n\t\tif len(vs) == 0 {\n\t\t\ts.Where(sql.False())\n\t\t\treturn\n\t\t}\n\t\ts.Where(sql.NotIn(s.C(FieldHeroRepeat), v...))\n\t})\n}", "id": 102, "concepts": ["sql.Selector", "sql.NotIn", "sql.False", "sql.C", "sql.Where", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn", "sql.NotIn"], "_raw_llm_output": "sql.Selector, sql.NotIn, sql.False, sql.C, sql.Where, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn, sql.NotIn"}
{"seed": "// NewControllerServiceAPIWithDefaults instantiates a new ControllerServiceAPI object\n// This constructor will only assign default values to properties that have it defined,\n// but it doesn't guarantee that properties required by API are set\nfunc NewControllerServiceAPIWithDefaults() *ControllerServiceAPI {\n\tthis := ControllerServiceAPI{}\n\treturn &this\n}", "id": 135, "concepts": ["struct definition", "default value assignment"], "_raw_llm_output": "struct definition, default value assignment"}
{"seed": "// derefFully dereferences pointer values until it reaches a non-pointer value.\n// If a nil pointer is reached it returns the zero value of the eventual\n// non-pointer type. If a non-pointer value is provided it is returned unchanged.\nfunc derefFully(v reflect.Value) reflect.Value {\n\tfor v.Type().Kind() == reflect.Ptr {\n\t\tif v.IsNil() {\n\t\t\tv = reflect.Zero(v.Type().Elem())\n\t\t}\n\t\tv = v.Elem()\n\t}\n\treturn v\n}", "id": 151, "concepts": ["reflect package usage", "pointer dereferencing", "nil pointer handling"], "_raw_llm_output": "reflect package usage, pointer dereferencing, nil pointer handling"}
{"seed": "// RecentTasksActivityLRTimeASC function sorts data by LastRunTime field in ascending order\n// sorting layers: LRTime > LRStatus(ASC) > Name(ASC)\n// function chain according to sorting layers: RecentTasksActivityLRTimeASC > LRTimeSubsortingByLRStatusASC > subsortingByNameASC\nfunc RecentTasksActivityLRTimeASC(p1, p2 interface{}) bool {\n\tp1RTime := p1.(RecentTasksActivity).TaskInstance.LastRunTime.Truncate(time.Minute)\n\tp2RTime := p2.(RecentTasksActivity).TaskInstance.LastRunTime.Truncate(time.Minute)\n\n\tif p1RTime == p2RTime {\n\t\treturn LRTimeSubsortingByLRStatusASC(p1, p2)\n\t}\n\n\treturn p1RTime.Before(p2RTime)\n}", "id": 152, "concepts": ["interface", "function composition", "sorting", "time handling"], "_raw_llm_output": "interface, function composition, sorting, time handling"}
{"seed": "// WithCommandLine sets the command-line parameters.\n// see: https://www.kernel.org/doc/html/latest/admin-guide/kernel-parameters.html\nfunc WithCommandLine(cmdLine string) LinuxBootLoaderOption {\n\treturn func(b *LinuxBootLoader) {\n\t\tb.cmdLine = cmdLine\n\t\tcs := charWithGoString(cmdLine)\n\t\tdefer cs.Free()\n\t\tC.setCommandLineVZLinuxBootLoader(b.Ptr(), cs.CString())\n\t}\n}", "id": 158, "concepts": ["C.setCommandLineVZLinuxBootLoader", "charWithGoString", "LinuxBootLoaderOption", "LinuxBootLoader"], "_raw_llm_output": "C.setCommandLineVZLinuxBootLoader, charWithGoString, LinuxBootLoaderOption, LinuxBootLoader"}
{"seed": "// StatDir gathers information of given directory by depth-first.\n// It returns slice of file list and includes subdirectories if enabled;\n// it returns error and nil slice when error occurs in underlying functions,\n// or given path is not a directory or does not exist.\n//\n// Slice does not include given path itself.\n// If subdirectories is enabled, they will have suffix '/'.\nfunc StatDir(rootPath string, includeDir ...bool) ([]string, error) {\n\tif !IsDir(rootPath) {\n\t\treturn nil, errors.New(\"not a directory or does not exist: \" + rootPath)\n\t}\n\n\tisIncludeDir := false\n\tif len(includeDir) >= 1 {\n\t\tisIncludeDir = includeDir[0]\n\t}\n\treturn statDir(rootPath, \"\", isIncludeDir, false)\n}", "id": 159, "concepts": ["error handling (errors.New)", "directory traversal", "concurrency", "standard library usage"], "_raw_llm_output": "error handling (errors.New), directory traversal, concurrency, standard library usage"}
{"seed": "// SocialAvatarURLGT applies the GT predicate on the \"social_avatar_url\" field.\nfunc SocialAvatarURLGT(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.GT(s.C(FieldSocialAvatarURL), v))\n\t})\n}", "id": 167, "concepts": ["sql.Selector", "sql.Where", "sql.GT", "sql.C", "predicate.User", "predicate.FieldSocialAvatarURL"], "_raw_llm_output": "sql.Selector, sql.Where, sql.GT, sql.C, predicate.User, predicate.FieldSocialAvatarURL"}
{"seed": "// toLabelPairs converts labels.Labels into []*dto.LabelPair. The __name__\n// label is always dropped, since the metric name is retrieved from the family\n// name instead.\n//\n// The quantile label is dropped for summaries, and the le label is dropped for\n// histograms.\nfunc toLabelPairs(mt dto.MetricType, ls labels.Labels) []*dto.LabelPair {\n\tres := make([]*dto.LabelPair, 0, len(ls))\n\tfor _, l := range ls {\n\t\tif l.Name == model.MetricNameLabel {\n\t\t\tcontinue\n\t\t} else if l.Name == model.QuantileLabel && mt == dto.MetricType_SUMMARY {\n\t\t\tcontinue\n\t\t} else if l.Name == model.BucketLabel && mt == dto.MetricType_HISTOGRAM {\n\t\t\tcontinue\n\t\t}\n\n\t\tres = append(res, &dto.LabelPair{\n\t\t\tName:  pointer.String(l.Name),\n\t\t\tValue: pointer.String(l.Value),\n\t\t})\n\t}\n\n\tsort.Slice(res, func(i, j int) bool {\n\t\tswitch {\n\t\tcase *res[i].Name < *res[j].Name:\n\t\t\treturn true\n\t\tcase *res[i].Value < *res[j].Value:\n\t\t\treturn true\n\t\tdefault:\n\t\t\treturn false\n\t\t}\n\t})\n\treturn res\n}", "id": 171, "concepts": ["string sorting", "label manipulation", "label filtering", "label sorting"], "_raw_llm_output": "string sorting, label manipulation, label filtering, label sorting"}
{"seed": "// getSplicedStrList function takes a string and a string slice as an argument, divides the string into different\n// elements divided by ',' and stores these elements in the string slice.\n// It returns the populated string slice as an output.\n//\n// If the given slice hasn't enough space, it will allocate more and return.\nfunc getSplicedStrList(headerValue string, dst []string) []string {\n\tif headerValue == \"\" {\n\t\treturn nil\n\t}\n\n\tvar (\n\t\tindex             int\n\t\tcharacter         rune\n\t\tlastElementEndsAt uint8\n\t\tinsertIndex       int\n\t)\n\tfor index, character = range headerValue + \"$\" {\n\t\tif character == ',' || index == len(headerValue) {\n\t\t\tif insertIndex >= len(dst) {\n\t\t\t\toldSlice := dst\n\t\t\t\tdst = make([]string, len(dst)+(len(dst)>>1)+2)\n\t\t\t\tcopy(dst, oldSlice)\n\t\t\t}\n\t\t\tdst[insertIndex] = utils.TrimLeft(headerValue[lastElementEndsAt:index], ' ')\n\t\t\tlastElementEndsAt = uint8(index + 1)\n\t\t\tinsertIndex++\n\t\t}\n\t}\n\n\tif len(dst) > insertIndex {\n\t\tdst = dst[:insertIndex]\n\t}\n\treturn dst\n}", "id": 180, "concepts": ["string manipulation", "rune handling", "string trimming", "string concatenation", "slice allocation", "slice iteration (range loop)", "basic function definition"], "_raw_llm_output": "string manipulation, rune handling, string trimming, string concatenation, slice allocation, slice iteration (range loop), basic function definition"}
{"seed": "// SocialTypeEqualFold applies the EqualFold predicate on the \"social_type\" field.\nfunc SocialTypeEqualFold(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.EqualFold(s.C(FieldSocialType), v))\n\t})\n}", "id": 185, "concepts": ["sql.Selector", "sql.EqualFold", "sql.C", "predicate.User"], "_raw_llm_output": "sql.Selector, sql.EqualFold, sql.C, predicate.User"}
{"seed": "// PossibleIdentityTypeValues returns an array of possible values for the IdentityType const type.\nfunc PossibleIdentityTypeValues() []IdentityType {\n\treturn []IdentityType{SystemAssigned}\n}", "id": 196, "concepts": ["type definition", "array definition", "const type"], "_raw_llm_output": "type definition, array definition, const type"}
{"seed": "// Acronym_ is a convenience wrapper for Acronym without the attrs argument.\nfunc Acronym_(children ...HTML) HTML {\n  return Acronym(nil, children...)\n}", "id": 202, "concepts": ["function definition", "function call", "function return"], "_raw_llm_output": "function definition, function call, function return"}
{"seed": "// SocialTypeNotIn applies the NotIn predicate on the \"social_type\" field.\nfunc SocialTypeNotIn(vs ...string) predicate.User {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.User(func(s *sql.Selector) {\n\t\t// if not arguments were provided, append the FALSE constants,\n\t\t// since we can't apply \"IN ()\". This will make this predicate falsy.\n\t\tif len(vs) == 0 {\n\t\t\ts.Where(sql.False())\n\t\t\treturn\n\t\t}\n\t\ts.Where(sql.NotIn(s.C(FieldSocialType), v...))\n\t})\n}", "id": 207, "concepts": ["sql.Selector", "sql.NotIn", "sql.False", "predicate.User", "sql.C"], "_raw_llm_output": "sql.Selector, sql.NotIn, sql.False, predicate.User, sql.C"}
{"seed": "// NewSourcesCheckable creates a new instance of SourcesCheckable. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.\nfunc NewSourcesCheckable(t mockConstructorTestingTNewSourcesCheckable) *SourcesCheckable {\n\tmock := &SourcesCheckable{}\n\tmock.Mock.Test(t)\n\n\tt.Cleanup(func() { mock.AssertExpectations(t) })\n\n\treturn mock\n}", "id": 215, "concepts": ["testing interface", "mocking", "cleanup function"], "_raw_llm_output": "testing interface, mocking, cleanup function"}
{"seed": "// Middleware returns a new gorilla/mux middleware handler\n// for tracing requests and reporting errors, using the\n// given tracer, or elasticapm.DefaultTracer if the tracer\n// is nil.\n//\n// This middleware will recover and report panics, so it can\n// be used instead of the gorilla/middleware.RecoveryHandler\n// middleware.\nfunc Middleware(t *elasticapm.Tracer) mux.MiddlewareFunc {\n\treturn func(h http.Handler) http.Handler {\n\t\treturn &apmhttp.Handler{\n\t\t\tHandler:     h,\n\t\t\tRecovery:    apmhttp.NewTraceRecovery(t),\n\t\t\tRequestName: routeRequestName,\n\t\t\tTracer:      t,\n\t\t}\n\t}\n}", "id": 224, "concepts": ["middleware", "gorilla/mux", "elasticapm.DefaultTracer", "elasticapm.Tracer", "apmhttp.Handler", "apmhttp.NewTraceRecovery", "apmhttp.RequestName", "http.Handler", "http.HandlerFunc"], "_raw_llm_output": "middleware, gorilla/mux, elasticapm.DefaultTracer, elasticapm.Tracer, apmhttp.Handler, apmhttp.NewTraceRecovery, apmhttp.RequestName, http.Handler, http.HandlerFunc"}
{"seed": "// H3 represents the HTML element 'h3'.\n// For more information visit https://www.w3schools.com/tags/tag_h3.asp.\nfunc H3(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"h3\", Attributes: attrs, Children: children}\n}", "id": 229, "concepts": ["HTML generation", "HTML element definition", "HTML attribute definition", "HTML element children definition"], "_raw_llm_output": "HTML generation, HTML element definition, HTML attribute definition, HTML element children definition"}
{"seed": "// GetDriveState returns the driving and position state of the vehicle\nfunc GetDriveState(client *http.Client, token *Token, id int) (*DriveState, error) {\n\tresJson, err := GetRequest(client, token, fmt.Sprintf(DriveStateURL, id))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar res DriveStateResponse\n\terr = json.Unmarshal(resJson, &res)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &(res.Response), nil\n}", "id": 235, "concepts": ["http client usage", "json decoding", "error handling", "struct definition", "function definition"], "_raw_llm_output": "http client usage, json decoding, error handling, struct definition, function definition"}
{"seed": "// \u8ba1\u6570\u6392\u5e8f\n//\n// Time: O(n)\n// Space: O(n)\n//\n// Note: n\u4e3a\u6570\u7ec4\u5185\u7684\u6570\u5b57\u53d6\u503c\u533a\u95f4\nfunc CoutingSort(array []int) []int {\n\t// \u627e\u51fa\u6700\u5927\u503c\u548c\u6700\u5c0f\u503c\uff0c\u4ece\u800c\u786e\u5b9a\u754c\u9650\uff0c\u51cf\u5c11\u4e0b\u9762count\u6570\u7ec4\u5185\u5b58\u5f00\u9500\n\tmin, max := util.Min(array...), util.Max(array...)\n\n\t// \u7edf\u8ba1array\u91cc\u8fb9\u6bcf\u4e2a\u6570\u5b57\u7684\u4e2a\u6570, count\u7684\u4e0b\u6807index\u548carray\u91cc\u8fb9\u7684\u5143\u7d20num\u4e4b\u95f4\u7684\n\t// \u5173\u7cfb\u4e3a index=num-min\n\tcount := make([]int, max-min+1)\n\tfor _, num := range array {\n\t\tcount[num-min]++\n\t}\n\n\t// \u6839\u636e\u7edf\u8ba1\u7ed3\u679c\u5bf9\u539f\u6570\u7ec4\u8fdb\u884c\u586b\u5145\n\tpointer := 0\n\tfor index, cnt := range count {\n\t\tfor i := 0; i < cnt; i++ {\n\t\t\tarray[pointer] = index + min\n\t\t\tpointer++\n\t\t}\n\t}\n\n\treturn array\n}", "id": 237, "concepts": ["array iteration", "array manipulation", "array sorting", "array counting", "array filling", "array bounds checking", "array bounds checking"], "_raw_llm_output": "array iteration, array manipulation, array sorting, array counting, array filling, array bounds checking, array bounds checking"}
{"seed": "// Object_ is a convenience wrapper for Object without the attrs argument.\nfunc Object_(children ...HTML) HTML {\n  return Object(nil, children...)\n}", "id": 240, "concepts": ["HTML tag definition", "HTML tag attribute definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", ""], "_raw_llm_output": "HTML tag definition, HTML tag attribute definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition,"}
{"seed": "// NewViewedWordresult initializes viewed result type Wordresult from result\n// type Wordresult using the given view.\nfunc NewViewedWordresult(res *Wordresult, view string) *shiritoriviews.Wordresult {\n\tp := newWordresultView(res)\n\treturn &shiritoriviews.Wordresult{Projected: p, View: \"default\"}\n}", "id": 241, "concepts": ["type casting", "interface implementation", "interface usage", "type casting", "function definition"], "_raw_llm_output": "type casting, interface implementation, interface usage, type casting, function definition"}
{"seed": "// Option represents the HTML element 'option'.\n// For more information visit https://www.w3schools.com/tags/tag_option.asp.\nfunc Option(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"option\", Attributes: attrs, Children: children}\n}", "id": 251, "concepts": ["HTML generation", "HTML tree traversal", "HTML tree manipulation"], "_raw_llm_output": "HTML generation, HTML tree traversal, HTML tree manipulation"}
{"seed": "// csprngShuffle randomizes the order of elements given a CSPRNG. n is\n// the number of elements, which must be >= 0 and < 2\u00b3\u00b9. swap swaps\n// the elements with indexes i and j.\n//\n// This function implements\n// https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle , and is\n// adapted from math/rand.Shuffle from go 1.10.\nfunc csprngShuffle(csprng io.Reader, n int, swap func(i, j int)) error {\n\tif n < 0 {\n\t\tpanic(\"csprngShuffle: n < 0\")\n\t}\n\tif n > ((1 << 31) - 1) {\n\t\tpanic(\"csprngShuffle: n >= 2\u00b3\u00b9\")\n\t}\n\n\tfor i := n - 1; i > 0; i-- {\n\t\tj, err := csprngUint32n(csprng, uint32(i+1))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tswap(i, int(j))\n\t}\n\treturn nil\n}", "id": 281, "concepts": ["cryptographic random number generation", "CSPRNG", "math/rand.Shuffle", "math/rand.Uint32n"], "_raw_llm_output": "cryptographic random number generation, CSPRNG, math/rand.Shuffle, math/rand.Uint32n"}
{"seed": "// NewDeleteFreeIpaByEnvironmentV1ParamsWithHTTPClient creates a new DeleteFreeIpaByEnvironmentV1Params object\n// with the default values initialized, and the ability to set a custom HTTPClient for a request\nfunc NewDeleteFreeIpaByEnvironmentV1ParamsWithHTTPClient(client *http.Client) *DeleteFreeIpaByEnvironmentV1Params {\n\tvar (\n\t\tforcedDefault = bool(false)\n\t)\n\treturn &DeleteFreeIpaByEnvironmentV1Params{\n\t\tForced:     &forcedDefault,\n\t\tHTTPClient: client,\n\t}\n}", "id": 291, "concepts": ["http.Client", "pointer usage", "struct initialization"], "_raw_llm_output": "http.Client, pointer usage, struct initialization"}
{"seed": "// NewStub produces a file that can be instantiated with details from a stat\n// call.\nfunc NewStub(name string, size int64, lastModified time.Time) *File {\n\treturn &File{\n\t\tName:         name,\n\t\tSize:         size,\n\t\tLastModified: lastModified,\n\t}\n}", "id": 307, "concepts": ["struct definition", "struct field access", "time package usage"], "_raw_llm_output": "struct definition, struct field access, time package usage"}
{"seed": "// ReplaceAllComplementFunc returns a copy of b in which all parts that are not\n// matched by re have been replaced by the return value of the function repl\n// applied to the unmatched byte slice.  In other words, b is split according\n// to re, and all components of the split are replaced according to repl.\nfunc ReplaceAllComplementFunc(re *regexp.Regexp, b []byte, repl func([]byte) []byte) []byte {\n\tmatches := re.FindAllIndex(b, -1)\n\tbuf := make([]byte, 0, len(b))\n\tbeg := 0\n\tend := 0\n\n\tfor _, match := range matches {\n\t\tend = match[0]\n\t\tif match[1] != 0 {\n\t\t\tbuf = append(buf, repl(b[beg:end])...)\n\t\t\tbuf = append(buf, b[end:match[1]]...)\n\t\t}\n\t\tbeg = match[1]\n\t}\n\n\tif end != len(b) {\n\t\tbuf = append(buf, repl(b[beg:])...)\n\t}\n\n\treturn buf\n}", "id": 313, "concepts": ["regexp", "regular expression", "string manipulation", "function composition"], "_raw_llm_output": "regexp, regular expression, string manipulation, function composition"}
{"seed": "// NewCheckCanDeleteMonitorResponseWithDefaults instantiates a new CheckCanDeleteMonitorResponse object.\n// This constructor will only assign default values to properties that have it defined,\n// but it doesn't guarantee that properties required by API are set.\nfunc NewCheckCanDeleteMonitorResponseWithDefaults() *CheckCanDeleteMonitorResponse {\n\tthis := CheckCanDeleteMonitorResponse{}\n\treturn &this\n}", "id": 314, "concepts": ["struct instantiation", "struct definition", "struct property definition", "struct property initialization", "struct property assignment"], "_raw_llm_output": "struct instantiation, struct definition, struct property definition, struct property initialization, struct property assignment"}
{"seed": "// ReadDemandSource reads a full DemandSource structure from the database based on the supplied row object\nfunc ReadDemandSource(row *sql.Row, a *DemandSource) error {\n\terr := row.Scan(&a.SourceSLSID, &a.BID, &a.Name, &a.Industry, &a.CreateTS, &a.CreateBy, &a.LastModTime, &a.LastModBy)\n\tSkipSQLNoRowsError(&err)\n\treturn err\n}", "id": 331, "concepts": ["sql.Row", "sql.Scan", "error handling (SkipSQLNoRowsError)", "sql.NullString", "sql.NullInt64"], "_raw_llm_output": "sql.Row, sql.Scan, error handling (SkipSQLNoRowsError), sql.NullString, sql.NullInt64"}
{"seed": "// agentLogEntry returns true if the specified log entry actually contains\n// an encoded agent log entry.\nfunc agentLogEntry(le LogEntry) bool {\n\tif le.Source != agentSourceField {\n\t\treturn false\n\t}\n\n\tmsg := le.Msg\n\tif msg == \"\" {\n\t\treturn false\n\t}\n\n\tif strings.HasPrefix(msg, \"time=\") {\n\t\treturn true\n\t}\n\n\treturn false\n}", "id": 339, "concepts": ["string manipulation", "string prefix check"], "_raw_llm_output": "string manipulation, string prefix check"}
{"seed": "// NewNameIn applies the In predicate on the \"new_name\" field.\nfunc NewNameIn(vs ...string) predicate.User {\n\treturn predicate.User(sql.FieldIn(FieldNewName, vs...))\n}", "id": 347, "concepts": ["sql.FieldIn", "predicate.User", "sql.Field", "sql.Field"], "_raw_llm_output": "sql.FieldIn, predicate.User, sql.Field, sql.Field"}
{"seed": "// NewExpanderWithEnvironment create a new Expander with variables from os.Environ and the provided variables\n//\n// The provided variables overwrite the os.Environ variables\nfunc NewExpanderWithEnvironment(m map[string]string) Expander {\n\tvars := map[string]string{}\n\tfor _, env := range os.Environ() {\n\t\ti := strings.Index(env, \"=\")\n\t\tvars[env[:i]] = env[i+1:]\n\t}\n\tfor key, val := range m {\n\t\tvars[key] = val\n\t}\n\n\treturn NewExpander(vars)\n}", "id": 350, "concepts": ["os.Environ", "map iteration", "map lookup", "map update", "map creation", "map deletion", "map iteration"], "_raw_llm_output": "os.Environ, map iteration, map lookup, map update, map creation, map deletion, map iteration"}
{"seed": "/* \n\u63a8\u9001\u8ba2\u5355 \nalibaba.ele.fengniao.order.push\n\n\u63a8\u9001\u6dd8\u5b9d\u8ba2\u5355\u81f3\u8702\u9e1f\u5f00\u653e\u5e73\u53f0\u914d\u9001\n*/\nfunc AlibabaEleFengniaoOrderPush(clt *core.SDKClient, req *logistic.AlibabaEleFengniaoOrderPushRequest, session string) (*logistic.AlibabaEleFengniaoOrderPushAPIResponse, error) {\n    var resp logistic.AlibabaEleFengniaoOrderPushAPIResponse\n    err := clt.Post(req, &resp, session)\n    if err != nil {\n        return nil, err\n    }\n    return &resp, nil\n}", "id": 354, "concepts": ["struct definition", "interface definition", "function definition", "anonymous function", "function call", "function return", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", ""], "_raw_llm_output": "struct definition, interface definition, function definition, anonymous function, function call, function return, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call,"}
{"seed": "// SocialEmailEQ applies the EQ predicate on the \"social_email\" field.\nfunc SocialEmailEQ(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldSocialEmail), v))\n\t})\n}", "id": 374, "concepts": ["sql package usage", "sql.Selector", "sql.C", "sql.EQ", "predicate.User"], "_raw_llm_output": "sql package usage, sql.Selector, sql.C, sql.EQ, predicate.User"}
{"seed": "// NewPointerFromSignal will return an unsafe pointer to the given\n// object. This is primarily used in conjunction with MethodBindPtrCall.\nfunc NewPointerFromSignal(obj Signal) Pointer {\n\treturn Pointer{base: unsafe.Pointer(obj.getBase())}\n}", "id": 385, "concepts": ["unsafe package usage", "pointer conversion", "unsafe.Pointer"], "_raw_llm_output": "unsafe package usage, pointer conversion, unsafe.Pointer"}
{"seed": "// SocialPayloadLT applies the LT predicate on the \"social_payload\" field.\nfunc SocialPayloadLT(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.LT(s.C(FieldSocialPayload), v))\n\t})\n}", "id": 389, "concepts": ["sql package usage", "sql.Selector", "sql.C", "sql.LT", "sql.Where", "sql.Predicate"], "_raw_llm_output": "sql package usage, sql.Selector, sql.C, sql.LT, sql.Where, sql.Predicate"}
{"seed": "// NewNameNotNil applies the NotNil predicate on the \"new_name\" field.\nfunc NewNameNotNil() predicate.User {\n\treturn predicate.User(sql.FieldNotNull(FieldNewName))\n}", "id": 390, "concepts": ["predicate.User", "sql.FieldNotNull", "sql.Field"], "_raw_llm_output": "predicate.User, sql.FieldNotNull, sql.Field"}
{"seed": "// Applet_ is a convenience wrapper for Applet without the attrs argument.\nfunc Applet_(children ...HTML) HTML {\n  return Applet(nil, children...)\n}", "id": 395, "concepts": ["HTML", "HTML element definition", "HTML element attribute definition"], "_raw_llm_output": "HTML, HTML element definition, HTML element attribute definition"}
{"seed": "// BlobLTE applies the LTE predicate on the \"blob\" field.\nfunc BlobLTE(v []byte) predicate.User {\n\treturn predicate.User(sql.FieldLTE(FieldBlob, v))\n}", "id": 398, "concepts": ["sql.FieldLTE", "sql.FieldEQ", "sql.FieldGT", "sql.FieldGTE", "sql.FieldLT", "sql.FieldLTE", "sql.FieldNE", "sql.FieldNEQ", "sql.FieldIN", "sql.FieldNotIn", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldContains", "sql.FieldNotContains", "sql.FieldStartsWith", "sql.FieldNotStartsWith", "sql.FieldEndsWith", "sql.FieldNotEndsWith", "sql.FieldNull", "sql.FieldNotNull", "sql.FieldExists", "sql.FieldNotExists", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldBetween", "sql.FieldNotBetween", "sql.FieldRegexp", "sql.FieldNotRegexp", "sql.FieldIs", "sql.FieldIsNot", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldBetween", "sql.FieldNotBetween", "sql.FieldRegexp", "sql.FieldNotRegexp", "sql.FieldIs", "sql.FieldIsNot", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldBetween", "sql.FieldNotBetween", "sql.FieldRegexp", "sql.FieldNotRegexp", "sql.FieldIs", "sql.FieldIsNot", "sql.FieldIn", "sql.FieldNotIn", "sql."], "_raw_llm_output": "sql.FieldLTE, sql.FieldEQ, sql.FieldGT, sql.FieldGTE, sql.FieldLT, sql.FieldLTE, sql.FieldNE, sql.FieldNEQ, sql.FieldIN, sql.FieldNotIn, sql.FieldLike, sql.FieldNotLike, sql.FieldContains, sql.FieldNotContains, sql.FieldStartsWith, sql.FieldNotStartsWith, sql.FieldEndsWith, sql.FieldNotEndsWith, sql.FieldNull, sql.FieldNotNull, sql.FieldExists, sql.FieldNotExists, sql.FieldIn, sql.FieldNotIn, sql.FieldBetween, sql.FieldNotBetween, sql.FieldRegexp, sql.FieldNotRegexp, sql.FieldIs, sql.FieldIsNot, sql.FieldIn, sql.FieldNotIn, sql.FieldBetween, sql.FieldNotBetween, sql.FieldRegexp, sql.FieldNotRegexp, sql.FieldIs, sql.FieldIsNot, sql.FieldIn, sql.FieldNotIn, sql.FieldBetween, sql.FieldNotBetween, sql.FieldRegexp, sql.FieldNotRegexp, sql.FieldIs, sql.FieldIsNot, sql.FieldIn, sql.FieldNotIn, sql."}
{"seed": "// HiBlueString is a convenient helper function to return a string with hi-intensity blue\n// foreground.\nfunc HiBlueString(format string, a ...interface{}) (s string) {\n\ts = colorString(FgHiBlue, format, a...)\n\treturn\n}", "id": 430, "concepts": ["string formatting", "color package usage"], "_raw_llm_output": "string formatting, color package usage"}
{"seed": "// DecodeInputInlineQueryResult implements binary de-serialization for InputInlineQueryResultClass.\nfunc DecodeInputInlineQueryResult(buf *bin.Buffer) (InputInlineQueryResultClass, error) {\n\tid, err := buf.PeekID()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tswitch id {\n\tcase InputInlineQueryResultAnimationTypeID:\n\t\t// Decoding inputInlineQueryResultAnimation#a7335216.\n\t\tv := InputInlineQueryResultAnimation{}\n\t\tif err := v.Decode(buf); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to decode InputInlineQueryResultClass: %w\", err)\n\t\t}\n\t\treturn &v, nil\n\tcase InputInlineQueryResultArticleTypeID:\n\t\t// Decoding inputInlineQueryResultArticle#75a3d10c.\n\t\tv := InputInlineQueryResultArticle{}\n\t\tif err := v.Decode(buf); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to decode InputInlineQueryResultClass: %w\", err)\n\t\t}\n\t\treturn &v, nil\n\tcase InputInlineQueryResultAudioTypeID:\n\t\t// Decoding inputInlineQueryResultAudio#4b1c35d4.\n\t\tv := InputInlineQueryResultAudio{}\n\t\tif err := v.Decode(buf); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to decode InputInlineQueryResultClass: %w\", err)\n\t\t}\n\t\treturn &v, nil\n\tcase InputInlineQueryResultContactTypeID:\n\t\t// Decoding inputInlineQueryResultContact#6e08b5d2.\n\t\tv := InputInlineQueryResultContact{}\n\t\tif err := v.Decode(buf); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to decode InputInlineQueryResultClass: %w\", err)\n\t\t}\n\t\treturn &v, nil\n\tcase InputInlineQueryResultDocumentTypeID:\n\t\t// Decoding inputInlineQueryResultDocument#227fd0cd.\n\t\tv := InputInlineQueryResultDocument{}\n\t\tif err := v.Decode(buf); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to decode InputInlineQueryResultClass: %w\", err)\n\t\t}\n\t\treturn &v, nil\n\tcase InputInlineQueryResultGameTypeID:\n\t\t// Decoding inputInlineQueryResultGame#39951fd7.\n\t\tv := InputInlineQueryResultGame{}\n\t\tif err := v.Decode(buf); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to decode InputInlineQueryResultClass: %w\", err)\n\t\t}\n\t\treturn &v, nil\n\tcase InputInlineQueryResultLocationTypeID:\n\t\t// Decoding inputInlineQueryResultLocation#8f7cbe56.\n\t\tv := InputInlineQueryResultLocation{}\n\t\tif err := v.Decode(buf); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to decode InputInlineQueryResultClass: %w\", err)\n\t\t}\n\t\treturn &v, nil\n\tcase InputInlineQueryResultPhotoTypeID:\n\t\t// Decoding inputInlineQueryResultPhoto#bd0b361f.\n\t\tv := InputInlineQueryResultPhoto{}\n\t\tif err := v.Decode(buf); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to decode InputInlineQueryResultClass: %w\", err)\n\t\t}\n\t\treturn &v, nil\n\tcase InputInlineQueryResultStickerTypeID:\n\t\t// Decoding inputInlineQueryResultSticker#10550459.\n\t\tv := InputInlineQueryResultSticker{}\n\t\tif err := v.Decode(buf); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to decode InputInlineQueryResultClass: %w\", err)\n\t\t}\n\t\treturn &v, nil\n\tcase InputInlineQueryResultVenueTypeID:\n\t\t// Decoding inputInlineQueryResultVenue#2049c13d.\n\t\tv := InputInlineQueryResultVenue{}\n\t\tif err := v.Decode(buf); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to decode InputInlineQueryResultClass: %w\", err)\n\t\t}\n\t\treturn &v, nil\n\tcase InputInlineQueryResultVideoTypeID:\n\t\t// Decoding inputInlineQueryResultVideo#66c344e7.\n\t\tv := InputInlineQueryResultVideo{}\n\t\tif err := v.Decode(buf); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to decode InputInlineQueryResultClass: %w\", err)\n\t\t}\n\t\treturn &v, nil\n\tcase InputInlineQueryResultVoiceNoteTypeID:\n\t\t// Decoding inputInlineQueryResultVoiceNote#954da949.\n\t\tv := InputInlineQueryResultVoiceNote{}\n\t\tif err := v.Decode(buf); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to decode InputInlineQueryResultClass: %w\", err)\n\t\t}\n\t\treturn &v, nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unable to decode InputInlineQueryResultClass: %w\", bin.NewUnexpectedID(id))\n\t}\n}", "id": 438, "concepts": ["switch statement", "error handling (errors.Is)", "type casting", "standard library usage"], "_raw_llm_output": "switch statement, error handling (errors.Is), type casting, standard library usage"}
{"seed": "// TransfertobankaccountGTE applies the GTE predicate on the \"transfertobankaccount\" field.\nfunc TransfertobankaccountGTE(v float64) predicate.Bulk {\n\treturn predicate.Bulk(func(s *sql.Selector) {\n\t\ts.Where(sql.GTE(s.C(FieldTransfertobankaccount), v))\n\t})\n}", "id": 440, "concepts": ["sql.Selector", "sql.GTE", "sql.C", "sql.Where", "sql.Bulk", "sql.Predicate"], "_raw_llm_output": "sql.Selector, sql.GTE, sql.C, sql.Where, sql.Bulk, sql.Predicate"}
{"seed": "// NewSynchronizeUserV1ParamsWithContext creates a new SynchronizeUserV1Params object\n// with the default values initialized, and the ability to set a context for a request\nfunc NewSynchronizeUserV1ParamsWithContext(ctx context.Context) *SynchronizeUserV1Params {\n\tvar ()\n\treturn &SynchronizeUserV1Params{\n\n\t\tContext: ctx,\n\t}\n}", "id": 441, "concepts": ["context", "context.Context", "function definition", "function parameter", "function return value"], "_raw_llm_output": "context, context.Context, function definition, function parameter, function return value"}
{"seed": "// BufferLTE applies the LTE predicate on the \"buffer\" field.\nfunc BufferLTE(v []byte) predicate.User {\n\treturn predicate.User(sql.FieldLTE(FieldBuffer, v))\n}", "id": 443, "concepts": ["sql.FieldLTE", "sql.FieldEQ", "sql.FieldGT", "sql.FieldGTE", "sql.FieldLT", "sql.FieldLTE", "sql.FieldNE", "sql.FieldIN", "sql.FieldNotIn", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldRegexp", "sql.FieldNotRegexp", "sql.FieldIs", "sql.FieldIsNot", "sql.FieldIsNull", "sql.FieldIsNotNull", "sql.FieldBetween", "sql.FieldNotBetween", "sql.FieldExists", "sql.FieldNotExists", "sql.FieldContains", "sql.FieldNotContains", "sql.FieldHas", "sql.FieldNotHas", "sql.FieldHasAny", "sql.FieldNotHasAny", "sql.FieldHasAll", "sql.FieldNotHasAll", "sql.FieldHasNone", "sql.FieldNotHasNone", "sql.FieldHasSome", "sql.FieldNotHasSome", "sql.FieldHasExactly", "sql.FieldNotHasExactly", "sql.FieldHasAtLeast", "sql.FieldNotHasAtLeast", "sql.FieldHasAtMost", "sql.FieldNotHasAtMost", "sql.FieldHasAtLeastOne", "sql.FieldNotHasAtLeastOne", "sql.FieldHasAtMostOne", "sql.Field"], "_raw_llm_output": "sql.FieldLTE, sql.FieldEQ, sql.FieldGT, sql.FieldGTE, sql.FieldLT, sql.FieldLTE, sql.FieldNE, sql.FieldIN, sql.FieldNotIn, sql.FieldLike, sql.FieldNotLike, sql.FieldRegexp, sql.FieldNotRegexp, sql.FieldIs, sql.FieldIsNot, sql.FieldIsNull, sql.FieldIsNotNull, sql.FieldBetween, sql.FieldNotBetween, sql.FieldExists, sql.FieldNotExists, sql.FieldContains, sql.FieldNotContains, sql.FieldHas, sql.FieldNotHas, sql.FieldHasAny, sql.FieldNotHasAny, sql.FieldHasAll, sql.FieldNotHasAll, sql.FieldHasNone, sql.FieldNotHasNone, sql.FieldHasSome, sql.FieldNotHasSome, sql.FieldHasExactly, sql.FieldNotHasExactly, sql.FieldHasAtLeast, sql.FieldNotHasAtLeast, sql.FieldHasAtMost, sql.FieldNotHasAtMost, sql.FieldHasAtLeastOne, sql.FieldNotHasAtLeastOne, sql.FieldHasAtMostOne, sql.Field"}
{"seed": "// PossibleOperationsDefinitionOriginValues returns the possible values for the OperationsDefinitionOrigin const type.\nfunc PossibleOperationsDefinitionOriginValues() []OperationsDefinitionOrigin {\n\treturn []OperationsDefinitionOrigin{\n\t\tOperationsDefinitionOriginNotSpecified,\n\t\tOperationsDefinitionOriginSystem,\n\t\tOperationsDefinitionOriginUser,\n\t}\n}", "id": 451, "concepts": ["const type definition", "const type usage", "slice definition", "slice iteration (range loop)", "basic function definition"], "_raw_llm_output": "const type definition, const type usage, slice definition, slice iteration (range loop), basic function definition"}
{"seed": "// NewGetContactsParams creates a new GetContactsParams object\n// with the default values initialized.\nfunc NewGetContactsParams() *GetContactsParams {\n\tvar (\n\t\tlimitDefault  = int32(5000)\n\t\toffsetDefault = int32(0)\n\t)\n\treturn &GetContactsParams{\n\t\tLimit:  &limitDefault,\n\t\tOffset: &offsetDefault,\n\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 453, "concepts": ["struct definition", "pointer usage", "default values"], "_raw_llm_output": "struct definition, pointer usage, default values"}
{"seed": "// StateNotIn applies the NotIn predicate on the \"state\" field.\nfunc StateNotIn(vs ...State) predicate.User {\n\treturn predicate.User(sql.FieldNotIn(FieldState, vs...))\n}", "id": 459, "concepts": ["predicate.User", "sql.FieldNotIn", "standard library usage"], "_raw_llm_output": "predicate.User, sql.FieldNotIn, standard library usage"}
{"seed": "// NewByteMapCache constructs a new, empty ByteMapCache.\nfunc NewByteMapCache() ByteMapCache {\n\treturn ByteMapCache{m: &sync.RWMutex{}, cache: &map[string]ByteTime{}}\n}", "id": 460, "concepts": ["map iteration (range loop)", "concurrency", "sync.RWMutex", "mutexes"], "_raw_llm_output": "map iteration (range loop), concurrency, sync.RWMutex, mutexes"}
{"seed": "// AssertNCHandleDownlinkMetaDataRequest asserts the given downlink meta-data request.\nfunc AssertNCHandleDownlinkMetaDataRequest(req nc.HandleDownlinkMetaDataRequest) Assertion {\n\treturn func(assert *require.Assertions, ts *IntegrationTestSuite) {\n\t\tr := <-ts.NCClient.HandleDownlinkMetaDataChan\n\t\tif !proto.Equal(&r, &req) {\n\t\t\tassert.Equal(req, r)\n\t\t}\n\t}\n}", "id": 471, "concepts": ["interface assertion", "proto package usage", "channel handling", "standard library usage"], "_raw_llm_output": "interface assertion, proto package usage, channel handling, standard library usage"}
{"seed": "// Script represents the HTML element 'script'.\n// For more information visit https://www.w3schools.com/tags/tag_script.asp.\nfunc Script(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"script\", Attributes: attrs, Children: children}\n}", "id": 479, "concepts": ["HTML generation", "HTML tree", "HTML element definition", "HTML attribute definition"], "_raw_llm_output": "HTML generation, HTML tree, HTML element definition, HTML attribute definition"}
{"seed": "// Rt_ is a convenience wrapper for Rt without the attrs argument.\nfunc Rt_(children ...HTML) HTML {\n  return Rt(nil, children...)\n}", "id": 481, "concepts": ["basic function definition", "function overloading", "variadic function argument"], "_raw_llm_output": "basic function definition, function overloading, variadic function argument"}
{"seed": "// Source represents the HTML void element 'source'.\n// For more information visit https://www.w3schools.com/tags/tag_source.asp.\nfunc Source(attrs []htmlgo.Attribute) HTML {\n\treturn &htmlgo.Tree{Tag: \"source\", Attributes: attrs, SelfClosing: true}\n}", "id": 485, "concepts": ["HTML generation", "HTML tree creation", "HTML attribute handling"], "_raw_llm_output": "HTML generation, HTML tree creation, HTML attribute handling"}
{"seed": "// DateTimeIsNil applies the IsNil predicate on the \"dateTime\" field.\nfunc DateTimeIsNil() predicate.Bulk {\n\treturn predicate.Bulk(func(s *sql.Selector) {\n\t\ts.Where(sql.IsNull(s.C(FieldDateTime)))\n\t})\n}", "id": 488, "concepts": ["sql.Selector", "sql.IsNull", "sql.Bulk", "predicate.Bulk", "sql.C", "sql.IsNull"], "_raw_llm_output": "sql.Selector, sql.IsNull, sql.Bulk, predicate.Bulk, sql.C, sql.IsNull"}
{"seed": "// Table represents the HTML element 'table'.\n// For more information visit https://www.w3schools.com/tags/tag_table.asp.\nfunc Table(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"table\", Attributes: attrs, Children: children}\n}", "id": 491, "concepts": ["HTML generation", "HTML element definition", "HTML attribute definition"], "_raw_llm_output": "HTML generation, HTML element definition, HTML attribute definition"}
{"seed": "// ConnectionDirectionPUnknown returns a pointer to ConnectionDirectionVUnknown\nfunc ConnectionDirectionPUnknown() *ConnectionDirection {\n\tv := ConnectionDirectionVUnknown\n\treturn &v\n}", "id": 512, "concepts": ["pointer", "pointer dereference"], "_raw_llm_output": "pointer, pointer dereference"}
{"seed": "// WithUserAgent sets the User-Agent header on all requests, including the passed\n// in value for plugin.\nfunc WithUserAgent(plugin string) Option {\n\tuserAgent := heartbeat.UserAgent(plugin)\n\n\treturn func(c *Client) {\n\t\tc.userAgentHeader = userAgent\n\t}\n}", "id": 520, "concepts": ["function definition", "function composition", "function application", "function signature", "function call", "function argument", "function return value", "function body", "function scope", "function declaration", "function definition", "function type", "function signature", "function parameter", "function parameter type", "function parameter name", "function parameter value", "function parameter assignment", "function parameter declaration", "function parameter initialization", "function parameter initialization value", "function parameter initialization value type", "function parameter initialization value assignment", "function parameter initialization value assignment type", "function parameter initialization value assignment value", "function parameter initialization value assignment value type", "function parameter initialization value assignment value assignment", "function parameter initialization value assignment value type assignment", "function parameter initialization value assignment value type assignment value", "function parameter initialization value assignment value type assignment value type", "function parameter initialization value assignment value type assignment value type assignment", "function parameter initialization value assignment value type assignment value type assignment value", "function parameter initialization value assignment value type assignment value type assignment value type", "function parameter initialization value assignment value type assignment value type assignment value type assignment value", "function parameter initialization value assignment value type assignment value type assignment value type assignment value type", "function parameter initialization value assignment value type assignment value type assignment value type assignment value type assignment value", "function parameter initialization value assignment value type assignment value type assignment value type assignment value type assignment value type", ""], "_raw_llm_output": "function definition, function composition, function application, function signature, function call, function argument, function return value, function body, function scope, function declaration, function definition, function type, function signature, function parameter, function parameter type, function parameter name, function parameter value, function parameter assignment, function parameter declaration, function parameter initialization, function parameter initialization value, function parameter initialization value type, function parameter initialization value assignment, function parameter initialization value assignment type, function parameter initialization value assignment value, function parameter initialization value assignment value type, function parameter initialization value assignment value assignment, function parameter initialization value assignment value type assignment, function parameter initialization value assignment value type assignment value, function parameter initialization value assignment value type assignment value type, function parameter initialization value assignment value type assignment value type assignment, function parameter initialization value assignment value type assignment value type assignment value, function parameter initialization value assignment value type assignment value type assignment value type, function parameter initialization value assignment value type assignment value type assignment value type assignment value, function parameter initialization value assignment value type assignment value type assignment value type assignment value type, function parameter initialization value assignment value type assignment value type assignment value type assignment value type assignment value, function parameter initialization value assignment value type assignment value type assignment value type assignment value type assignment value type,"}
{"seed": "// NicknameContainsFold applies the ContainsFold predicate on the \"nickname\" field.\nfunc NicknameContainsFold(v string) predicate.User {\n\treturn predicate.User(sql.FieldContainsFold(FieldNickname, v))\n}", "id": 522, "concepts": ["sql.FieldContainsFold", "predicate.User", "predicate.FieldContainsFold"], "_raw_llm_output": "sql.FieldContainsFold, predicate.User, predicate.FieldContainsFold"}
{"seed": "// +lifted:source=https://github.com/kubernetes/kubernetes/blob/release-1.26/test/utils/deployment.go#L179-L187\n// +lifted:changed\n\n// GetNewReplicaSet returns a replica set that matches the intent of the given deployment; get ReplicaSetList from client interface.\n// Returns nil if the new replica set doesn't exist yet.\nfunc GetNewReplicaSet(deployment *appsv1.Deployment, f RsListFunc) (*appsv1.ReplicaSet, error) {\n\trsList, err := ListReplicaSetsByDeployment(deployment, f)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn FindNewReplicaSet(deployment, rsList), nil\n}", "id": 524, "concepts": ["struct definition", "interface definition", "function definition", "function definition with return value", "function definition with multiple return values", "function definition with multiple return values and named return values", "function definition with multiple return values and named return values with return value", "function definition with multiple return values and named return values with multiple return values", "function definition with multiple return values and named return values with multiple return values with return value", "function definition with multiple return values and named return values with multiple return values with multiple return values", "function definition with multiple return values and named return values with multiple return values with multiple return values with return value", "function definition with multiple return values and named return values with multiple return values with multiple return values with multiple return values", "function definition with multiple return values and named return values with multiple return values with multiple return values with multiple return values with return value", "function definition with multiple return values and named return values with multiple return values with multiple return values with multiple return values with multiple return values", "function definition with multiple return values and named return values with multiple return values with multiple return values with multiple return values with multiple return values with return value", "function definition with multiple return values and named return values with multiple return values with multiple return values with multiple return values with multiple return values with multiple"], "_raw_llm_output": "struct definition, interface definition, function definition, function definition with return value, function definition with multiple return values, function definition with multiple return values and named return values, function definition with multiple return values and named return values with return value, function definition with multiple return values and named return values with multiple return values, function definition with multiple return values and named return values with multiple return values with return value, function definition with multiple return values and named return values with multiple return values with multiple return values, function definition with multiple return values and named return values with multiple return values with multiple return values with return value, function definition with multiple return values and named return values with multiple return values with multiple return values with multiple return values, function definition with multiple return values and named return values with multiple return values with multiple return values with multiple return values with return value, function definition with multiple return values and named return values with multiple return values with multiple return values with multiple return values with multiple return values, function definition with multiple return values and named return values with multiple return values with multiple return values with multiple return values with multiple return values with return value, function definition with multiple return values and named return values with multiple return values with multiple return values with multiple return values with multiple return values with multiple"}
{"seed": "// IsSlicePtr reports whether v is a slice ptr type.\nfunc IsSlicePtr(v interface{}) bool {\n\treturn kindOf(v) == reflect.Ptr && reflect.TypeOf(v).Elem().Kind() == reflect.Slice\n}", "id": 534, "concepts": ["reflection", "type checking", "interface{}"], "_raw_llm_output": "reflection, type checking, interface{}"}
{"seed": "// GetNotificationUserSubscriberPreferenceService returns an instance of the Notification_User_Subscriber_Preference SoftLayer service\nfunc GetNotificationUserSubscriberPreferenceService(sess *session.Session) Notification_User_Subscriber_Preference {\n\treturn Notification_User_Subscriber_Preference{Session: sess}\n}", "id": 539, "concepts": ["struct definition", "service definition", "session.Session usage"], "_raw_llm_output": "struct definition, service definition, session.Session usage"}
{"seed": "// Parse returns a CandidatePromotionRule by name.\n// It returns an error if there is no known rule by the given name.\nfunc Parse(ruleName string) (CandidatePromotionRule, error) {\n\tswitch ruleName {\n\tcase \"prefer\", \"neutral\", \"prefer_not\", \"must_not\":\n\t\treturn CandidatePromotionRule(ruleName), nil\n\tcase \"must\":\n\t\treturn CandidatePromotionRule(\"\"), fmt.Errorf(\"CandidatePromotionRule: %v not supported yet\", ruleName)\n\tdefault:\n\t\treturn CandidatePromotionRule(\"\"), fmt.Errorf(\"Invalid CandidatePromotionRule: %v\", ruleName)\n\t}\n}", "id": 542, "concepts": ["switch statement", "error handling (fmt.Errorf)", "basic function definition"], "_raw_llm_output": "switch statement, error handling (fmt.Errorf), basic function definition"}
{"seed": "// newWordresultView projects result type Wordresult to projected type\n// WordresultView using the \"default\" view.\nfunc newWordresultView(res *Wordresult) *shiritoriviews.WordresultView {\n\tvres := &shiritoriviews.WordresultView{\n\t\tWord:   &res.Word,\n\t\tExists: &res.Exists,\n\t\tHash:   &res.Hash,\n\t}\n\treturn vres\n}", "id": 547, "concepts": ["struct embedding", "struct composition", "struct field access"], "_raw_llm_output": "struct embedding, struct composition, struct field access"}
{"seed": "// NewHList creates and returns a pointer to a new horizontal list panel\n// with the specified dimensions\nfunc NewHList(width, height float32) *List {\n\n\treturn newList(false, width, height)\n}", "id": 549, "concepts": ["struct definition", "pointer usage", "boolean type", "method definition"], "_raw_llm_output": "struct definition, pointer usage, boolean type, method definition"}
{"seed": "//\n// Asset loads and returns the asset for the given name.\n// It returns an error if the asset could not be found or\n// could not be loaded.\n//\nfunc Asset(name string) ([]byte, error) {\n\tcannonicalName := strings.Replace(name, \"\\\\\", \"/\", -1)\n\tif f, ok := _bindata[cannonicalName]; ok {\n\t\ta, err := f()\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"Asset %s can't read by error: %v\", name, err)\n\t\t}\n\t\treturn a.bytes, nil\n\t}\n\treturn nil, &os.PathError{Op: \"open\", Path: name, Err: os.ErrNotExist}\n}", "id": 554, "concepts": ["package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", "package initialization", ""], "_raw_llm_output": "package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization, package initialization,"}
{"seed": "// Dl represents the HTML element 'dl'.\n// For more information visit https://www.w3schools.com/tags/tag_dl.asp.\nfunc Dl(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"dl\", Attributes: attrs, Children: children}\n}", "id": 558, "concepts": ["HTML tree building", "HTML element definition", "HTML attribute definition"], "_raw_llm_output": "HTML tree building, HTML element definition, HTML attribute definition"}
{"seed": "// TransfertobankaccountLT applies the LT predicate on the \"transfertobankaccount\" field.\nfunc TransfertobankaccountLT(v float64) predicate.Bulk {\n\treturn predicate.Bulk(func(s *sql.Selector) {\n\t\ts.Where(sql.LT(s.C(FieldTransfertobankaccount), v))\n\t})\n}", "id": 560, "concepts": ["sql.Selector", "sql.LT", "sql.C", "sql.Where", "sql.Bulk", "sql.Predicate"], "_raw_llm_output": "sql.Selector, sql.LT, sql.C, sql.Where, sql.Bulk, sql.Predicate"}
{"seed": "// ChannelState_Values returns all elements of the ChannelState enum\nfunc ChannelState_Values() []string {\n\treturn []string{\n\t\tChannelStateRunning,\n\t\tChannelStateStopped,\n\t}\n}", "id": 574, "concepts": ["enum definition", "enum usage"], "_raw_llm_output": "enum definition, enum usage"}
{"seed": "// Samp represents the HTML element 'samp'.\n// For more information visit https://www.w3schools.com/tags/tag_samp.asp.\nfunc Samp(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"samp\", Attributes: attrs, Children: children}\n}", "id": 576, "concepts": ["HTML generation", "HTML element definition", "HTML attribute definition", "HTML child definition"], "_raw_llm_output": "HTML generation, HTML element definition, HTML attribute definition, HTML child definition"}
{"seed": "// PossibleTierTypeValues returns an array of possible values for the TierType const type.\nfunc PossibleTierTypeValues() []TierType {\n\treturn []TierType{Commitment100000AUHours, Commitment10000AUHours, Commitment1000AUHours, Commitment100AUHours, Commitment500000AUHours, Commitment50000AUHours, Commitment5000AUHours, Commitment500AUHours, Consumption}\n}", "id": 580, "concepts": ["array", "const type", "array iteration"], "_raw_llm_output": "array, const type, array iteration"}
{"seed": "// IntValue returns a Value holding the given arg.\nfunc IntValue(n int64) Value {\n\treturn Value{iface: n}\n}", "id": 587, "concepts": ["struct definition", "interface definition", "method definition", "method receiver", "method invocation"], "_raw_llm_output": "struct definition, interface definition, method definition, method receiver, method invocation"}
{"seed": "// SocialAvatarURLGTE applies the GTE predicate on the \"social_avatar_url\" field.\nfunc SocialAvatarURLGTE(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.GTE(s.C(FieldSocialAvatarURL), v))\n\t})\n}", "id": 590, "concepts": ["sql.Selector", "sql.GTE", "sql.C", "sql.Where", "predicate.User"], "_raw_llm_output": "sql.Selector, sql.GTE, sql.C, sql.Where, predicate.User"}
{"seed": "// PhoneLTE applies the LTE predicate on the \"phone\" field.\nfunc PhoneLTE(v string) predicate.User {\n\treturn predicate.User(sql.FieldLTE(FieldPhone, v))\n}", "id": 591, "concepts": ["interface conversion", "interface assertion", "sql.FieldLTE"], "_raw_llm_output": "interface conversion, interface assertion, sql.FieldLTE"}
{"seed": "// Tests that a document, represented as a slice of lines, has a line.  Ignores\n// leading and trailing space.\nfunc hasLine(lines []string, needle string) bool {\n\tfor _, line := range lines {\n\t\ttrimmedLine := strings.Trim(line, \" \\n\")\n\t\tif trimmedLine == needle {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}", "id": 594, "concepts": ["string manipulation", "string comparison", "string trimming", "slice iteration"], "_raw_llm_output": "string manipulation, string comparison, string trimming, slice iteration"}
{"seed": "// A_ is a convenience wrapper for A without the attrs argument.\nfunc A_(children ...HTML) HTML {\n  return A(nil, children...)\n}", "id": 597, "concepts": ["function definition", "variadic function argument", "function return value"], "_raw_llm_output": "function definition, variadic function argument, function return value"}
{"seed": "// TakeLast is a consolidation function which takes the last datapoint which has non nan value.\nfunc TakeLast(values ts.Datapoints) float64 {\n\tfor i := len(values) - 1; i >= 0; i-- {\n\t\tif !math.IsNaN(values[i].Value) {\n\t\t\treturn values[i].Value\n\t\t}\n\t}\n\n\treturn math.NaN()\n}", "id": 613, "concepts": ["slice iteration (for loop)", "slice manipulation", "NaN handling"], "_raw_llm_output": "slice iteration (for loop), slice manipulation, NaN handling"}
{"seed": "/**\n * Takes an MT19937 output and transforms it back into the\n * corresponding element of the MT19937 state array.\n *\n * Useful information on this at:\n *   https://jazzy.id.au/2010/09/22/cracking_random_number_generators_part_3.html\n *   https://www.maths.tcd.ie/~fionn/misc/mt.php\n */\nfunc untemperMT19937Number(y uint32) uint32 {\n\ty ^= y >> 18\n\n\ty ^= y << 15 & 0xefc60000\n\n\tfor i := 0; i < 7; i++ {\n\t\ty ^= y << 7 & 0x9d2c5680\n\t}\n\n\tfor i := 0; i < 3; i++ {\n\t\ty ^= y >> 11\n\t}\n\n\treturn y\n}", "id": 620, "concepts": ["bitwise operations", "bit shifting", "bit masking", "bitwise XOR", "bitwise AND", "bitwise OR", "bitwise NOT", "bitwise left shift", "bitwise right shift", "bitwise left shift", "bitwise right shift", "bitwise left shift", "bitwise right shift", "bitwise left shift", "bitwise right shift", "bitwise left shift", "bitwise right shift", "bitwise left shift", "bitwise right shift", "bitwise left shift", "bitwise right shift", "bitwise left shift", "bitwise right shift", "bitwise left shift", "bitwise right shift", "bitwise left shift", "bitwise right shift", "bitwise left shift", "bitwise right shift", "bitwise left shift", "bitwise right shift", "bitwise left shift", "bitwise right shift", "bitwise left shift", "bitwise right shift", "bitwise left shift", "bitwise right shift", "bitwise left shift", "bitwise right shift", "bitwise left shift", "bitwise right shift", "bitwise left shift", "bitwise right shift", "bitwise left shift", "bitwise right shift", "bitwise left shift", "bitwise right shift", "bitwise left shift", "bitwise right shift", "bitwise left shift", "bitwise right shift", "bitwise left shift", "bitwise"], "_raw_llm_output": "bitwise operations, bit shifting, bit masking, bitwise XOR, bitwise AND, bitwise OR, bitwise NOT, bitwise left shift, bitwise right shift, bitwise left shift, bitwise right shift, bitwise left shift, bitwise right shift, bitwise left shift, bitwise right shift, bitwise left shift, bitwise right shift, bitwise left shift, bitwise right shift, bitwise left shift, bitwise right shift, bitwise left shift, bitwise right shift, bitwise left shift, bitwise right shift, bitwise left shift, bitwise right shift, bitwise left shift, bitwise right shift, bitwise left shift, bitwise right shift, bitwise left shift, bitwise right shift, bitwise left shift, bitwise right shift, bitwise left shift, bitwise right shift, bitwise left shift, bitwise right shift, bitwise left shift, bitwise right shift, bitwise left shift, bitwise right shift, bitwise left shift, bitwise right shift, bitwise left shift, bitwise right shift, bitwise left shift, bitwise right shift, bitwise left shift, bitwise right shift, bitwise left shift, bitwise"}
{"seed": "// DecodeSendEmailResponse returns a decoder for responses returned by the user\n// sendEmail endpoint. restoreBody controls whether the response body should be\n// restored after having been read.\n// DecodeSendEmailResponse may return the following errors:\n//\t- \"email_not_found\" (type *goa.ServiceError): http.StatusNotFound\n//\t- error: internal error\nfunc DecodeSendEmailResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {\n\treturn func(resp *http.Response) (interface{}, error) {\n\t\tif restoreBody {\n\t\t\tb, err := ioutil.ReadAll(resp.Body)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tresp.Body = ioutil.NopCloser(bytes.NewBuffer(b))\n\t\t\tdefer func() {\n\t\t\t\tresp.Body = ioutil.NopCloser(bytes.NewBuffer(b))\n\t\t\t}()\n\t\t} else {\n\t\t\tdefer resp.Body.Close()\n\t\t}\n\t\tswitch resp.StatusCode {\n\t\tcase http.StatusOK:\n\t\t\tvar (\n\t\t\t\tbody SendEmailResponseBody\n\t\t\t\terr  error\n\t\t\t)\n\t\t\terr = decoder(resp).Decode(&body)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, goahttp.ErrDecodingError(\"user\", \"sendEmail\", err)\n\t\t\t}\n\t\t\tp := NewSendEmailResponseDataOK(&body)\n\t\t\tview := \"default\"\n\t\t\tvres := &userviews.ResponseData{p, view}\n\t\t\tif err = userviews.ValidateResponseData(vres); err != nil {\n\t\t\t\treturn nil, goahttp.ErrValidationError(\"user\", \"sendEmail\", err)\n\t\t\t}\n\t\t\tres := user.NewResponseData(vres)\n\t\t\treturn res, nil\n\t\tcase http.StatusNotFound:\n\t\t\tvar (\n\t\t\t\tbody SendEmailEmailNotFoundResponseBody\n\t\t\t\terr  error\n\t\t\t)\n\t\t\terr = decoder(resp).Decode(&body)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, goahttp.ErrDecodingError(\"user\", \"sendEmail\", err)\n\t\t\t}\n\t\t\terr = ValidateSendEmailEmailNotFoundResponseBody(&body)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, goahttp.ErrValidationError(\"user\", \"sendEmail\", err)\n\t\t\t}\n\t\t\treturn nil, NewSendEmailEmailNotFound(&body)\n\t\tdefault:\n\t\t\tbody, _ := ioutil.ReadAll(resp.Body)\n\t\t\treturn nil, goahttp.ErrInvalidResponse(\"user\", \"sendEmail\", resp.StatusCode, string(body))\n\t\t}\n\t}\n}", "id": 635, "concepts": ["http client usage", "http response handling", "error handling (type assertion", "interface assertion)", "error handling (type assertion", "interface assertion)", "error handling (type assertion", "interface assertion)", "error handling (type assertion", "interface assertion)", "error handling (type assertion", "interface assertion)", "error handling (type assertion", "interface assertion)", "error handling (type assertion", "interface assertion)", "error handling (type assertion", "interface assertion)", "error handling (type assertion", "interface assertion)", "error handling (type assertion", "interface assertion)", "error handling (type assertion", "interface assertion)", "error handling (type assertion", "interface assertion)", "error handling (type assertion", "interface assertion)", "error handling (type assertion", "interface assertion)", "error handling (type assertion", "interface assertion)", "error handling (type assertion", "interface assertion)", "error handling (type assertion", "interface assertion)", "error handling (type assertion", "interface assertion)", "error handling (type assertion", "interface assertion)", "error handling (type assertion", "interface assertion)", "error handling (type assertion", "interface assertion)", "error handling (type assertion", "interface assertion)", "error handling (type assertion", "interface assertion)", "error handling (type assertion", "interface assertion)", "error handling (type assertion", "interface assertion)", "error handling (type assertion", "interface assertion)", "error handling (type assertion", "interface assertion)", "error handling (type"], "_raw_llm_output": "http client usage, http response handling, error handling (type assertion, interface assertion), error handling (type assertion, interface assertion), error handling (type assertion, interface assertion), error handling (type assertion, interface assertion), error handling (type assertion, interface assertion), error handling (type assertion, interface assertion), error handling (type assertion, interface assertion), error handling (type assertion, interface assertion), error handling (type assertion, interface assertion), error handling (type assertion, interface assertion), error handling (type assertion, interface assertion), error handling (type assertion, interface assertion), error handling (type assertion, interface assertion), error handling (type assertion, interface assertion), error handling (type assertion, interface assertion), error handling (type assertion, interface assertion), error handling (type assertion, interface assertion), error handling (type assertion, interface assertion), error handling (type assertion, interface assertion), error handling (type assertion, interface assertion), error handling (type assertion, interface assertion), error handling (type assertion, interface assertion), error handling (type assertion, interface assertion), error handling (type assertion, interface assertion), error handling (type assertion, interface assertion), error handling (type assertion, interface assertion), error handling (type assertion, interface assertion), error handling (type"}
{"seed": "// FormatForShell takes a command name and an argument string and returns a\n// command and arguments that pass this command to the shell.  Note that neither\n// the command nor the arguments are quoted.  Consider FormatForShellQuoted\n// instead.\nfunc FormatForShell(name string, args string) (string, []string) {\n\treturn \"sh\", []string{\"-c\", name + \" \" + args}\n}", "id": 646, "concepts": ["command line arguments", "shell quoting", "string manipulation"], "_raw_llm_output": "command line arguments, shell quoting, string manipulation"}
{"seed": "// lookupKeyStack returns a value from the first context in the stack that\n// contains a value for that key. If a value was not found, the reflect.Value zero\n// type is returned.\nfunc lookupKeyStack(key string, contexts []reflect.Value) reflect.Value {\n\tvar v reflect.Value\n\tfor i := len(contexts) - 1; i >= 0; i-- {\n\t\tctx := contexts[i]\n\t\tv = lookupKeyContext(key, ctx)\n\t\tif v.IsValid() {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn v\n}", "id": 647, "concepts": ["reflect package usage", "context handling"], "_raw_llm_output": "reflect package usage, context handling"}
{"seed": "// CustomDnsConfigPropertiesFormat_STATUSGenerator returns a generator of CustomDnsConfigPropertiesFormat_STATUS instances for property testing.\nfunc CustomDnsConfigPropertiesFormat_STATUSGenerator() gopter.Gen {\n\tif customDnsConfigPropertiesFormat_STATUSGenerator != nil {\n\t\treturn customDnsConfigPropertiesFormat_STATUSGenerator\n\t}\n\n\tgenerators := make(map[string]gopter.Gen)\n\tAddIndependentPropertyGeneratorsForCustomDnsConfigPropertiesFormat_STATUS(generators)\n\tcustomDnsConfigPropertiesFormat_STATUSGenerator = gen.Struct(reflect.TypeOf(CustomDnsConfigPropertiesFormat_STATUS{}), generators)\n\n\treturn customDnsConfigPropertiesFormat_STATUSGenerator\n}", "id": 656, "concepts": ["struct", "map", "reflection", "property testing"], "_raw_llm_output": "struct, map, reflection, property testing"}
{"seed": "//Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:\n//\n//Integers in each row are sorted in ascending from left to right.\n//Integers in each column are sorted in ascending from top to bottom.\n//Example:\n//\n//Consider the following matrix:\n//\n//[\n//  [1,   4,  7, 11, 15],\n//  [2,   5,  8, 12, 19],\n//  [3,   6,  9, 16, 22],\n//  [10, 13, 14, 17, 24],\n//  [18, 21, 23, 26, 30]\n//]\n//Given target = 5, return true.\n//\n//Given target = 20, return false.\n\nfunc searchMatrix(matrix [][]int, target int) bool {\n\tif len(matrix) == 0 {\n\t\treturn false\n\t}\n\n\tcurrRow := 0\n\tcurrCol := len(matrix[0]) - 1\n\n\tfor inArea(currRow, currCol, matrix) {\n\t\tif target > matrix[currRow][currCol] {\n\t\t\tcurrRow += 1\n\t\t\tcontinue\n\t\t}\n\t\tif target < matrix[currRow][currCol] {\n\t\t\tcurrCol -= 1\n\t\t\tcontinue\n\t\t}\n\t\tif target == matrix[currRow][currCol] {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}", "id": 658, "concepts": ["binary search", "matrix traversal"], "_raw_llm_output": "binary search, matrix traversal"}
{"seed": "// generateDataKey generates a new data key used to encrypt a key.\n// The first successful response is used. An error is returned only\n// if all regions fail to generate a key.\nfunc generateDataKey(ctx context.Context, clients []AWSKMSClient) (*kms.GenerateDataKeyOutput, error) {\n\tfor i := range clients {\n\t\tc := &clients[i]\n\n\t\tstart := time.Now()\n\n\t\tresp, err := c.KMS.GenerateDataKeyWithContext(ctx, &kms.GenerateDataKeyInput{\n\t\t\tKeyId:   &c.ARN,\n\t\t\tKeySpec: aws.String(kms.DataKeySpecAes256),\n\t\t})\n\n\t\tgenerateDataKeyTimer := metrics.GetOrRegisterTimer(fmt.Sprintf(\"%s.kms.aws.generatedatakey.%s\", appencryption.MetricsPrefix, c.Region), nil)\n\t\tgenerateDataKeyTimer.UpdateSince(start)\n\n\t\tif err != nil {\n\t\t\tlog.Debugf(\"error generating data key in region (%s) trying next region: %s\\n\", c.Region, err)\n\t\t\tcontinue\n\t\t}\n\n\t\treturn resp, nil\n\t}\n\n\treturn nil, errors.New(\"all regions returned errors\")\n}", "id": 664, "concepts": ["AWS KMS", "AWS KMS client", "AWS KMS region", "AWS KMS key ID", "AWS KMS key spec", "AWS KMS data key", "AWS KMS GenerateDataKey API call", "AWS KMS GenerateDataKey API response", "AWS KMS GenerateDataKey API error", "AWS KMS GenerateDataKey API error handling", "AWS KMS GenerateDataKey API error handling", "AWS KMS GenerateDataKey API error handling", "AWS KMS GenerateDataKey API error handling", "AWS KMS GenerateDataKey API error handling", "AWS KMS GenerateDataKey API error handling", "AWS KMS GenerateDataKey API error handling", "AWS KMS GenerateDataKey API error handling", "AWS KMS GenerateDataKey API error handling", "AWS KMS GenerateDataKey API error handling", "AWS KMS GenerateDataKey API error handling", "AWS KMS GenerateDataKey API error handling", "AWS KMS GenerateDataKey API error handling", "AWS KMS GenerateDataKey API error handling", "AWS KMS GenerateDataKey API error handling", "AWS KMS GenerateDataKey API error handling", "AWS KMS GenerateDataKey API error handling", "AWS KMS GenerateDataKey API error handling", "AWS KMS GenerateDataKey API error handling", "AWS KMS GenerateDataKey"], "_raw_llm_output": "AWS KMS, AWS KMS client, AWS KMS region, AWS KMS key ID, AWS KMS key spec, AWS KMS data key, AWS KMS GenerateDataKey API call, AWS KMS GenerateDataKey API response, AWS KMS GenerateDataKey API error, AWS KMS GenerateDataKey API error handling, AWS KMS GenerateDataKey API error handling, AWS KMS GenerateDataKey API error handling, AWS KMS GenerateDataKey API error handling, AWS KMS GenerateDataKey API error handling, AWS KMS GenerateDataKey API error handling, AWS KMS GenerateDataKey API error handling, AWS KMS GenerateDataKey API error handling, AWS KMS GenerateDataKey API error handling, AWS KMS GenerateDataKey API error handling, AWS KMS GenerateDataKey API error handling, AWS KMS GenerateDataKey API error handling, AWS KMS GenerateDataKey API error handling, AWS KMS GenerateDataKey API error handling, AWS KMS GenerateDataKey API error handling, AWS KMS GenerateDataKey API error handling, AWS KMS GenerateDataKey API error handling, AWS KMS GenerateDataKey API error handling, AWS KMS GenerateDataKey API error handling, AWS KMS GenerateDataKey"}
{"seed": "// ValidateSubjectAccessReviewSpec validates a SubjectAccessReviewSpec and returns an\n// ErrorList with any errors.\nfunc ValidateSubjectAccessReviewSpec(spec authorizationapi.SubjectAccessReviewSpec, fldPath *field.Path) field.ErrorList {\n\tallErrs := field.ErrorList{}\n\tif spec.ResourceAttributes != nil && spec.NonResourceAttributes != nil {\n\t\tallErrs = append(allErrs, field.Invalid(fldPath.Child(\"nonResourceAttributes\"), spec.NonResourceAttributes, `cannot be specified in combination with resourceAttributes`))\n\t}\n\tif spec.ResourceAttributes == nil && spec.NonResourceAttributes == nil {\n\t\tallErrs = append(allErrs, field.Invalid(fldPath.Child(\"resourceAttributes\"), spec.NonResourceAttributes, `exactly one of nonResourceAttributes or resourceAttributes must be specified`))\n\t}\n\tif len(spec.User) == 0 && len(spec.Groups) == 0 {\n\t\tallErrs = append(allErrs, field.Invalid(fldPath.Child(\"user\"), spec.User, `at least one of user or group must be specified`))\n\t}\n\n\treturn allErrs\n}", "id": 667, "concepts": ["field.ErrorList", "field.Invalid", "field.Path", "field.Error", "field.Path.Child", "field.Invalid.ErrorList"], "_raw_llm_output": "field.ErrorList, field.Invalid, field.Path, field.Error, field.Path.Child, field.Invalid.ErrorList"}
{"seed": "// ConnectionDirectionPUnknownFutureValue returns a pointer to ConnectionDirectionVUnknownFutureValue\nfunc ConnectionDirectionPUnknownFutureValue() *ConnectionDirection {\n\tv := ConnectionDirectionVUnknownFutureValue\n\treturn &v\n}", "id": 695, "concepts": ["pointer", "pointer dereference", "pointer assignment"], "_raw_llm_output": "pointer, pointer dereference, pointer assignment"}
{"seed": "// IsComparableNumeric checks a value to see if it a numeric value amenable to comparison\nfunc IsComparableNumeric(v interface{}) bool {\n\n\tswitch v.(type) {\n\tcase bool, int, int8, int32, int64,\n\t\tuint, uint8, uint32, uint64,\n\t\tfloat32, float64:\n\n\t\treturn true\n\t}\n\treturn false\n}", "id": 708, "concepts": ["type assertion", "type switch", "basic type definition"], "_raw_llm_output": "type assertion, type switch, basic type definition"}
{"seed": "// WithCollectors adds more collectors to the CollectorIntegration being created.\nfunc WithCollectors(cs ...prometheus.Collector) CollectorIntegrationConfig {\n\treturn func(i *CollectorIntegration) {\n\t\ti.cs = append(i.cs, cs...)\n\t}\n}", "id": 716, "concepts": ["function composition", "functional programming", "function definition", "function composition", "function composition"], "_raw_llm_output": "function composition, functional programming, function definition, function composition, function composition"}
{"seed": "// NewComponentReferenceDTOWithDefaults instantiates a new ComponentReferenceDTO object\n// This constructor will only assign default values to properties that have it defined,\n// but it doesn't guarantee that properties required by API are set\nfunc NewComponentReferenceDTOWithDefaults() *ComponentReferenceDTO {\n\tthis := ComponentReferenceDTO{}\n\treturn &this\n}", "id": 745, "concepts": ["constructor", "default values", "API usage"], "_raw_llm_output": "constructor, default values, API usage"}
{"seed": "// Int returns a pointer to the int value passed in.  Used to\n// set the IPConfig.Interface field.\nfunc Int(v int) *int {\n\treturn &v\n}", "id": 756, "concepts": ["pointer usage", "basic function definition"], "_raw_llm_output": "pointer usage, basic function definition"}
{"seed": "// AsteroidDiameter returns approximate diameter given absolute magnitude H\n// and albedo A.\n//\n// Result is in km.\nfunc AsteroidDiameter(H, A float64) float64 {\n\treturn math.Pow(10, 3.12-.2*H-.5*math.Log10(A))\n}", "id": 759, "concepts": ["math package usage", "basic function definition", "math.Pow", "math.Log10", "math.Pow"], "_raw_llm_output": "math package usage, basic function definition, math.Pow, math.Log10, math.Pow"}
{"seed": "// Placeholders behaves like strings.Join([]string{\"?\",...,\"?\"}, \",\")\nfunc Placeholders(n int) string {\n\treturn strings_.JoinRepeat(\"?\", \",\", n)\n}", "id": 768, "concepts": ["string manipulation", "string repetition", "string joining"], "_raw_llm_output": "string manipulation, string repetition, string joining"}
{"seed": "// stateESign is the state after reading the mantissa, e, and sign in a number,\n// such as after reading `G314e-` or `G0.314e+`.\nfunc stateESign(s *scanner, c byte) int {\n\tif '0' <= c && c <= '9' {\n\t\ts.step = stateE0\n\t\treturn scanContinue\n\t}\n\treturn s.error(c, \"in exponent of numeric literal\")\n}", "id": 772, "concepts": ["state machine", "state transition", "error handling"], "_raw_llm_output": "state machine, state transition, error handling"}
{"seed": "// NewPutOrdersOrderFidProductsOrderProductFidSetInitialTermParamsWithTimeout creates a new PutOrdersOrderFidProductsOrderProductFidSetInitialTermParams object\n// with the ability to set a timeout on a request.\nfunc NewPutOrdersOrderFidProductsOrderProductFidSetInitialTermParamsWithTimeout(timeout time.Duration) *PutOrdersOrderFidProductsOrderProductFidSetInitialTermParams {\n\treturn &PutOrdersOrderFidProductsOrderProductFidSetInitialTermParams{\n\t\ttimeout: timeout,\n\t}\n}", "id": 773, "concepts": ["function definition", "timeout handling", "time package usage"], "_raw_llm_output": "function definition, timeout handling, time package usage"}
{"seed": "// HasPets applies the HasEdge predicate on the \"pets\" edge.\nfunc HasPets() predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\tstep := sqlgraph.NewStep(\n\t\t\tsqlgraph.From(Table, FieldID),\n\t\t\tsqlgraph.Edge(sqlgraph.O2O, false, PetsTable, PetsColumn),\n\t\t)\n\t\tsqlgraph.HasNeighbors(s, step)\n\t})\n}", "id": 783, "concepts": ["sqlgraph package usage", "sql.Selector usage", "sqlgraph.From", "sqlgraph.Edge", "sqlgraph.HasNeighbors"], "_raw_llm_output": "sqlgraph package usage, sql.Selector usage, sqlgraph.From, sqlgraph.Edge, sqlgraph.HasNeighbors"}
{"seed": "// NewClientEncryptionKeyID returns a new ClientEncryptionKeyId struct\nfunc NewClientEncryptionKeyID(subscriptionId string, resourceGroupName string, databaseAccountName string, sqlDatabaseName string, clientEncryptionKeyName string) ClientEncryptionKeyId {\n\treturn ClientEncryptionKeyId{\n\t\tSubscriptionId:          subscriptionId,\n\t\tResourceGroupName:       resourceGroupName,\n\t\tDatabaseAccountName:     databaseAccountName,\n\t\tSqlDatabaseName:         sqlDatabaseName,\n\t\tClientEncryptionKeyName: clientEncryptionKeyName,\n\t}\n}", "id": 786, "concepts": ["struct definition", "struct field definition", "struct field initialization"], "_raw_llm_output": "struct definition, struct field definition, struct field initialization"}
{"seed": "// PrivateEndpointIPConfiguration_STATUSGenerator returns a generator of PrivateEndpointIPConfiguration_STATUS instances for property testing.\nfunc PrivateEndpointIPConfiguration_STATUSGenerator() gopter.Gen {\n\tif privateEndpointIPConfiguration_STATUSGenerator != nil {\n\t\treturn privateEndpointIPConfiguration_STATUSGenerator\n\t}\n\n\tgenerators := make(map[string]gopter.Gen)\n\tAddIndependentPropertyGeneratorsForPrivateEndpointIPConfiguration_STATUS(generators)\n\tprivateEndpointIPConfiguration_STATUSGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointIPConfiguration_STATUS{}), generators)\n\n\treturn privateEndpointIPConfiguration_STATUSGenerator\n}", "id": 789, "concepts": ["reflection", "struct definition", "property testing"], "_raw_llm_output": "reflection, struct definition, property testing"}
{"seed": "// NewDecoder returns a new decoder that reads from r.\n//\n// The decoder introduces its own buffering and may read data from r\n// beyond the requested msgpack values. Buffering can be disabled\n// by passing a reader that implements io.ByteScanner interface.\nfunc NewDecoder(r io.Reader) *Decoder {\n\td := new(Decoder)\n\td.Reset(r)\n\treturn d\n}", "id": 794, "concepts": ["io.Reader", "io.ByteScanner", "io.Reader interface", "io.Writer interface", "io.Closer interface", "io.ByteReader interface", "io.ByteWriter interface", "io.Seeker interface", "io.SeekerAt interface", "io.ReaderFrom interface", "io.WriterTo interface", "io.ReadWriter interface", "io.ReadCloser interface", "io.WriteCloser interface", "io.ReadWriteCloser interface", "io.ReadWriteSeeker interface", "io.ReadWriteSeekerAt interface", "io.ReadAtSeeker interface", "io.ReadSeeker interface", "io.ReadSeekerAt interface", "io.ByteScanner interface", "io.ByteWriter interface", "io.ByteReader interface", "io.ByteReader interface", "io.ByteWriter interface", "io.ByteReader interface", "io.ByteWriter interface", "io.ByteReader interface", "io.ByteWriter interface", "io.ByteReader interface", "io.ByteWriter interface", "io.ByteReader interface", "io.ByteWriter interface", "io.ByteReader interface", "io.ByteWriter interface", "io.ByteReader interface", "io.ByteWriter interface", "io.ByteReader interface", "io.ByteWriter interface", "io.ByteReader interface", "io.ByteWriter interface", "io.ByteReader interface", ""], "_raw_llm_output": "io.Reader, io.ByteScanner, io.Reader interface, io.Writer interface, io.Closer interface, io.ByteReader interface, io.ByteWriter interface, io.Seeker interface, io.SeekerAt interface, io.ReaderFrom interface, io.WriterTo interface, io.ReadWriter interface, io.ReadCloser interface, io.WriteCloser interface, io.ReadWriteCloser interface, io.ReadWriteSeeker interface, io.ReadWriteSeekerAt interface, io.ReadAtSeeker interface, io.ReadSeeker interface, io.ReadSeekerAt interface, io.ByteScanner interface, io.ByteWriter interface, io.ByteReader interface, io.ByteReader interface, io.ByteWriter interface, io.ByteReader interface, io.ByteWriter interface, io.ByteReader interface, io.ByteWriter interface, io.ByteReader interface, io.ByteWriter interface, io.ByteReader interface, io.ByteWriter interface, io.ByteReader interface, io.ByteWriter interface, io.ByteReader interface, io.ByteWriter interface, io.ByteReader interface, io.ByteWriter interface, io.ByteReader interface, io.ByteWriter interface, io.ByteReader interface,"}
{"seed": "// DefaultConfigFile returns the path of paddlecloud default config file path\nfunc DefaultConfigFile() string {\n\treturn filepath.Join(pathutil.UserHomeDir(), \".paddle\", \"config\")\n}", "id": 805, "concepts": ["string manipulation", "filepath package usage"], "_raw_llm_output": "string manipulation, filepath package usage"}
{"seed": "// ValueAlloc() allocates a Value and sets a runtime finalizer to call\n// g_value_unset() on the underlying GValue after leaving scope.\n// ValueAlloc() returns a non-nil error if the allocation failed.\nfunc ValueAlloc() (*Value, error) {\n\tc := C._g_value_alloc()\n\tif c == nil {\n\t\treturn nil, nilPtrErr\n\t}\n\tv := &Value{*c}\n\truntime.SetFinalizer(v, (*Value).unset)\n\treturn v, nil\n}", "id": 824, "concepts": ["runtime.SetFinalizer", "C.g_value_alloc", "C.g_value_unset", "nil pointer handling"], "_raw_llm_output": "runtime.SetFinalizer, C.g_value_alloc, C.g_value_unset, nil pointer handling"}
{"seed": "// IsKindNamespace returns true if the passed Unstructured object is\n// GroupKind == Core/Namespace (no version checked); false otherwise.\nfunc IsKindNamespace(u *unstructured.Unstructured) bool {\n\tif u == nil {\n\t\treturn false\n\t}\n\tgvk := u.GroupVersionKind()\n\treturn CoreNamespace == gvk.GroupKind()\n}", "id": 833, "concepts": ["unstructured package usage", "GroupKind", "type comparison"], "_raw_llm_output": "unstructured package usage, GroupKind, type comparison"}
{"seed": "/**\n * Create a cryptographic hash by converting all the fields of a Block to binary.\n * The result is a hexadecimal string, since the `sha256` function is used, the result\n * is always 64 characters long (32 bytes or 256 bits).\n *\n * To simplify the rest of the code, `HashBlock(nil)` is not an error.\n * Instead we return all zeros of the correct length.\n */\nfunc HashBlock(block *Block) string {\n    if block == nil {\n        return \"0000000000000000000000000000000000000000000000000000000000000000\"\n    }\n\n    // This function converts the block to bytes by writing the fields into a Buffer,\n    // then sending the Buffer contents to an sha256 object.  We do it this way so it\n    // is easy to examine the bytes by printing the Buffer contents.\n\n    buf := new(bytes.Buffer)\n\n    // Write the PrevHash field\n    binPrevBlockHash, err := hex.DecodeString(block.PrevHash)\n    if err != nil { panic(\"Error decoding block.PrevHash\") }\n    buf.Write(binPrevBlockHash)\n\n    // Write the Height field\n    err = binary.Write(buf, binary.LittleEndian, block.Height)\n    if err != nil { panic(\"Error writing block.Height\") }\n\n    // Done writing fields, get the Buffer contents\n    blockBytes := buf.Bytes()\n\n    // Uncomment one of these statements to print out the bytes\n    // fmt.Printf(\"%s\\n\", hex.Dump(blockBytes))              // Pretty hex dump format\n    // fmt.Printf(\"%s\\n\", hex.EncodeToString(blockBytes))    // Mashed-together characters format\n\n    // Compute the hash of blockBytes using the sha256 cryptographic hash algorithm\n    hasher := sha256.New()\n    hasher.Write(blockBytes)\n    hash := hex.EncodeToString(hasher.Sum(nil))\n\n    // Uncomment this statement to print out the hash\n    // fmt.Printf(\"The hash of these bytes is %s\\n\", hash)\n\n    return hash\n}", "id": 834, "concepts": ["cryptographic hash", "sha256", "hex encoding", "binary encoding", "buffering", "error handling", "standard library usage"], "_raw_llm_output": "cryptographic hash, sha256, hex encoding, binary encoding, buffering, error handling, standard library usage"}
{"seed": "// Footer_ is a convenience wrapper for Footer without the attrs argument.\nfunc Footer_(children ...HTML) HTML {\n  return Footer(nil, children...)\n}", "id": 837, "concepts": ["function definition", "variadic function argument", "type conversion"], "_raw_llm_output": "function definition, variadic function argument, type conversion"}
{"seed": "// IpAddressStatus_Values returns all elements of the IpAddressStatus enum\nfunc IpAddressStatus_Values() []string {\n\treturn []string{\n\t\tIpAddressStatusCreating,\n\t\tIpAddressStatusFailedCreation,\n\t\tIpAddressStatusAttaching,\n\t\tIpAddressStatusAttached,\n\t\tIpAddressStatusRemapDetaching,\n\t\tIpAddressStatusRemapAttaching,\n\t\tIpAddressStatusDetaching,\n\t\tIpAddressStatusFailedResourceGone,\n\t\tIpAddressStatusDeleting,\n\t\tIpAddressStatusDeleteFailedFasExpired,\n\t\tIpAddressStatusUpdating,\n\t\tIpAddressStatusUpdateFailed,\n\t}\n}", "id": 854, "concepts": ["enum handling", "string slice definition", "string slice iteration"], "_raw_llm_output": "enum handling, string slice definition, string slice iteration"}
{"seed": "// NewBarChart returns a new *BarChart with current theme.\nfunc NewBarChart() *BarChart {\n\treturn &BarChart{\n\t\tBlock:     *NewBlock(),\n\t\tBarColor:  ThemeAttr(\"barchart.bar.bg\"),\n\t\tNumColor:  ThemeAttr(\"barchart.num.fg\"),\n\t\tTextColor: ThemeAttr(\"barchart.text.fg\"),\n\t\tNumFmt:    func(n int) string { return fmt.Sprint(n) },\n\t\tBarGap:    1,\n\t\tBarWidth:  3,\n\t\tCellChar:  ' ',\n\t}\n}", "id": 858, "concepts": ["struct definition", "function definition", "pointer usage", "method definition", "anonymous function usage", "function composition"], "_raw_llm_output": "struct definition, function definition, pointer usage, method definition, anonymous function usage, function composition"}
{"seed": "// MessageType_Values returns all elements of the MessageType enum\nfunc MessageType_Values() []string {\n\treturn []string{\n\t\tMessageTypeSpliceInsert,\n\t\tMessageTypeTimeSignal,\n\t}\n}", "id": 859, "concepts": ["enum", "string conversion", "array iteration"], "_raw_llm_output": "enum, string conversion, array iteration"}
{"seed": "// Perform binary search to find a string in a slice, by returning its index.\n// If not found, -1 will be returned.\n// The algorithm is simply implemented by using the sort library.\nfunc stringBinarySearch(slice []string, elem string) int {\n\tidx := sort.SearchStrings(slice, elem)\n\n\tif idx != len(slice) && slice[idx] == elem {\n\t\treturn idx\n\t} else {\n\t\treturn -1\n\t}\n}", "id": 863, "concepts": ["sort library", "string search"], "_raw_llm_output": "sort library, string search"}
{"seed": "// PossibleRegionalityValues returns the possible values for the Regionality const type.\nfunc PossibleRegionalityValues() []Regionality {\n\treturn []Regionality{\n\t\tRegionalityGlobal,\n\t\tRegionalityNotSpecified,\n\t\tRegionalityRegional,\n\t}\n}", "id": 864, "concepts": ["const type", "possible values"], "_raw_llm_output": "const type, possible values"}
{"seed": "// Apply applies all the given middleware to provided\n// handler function and then returns it.\nfunc Apply(handler Handler, middleware ...Middleware) Handler {\n\th := handler\n\tfor _, m := range middleware {\n\t\th = m(h)\n\t}\n\treturn h\n}", "id": 876, "concepts": ["function composition", "function definition", "function signature"], "_raw_llm_output": "function composition, function definition, function signature"}
{"seed": "// FillPolicy_Values returns all elements of the FillPolicy enum\nfunc FillPolicy_Values() []string {\n\treturn []string{\n\t\tFillPolicyFullAvailOnly,\n\t\tFillPolicyPartialAvail,\n\t}\n}", "id": 878, "concepts": ["enum", "string formatting", "type conversion"], "_raw_llm_output": "enum, string formatting, type conversion"}
{"seed": "// Compress compresses the file inPath using tmpDir fo storing the compressed output file and\n// any intermediate temporary files it might need to create. It returns the full path to the\n// compressed file, or an error.\nfunc Compress(inPath string, tmpDir string) (string, error) {\n\t// create a temporary file with a unique name compress it -- multiple files\n\t// are named 000: pg_notify/0000, pg_subtrans/0000\n\toutFile, err := ioutil.TempFile(tmpDir, \"pgCarpenter.\")\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// open input file\n\tinFile, err := os.Open(inPath)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\t// we open this for read only, and this process exists after a finite (short)\n\t// period of time; there's no need to throw an error if closing it fails\n\tdefer inFile.Close()\n\n\t// buffer read from the input file and lz4 writer\n\tr := bufio.NewReader(inFile)\n\tw := lz4.NewWriter(outFile)\n\n\t// read 4k at a time\n\tbuf := make([]byte, 4096)\n\tfor {\n\t\tn, err := r.Read(buf)\n\t\tif err != nil && err != io.EOF {\n\t\t\treturn \"\", err\n\t\t}\n\n\t\t// we're done\n\t\tif n == 0 {\n\t\t\tbreak\n\t\t}\n\n\t\t// write the 4k chunk\n\t\tif _, err := w.Write(buf[:n]); err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t}\n\n\t// flush any pending compressed data\n\tif err = w.Flush(); err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// make sure we successfully close the compressed file\n\tif err := outFile.Close(); err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn outFile.Name(), nil\n}", "id": 884, "concepts": ["file handling", "io.Reader", "io.Writer", "io.EOF", "io.ReadWriter", "io.Closer", "ioutil.TempFile", "os.Open", "os.Create", "os.File.Close", "bufio.NewReader", "bufio.Writer", "lz4.NewWriter", "lz4.Writer.Write", "lz4.Writer.Flush", "lz4.Writer.Close", "os.File.Name"], "_raw_llm_output": "file handling, io.Reader, io.Writer, io.EOF, io.ReadWriter, io.Closer, ioutil.TempFile, os.Open, os.Create, os.File.Close, bufio.NewReader, bufio.Writer, lz4.NewWriter, lz4.Writer.Write, lz4.Writer.Flush, lz4.Writer.Close, os.File.Name"}
{"seed": "// AssertASNoHandleTxAckRequest asserts that there is no tx ack request.\nfunc AssertASNoHandleTxAckRequest() Assertion {\n\treturn func(assert *require.Assertions, ts *IntegrationTestSuite) {\n\t\ttime.Sleep(100 * time.Millisecond)\n\t\tselect {\n\t\tcase <-ts.ASClient.HandleTxAckChan:\n\t\t\tassert.Fail(\"unexpected tx ack request\")\n\t\tdefault:\n\t\t}\n\t}\n}", "id": 887, "concepts": ["channel", "select statement", "standard library usage"], "_raw_llm_output": "channel, select statement, standard library usage"}
{"seed": "// Details represents the HTML element 'details'.\n// For more information visit https://www.w3schools.com/tags/tag_details.asp.\nfunc Details(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"details\", Attributes: attrs, Children: children}\n}", "id": 891, "concepts": ["HTML generation", "HTML tree", "HTML element", "HTML attribute"], "_raw_llm_output": "HTML generation, HTML tree, HTML element, HTML attribute"}
{"seed": "// \u7b2c\u4e00\u9636\u6bb5\u534f\u5546\uff0c\u89e3\u6790 client \u7684\u5305\nfunc parseSocksAuthRequest(conn net.Conn) (*SocksAuthRequest, error) {\n\tb := make([]byte, 257)\n\tn, err := conn.Read(b)\n\n\tif n >= 3 {\n\t\tsocksAuthRequest := &SocksAuthRequest{\n\t\t\tVERSION:  int32(b[0]),\n\t\t\tNMETHODS: int32(b[1]),\n\t\t\tMETHODS:  b[2:n],\n\t\t}\n\t\tutils.Logger.Debug(\"\u4e00\u6b21\u534f\u5546\u8bf7\u6c42: \", *socksAuthRequest)\n\t\tif socksAuthRequest.VERSION != 5 {\n\t\t\treturn nil, errors.New(\"\u53ea\u652f\u6301 SOCKS5 \u534f\u8bae\uff0c\u8be5\u534f\u8bae\u4e3a SOCKS\"+strconv.Itoa(int(socksAuthRequest.VERSION)))\n\t\t}\n\t\treturn socksAuthRequest, nil\n\t}\n\tutils.Logger.Debug(\"\u8ba4\u8bc1\u534f\u8bae\u683c\u5f0f\u9519\u8bef\")\n\tutils.Logger.Debug(\"length: \", n)\n\treturn nil, err\n}", "id": 896, "concepts": ["net/http", "net/url", "net/http/httputil", "net/http/cookiejar", "net/http/cookie", "net/http/httptrace", "net/http/httptest", "net/http/httptrace", "net/http/httputil", "net/http/httptrace", "net/http/httputil", "net/http/httptrace", "net/http/httputil", "net/http/httptrace", "net/http/httputil", "net/http/httptrace", "net/http/httputil", "net/http/httptrace", "net/http/httputil", "net/http/httptrace", "net/http/httputil", "net/http/httptrace", "net/http/httputil", "net/http/httptrace", "net/http/httputil", "net/http/httptrace", "net/http/httputil", "net/http/httptrace", "net/http/httputil", "net/http/httptrace", "net/http/httputil", "net/http/httptrace", "net/http/httputil", "net/http/httptrace", "net/http/httputil", "net/http/httptrace", "net/http/httputil", "net/http"], "_raw_llm_output": "net/http, net/url, net/http/httputil, net/http/cookiejar, net/http/cookie, net/http/httptrace, net/http/httptest, net/http/httptrace, net/http/httputil, net/http/httptrace, net/http/httputil, net/http/httptrace, net/http/httputil, net/http/httptrace, net/http/httputil, net/http/httptrace, net/http/httputil, net/http/httptrace, net/http/httputil, net/http/httptrace, net/http/httputil, net/http/httptrace, net/http/httputil, net/http/httptrace, net/http/httputil, net/http/httptrace, net/http/httputil, net/http/httptrace, net/http/httputil, net/http/httptrace, net/http/httputil, net/http/httptrace, net/http/httputil, net/http/httptrace, net/http/httputil, net/http/httptrace, net/http/httputil, net/http"}
{"seed": "// Audio_ is a convenience wrapper for Audio without the attrs argument.\nfunc Audio_(children ...HTML) HTML {\n  return Audio(nil, children...)\n}", "id": 898, "concepts": ["function definition", "function argument", "function return", "function call", "function composition", "function composition with multiple arguments", "anonymous function", "function composition with multiple return values", "function composition with multiple return values and multiple arguments"], "_raw_llm_output": "function definition, function argument, function return, function call, function composition, function composition with multiple arguments, anonymous function, function composition with multiple return values, function composition with multiple return values and multiple arguments"}
{"seed": "// sortAcceptedTypes sorts accepted types by quality and specificity, preserving order of equal elements\n//\n// Parameters are not supported, they are ignored when sorting by specificity.\n//\n// See: https://www.rfc-editor.org/rfc/rfc9110#name-content-negotiation-fields\nfunc sortAcceptedTypes(at *[]acceptedType) {\n\tif at == nil || len(*at) < 2 {\n\t\treturn\n\t}\n\tacceptedTypes := *at\n\n\tfor i := 1; i < len(acceptedTypes); i++ {\n\t\tlo, hi := 0, i-1\n\t\tfor lo <= hi {\n\t\t\tmid := (lo + hi) / 2\n\t\t\tif acceptedTypes[i].quality < acceptedTypes[mid].quality ||\n\t\t\t\t(acceptedTypes[i].quality == acceptedTypes[mid].quality && acceptedTypes[i].specificity < acceptedTypes[mid].specificity) ||\n\t\t\t\t(acceptedTypes[i].quality == acceptedTypes[mid].quality && acceptedTypes[i].specificity == acceptedTypes[mid].specificity && acceptedTypes[i].order > acceptedTypes[mid].order) {\n\t\t\t\tlo = mid + 1\n\t\t\t} else {\n\t\t\t\thi = mid - 1\n\t\t\t}\n\t\t}\n\t\tfor j := i; j > lo; j-- {\n\t\t\tacceptedTypes[j-1], acceptedTypes[j] = acceptedTypes[j], acceptedTypes[j-1]\n\t\t}\n\t}\n}", "id": 904, "concepts": ["slice sorting", "slice iteration (range loop)", "slice manipulation", "integer comparison", "basic function definition"], "_raw_llm_output": "slice sorting, slice iteration (range loop), slice manipulation, integer comparison, basic function definition"}
{"seed": "// DescriptionIsNil applies the IsNil predicate on the \"description\" field.\nfunc DescriptionIsNil() predicate.User {\n\treturn predicate.User(sql.FieldIsNull(FieldDescription))\n}", "id": 909, "concepts": ["predicate.User", "sql.FieldIsNull", "sql.Field"], "_raw_llm_output": "predicate.User, sql.FieldIsNull, sql.Field"}
{"seed": "// DecodeFollowResponse returns a decoder for responses returned by the\n// following follow endpoint. restoreBody controls whether the response body\n// should be restored after having been read.\n// DecodeFollowResponse may return the following errors:\n//   - \"unauthorized\" (type *goa.ServiceError): http.StatusUnauthorized\n//   - \"forbidden\" (type *goa.ServiceError): http.StatusForbidden\n//   - \"not-found\" (type *goa.ServiceError): http.StatusNotFound\n//   - \"bad-request\" (type *goa.ServiceError): http.StatusBadRequest\n//   - error: internal error\nfunc DecodeFollowResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {\n\treturn func(resp *http.Response) (interface{}, error) {\n\t\tif restoreBody {\n\t\t\tb, err := ioutil.ReadAll(resp.Body)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tresp.Body = ioutil.NopCloser(bytes.NewBuffer(b))\n\t\t\tdefer func() {\n\t\t\t\tresp.Body = ioutil.NopCloser(bytes.NewBuffer(b))\n\t\t\t}()\n\t\t} else {\n\t\t\tdefer resp.Body.Close()\n\t\t}\n\t\tswitch resp.StatusCode {\n\t\tcase http.StatusNoContent:\n\t\t\treturn nil, nil\n\t\tcase http.StatusUnauthorized:\n\t\t\tvar (\n\t\t\t\tbody FollowUnauthorizedResponseBody\n\t\t\t\terr  error\n\t\t\t)\n\t\t\terr = decoder(resp).Decode(&body)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, goahttp.ErrDecodingError(\"following\", \"follow\", err)\n\t\t\t}\n\t\t\terr = ValidateFollowUnauthorizedResponseBody(&body)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, goahttp.ErrValidationError(\"following\", \"follow\", err)\n\t\t\t}\n\t\t\treturn nil, NewFollowUnauthorized(&body)\n\t\tcase http.StatusForbidden:\n\t\t\tvar (\n\t\t\t\tbody FollowForbiddenResponseBody\n\t\t\t\terr  error\n\t\t\t)\n\t\t\terr = decoder(resp).Decode(&body)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, goahttp.ErrDecodingError(\"following\", \"follow\", err)\n\t\t\t}\n\t\t\terr = ValidateFollowForbiddenResponseBody(&body)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, goahttp.ErrValidationError(\"following\", \"follow\", err)\n\t\t\t}\n\t\t\treturn nil, NewFollowForbidden(&body)\n\t\tcase http.StatusNotFound:\n\t\t\tvar (\n\t\t\t\tbody FollowNotFoundResponseBody\n\t\t\t\terr  error\n\t\t\t)\n\t\t\terr = decoder(resp).Decode(&body)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, goahttp.ErrDecodingError(\"following\", \"follow\", err)\n\t\t\t}\n\t\t\terr = ValidateFollowNotFoundResponseBody(&body)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, goahttp.ErrValidationError(\"following\", \"follow\", err)\n\t\t\t}\n\t\t\treturn nil, NewFollowNotFound(&body)\n\t\tcase http.StatusBadRequest:\n\t\t\tvar (\n\t\t\t\tbody FollowBadRequestResponseBody\n\t\t\t\terr  error\n\t\t\t)\n\t\t\terr = decoder(resp).Decode(&body)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, goahttp.ErrDecodingError(\"following\", \"follow\", err)\n\t\t\t}\n\t\t\terr = ValidateFollowBadRequestResponseBody(&body)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, goahttp.ErrValidationError(\"following\", \"follow\", err)\n\t\t\t}\n\t\t\treturn nil, NewFollowBadRequest(&body)\n\t\tdefault:\n\t\t\tbody, _ := ioutil.ReadAll(resp.Body)\n\t\t\treturn nil, goahttp.ErrInvalidResponse(\"following\", \"follow\", resp.StatusCode, string(body))\n\t\t}\n\t}\n}", "id": 917, "concepts": ["error handling (errors.Is)", "standard library usage (like `fmt`", "`net/http`", "`encoding/json`", "`os`", "`sync`", "`errors`)", "concurrency patterns (goroutines", "channels", "mutexes)", "error handling (idiomatic `if err != nil`", "`errors.Is`", "`errors.As`)", "types (structs", "interfaces", "slices", "maps)", "common Go idioms (like `defer`)", "pointers", "and control flow. List these concepts concisely in a comma-separated format."], "_raw_llm_output": "error handling (errors.Is), standard library usage (like `fmt`, `net/http`, `encoding/json`, `os`, `sync`, `errors`), concurrency patterns (goroutines, channels, mutexes), error handling (idiomatic `if err != nil`, `errors.Is`, `errors.As`), types (structs, interfaces, slices, maps), common Go idioms (like `defer`), pointers, and control flow. List these concepts concisely in a comma-separated format."}
{"seed": "// Age applies equality check predicate on the \"age\" field. It's identical to AgeEQ.\nfunc Age(v int) predicate.User {\n\treturn predicate.User(sql.FieldEQ(FieldAge, v))\n}", "id": 920, "concepts": ["predicate.User", "sql.FieldEQ", "sql.FieldGT", "sql.FieldLT", "sql.FieldGTE", "sql.FieldLTE", "sql.FieldEQ", "sql.FieldNEQ", "sql.FieldIN", "sql.FieldNotIn", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldContains", "sql.FieldNotContains", "sql.FieldStartsWith", "sql.FieldNotStartsWith", "sql.FieldEndsWith", "sql.FieldNotEndsWith", "sql.FieldNull", "sql.FieldNotNull", "sql.FieldBetween", "sql.FieldNotBetween", "sql.FieldRegexp", "sql.FieldNotRegexp", "sql.FieldExists", "sql.FieldNotExists", "sql.FieldHas", "sql.FieldNotHas", "sql.FieldHasAny", "sql.FieldNotHasAny", "sql.FieldHasAll", "sql.FieldNotHasAll", "sql.FieldHasNone", "sql.FieldNotHasNone", "sql.FieldHasSome", "sql.FieldNotHasSome", "sql.FieldHasExactly", "sql.FieldNotHasExactly", "sql.FieldHasAtLeast", "sql.FieldNotHasAtLeast", "sql.FieldHasAtMost", "sql.FieldNotHasAtMost", "sql.FieldHasAtLeastN", "sql.Field"], "_raw_llm_output": "predicate.User, sql.FieldEQ, sql.FieldGT, sql.FieldLT, sql.FieldGTE, sql.FieldLTE, sql.FieldEQ, sql.FieldNEQ, sql.FieldIN, sql.FieldNotIn, sql.FieldLike, sql.FieldNotLike, sql.FieldContains, sql.FieldNotContains, sql.FieldStartsWith, sql.FieldNotStartsWith, sql.FieldEndsWith, sql.FieldNotEndsWith, sql.FieldNull, sql.FieldNotNull, sql.FieldBetween, sql.FieldNotBetween, sql.FieldRegexp, sql.FieldNotRegexp, sql.FieldExists, sql.FieldNotExists, sql.FieldHas, sql.FieldNotHas, sql.FieldHasAny, sql.FieldNotHasAny, sql.FieldHasAll, sql.FieldNotHasAll, sql.FieldHasNone, sql.FieldNotHasNone, sql.FieldHasSome, sql.FieldNotHasSome, sql.FieldHasExactly, sql.FieldNotHasExactly, sql.FieldHasAtLeast, sql.FieldNotHasAtLeast, sql.FieldHasAtMost, sql.FieldNotHasAtMost, sql.FieldHasAtLeastN, sql.Field"}
{"seed": "// IsMessage returns true if this message is in a channel/group conversation\nfunc IsMessage(rtm *slack.RTM, evt *slack.MessageEvent) bool {\n\tch := rtm.GetInfo().GetChannelByID(evt.Channel)\n\tgp := rtm.GetInfo().GetGroupByID(evt.Channel)\n\treturn ch != nil || gp != nil\n}", "id": 930, "concepts": ["slack package usage", "channel/group conversation handling"], "_raw_llm_output": "slack package usage, channel/group conversation handling"}
{"seed": "// appMiddleware implements any app middleware calls,\n// for example net/context or any other logic you can wrap controllers call in\n// In our case we handle there error logic\nfunc appMiddleware(f func (c *router.MyContext) error) func (c *router.MyContext) {\n\tappError := new(ctrl.EventError)\n\treturn func (c *router.MyContext) {\n\t\terr := f(c)\n\t\tif err != nil {\n\t\t\tappError.Message = err.Error()\n\t\t}\n\t\tc.AppContext.Log.Print(appError.Message)\n\t}\n}", "id": 935, "concepts": ["middleware", "error handling", "anonymous function", "concurrency", "standard library usage"], "_raw_llm_output": "middleware, error handling, anonymous function, concurrency, standard library usage"}
{"seed": "// discoverUninstallationEnvironment inspects the current environment and checks\n// that everything looks good for Trident uninstallation, but it makes no changes\n// to the environment.\nfunc discoverUninstallationEnvironment() error {\n\tvar err error\n\n\tOperatingMode = ModeInstall\n\tServer = \"\"\n\n\t// Default deployment image to what Trident was built with\n\tif tridentImage == \"\" {\n\t\ttridentImage = tridentconfig.BuildImage\n\t}\n\n\t// Create the Kubernetes client\n\tif client, err = initClient(); err != nil {\n\t\treturn fmt.Errorf(\"could not initialize Kubernetes client; %v\", err)\n\t}\n\n\t// Infer installation namespace if not specified\n\tif TridentPodNamespace == \"\" {\n\t\tTridentPodNamespace = client.Namespace()\n\t}\n\n\t// Direct all subsequent client commands to the chosen namespace\n\tclient.SetNamespace(TridentPodNamespace)\n\n\tLog().WithFields(LogFields{\n\t\t\"kubernetesVersion\": client.Version().String(),\n\t}).Debug(\"Validated uninstallation environment.\")\n\n\treturn nil\n}", "id": 957, "concepts": ["if statement", "string formatting", "fmt package usage", "client-go package usage"], "_raw_llm_output": "if statement, string formatting, fmt package usage, client-go package usage"}
{"seed": "// Ul_ is a convenience wrapper for Ul without the attrs argument.\nfunc Ul_(children ...HTML) HTML {\n  return Ul(nil, children...)\n}", "id": 967, "concepts": ["HTML struct definition", "HTML struct field definition", "HTML struct field initialization", "HTML struct field access", "HTML struct field assignment", "HTML struct field method definition", "HTML struct field method call", "HTML struct field method call with receiver", "HTML struct field method call with receiver and arguments", "HTML struct field method call with receiver and arguments", "HTML struct field method call with receiver and arguments", "HTML struct field method call with receiver and arguments", "HTML struct field method call with receiver and arguments", "HTML struct field method call with receiver and arguments", "HTML struct field method call with receiver and arguments", "HTML struct field method call with receiver and arguments", "HTML struct field method call with receiver and arguments", "HTML struct field method call with receiver and arguments", "HTML struct field method call with receiver and arguments", "HTML struct field method call with receiver and arguments", "HTML struct field method call with receiver and arguments", "HTML struct field method call with receiver and arguments", "HTML struct field method call with receiver and arguments", "HTML struct field method call with receiver and arguments", "HTML struct field method call with receiver and arguments", "HTML struct field method call with receiver and arguments", "HTML struct field method call with receiver and arguments", "HTML struct field method call with receiver and arguments", "HTML struct field method call with receiver and arguments", "HTML"], "_raw_llm_output": "HTML struct definition, HTML struct field definition, HTML struct field initialization, HTML struct field access, HTML struct field assignment, HTML struct field method definition, HTML struct field method call, HTML struct field method call with receiver, HTML struct field method call with receiver and arguments, HTML struct field method call with receiver and arguments, HTML struct field method call with receiver and arguments, HTML struct field method call with receiver and arguments, HTML struct field method call with receiver and arguments, HTML struct field method call with receiver and arguments, HTML struct field method call with receiver and arguments, HTML struct field method call with receiver and arguments, HTML struct field method call with receiver and arguments, HTML struct field method call with receiver and arguments, HTML struct field method call with receiver and arguments, HTML struct field method call with receiver and arguments, HTML struct field method call with receiver and arguments, HTML struct field method call with receiver and arguments, HTML struct field method call with receiver and arguments, HTML struct field method call with receiver and arguments, HTML struct field method call with receiver and arguments, HTML struct field method call with receiver and arguments, HTML struct field method call with receiver and arguments, HTML struct field method call with receiver and arguments, HTML struct field method call with receiver and arguments, HTML"}
{"seed": "// getTestFiles finds all *_test.arrai files in given path (recursively), reads them and returns a File array with\n// them. It skips over hidden directories. It returns an error if any filesystem operation failed, or if no files were\n// found.\nfunc getTestFiles(ctx context.Context, path string) ([]File, error) {\n\tvar files []File\n\tfs := ctxfs.SourceFsFrom(ctx)\n\n\terr := afero.Walk(fs, path, func(path string, info os.FileInfo, walkErr error) error {\n\t\tif walkErr != nil {\n\t\t\treturn walkErr\n\t\t}\n\n\t\tif info.IsDir() {\n\t\t\t// Skip hidden dirs.\n\t\t\tif strings.HasPrefix(info.Name(), \".\") {\n\t\t\t\treturn filepath.SkipDir\n\t\t\t}\n\n\t\t\t// Not a file, continue walking the directory tree.\n\t\t\treturn nil\n\t\t}\n\n\t\tif strings.HasSuffix(path, \"_test.arrai\") == false { //nolint:gosimple\n\t\t\treturn nil\n\t\t}\n\n\t\tbytes, readErr := afero.ReadFile(fs, path)\n\t\tif readErr != nil {\n\t\t\treturn fmt.Errorf(\"failed reading test file '%s': %v\", path, readErr)\n\t\t}\n\n\t\tfiles = append(files, File{Path: path, Source: string(bytes)})\n\t\treturn nil\n\t})\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(files) == 0 {\n\t\treturn nil, fmt.Errorf(\"no test files (ending in '_test.arrai') were found in Path: %v\", path)\n\t}\n\treturn files, nil\n}", "id": 970, "concepts": ["afero package usage", "filepath.Walk", "afero.ReadFile", "error handling"], "_raw_llm_output": "afero package usage, filepath.Walk, afero.ReadFile, error handling"}
{"seed": "// lookupBlob looks up an object at hash `id` in `repo`, and returns\n// it as a git blob. If the object is not a blob, an error is returned.\nfunc lookupBlob(r *git.Repository, id *git.Oid) (*git.Blob, error) {\n\tobj, err := r.Lookup(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif blob, ok := obj.(*git.Blob); ok {\n\t\treturn blob, nil\n\t}\n\treturn nil, fmt.Errorf(\"hash %v exist but is not a blob\", id)\n}", "id": 971, "concepts": ["git.Repository", "git.Lookup", "git.Blob", "git.Oid", "error handling (fmt.Errorf)", "type assertion"], "_raw_llm_output": "git.Repository, git.Lookup, git.Blob, git.Oid, error handling (fmt.Errorf), type assertion"}
{"seed": "// NewValidateCreateServiceRequestNamingParamsWithContext creates a new ValidateCreateServiceRequestNamingParams object\n// with the default values initialized, and the ability to set a context for a request\nfunc NewValidateCreateServiceRequestNamingParamsWithContext(ctx context.Context) *ValidateCreateServiceRequestNamingParams {\n\tvar ()\n\treturn &ValidateCreateServiceRequestNamingParams{\n\n\t\tContext: ctx,\n\t}\n}", "id": 973, "concepts": ["context package usage", "struct initialization", "method chaining"], "_raw_llm_output": "context package usage, struct initialization, method chaining"}
{"seed": "// RuleTypeOption_Values returns all elements of the RuleTypeOption enum\nfunc RuleTypeOption_Values() []string {\n\treturn []string{\n\t\tRuleTypeOptionForward,\n\t\tRuleTypeOptionSystem,\n\t\tRuleTypeOptionRecursive,\n\t}\n}", "id": 977, "concepts": ["enum handling", "string manipulation"], "_raw_llm_output": "enum handling, string manipulation"}
{"seed": "// NewEnsemblingJobSourceWithDefaults instantiates a new EnsemblingJobSource object\n// This constructor will only assign default values to properties that have it defined,\n// but it doesn't guarantee that properties required by API are set\nfunc NewEnsemblingJobSourceWithDefaults() *EnsemblingJobSource {\n\tthis := EnsemblingJobSource{}\n\treturn &this\n}", "id": 979, "concepts": ["constructor", "default value assignment"], "_raw_llm_output": "constructor, default value assignment"}
{"seed": "// Blink represents the HTML element 'blink'.\n// For more information visit https://www.w3schools.com/tags/tag_blink.asp.\nfunc Blink(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"blink\", Attributes: attrs, Children: children}\n}", "id": 985, "concepts": ["HTML generation (HTML tree)", "HTML element definition", "HTML attribute definition"], "_raw_llm_output": "HTML generation (HTML tree), HTML element definition, HTML attribute definition"}
{"seed": "// CheckAndSetReloadProcess sets the reloadProcess flag.\n// Returns its previous value.\nfunc CheckAndSetReloadProcess() bool {\n\treloadMutex.Lock()\n\tdefer reloadMutex.Unlock()\n\tretval := reloadProcess\n\treloadProcess = true\n\treturn retval\n}", "id": 1004, "concepts": ["mutex", "boolean flag", "locking"], "_raw_llm_output": "mutex, boolean flag, locking"}
{"seed": "// H2 represents the HTML element 'h2'.\n// For more information visit https://www.w3schools.com/tags/tag_h2.asp.\nfunc H2(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"h2\", Attributes: attrs, Children: children}\n}", "id": 1007, "concepts": ["HTML generation", "HTML generation with attributes", "HTML generation with children", "HTML generation with multiple children", "HTML generation with multiple children and attributes"], "_raw_llm_output": "HTML generation, HTML generation with attributes, HTML generation with children, HTML generation with multiple children, HTML generation with multiple children and attributes"}
{"seed": "// GetWaitTimeDuration returns a wait timeout based on the following precedences:\n// 1. spec.scheduleTimeoutSeconds of the given pg, if specified\n// 2. fall back to defaultTimeout\nfunc GetWaitTimeDuration(pg *v1alpha1.PodGroup, defaultTimeout time.Duration) time.Duration {\n\tif pg != nil && pg.Spec.ScheduleTimeoutSeconds != nil {\n\t\tif *pg.Spec.ScheduleTimeoutSeconds >= 0 {\n\t\t\treturn time.Duration(*pg.Spec.ScheduleTimeoutSeconds) * time.Second\n\t\t} else {\n\t\t\tklog.Errorf(\"podGroup's ScheduleTimeoutSeconds illegal, podGroupName: %s\", klog.KObj(pg))\n\t\t}\n\t}\n\n\treturn defaultTimeout\n}", "id": 1010, "concepts": ["time handling", "pointer handling", "error handling", "if-else statement", "basic function definition"], "_raw_llm_output": "time handling, pointer handling, error handling, if-else statement, basic function definition"}
{"seed": "// RequireFromURI is similar to FromURI except that instead of returning an\n// error on malformed input, it panics. It should only be used when the input is\n// statically verifiable.\nfunc RequireFromURI(uri *url.URL) ID {\n\tid, err := FromURI(uri)\n\tpanicOnErr(err)\n\treturn id\n}", "id": 1018, "concepts": ["panic", "panicOnErr function definition", "error handling"], "_raw_llm_output": "panic, panicOnErr function definition, error handling"}
{"seed": "// ParseUpdateInstancePoolResponse parses an HTTP response from a UpdateInstancePoolWithResponse call\nfunc ParseUpdateInstancePoolResponse(rsp *http.Response) (*UpdateInstancePoolResponse, error) {\n\tbodyBytes, err := ioutil.ReadAll(rsp.Body)\n\tdefer rsp.Body.Close()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse := &UpdateInstancePoolResponse{\n\t\tBody:         bodyBytes,\n\t\tHTTPResponse: rsp,\n\t}\n\n\tswitch {\n\tcase strings.Contains(rsp.Header.Get(\"Content-Type\"), \"json\") && rsp.StatusCode == 200:\n\t\tvar dest Operation\n\t\tif err := json.Unmarshal(bodyBytes, &dest); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresponse.JSON200 = &dest\n\n\t}\n\n\treturn response, nil\n}", "id": 1019, "concepts": ["http.Response", "http.Client", "json.Unmarshal", "ioutil.ReadAll", "switch statement", "error handling"], "_raw_llm_output": "http.Response, http.Client, json.Unmarshal, ioutil.ReadAll, switch statement, error handling"}
{"seed": "// MoonTopocentric2 returns observed topocentric semidiameter of the Moon\n// \u6708\u4eae\u7684\u7ad9\u5fc3\u89c6\u534a\u5f84\uff08\u7b80\u5355\u516c\u5f0f\uff09\n// by a less rigorous method.\n//\n// \u0394 is distance to Moon in AU, h is altitude of the Moon above the observer's\n// horizon.\nfunc MoonTopocentric2(\u0394 float64, h unit.Angle) unit.Angle {\n\treturn Moon.Mul((1 + h.Sin()*parallax.Horizontal(\u0394).Sin()) / \u0394)\n}", "id": 1021, "concepts": ["math", "unit conversion", "function definition", "simple formula"], "_raw_llm_output": "math, unit conversion, function definition, simple formula"}
{"seed": "// PrepareLokomotiveTerraformModuleAt creates a directory named path\n// including all required parents and puts the Lokomotive Kubernetes\n// terraform module sources into path.\n// An error is returned if the directory already exists.\n//\n// The terraform sources are loaded either from data embedded in the\n// lokoctl binary or from the filesystem, depending on whether the\n// LOKOCTL_USE_FS_ASSETS environment variable was specified.\nfunc PrepareLokomotiveTerraformModuleAt(path string) error {\n\twalk := walkers.CopyingWalker(path, 0755)\n\tif err := assets.Assets.WalkFiles(\"/lokomotive-kubernetes\", walk); err != nil {\n\t\treturn errors.Wrap(err, \"failed to walk assets\")\n\t}\n\treturn nil\n}", "id": 1022, "concepts": ["filesystem handling", "error handling", "standard library usage"], "_raw_llm_output": "filesystem handling, error handling, standard library usage"}
{"seed": "/*\nhttps://leetcode.com/problems/merge-two-sorted-lists/\n\nMerge two sorted linked lists and return it as a new list.\nThe new list should be made by splicing together the nodes of the first two lists.\n\nExample:\nInput: 1->2->4, 1->3->4\nOutput: 1->1->2->3->4->4\n*/\n\nfunc MergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {\n\treturn mergeTwoLists(l1, l2)\n}", "id": 1026, "concepts": ["linked list", "recursion", "base case handling"], "_raw_llm_output": "linked list, recursion, base case handling"}
{"seed": "//\n// Read a KeysAndCert from a slice of bytes, retuning it and the remaining data as well as any errors\n// encoutered parsing the KeysAndCert.\n//\nfunc ReadKeysAndCert(data []byte) (keys_and_cert KeysAndCert, remainder []byte, err error) {\n\tdata_len := len(data)\n\tif data_len < KEYS_AND_CERT_MIN_SIZE {\n\t\tlog.WithFields(log.Fields{\n\t\t\t\"at\":           \"ReadKeysAndCert\",\n\t\t\t\"data_len\":     data_len,\n\t\t\t\"required_len\": KEYS_AND_CERT_MIN_SIZE,\n\t\t\t\"reason\":       \"not enough data\",\n\t\t}).Error(\"error parsing keys and cert\")\n\t\terr = errors.New(\"error parsing KeysAndCert: data is smaller than minimum valid size\")\n\t\treturn\n\t}\n\tkeys_and_cert = KeysAndCert(data[:KEYS_AND_CERT_MIN_SIZE])\n\tcert, _ := keys_and_cert.Certificate()\n\tcert_len, cert_len_err := cert.Length()\n\tif cert_len == 0 {\n\t\tremainder = data[KEYS_AND_CERT_MIN_SIZE:]\n\t\treturn\n\t}\n\tif data_len < KEYS_AND_CERT_MIN_SIZE+cert_len {\n\t\tkeys_and_cert = append(keys_and_cert, data[KEYS_AND_CERT_MIN_SIZE:]...)\n\t\terr = cert_len_err\n\t} else {\n\t\tkeys_and_cert = append(keys_and_cert, data[KEYS_AND_CERT_MIN_SIZE:KEYS_AND_CERT_MIN_SIZE+cert_len]...)\n\t\tremainder = data[KEYS_AND_CERT_MIN_SIZE+cert_len:]\n\t}\n\treturn\n}", "id": 1038, "concepts": ["slice iteration (range loop)", "slice concatenation", "error handling (errors.New)", "error handling (errors.As)", "error handling (errors.Is)", "error handling (idiomatic if err != nil)", "error handling (error wrapping)", "error handling (error chaining)", "error handling (error handling in a function)", "error handling (error handling in a function)", "error handling (error handling in a function)", "error handling (error handling in a function)", "error handling (error handling in a function)", "error handling (error handling in a function)", "error handling (error handling in a function)", "error handling (error handling in a function)", "error handling (error handling in a function)", "error handling (error handling in a function)", "error handling (error handling in a function)", "error handling (error handling in a function)", "error handling (error handling in a function)", "error handling (error handling in a function)", "error handling (error handling in a function)", "error handling (error handling in a function)", "error handling (error handling in a function)", "error handling (error handling in a function)", "error handling (error handling in a function)", "error handling (error handling in a function)", "error handling (error handling in a function)", "error handling (error handling in a function)", "error handling ("], "_raw_llm_output": "slice iteration (range loop), slice concatenation, error handling (errors.New), error handling (errors.As), error handling (errors.Is), error handling (idiomatic if err != nil), error handling (error wrapping), error handling (error chaining), error handling (error handling in a function), error handling (error handling in a function), error handling (error handling in a function), error handling (error handling in a function), error handling (error handling in a function), error handling (error handling in a function), error handling (error handling in a function), error handling (error handling in a function), error handling (error handling in a function), error handling (error handling in a function), error handling (error handling in a function), error handling (error handling in a function), error handling (error handling in a function), error handling (error handling in a function), error handling (error handling in a function), error handling (error handling in a function), error handling (error handling in a function), error handling (error handling in a function), error handling (error handling in a function), error handling (error handling in a function), error handling (error handling in a function), error handling (error handling in a function), error handling ("}
{"seed": "// Article represents the HTML element 'article'.\n// For more information visit https://www.w3schools.com/tags/tag_article.asp.\nfunc Article(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"article\", Attributes: attrs, Children: children}\n}", "id": 1040, "concepts": ["HTML generation", "HTML element definition", "HTML attribute definition", "HTML element children definition"], "_raw_llm_output": "HTML generation, HTML element definition, HTML attribute definition, HTML element children definition"}
{"seed": "// In-order traverse of binary tree\nfunc traverseTree(node *TreeNode) {\n\tif node == nil { return }\n\n\ttraverseTree(node.left)\n\tfmt.Printf(\"%d\\n\", node.data)\n\ttraverseTree(node.right)\n}", "id": 1046, "concepts": ["binary tree traversal", "recursion"], "_raw_llm_output": "binary tree traversal, recursion"}
{"seed": "// SocialUserIDContainsFold applies the ContainsFold predicate on the \"social_user_id\" field.\nfunc SocialUserIDContainsFold(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.ContainsFold(s.C(FieldSocialUserID), v))\n\t})\n}", "id": 1048, "concepts": ["sql.Selector", "predicate.User", "sql.ContainsFold", "basic function definition"], "_raw_llm_output": "sql.Selector, predicate.User, sql.ContainsFold, basic function definition"}
{"seed": "// RegisterHTTPHandlers registers JSON HTTP handlers with mux using the given\n// search Service.  The following method with be exposed:\n//\n//   GET /search\n//     Request: JSON encoded storage.SearchRequest\n//     Response: JSON encoded storage.SearchReply\n//\n// Note: /search will return its response as serialized protobuf if the\n// \"proto\" query parameter is set.\nfunc RegisterHTTPHandlers(ctx context.Context, s Service, mux *http.ServeMux) {\n\tmux.HandleFunc(\"/search\", func(w http.ResponseWriter, r *http.Request) {\n\t\tstart := time.Now()\n\t\tdefer func() {\n\t\t\tlog.Printf(\"search.Search:\\t%s\", time.Since(start))\n\t\t}()\n\n\t\tvar req spb.SearchRequest\n\t\tif err := web.ReadJSONBody(r, &req); err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\t\treply, err := s.Search(ctx, &req)\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tif err := web.WriteResponse(w, r, reply); err != nil {\n\t\t\tlog.Println(err)\n\t\t}\n\t})\n}", "id": 1049, "concepts": ["HTTP handling", "JSON encoding/decoding", "HTTP response handling", "context", "error handling", "protobuf usage", "web package usage"], "_raw_llm_output": "HTTP handling, JSON encoding/decoding, HTTP response handling, context, error handling, protobuf usage, web package usage"}
{"seed": "// OptUnmountStderr writes standard error to w.\nfunc OptUnmountStderr(w io.Writer) UnmountOpt {\n\treturn func(mo *unmountOpts) error {\n\t\tmo.stderr = w\n\t\treturn nil\n\t}\n}", "id": 1059, "concepts": ["function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", ""], "_raw_llm_output": "function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition,"}
{"seed": "// SocialNameEqualFold applies the EqualFold predicate on the \"social_name\" field.\nfunc SocialNameEqualFold(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.EqualFold(s.C(FieldSocialName), v))\n\t})\n}", "id": 1063, "concepts": ["sql.Selector", "sql.EqualFold", "sql.C", "predicate.User", "predicate.FieldSocialName"], "_raw_llm_output": "sql.Selector, sql.EqualFold, sql.C, predicate.User, predicate.FieldSocialName"}
{"seed": "// Name applies equality check predicate on the \"name\" field. It's identical to NameEQ.\nfunc Name(v string) predicate.User {\n\treturn predicate.User(sql.FieldEQ(FieldName, v))\n}", "id": 1067, "concepts": ["interface composition", "function composition", "predicate composition", "sql.FieldEQ"], "_raw_llm_output": "interface composition, function composition, predicate composition, sql.FieldEQ"}
{"seed": "// Sensitive creates a new Sensitive that wraps the given value\nfunc Sensitive(v interface{}) dgo.Sensitive {\n\treturn &sensitive{Value(v)}\n}", "id": 1077, "concepts": ["interface", "type conversion", "pointer usage"], "_raw_llm_output": "interface, type conversion, pointer usage"}
{"seed": "// GNUSyntax returns the GNU assembler syntax for the instruction, as defined by GNU binutils.\n// This form typically matches the syntax defined in the ARM Reference Manual.\nfunc GNUSyntax(inst Inst) string {\n\tvar buf bytes.Buffer\n\top := inst.Op.String()\n\top = saveDot.Replace(op)\n\top = strings.Replace(op, \".\", \"\", -1)\n\top = strings.Replace(op, \"_dot_\", \".\", -1)\n\top = strings.ToLower(op)\n\tbuf.WriteString(op)\n\tsep := \" \"\n\tfor i, arg := range inst.Args {\n\t\tif arg == nil {\n\t\t\tbreak\n\t\t}\n\t\ttext := gnuArg(&inst, i, arg)\n\t\tif text == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tbuf.WriteString(sep)\n\t\tsep = \", \"\n\t\tbuf.WriteString(text)\n\t}\n\treturn buf.String()\n}", "id": 1092, "concepts": ["string manipulation", "string formatting", "string concatenation", "string replacement", "string iteration", "string indexing", "string length", "string comparison", "string concatenation", "string iteration", "string indexing", "string length", "string comparison", "string concatenation", "string iteration", "string indexing", "string length", "string comparison", "string concatenation", "string iteration", "string indexing", "string length", "string comparison", "string concatenation", "string iteration", "string indexing", "string length", "string comparison", "string concatenation", "string iteration", "string indexing", "string length", "string comparison", "string concatenation", "string iteration", "string indexing", "string length", "string comparison", "string concatenation", "string iteration", "string indexing", "string length", "string comparison", "string concatenation", "string iteration", "string indexing", "string length", "string comparison", "string concatenation", "string iteration", "string indexing", "string length", "string comparison", "string concatenation", "string iteration", "string indexing", "string length", "string comparison", "string concatenation", "string iteration", "string indexing", "string length", "string comparison", "string concatenation", "string iteration", "string indexing", "string length", "string comparison", "string concatenation", "string iteration", "string indexing", "string length", "string comparison", "string concatenation", "string iteration", "string indexing", "string length", "string comparison", "string concatenation", "string iteration"], "_raw_llm_output": "string manipulation, string formatting, string concatenation, string replacement, string iteration, string indexing, string length, string comparison, string concatenation, string iteration, string indexing, string length, string comparison, string concatenation, string iteration, string indexing, string length, string comparison, string concatenation, string iteration, string indexing, string length, string comparison, string concatenation, string iteration, string indexing, string length, string comparison, string concatenation, string iteration, string indexing, string length, string comparison, string concatenation, string iteration, string indexing, string length, string comparison, string concatenation, string iteration, string indexing, string length, string comparison, string concatenation, string iteration, string indexing, string length, string comparison, string concatenation, string iteration, string indexing, string length, string comparison, string concatenation, string iteration, string indexing, string length, string comparison, string concatenation, string iteration, string indexing, string length, string comparison, string concatenation, string iteration, string indexing, string length, string comparison, string concatenation, string iteration, string indexing, string length, string comparison, string concatenation, string iteration, string indexing, string length, string comparison, string concatenation, string iteration"}
{"seed": "// NewNameEQ applies the EQ predicate on the \"new_name\" field.\nfunc NewNameEQ(v string) predicate.User {\n\treturn predicate.User(sql.FieldEQ(FieldNewName, v))\n}", "id": 1101, "concepts": ["struct field access", "predicate composition"], "_raw_llm_output": "struct field access, predicate composition"}
{"seed": "// NewBotStateFromValue returns a pointer to a valid BotState\n// for the value passed as argument, or an error if the value passed is not allowed by the enum\nfunc NewBotStateFromValue(v int32) (*BotState, error) {\n\tev := BotState(v)\n\tif ev.IsValid() {\n\t\treturn &ev, nil\n\t} else {\n\t\treturn nil, fmt.Errorf(\"invalid value '%v' for BotState: valid values are %v\", v, AllowedBotStateEnumValues)\n\t}\n}", "id": 1107, "concepts": ["enum", "error handling"], "_raw_llm_output": "enum, error handling"}
{"seed": "// Used for debugging. Log a path, found by debugWalkDir, to klog.\nfunc debugLogPath(path string, info os.FileInfo, err error) error {\n\tif err != nil {\n\t\tklog.Error(err)\n\t\treturn err\n\t}\n\tklog.V(4).Infof(\"found path %s\", path)\n\treturn nil\n}", "id": 1110, "concepts": ["os.FileInfo", "os.File", "os.File.Readdir", "os.File.Readdirnames", "os.File.Stat", "os.File.Close", "os.File.Read", "os.File.Seek", "os.File.Write", "os.File.WriteString", "os.File.Sync", "os.File.Truncate", "os.File.Chmod", "os.File.Chown", "os.File.Chdir", "os.File.Name", "os.File.Stat", "os.File.Close", "os.File.Read", "os.File.Seek", "os.File.Write", "os.File.WriteString", "os.File.Sync", "os.File.Truncate", "os.File.Chmod", "os.File.Chown", "os.File.Chdir", "os.File.Name", "os.File.Stat", "os.File.Close", "os.File.Read", "os.File.Seek", "os.File.Write", "os.File.WriteString", "os.File.Sync", "os.File.Truncate", "os.File.Chmod", "os.File.Chown", "os.File.Chdir", "os.File.Name", "os.File.Stat", "os"], "_raw_llm_output": "os.FileInfo, os.File, os.File.Readdir, os.File.Readdirnames, os.File.Stat, os.File.Close, os.File.Read, os.File.Seek, os.File.Write, os.File.WriteString, os.File.Sync, os.File.Truncate, os.File.Chmod, os.File.Chown, os.File.Chdir, os.File.Name, os.File.Stat, os.File.Close, os.File.Read, os.File.Seek, os.File.Write, os.File.WriteString, os.File.Sync, os.File.Truncate, os.File.Chmod, os.File.Chown, os.File.Chdir, os.File.Name, os.File.Stat, os.File.Close, os.File.Read, os.File.Seek, os.File.Write, os.File.WriteString, os.File.Sync, os.File.Truncate, os.File.Chmod, os.File.Chown, os.File.Chdir, os.File.Name, os.File.Stat, os"}
{"seed": "// WithEnvVarSplit tells Parse to split environment variables on the given\n// delimiter, and to make a call to Set on the corresponding flag with each\n// split token.\nfunc WithEnvVarSplit(delimiter string) Option {\n\treturn func(c *Context) {\n\t\tc.envVarSplit = delimiter\n\t}\n}", "id": 1115, "concepts": ["function composition", "function options", "environment variable handling"], "_raw_llm_output": "function composition, function options, environment variable handling"}
{"seed": "// LoadMany loads and returns whichever named job IDs exist in the database.\n// This means that jobs might well be empty. An error is returned only for\n// cases where there are DB issues. Unparseable jobs are treated as\n// nonexistent.\nfunc LoadMany(db *bolt.DB, jobIds []string) (jobs []*Job, err error) {\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\tjobsBucket := tx.Bucket([]byte(\"jobs\"))\n\t\tif jobsBucket == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\tfor _, jobId := range jobIds {\n\t\t\tjobJson := jobsBucket.Get([]byte(jobId))\n\t\t\tif jobJson == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tjob := &Job{\n\t\t\t\tSubscriptionsMu: &sync.Mutex{},\n\t\t\t}\n\t\t\tif err := json.Unmarshal(jobJson, job); err != nil {\n\t\t\t\tlog.Warningf(\"DB contained job with id %q, but could not parse: %v\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfor _, j := range job.Messages {\n\t\t\t\tj.JobId = job.JobId\n\t\t\t}\n\n\t\t\tfor _, sess := range job.Sessions {\n\t\t\t\tsort.Slice(sess.EventNumber, func(i, j int) bool {\n\t\t\t\t\treturn sess.EventNumber[i] < sess.EventNumber[j]\n\t\t\t\t})\n\t\t\t\tsort.Ints(sess.Character)\n\t\t\t}\n\t\t\tjobs = append(jobs, job)\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn jobs, nil\n}", "id": 1116, "concepts": ["bolt package usage", "json package usage", "sync.Mutex", "sync.WaitGroup", "sync.RWMutex", "sync.Once", "concurrency", "standard library usage"], "_raw_llm_output": "bolt package usage, json package usage, sync.Mutex, sync.WaitGroup, sync.RWMutex, sync.Once, concurrency, standard library usage"}
{"seed": "// Author returns package author\nfunc Author() string {\n\treturn \"[Li Kexian](https://www.likexian.com/)\"\n}", "id": 1117, "concepts": ["package author"], "_raw_llm_output": "package author"}
{"seed": "// WithConfigFileParser tells Parse how to interpret the config file provided\n// via WithConfigFile or WithConfigFileFlag.\nfunc WithConfigFileParser(p ConfigFileParser) Option {\n\treturn func(c *Context) {\n\t\tc.configFileParser = p\n\t}\n}", "id": 1128, "concepts": ["function composition", "function composition with Option type"], "_raw_llm_output": "function composition, function composition with Option type"}
{"seed": "// NewSplitter produces a new Splitter with the given callback.\n// The Splitter is an io.WriteCloser.\n// As bytes are written to it,\n// it finds chunk boundaries and calls the callback.\n//\n// The callback receives the bytes of the chunk,\n// and the chunk's \"level,\"\n// which is the number of extra trailing zeroes in the rolling checksum\n// (in excess of Splitter.SplitBits).\n//\n// Do not forget to call Close on the Splitter\n// to flush any remaining chunk from its internal buffer.\nfunc NewSplitter(f func([]byte, uint) error) *Splitter {\n\trs := buzhash32.New()\n\tvar zeroes [windowSize]byte\n\trs.Write(zeroes[:]) // initialize the rolling checksum window\n\n\treturn &Splitter{f: f, rs: rs}\n}", "id": 1135, "concepts": ["io.WriteCloser", "io.Closer", "io.Writer", "io.Reader", "io.ReaderFrom", "io.WriterTo", "io.ReaderAt", "io.Seeker", "io.ByteReader", "io.ByteWriter", "io.ByteScanner", "io.ByteSizer", "io.RuneReader", "io.RuneWriter", "io.RuneScanner", "io.RuneSizer", "io.WriterAt", "io.WriterTo", "io.Seeker", "io.ReaderFrom", "io.WriterTo", "io.ReaderAt", "io.ByteReader", "io.ByteWriter", "io.ByteScanner", "io.ByteSizer", "io.RuneReader", "io.RuneWriter", "io.RuneScanner", "io.RuneSizer", "io.WriterAt", "io.WriterTo", "io.Seeker", "io.ReaderFrom", "io.WriterTo", "io.ReaderAt", "io.ByteReader", "io.ByteWriter", "io.ByteScanner", "io.ByteSizer", "io.RuneReader", "io.RuneWriter", "io.RuneScanner", "io.RuneSizer", "io.WriterAt", "io.WriterTo", "io.Seeker", "io.ReaderFrom", "io.WriterTo", "io.ReaderAt", "io.ByteReader", "io.Byte"], "_raw_llm_output": "io.WriteCloser, io.Closer, io.Writer, io.Reader, io.ReaderFrom, io.WriterTo, io.ReaderAt, io.Seeker, io.ByteReader, io.ByteWriter, io.ByteScanner, io.ByteSizer, io.RuneReader, io.RuneWriter, io.RuneScanner, io.RuneSizer, io.WriterAt, io.WriterTo, io.Seeker, io.ReaderFrom, io.WriterTo, io.ReaderAt, io.ByteReader, io.ByteWriter, io.ByteScanner, io.ByteSizer, io.RuneReader, io.RuneWriter, io.RuneScanner, io.RuneSizer, io.WriterAt, io.WriterTo, io.Seeker, io.ReaderFrom, io.WriterTo, io.ReaderAt, io.ByteReader, io.ByteWriter, io.ByteScanner, io.ByteSizer, io.RuneReader, io.RuneWriter, io.RuneScanner, io.RuneSizer, io.WriterAt, io.WriterTo, io.Seeker, io.ReaderFrom, io.WriterTo, io.ReaderAt, io.ByteReader, io.Byte"}
{"seed": "// Part2 returns the shortest possible polymer length after removing all\n// instances of any one chosen character (case-insensitive) and then collapsing\n// the polymer.\nfunc Part2(input string) (string, error) {\n\tbaseUnits, err := parseInput(input)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tminLength := baseUnits.Len()\n\tfor char := 'a'; char <= 'z'; char++ {\n\t\tunits := copy(baseUnits)\n\t\tremoveChar(units, char)\n\t\tcollapse(units)\n\t\tif units.Len() < minLength {\n\t\t\tminLength = units.Len()\n\t\t}\n\t}\n\treturn strconv.Itoa(minLength), nil\n}", "id": 1146, "concepts": ["string manipulation", "rune handling", "character comparison", "string formatting", "fmt package usage", "error handling (errors.New)", "integer division"], "_raw_llm_output": "string manipulation, rune handling, character comparison, string formatting, fmt package usage, error handling (errors.New), integer division"}
{"seed": "// NewECDSASHASignatureGenerator creates a SignatureGenerator that can\n// sign a JWT using the Elliptic Curve Digital Signature Algorithm\n// (ECDSA), using SHA-256, SHA-384 or SHA-512 as a hashing algorithm.\n//\n// ECDSA uses asymmetrical cryptography, meaning that signing is\n// performed using a private key, while verification only relies on a\n// public key.\nfunc NewECDSASHASignatureGenerator(privateKey *ecdsa.PrivateKey, randomNumberGenerator random.ThreadSafeGenerator) (SignatureGenerator, error) {\n\tbitSize := privateKey.PublicKey.Curve.Params().BitSize\n\tparameters, ok := supportedECDSASHAParameters[bitSize]\n\tif !ok {\n\t\treturn nil, status.Errorf(codes.InvalidArgument, \"Private key has an invalid bit size: %d\", bitSize)\n\t}\n\treturn &ecdsaSHASignatureGenerator{\n\t\tprivateKey:            privateKey,\n\t\tparameters:            parameters,\n\t\trandomNumberGenerator: randomNumberGenerator,\n\t}, nil\n}", "id": 1154, "concepts": ["ECDSA", "SHA-256", "SHA-384", "SHA-512", "cryptography", "public key cryptography", "private key cryptography"], "_raw_llm_output": "ECDSA, SHA-256, SHA-384, SHA-512, cryptography, public key cryptography, private key cryptography"}
{"seed": "// NewTestEmailConfigurationParams creates a new TestEmailConfigurationParams object,\n// with the default timeout for this client.\n//\n// Default values are not hydrated, since defaults are normally applied by the API server side.\n//\n// To enforce default values in parameter, use SetDefaults or WithDefaults.\nfunc NewTestEmailConfigurationParams() *TestEmailConfigurationParams {\n\treturn &TestEmailConfigurationParams{\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 1161, "concepts": ["struct definition", "default value assignment", "struct field assignment"], "_raw_llm_output": "struct definition, default value assignment, struct field assignment"}
{"seed": "// AgeEQ applies the EQ predicate on the \"age\" field.\nfunc AgeEQ(v int) predicate.User {\n\treturn predicate.User(sql.FieldEQ(FieldAge, v))\n}", "id": 1169, "concepts": ["predicate", "predicate.User", "sql.FieldEQ", "sql.Field"], "_raw_llm_output": "predicate, predicate.User, sql.FieldEQ, sql.Field"}
{"seed": "// uint32ToIPv4 converts an 32 bit integer to net.IP\nfunc uint32ToIPv4(intIP uint32) net.IP {\n\tip := make(net.IP, 4)\n\tbinary.BigEndian.PutUint32(ip, intIP)\n\treturn ip\n}", "id": 1189, "concepts": ["net.IP", "binary.BigEndian", "integer conversion"], "_raw_llm_output": "net.IP, binary.BigEndian, integer conversion"}
{"seed": "// FirewallDomainImportOperation_Values returns all elements of the FirewallDomainImportOperation enum\nfunc FirewallDomainImportOperation_Values() []string {\n\treturn []string{\n\t\tFirewallDomainImportOperationReplace,\n\t}\n}", "id": 1200, "concepts": ["enum", "string manipulation", "basic function definition"], "_raw_llm_output": "enum, string manipulation, basic function definition"}
{"seed": "// StringInSlice returns true if the provided string is in the provided slice\nfunc StringInSlice(key string, list []string) bool {\n\tfor _, entry := range list {\n\t\tif entry == key {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}", "id": 1221, "concepts": ["slice iteration (range loop)", "string comparison"], "_raw_llm_output": "slice iteration (range loop), string comparison"}
{"seed": "// PossibleNetworkRuleIPActionValues returns an array of possible values for the NetworkRuleIPAction const type.\nfunc PossibleNetworkRuleIPActionValues() []NetworkRuleIPAction {\n\treturn []NetworkRuleIPAction{NetworkRuleIPActionAllow}\n}", "id": 1224, "concepts": ["enumerations", "const declaration", "array declaration"], "_raw_llm_output": "enumerations, const declaration, array declaration"}
{"seed": "// IsDir returns true if given path is a directory,\n// or returns false when it's a file or does not exist.\nfunc IsDir(dir string) bool {\n\tf, e := os.Stat(dir)\n\tif e != nil {\n\t\treturn false\n\t}\n\treturn f.IsDir()\n}", "id": 1231, "concepts": ["os.Stat", "os.IsDir"], "_raw_llm_output": "os.Stat, os.IsDir"}
{"seed": "// PhoneContainsFold applies the ContainsFold predicate on the \"phone\" field.\nfunc PhoneContainsFold(v string) predicate.User {\n\treturn predicate.User(sql.FieldContainsFold(FieldPhone, v))\n}", "id": 1257, "concepts": ["predicate.User", "sql.FieldContainsFold", "sql.FieldContainsFold usage"], "_raw_llm_output": "predicate.User, sql.FieldContainsFold, sql.FieldContainsFold usage"}
{"seed": "// MakeDefaultExecutor returns a default implementation of executor\n// which does bare minimum:\n//\n// 1. It sends HTTP request, reads and returns HTTP response.\n//\n// 2. If request wants to upgrade connection (Connection: Upgrade),\n// it hijacks a connection, returns a correct response and does TCP\n// proxyfying of the sockets.\n//\n// This function is created as a bare minimum to give end user the\n// example on how to implementat his/her own executor.\nfunc MakeDefaultExecutor(dialer dialers.Dialer) Executor {\n\treturn func(ctx *layers.Context) error {\n\t\tconn, err := defaultExecutorDial(ctx, dialer)\n\t\tif err != nil {\n\t\t\treturn errors.Annotate(err, \"cannot dial to the netloc\", \"\", 0)\n\t\t}\n\n\t\tdialer.PatchHTTPRequest(ctx.Request())\n\n\t\tfor _, v := range ctx.RequestHeaders.GetLast(\"Connection\").Values() {\n\t\t\tif strings.EqualFold(v, \"Upgrade\") {\n\t\t\t\treturn defaultExecutorConnectionUpgrade(ctx, conn)\n\t\t\t}\n\t\t}\n\n\t\treturn defaultExecutorHTTPRequest(ctx, conn)\n\t}\n}", "id": 1263, "concepts": ["function definition", "function composition", "function composition with error handling", "function composition with error handling (errors.Annotate)", "function composition with error handling (errors.Is)", "function composition with error handling (errors.As)", "function composition with error handling (errors.Wrap)", "function composition with error handling (errors.Wrapf)", "function composition with error handling (errors.Wrapf)", "function composition with error handling (errors.Wrapf)", "function composition with error handling (errors.Wrapf)", "function composition with error handling (errors.Wrapf)", "function composition with error handling (errors.Wrapf)", "function composition with error handling (errors.Wrapf)", "function composition with error handling (errors.Wrapf)", "function composition with error handling (errors.Wrapf)", "function composition with error handling (errors.Wrapf)", "function composition with error handling (errors.Wrapf)", "function composition with error handling (errors.Wrapf)", "function composition with error handling (errors.Wrapf)", "function composition with error handling (errors.Wrapf)", "function composition with error handling (errors.Wrapf)", "function composition with error handling (errors.Wrapf)", "function composition with error handling (errors.Wrapf)", "function composition with error handling (errors.Wrapf)", "function composition with error"], "_raw_llm_output": "function definition, function composition, function composition with error handling, function composition with error handling (errors.Annotate), function composition with error handling (errors.Is), function composition with error handling (errors.As), function composition with error handling (errors.Wrap), function composition with error handling (errors.Wrapf), function composition with error handling (errors.Wrapf), function composition with error handling (errors.Wrapf), function composition with error handling (errors.Wrapf), function composition with error handling (errors.Wrapf), function composition with error handling (errors.Wrapf), function composition with error handling (errors.Wrapf), function composition with error handling (errors.Wrapf), function composition with error handling (errors.Wrapf), function composition with error handling (errors.Wrapf), function composition with error handling (errors.Wrapf), function composition with error handling (errors.Wrapf), function composition with error handling (errors.Wrapf), function composition with error handling (errors.Wrapf), function composition with error handling (errors.Wrapf), function composition with error handling (errors.Wrapf), function composition with error handling (errors.Wrapf), function composition with error handling (errors.Wrapf), function composition with error"}
{"seed": "// Embed represents the HTML void element 'embed'.\n// For more information visit https://www.w3schools.com/tags/tag_embed.asp.\nfunc Embed(attrs []htmlgo.Attribute) HTML {\n\treturn &htmlgo.Tree{Tag: \"embed\", Attributes: attrs, SelfClosing: true}\n}", "id": 1268, "concepts": ["HTML generation", "HTML tree traversal", "HTML element definition"], "_raw_llm_output": "HTML generation, HTML tree traversal, HTML element definition"}
{"seed": "// PossibleBlobStorageEventTypeValues returns an array of possible values for the BlobStorageEventType const type.\nfunc PossibleBlobStorageEventTypeValues() []BlobStorageEventType {\n\treturn []BlobStorageEventType{MicrosoftStorageBlobCreated, MicrosoftStorageBlobRenamed}\n}", "id": 1269, "concepts": ["constant definition", "array definition", "array iteration"], "_raw_llm_output": "constant definition, array definition, array iteration"}
{"seed": "// IsInvalidStateError returns whether the error is a InvalidStateError.\nfunc IsInvalidStateError(err error) bool {\n\t_, ok := err.(*InvalidStateError)\n\treturn ok\n}", "id": 1270, "concepts": ["error handling (type assertion)", "errors.As"], "_raw_llm_output": "error handling (type assertion), errors.As"}
{"seed": "// GetRegionList returns a list of AWS Regions as a slice of *ec2.Region\nfunc GetRegionList() []*ec2.Region {\n\tsess := session.Must(session.NewSession(&aws.Config{Region: aws.String(\"us-east-1\")}))\n\tsvc := ec2.New(sess)\n\n\t// Create a context with a timeout that will abort the request if it takes too long\n\tctx, cancelFn := context.WithTimeout(context.Background(), time.Second*5)\n\tdefer cancelFn()\n\n\tresp, err := svc.DescribeRegionsWithContext(ctx, nil)\n\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil\n\t}\n\n\treturn resp.Regions\n}", "id": 1273, "concepts": ["AWS SDK usage", "context", "timeout", "error handling"], "_raw_llm_output": "AWS SDK usage, context, timeout, error handling"}
{"seed": "// GetInstance gets an existing Instance resource's state with the given name, ID, and optional\n// state properties that are used to uniquely qualify the lookup (nil if not required).\nfunc GetInstance(ctx *pulumi.Context,\n\tname string, id pulumi.IDInput, state *InstanceState, opts ...pulumi.ResourceOption) (*Instance, error) {\n\tvar resource Instance\n\terr := ctx.ReadResource(\"alicloud:sddp/instance:Instance\", name, id, state, &resource, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &resource, nil\n}", "id": 1278, "concepts": ["resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation"], "_raw_llm_output": "resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation"}
{"seed": "// FromMessage creates a MarketDataSnapshotFullRefresh from a quickfix.Message instance\nfunc FromMessage(m *quickfix.Message) MarketDataSnapshotFullRefresh {\n\treturn MarketDataSnapshotFullRefresh{\n\t\tHeader:  fix42.Header{&m.Header},\n\t\tBody:    &m.Body,\n\t\tTrailer: fix42.Trailer{&m.Trailer},\n\t\tMessage: m,\n\t}\n}", "id": 1285, "concepts": ["quickfix.Message", "quickfix.Trailer", "quickfix.Header", "quickfix.Body", "struct composition", "struct embedding"], "_raw_llm_output": "quickfix.Message, quickfix.Trailer, quickfix.Header, quickfix.Body, struct composition, struct embedding"}
{"seed": "// NewWalletNumbersWithDefaults instantiates a new WalletNumbers object\n// This constructor will only assign default values to properties that have it defined,\n// but it doesn't guarantee that properties required by API are set\nfunc NewWalletNumbersWithDefaults() *WalletNumbers {\n\tthis := WalletNumbers{}\n\treturn &this\n}", "id": 1295, "concepts": ["struct initialization", "default values", "struct properties"], "_raw_llm_output": "struct initialization, default values, struct properties"}
{"seed": "// Unmarshal a CTE document, creating an object of the same type as the template.\n// If template is nil, an interface type will be returned.\n// If opts is nil, default options will be used.\nfunc UnmarshalCTE(reader io.Reader, template interface{}, opts *options.CTEUnmarshalerOptions) (decoded interface{}, err error) {\n\treturn NewCTEUnmarshaler(opts).Unmarshal(reader, template)\n}", "id": 1298, "concepts": ["interface", "function definition", "io.Reader", "standard library usage"], "_raw_llm_output": "interface, function definition, io.Reader, standard library usage"}
{"seed": "// NameNEQ applies the NEQ predicate on the \"name\" field.\nfunc NameNEQ(v string) predicate.User {\n\treturn predicate.User(sql.FieldNEQ(FieldName, v))\n}", "id": 1308, "concepts": ["predicate.User", "sql.FieldNEQ", "sql.FieldName"], "_raw_llm_output": "predicate.User, sql.FieldNEQ, sql.FieldName"}
{"seed": "// NewDeleteTagParamsWithHTTPClient creates a new DeleteTagParams object\n// with the default values initialized, and the ability to set a custom HTTPClient for a request\nfunc NewDeleteTagParamsWithHTTPClient(client *http.Client) *DeleteTagParams {\n\tvar ()\n\treturn &DeleteTagParams{\n\t\tHTTPClient: client,\n\t}\n}", "id": 1315, "concepts": ["http.Client", "function definition", "function parameter", "function return value", "function parameter type", "function parameter default value"], "_raw_llm_output": "http.Client, function definition, function parameter, function return value, function parameter type, function parameter default value"}
{"seed": "// LatestHeroScoreNEQ applies the NEQ predicate on the \"latest_hero_score\" field.\nfunc LatestHeroScoreNEQ(v int) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldLatestHeroScore), v))\n\t})\n}", "id": 1329, "concepts": ["sql.Selector", "sql.NEQ", "sql.C", "sql.Where", "sql.Predicate", "sql.Field", "sql.Query", "sql.QueryFunc", "sql.QueryFuncNEQ", "sql.QueryFuncEQ", "sql.QueryFuncLT", "sql.QueryFuncGT", "sql.QueryFuncLTE", "sql.QueryFuncGTE", "sql.QueryFuncLike", "sql.QueryFuncNotLike", "sql.QueryFuncIn", "sql.QueryFuncNotIn", "sql.QueryFuncNull", "sql.QueryFuncNotNull", "sql.QueryFuncExists", "sql.QueryFuncNotExists", "sql.QueryFuncAnd", "sql.QueryFuncOr", "sql.QueryFuncNot", "sql.QueryFuncOr", "sql.QueryFuncAnd", "sql.QueryFuncAnd", "sql.QueryFuncAnd", "sql.QueryFuncAnd", "sql.QueryFuncAnd", "sql.QueryFuncAnd", "sql.QueryFuncAnd", "sql.QueryFuncAnd", "sql.QueryFuncAnd", "sql.QueryFuncAnd", "sql.QueryFuncAnd", "sql.QueryFuncAnd", "sql.QueryFuncAnd", "sql.QueryFuncAnd", "sql.QueryFuncAnd", "sql.QueryFuncAnd", "sql.QueryFuncAnd", "sql.QueryFuncAnd", "sql"], "_raw_llm_output": "sql.Selector, sql.NEQ, sql.C, sql.Where, sql.Predicate, sql.Field, sql.Query, sql.QueryFunc, sql.QueryFuncNEQ, sql.QueryFuncEQ, sql.QueryFuncLT, sql.QueryFuncGT, sql.QueryFuncLTE, sql.QueryFuncGTE, sql.QueryFuncLike, sql.QueryFuncNotLike, sql.QueryFuncIn, sql.QueryFuncNotIn, sql.QueryFuncNull, sql.QueryFuncNotNull, sql.QueryFuncExists, sql.QueryFuncNotExists, sql.QueryFuncAnd, sql.QueryFuncOr, sql.QueryFuncNot, sql.QueryFuncOr, sql.QueryFuncAnd, sql.QueryFuncAnd, sql.QueryFuncAnd, sql.QueryFuncAnd, sql.QueryFuncAnd, sql.QueryFuncAnd, sql.QueryFuncAnd, sql.QueryFuncAnd, sql.QueryFuncAnd, sql.QueryFuncAnd, sql.QueryFuncAnd, sql.QueryFuncAnd, sql.QueryFuncAnd, sql.QueryFuncAnd, sql.QueryFuncAnd, sql.QueryFuncAnd, sql.QueryFuncAnd, sql.QueryFuncAnd, sql"}
{"seed": "// stateInStringEsc is the state after reading `'\\` during a quoted string.\nfunc stateInStringEsc(s *scanner, c byte) int {\n\tswitch c {\n\tcase 'b', 'f', 'n', 'r', 't', '\\\\', '/', '\"', '\\'':\n\t\ts.step = stateInString\n\t\treturn scanContinue\n\tcase 'u':\n\t\ts.step = stateInStringEscU\n\t\treturn scanContinue\n\t}\n\n\treturn s.error(c, \"in string escape code\")\n}", "id": 1330, "concepts": ["string manipulation", "rune handling", "character comparison", "state machine", "error handling"], "_raw_llm_output": "string manipulation, rune handling, character comparison, state machine, error handling"}
{"seed": "// prettyName returns the user-displayable name of the node if it has one.\n// Nodes with pretty names are any that are not \"text\" and do not contain _, except for bridi_tail and sumti_tail, which have the pretty names \"bridi tail\" and \"sumti tail\" respectively.\n// The pretty name of BRIVLA, CMEVLA, and CMAVO are brivla, cmevla, and cmavo respectively.\nfunc prettyName(n *peg.Fail) string {\n\tif n.Name == \"bridi_tail\" || n.Name == \"sumti_tail\" {\n\t\treturn strings.Replace(n.Name, \"_\", \" \", 1)\n\t}\n\tif n.Name == \"text\" || strings.ContainsRune(n.Name, '_') {\n\t\treturn \"\"\n\t}\n\treturn n.Name\n}", "id": 1344, "concepts": ["string manipulation", "string comparison", "rune handling", "basic function definition"], "_raw_llm_output": "string manipulation, string comparison, rune handling, basic function definition"}
{"seed": "// DSN lets you specify the unique Sentry DSN used to submit events for\n// your application. Specifying an empty DSN will disable the client.\nfunc DSN(dsn string) Option {\n\treturn &dsnOption{dsn}\n}", "id": 1361, "concepts": ["struct definition", "struct field definition", "struct field initialization", "struct field access", "struct method definition", "struct method invocation", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", ""], "_raw_llm_output": "struct definition, struct field definition, struct field initialization, struct field access, struct method definition, struct method invocation, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access,"}
{"seed": "// NewInlineObject26WithDefaults instantiates a new InlineObject26 object\n// This constructor will only assign default values to properties that have it defined,\n// but it doesn't guarantee that properties required by API are set\nfunc NewInlineObject26WithDefaults() *InlineObject26 {\n\tthis := InlineObject26{}\n\treturn &this\n}", "id": 1363, "concepts": ["struct definition", "struct initialization", "struct field assignment"], "_raw_llm_output": "struct definition, struct initialization, struct field assignment"}
{"seed": "// Unauthorizedf returns formatted Unauthorized error.\nfunc Unauthorizedf(format string, args ...interface{}) Unauthorized {\n\treturn Unauthorized(fmt.Sprintf(format, args...))\n}", "id": 1369, "concepts": ["error wrapping", "error handling (errors.New)", "error handling (errors.Is)", "error handling (errors.As)", "error handling (errors.Unwrap)", "error handling (errors.Errorf)", "error handling (errors.Wrapf)", "error handling (errors.Wrap)", "error handling (errors.Unwrap)", "error handling (errors.Cause)"], "_raw_llm_output": "error wrapping, error handling (errors.New), error handling (errors.Is), error handling (errors.As), error handling (errors.Unwrap), error handling (errors.Errorf), error handling (errors.Wrapf), error handling (errors.Wrap), error handling (errors.Unwrap), error handling (errors.Cause)"}
{"seed": "// ProjectNoExistError indicates project not exist error.\nfunc ProjectNoExistError(name string) error {\n\treturn fmt.Errorf(\"project '%s' does not exist\", name)\n}", "id": 1380, "concepts": ["error handling (fmt.Errorf)", "error wrapping"], "_raw_llm_output": "error handling (fmt.Errorf), error wrapping"}
{"seed": "// EnsembleOneTwo creates and starts an Ensemble with one full node and two miners.\n// It does not interconnect nodes nor does it begin mining.\n//\n// This function supports passing both ensemble and node functional options.\n// Functional options are applied to all nodes.\nfunc EnsembleOneTwo(t *testing.T, opts ...interface{}) (*TestFullNode, *TestMiner, *TestMiner, *Ensemble) {\n\topts = append(opts, WithAllSubsystems())\n\n\teopts, nopts := siftOptions(t, opts)\n\n\tvar (\n\t\tfull     TestFullNode\n\t\tone, two TestMiner\n\t)\n\tens := NewEnsemble(t, eopts...).\n\t\tFullNode(&full, nopts...).\n\t\tMiner(&one, &full, nopts...).\n\t\tMiner(&two, &full, nopts...).\n\t\tStart()\n\n\treturn &full, &one, &two, ens\n}", "id": 1384, "concepts": ["testing package", "testing.T", "testing.B", "testing.Skip", "testing.SkipNow", "testing.Parallel", "testing.Run", "testing.Benchmark", "testing.BenchmarkFunc", "testing.Example", "testing.ExampleFunc", "testing.Fail", "testing.FailNow", "testing.Failed", "testing.Failedf", "testing.Fatal", "testing.Fatalf", "testing.Log", "testing.Logf", "testing.Name", "testing.Skip", "testing.SkipNow", "testing.Skipf", "testing.Skipf", "testing.SkipNow", "testing.SkipNowf", "testing.Skipf", "testing.SkipNowf", "testing.Skipf", "testing.SkipNowf", "testing.Skipf", "testing.SkipNowf", "testing.Skipf", "testing.SkipNowf", "testing.Skipf", "testing.SkipNowf", "testing.Skipf", "testing.SkipNowf", "testing.Skipf", "testing.SkipNowf", "testing.Skipf", "testing.SkipNowf", "testing.Skipf", "testing.SkipNowf", "testing.Skipf", "testing.SkipNowf", "testing.Skipf", "testing.SkipNowf", "testing.Skipf", "testing.SkipNowf", "testing.Skipf", "testing.SkipNow"], "_raw_llm_output": "testing package, testing.T, testing.B, testing.Skip, testing.SkipNow, testing.Parallel, testing.Run, testing.Benchmark, testing.BenchmarkFunc, testing.Example, testing.ExampleFunc, testing.Fail, testing.FailNow, testing.Failed, testing.Failedf, testing.Fatal, testing.Fatalf, testing.Log, testing.Logf, testing.Name, testing.Skip, testing.SkipNow, testing.Skipf, testing.Skipf, testing.SkipNow, testing.SkipNowf, testing.Skipf, testing.SkipNowf, testing.Skipf, testing.SkipNowf, testing.Skipf, testing.SkipNowf, testing.Skipf, testing.SkipNowf, testing.Skipf, testing.SkipNowf, testing.Skipf, testing.SkipNowf, testing.Skipf, testing.SkipNowf, testing.Skipf, testing.SkipNowf, testing.Skipf, testing.SkipNowf, testing.Skipf, testing.SkipNowf, testing.Skipf, testing.SkipNowf, testing.Skipf, testing.SkipNowf, testing.Skipf, testing.SkipNow"}
{"seed": "// IsTypeSliceOfInterface reports whether v is a slice of interface.\nfunc IsTypeSliceOfInterface(t reflect.Type) bool {\n\tif t == reflect.TypeOf(nil) {\n\t\treturn false\n\t}\n\treturn t.Kind() == reflect.Slice && t.Elem().Kind() == reflect.Interface\n}", "id": 1389, "concepts": ["reflect.Type", "reflect.Kind", "reflect.Interface", "reflect.Slice"], "_raw_llm_output": "reflect.Type, reflect.Kind, reflect.Interface, reflect.Slice"}
{"seed": "// Velocity computes the vehicle's linear velocity in meters per second from motor rpm and radius\nfunc Velocity(rpm, rMot float64) float64 {\n\treturn rpm * math.Pi * rMot / 30\n}", "id": 1391, "concepts": ["math package usage", "basic function definition"], "_raw_llm_output": "math package usage, basic function definition"}
{"seed": "// PossibleSubscriptionTransitioningStateValues returns the possible values for the SubscriptionTransitioningState const type.\nfunc PossibleSubscriptionTransitioningStateValues() []SubscriptionTransitioningState {\n\treturn []SubscriptionTransitioningState{\n\t\tSubscriptionTransitioningStateDeleted,\n\t\tSubscriptionTransitioningStateRegistered,\n\t\tSubscriptionTransitioningStateSuspended,\n\t\tSubscriptionTransitioningStateSuspendedToDeleted,\n\t\tSubscriptionTransitioningStateSuspendedToRegistered,\n\t\tSubscriptionTransitioningStateSuspendedToUnregistered,\n\t\tSubscriptionTransitioningStateSuspendedToWarned,\n\t\tSubscriptionTransitioningStateUnregistered,\n\t\tSubscriptionTransitioningStateWarned,\n\t\tSubscriptionTransitioningStateWarnedToDeleted,\n\t\tSubscriptionTransitioningStateWarnedToRegistered,\n\t\tSubscriptionTransitioningStateWarnedToSuspended,\n\t\tSubscriptionTransitioningStateWarnedToUnregistered,\n\t}\n}", "id": 1403, "concepts": ["const type", "type definition", "type conversion", "type assertion", "type switch", "type comparison"], "_raw_llm_output": "const type, type definition, type conversion, type assertion, type switch, type comparison"}
{"seed": "// RiskDetailPAdminConfirmedSigninCompromised returns a pointer to RiskDetailVAdminConfirmedSigninCompromised\nfunc RiskDetailPAdminConfirmedSigninCompromised() *RiskDetail {\n\tv := RiskDetailVAdminConfirmedSigninCompromised\n\treturn &v\n}", "id": 1404, "concepts": ["pointer", "struct", "basic function definition"], "_raw_llm_output": "pointer, struct, basic function definition"}
{"seed": "// New creates a new instance of a Tracer that will write the output to\n// the specific io.Writer.\nfunc New(w io.Writer) Tracer {\n\treturn &tracer{out: w}\n}", "id": 1410, "concepts": ["function definition", "pointer usage", "io.Writer usage"], "_raw_llm_output": "function definition, pointer usage, io.Writer usage"}
{"seed": "// Or groups predicates with the OR operator between them.\nfunc Or(predicates ...predicate.User) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts1 := s.Clone().SetP(nil)\n\t\tfor i, p := range predicates {\n\t\t\tif i > 0 {\n\t\t\t\ts1.Or()\n\t\t\t}\n\t\t\tp(s1)\n\t\t}\n\t\ts.Where(s1.P())\n\t})\n}", "id": 1415, "concepts": ["predicate.User", "sql.Selector", "sql.Selector.Clone", "sql.Selector.SetP", "sql.Selector.Or", "sql.Selector.Where", "predicate.User function definition"], "_raw_llm_output": "predicate.User, sql.Selector, sql.Selector.Clone, sql.Selector.SetP, sql.Selector.Or, sql.Selector.Where, predicate.User function definition"}
{"seed": "// getRFC4251Mpint returns a stream of bytes representing a mixed-precision integer (a big.Int in Go)\n// prepended with a big-endian uint32 expressing the length of the data following.\n// This is the 'mpint' format in RFC4251 Section 5 (https://datatracker.ietf.org/doc/html/rfc4251#section-5)\nfunc getRFC4251Mpint(n *big.Int) []byte {\n\tbuf := new(bytes.Buffer)\n\tb := n.Bytes()\n\t// RFC4251: If the most significant bit would be set for a positive number, the number MUST be preceded by a zero byte.\n\tif b[0]&0x80 > 0 {\n\t\tb = append([]byte{0}, b...)\n\t}\n\t// write a uint32 with the length of the byte stream to the buffer\n\tbinary.Write(buf, binary.BigEndian, uint32(len(b)))\n\t// write the byte stream representing of the rest of the integer to the buffer\n\tbinary.Write(buf, binary.BigEndian, b)\n\treturn buf.Bytes()\n}", "id": 1425, "concepts": ["big.Int", "bytes.Buffer", "binary.Write", "big-endian", "uint32"], "_raw_llm_output": "big.Int, bytes.Buffer, binary.Write, big-endian, uint32"}
{"seed": "// PossibleMatchProcessingBehaviorValues returns an array of possible values for the MatchProcessingBehavior const type.\nfunc PossibleMatchProcessingBehaviorValues() []MatchProcessingBehavior {\n\treturn []MatchProcessingBehavior{MatchProcessingBehaviorContinue, MatchProcessingBehaviorStop}\n}", "id": 1431, "concepts": ["const type", "array definition"], "_raw_llm_output": "const type, array definition"}
{"seed": "// newProgressLogger creates a progressLogger based on the presence of\n// the GIT_LFS_PROGRESS environment variable. If it is present and a log file\n// is able to be created, the logger will write to the file. If it is absent,\n// or there is an err creating the file, the logger will ignore all writes.\nfunc newProgressLogger() (*progressLogger, error) {\n\tlogPath := Config.Getenv(\"GIT_LFS_PROGRESS\")\n\n\tif len(logPath) == 0 {\n\t\treturn &progressLogger{}, nil\n\t}\n\tif !filepath.IsAbs(logPath) {\n\t\treturn &progressLogger{}, fmt.Errorf(\"GIT_LFS_PROGRESS must be an absolute path\")\n\t}\n\n\tcbDir := filepath.Dir(logPath)\n\tif err := os.MkdirAll(cbDir, 0755); err != nil {\n\t\treturn &progressLogger{}, err\n\t}\n\n\tfile, err := os.OpenFile(logPath, os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0666)\n\tif err != nil {\n\t\treturn &progressLogger{}, err\n\t}\n\n\treturn &progressLogger{true, file}, nil\n}", "id": 1448, "concepts": ["os package usage", "filepath package usage", "error handling (os.OpenFile)", "error handling (os.MkdirAll)", "error handling (filepath.Dir)", "error handling (filepath.IsAbs)", "error handling (fmt.Errorf)"], "_raw_llm_output": "os package usage, filepath package usage, error handling (os.OpenFile), error handling (os.MkdirAll), error handling (filepath.Dir), error handling (filepath.IsAbs), error handling (fmt.Errorf)"}
{"seed": "// NameHasSuffix applies the HasSuffix predicate on the \"name\" field.\nfunc NameHasSuffix(v string) predicate.User {\n\treturn predicate.User(sql.FieldHasSuffix(FieldName, v))\n}", "id": 1452, "concepts": ["interface", "predicate", "sql.FieldHasSuffix"], "_raw_llm_output": "interface, predicate, sql.FieldHasSuffix"}
{"seed": "// getNatsClusterTypeMeta returns a new TypeMeta instance for the NatsCluster type.\nfunc getNatsClusterTypeMeta() metav1.TypeMeta {\n\treturn metav1.TypeMeta{\n\t\tKind:       v1alpha2.CRDResourceKind,\n\t\tAPIVersion: v1alpha2.SchemeGroupVersion.String(),\n\t}\n}", "id": 1457, "concepts": ["metav1.TypeMeta", "CRDResourceKind", "SchemeGroupVersion"], "_raw_llm_output": "metav1.TypeMeta, CRDResourceKind, SchemeGroupVersion"}
{"seed": "// GetLoopDelay returns the time delay in seconds between each application process loop\nfunc GetLoopDelay() (time.Duration, error) {\n\tvalue, err := strconv.Atoi(getEnv(\"ENM_CONFIG_LOOP_DELAY\", \"10\"))\n\treturn time.Duration(value) * time.Second, err\n}", "id": 1462, "concepts": ["environment variable usage", "strconv package usage"], "_raw_llm_output": "environment variable usage, strconv package usage"}
{"seed": "// WorkplaceNotIn applies the NotIn predicate on the \"workplace\" field.\nfunc WorkplaceNotIn(vs ...string) predicate.User {\n\treturn predicate.User(sql.FieldNotIn(FieldWorkplace, vs...))\n}", "id": 1469, "concepts": ["struct field access", "interface composition", "predicate composition", "struct composition", "SQL field access"], "_raw_llm_output": "struct field access, interface composition, predicate composition, struct composition, SQL field access"}
{"seed": "// processAPIResponse is a helper function to parse the API response body.\n// Under the hood, the following occurs:\n//\t- The provided data value will be associated with the Data field within the apiResponse struct\n//\t- The response will be parsed as an apiResponse struct\n//\t- If the apiResponse struct contains errors, they will be returned as an errors.ErrorList\nfunc processAPIResponse(r io.Reader, data interface{}) (err error) {\n\tvar resp apiResponse\n\tresp.Data = data\n\n\tif err = json.NewDecoder(r).Decode(&resp); err != nil {\n\t\t// Error encountered while decoding as JSON\n\t\treturn\n\t}\n\n\tif len(resp.Errors) == 0 {\n\t\t// No errors encountered, we can move on!\n\t\treturn\n\t}\n\n\tvar errs errors.ErrorList\n\t// Iterate through response error messages\n\tfor _, msg := range resp.Errors {\n\t\t// Push error message to errors list\n\t\terrs.Push(errors.Error(msg))\n\t}\n\n\t// Return errors list as an error\n\treturn errs.Err()\n}", "id": 1471, "concepts": ["error handling (errors.ErrorList)", "JSON decoding", "error message parsing"], "_raw_llm_output": "error handling (errors.ErrorList), JSON decoding, error message parsing"}
{"seed": "// simpleOrientation finds the orientation using the simple float64 type.\n// Its accuracy can't be guaranteed, therefore close decisions\n// return IndeterminateOrientation which signals Orientation that further\n// testing is necessary.\n//\n// It computes the determinant of the matrix and returns the orientation based\n// on the value of the determinant.\n//\n//\t| x1 y1 1 |\n//\t| x2 y2 1 |\n//\t| x  y  1 |\nfunc simpleOrientation(x1, y1, x2, y2, x, y float64) OrientationKind {\n\tif (x1 == x2 && x2 == x) || (y1 == y2 && y2 == y) {\n\t\t// points are horizontally or vertically aligned\n\t\treturn Colinear\n\t}\n\t// Compute the determinant of the matrix\n\tp := newFloat64Pred(x1).mulFloat64(y2).addFloat64Pred(newFloat64Pred(x2).mulFloat64(y)).\n\t\taddFloat64Pred(newFloat64Pred(x).mulFloat64(y1)).subFloat64Pred(newFloat64Pred(x1).mulFloat64(y)).\n\t\tsubFloat64Pred(newFloat64Pred(x2).mulFloat64(y1)).subFloat64Pred(newFloat64Pred(x).mulFloat64(y2))\n\t// det := x1*y2 + x2*y + x*y1 - x1*y - x2*y1 - x*y2\n\tdet := p.n\n\t// e determines when the determinant in simpleOrientation is too close to 0 to rely on floating point operations.\n\te := p.e\n\tif det > e {\n\t\treturn CCW\n\t}\n\tif det < -e {\n\t\treturn CW\n\t}\n\treturn IndeterminateOrientation\n}", "id": 1472, "concepts": ["float64 type", "floating point error handling", "floating point comparison", "floating point division", "floating point multiplication", "floating point subtraction", "floating point addition", "floating point determinant computation", "floating point determinant comparison", "floating point determinant error handling", "floating point determinant base case handling", "floating point determinant indeterminate handling", "floating point determinant orientation computation", "floating point determinant orientation comparison", "floating point determinant orientation error handling", "floating point determinant orientation base case handling", "floating point determinant orientation indeterminate handling", "floating point determinant orientation orientation computation", "floating point determinant orientation orientation comparison", "floating point determinant orientation orientation error handling", "floating point determinant orientation orientation base case handling", "floating point determinant orientation orientation indeterminate handling", "floating point determinant orientation orientation orientation computation", "floating point determinant orientation orientation orientation comparison", "floating point determinant orientation orientation orientation error handling", "floating point determinant orientation orientation orientation base case handling", "floating point determinant orientation orientation orientation indeterminate handling", "floating point determinant orientation orientation orientation orientation computation", "floating point determinant orientation orientation orientation orientation comparison", "floating point determinant orientation orientation orientation orientation orientation error handling", "floating point determinant orientation orientation orientation orientation orientation base case handling", "floating point determinant orientation orientation orientation orientation orientation"], "_raw_llm_output": "float64 type, floating point error handling, floating point comparison, floating point division, floating point multiplication, floating point subtraction, floating point addition, floating point determinant computation, floating point determinant comparison, floating point determinant error handling, floating point determinant base case handling, floating point determinant indeterminate handling, floating point determinant orientation computation, floating point determinant orientation comparison, floating point determinant orientation error handling, floating point determinant orientation base case handling, floating point determinant orientation indeterminate handling, floating point determinant orientation orientation computation, floating point determinant orientation orientation comparison, floating point determinant orientation orientation error handling, floating point determinant orientation orientation base case handling, floating point determinant orientation orientation indeterminate handling, floating point determinant orientation orientation orientation computation, floating point determinant orientation orientation orientation comparison, floating point determinant orientation orientation orientation error handling, floating point determinant orientation orientation orientation base case handling, floating point determinant orientation orientation orientation indeterminate handling, floating point determinant orientation orientation orientation orientation computation, floating point determinant orientation orientation orientation orientation comparison, floating point determinant orientation orientation orientation orientation orientation error handling, floating point determinant orientation orientation orientation orientation orientation base case handling, floating point determinant orientation orientation orientation orientation orientation"}
{"seed": "// getIntersectionStores returns the stores included in two region's peers.\nfunc getIntersectionStores(a []*metapb.Peer, b []*metapb.Peer) []uint64 {\n\tset := make([]uint64, 0)\n\thash := make(map[uint64]struct{})\n\n\tfor _, peer := range a {\n\t\thash[peer.GetStoreId()] = struct{}{}\n\t}\n\n\tfor _, peer := range b {\n\t\tif _, found := hash[peer.GetStoreId()]; found {\n\t\t\tset = append(set, peer.GetStoreId())\n\t\t}\n\t}\n\n\treturn set\n}", "id": 1475, "concepts": ["map iteration", "map lookup", "map creation", "map deletion", "map usage"], "_raw_llm_output": "map iteration, map lookup, map creation, map deletion, map usage"}
{"seed": "// ValidateSelfSubjectAccessReview validates a SelfSubjectAccessReview and returns an\n// ErrorList with any errors.\nfunc ValidateSelfSubjectAccessReview(sar *authorizationapi.SelfSubjectAccessReview) field.ErrorList {\n\tallErrs := ValidateSelfSubjectAccessReviewSpec(sar.Spec, field.NewPath(\"spec\"))\n\tobjectMetaShallowCopy := sar.ObjectMeta\n\tobjectMetaShallowCopy.ManagedFields = nil\n\tif !apiequality.Semantic.DeepEqual(metav1.ObjectMeta{}, objectMetaShallowCopy) {\n\t\tallErrs = append(allErrs, field.Invalid(field.NewPath(\"metadata\"), sar.ObjectMeta, `must be empty`))\n\t}\n\treturn allErrs\n}", "id": 1476, "concepts": ["field.ErrorList", "metav1.ObjectMeta", "apiequality.Semantic.DeepEqual"], "_raw_llm_output": "field.ErrorList, metav1.ObjectMeta, apiequality.Semantic.DeepEqual"}
{"seed": "// W logs message under tag with priority PriorityWarning to w.\nfunc W(w Writer, tag Tag, message string) error {\n\treturn w.Write(PriorityWarn, tag, message)\n}", "id": 1488, "concepts": ["interface implementation", "interface usage", "function composition"], "_raw_llm_output": "interface implementation, interface usage, function composition"}
{"seed": "// New constructs a new, empty, world.\nfunc New() *World {\n\treturn &World{}\n}", "id": 1494, "concepts": ["basic function definition", "struct definition", "pointer usage"], "_raw_llm_output": "basic function definition, struct definition, pointer usage"}
{"seed": "// AdMarkupType_Values returns all elements of the AdMarkupType enum\nfunc AdMarkupType_Values() []string {\n\treturn []string{\n\t\tAdMarkupTypeDaterange,\n\t\tAdMarkupTypeScte35Enhanced,\n\t}\n}", "id": 1496, "concepts": ["enum usage", "iota", "slice", "string concatenation"], "_raw_llm_output": "enum usage, iota, slice, string concatenation"}
{"seed": "// ParseDeleteElasticIpResponse parses an HTTP response from a DeleteElasticIpWithResponse call\nfunc ParseDeleteElasticIpResponse(rsp *http.Response) (*DeleteElasticIpResponse, error) {\n\tbodyBytes, err := ioutil.ReadAll(rsp.Body)\n\tdefer rsp.Body.Close()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse := &DeleteElasticIpResponse{\n\t\tBody:         bodyBytes,\n\t\tHTTPResponse: rsp,\n\t}\n\n\tswitch {\n\tcase strings.Contains(rsp.Header.Get(\"Content-Type\"), \"json\") && rsp.StatusCode == 200:\n\t\tvar dest Operation\n\t\tif err := json.Unmarshal(bodyBytes, &dest); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresponse.JSON200 = &dest\n\n\t}\n\n\treturn response, nil\n}", "id": 1498, "concepts": ["http.Response", "json.Unmarshal", "error handling (idiomatic `if err != nil`", "`errors.As`)", "type conversion", "string manipulation"], "_raw_llm_output": "http.Response, json.Unmarshal, error handling (idiomatic `if err != nil`, `errors.As`), type conversion, string manipulation"}
{"seed": "// CreateMessageRuleFromDiscriminatorValue creates a new instance of the appropriate class based on discriminator value\nfunc CreateMessageRuleFromDiscriminatorValue(parseNode i878a80d2330e89d26896388a3f487eef27b0a0e6c010c493bf80be1452208f91.ParseNode)(i878a80d2330e89d26896388a3f487eef27b0a0e6c010c493bf80be1452208f91.Parsable, error) {\n    return NewMessageRule(), nil\n}", "id": 1499, "concepts": ["interface implementation", "interface definition", "interface usage", "standard library usage"], "_raw_llm_output": "interface implementation, interface definition, interface usage, standard library usage"}
{"seed": "// IsRuleID matches a compliance rule by ID\nfunc IsRuleID(ruleID string) RuleMatcher {\n\treturn func(r *compliance.Rule) bool {\n\t\treturn r.ID == ruleID\n\t}\n}", "id": 1502, "concepts": ["function composition", "function definition", "function signature", "function type", "function value", "function pointer", "function receiver", "function literal", "function closure", "function application", "function application with arguments", "function application with named arguments", "function application with variadic arguments", "function application with return values", "function application with return values and named return values", "function application with return values and named return values and error handling", "function application with return values and named return values and error handling and named return values", "function application with return values and named return values and error handling and named return values and error handling", "function application with return values and named return values and error handling and named return values and error handling and named return values", "function application with return values and named return values and error handling and named return values and error handling and named return values and error handling", "function application with return values and named return values and error handling and named return values and error handling and named return values and error handling and named return values", "function application with return values and named return values and error handling and named return values and error handling and named return values and error handling and named return values and error handling", "function application with return values and named return values and error handling and named return values and error handling and named return values and error"], "_raw_llm_output": "function composition, function definition, function signature, function type, function value, function pointer, function receiver, function literal, function closure, function application, function application with arguments, function application with named arguments, function application with variadic arguments, function application with return values, function application with return values and named return values, function application with return values and named return values and error handling, function application with return values and named return values and error handling and named return values, function application with return values and named return values and error handling and named return values and error handling, function application with return values and named return values and error handling and named return values and error handling and named return values, function application with return values and named return values and error handling and named return values and error handling and named return values and error handling, function application with return values and named return values and error handling and named return values and error handling and named return values and error handling and named return values, function application with return values and named return values and error handling and named return values and error handling and named return values and error handling and named return values and error handling, function application with return values and named return values and error handling and named return values and error handling and named return values and error"}
{"seed": "// WithRetry prepares context for transaction for which the scheduler will retry\n// any (retriable) failed operations after given <period>. If <expBackoff>\n// is enabled, every failed retry will double the next delay. Non-zero <maxCount>\n// limits the maximum number of retries the scheduler will execute.\n// Can be combined with revert - even failed revert operations will be re-tried.\n// By default, the scheduler will not automatically retry failed operations.\nfunc WithRetry(ctx context.Context, period time.Duration, maxCount int, expBackoff bool) context.Context {\n\treturn context.WithValue(ctx, retryCtxKey, &RetryOpt{\n\t\tPeriod:     period,\n\t\tMaxCount:   maxCount,\n\t\tExpBackoff: expBackoff,\n\t})\n}", "id": 1505, "concepts": ["context", "context.WithValue", "context.Context", "context.ContextKey", "time.Duration", "time.Sleep", "context.DeadlineExceeded", "context.Canceled", "context.DeadlineExceeded", "context.DeadlineExceeded", "context.DeadlineExceeded", "context.DeadlineExceeded", "context.DeadlineExceeded", "context.DeadlineExceeded", "context.DeadlineExceeded", "context.DeadlineExceeded", "context.DeadlineExceeded", "context.DeadlineExceeded", "context.DeadlineExceeded"], "_raw_llm_output": "context, context.WithValue, context.Context, context.ContextKey, time.Duration, time.Sleep, context.DeadlineExceeded, context.Canceled, context.DeadlineExceeded, context.DeadlineExceeded, context.DeadlineExceeded, context.DeadlineExceeded, context.DeadlineExceeded, context.DeadlineExceeded, context.DeadlineExceeded, context.DeadlineExceeded, context.DeadlineExceeded, context.DeadlineExceeded, context.DeadlineExceeded"}
{"seed": "// PossibleKindBasicDataConnectionValues returns an array of possible values for the KindBasicDataConnection const type.\nfunc PossibleKindBasicDataConnectionValues() []KindBasicDataConnection {\n\treturn []KindBasicDataConnection{KindDataConnection, KindEventGrid, KindEventHub, KindIotHub}\n}", "id": 1519, "concepts": ["array", "basic function definition", "constant definition", "array iteration"], "_raw_llm_output": "array, basic function definition, constant definition, array iteration"}
{"seed": "// ExcludedVersion reports if the current module or any dependencies are using a version excluded by a dependency.\r\n// It returns true if so.\r\n// Currently requires main module's go.mod being in a consistent state (e.g., after a 'go list' or 'go build'), such that\r\n// the main module does not have a go.mod file using something it excludes.\r\n// gomodvet enforces this requirement.\r\n//\r\n// ExcludedVersion also assumes versions in any 'go.mod' file in the build is using canonical version strings.\r\n// The 'go' tool also enforces this when run (with some rare possible exceptions like multiple valid tags for a single commit),\r\n// but a person could check in any given 'go.mod' file prior to letting the 'go' tool use canonical version strings. If\r\n// that were to happen, the current ExcludedVersion could have a false negative (that is, potentially miss flagging something).\r\n// Rule: gomodvet-005\r\nfunc ExcludedVersion(verbose bool) (bool, error) {\r\n\treport := func(err error) error { return fmt.Errorf(\"excludedversion: %v\", err) }\r\n\r\n\t// track our versions in { path: version } map.\r\n\tversions := make(map[string]string)\r\n\tmods, err := buildlist.Resolve()\r\n\tif err != nil {\r\n\t\treturn false, report(err)\r\n\t}\r\n\t// build up our reference map\r\n\tfor _, mod := range mods {\r\n\t\tif verbose {\r\n\t\t\tfmt.Printf(\"gomodvet: excludedversion: module %s: %+v\\n\", mod.Path, mod)\r\n\t\t}\r\n\t\tversions[mod.Path] = mod.Version\r\n\t}\r\n\r\n\t// do our check by parsing each 'go.mod' file being used,\r\n\t// and check if we are using a path/version combination excluded\r\n\t// by one of a go.mod file in our dependecies\r\n\tflagged := false\r\n\tfor _, mod := range mods {\r\n\t\tif mod.Main {\r\n\t\t\t// here we assume the main module's 'go.mod' is in a consistent state,\r\n\t\t\t// and not using something excluded in its own 'go.mod' file. The 'go' tool\r\n\t\t\t// enforces this on a 'go build', 'go mod tidy', etc.\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\tfile, err := modfile.Parse(mod.GoMod)\r\n\t\tif err != nil {\r\n\t\t\treturn false, report(err)\r\n\t\t}\r\n\t\tfor _, exclude := range file.Exclude {\r\n\t\t\tusingVersion, ok := versions[exclude.Path]\r\n\t\t\tif !ok {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\tif usingVersion == exclude.Version {\r\n\t\t\t\tfmt.Printf(\"gomodvet-005: a module is using a version excluded by another module. excluded version: %s %s\\n\",\r\n\t\t\t\t\texclude.Path, exclude.Version)\r\n\t\t\t\tflagged = true\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn flagged, nil\r\n}", "id": 1527, "concepts": ["module resolution", "module definition", "module dependency handling", "go.mod file parsing", "module version handling"], "_raw_llm_output": "module resolution, module definition, module dependency handling, go.mod file parsing, module version handling"}
{"seed": "// GenElem creates the gen.Elem out of an\n// ast.TypeSpec. Right now the only supported\n// TypeSpec.Type is *ast.StructType\nfunc GenElem(in *ast.TypeSpec) gen.Elem {\n\t// handle supported types\n\tswitch in.Type.(type) {\n\n\tcase *ast.StructType:\n\t\tv := in.Type.(*ast.StructType)\n\t\tfmt.Printf(chalk.Green.Color(\"parsing %s...\"), in.Name.Name)\n\t\tp := &gen.Ptr{\n\t\t\tValue: &gen.Struct{\n\t\t\t\tName:   in.Name.Name, // ast.Ident\n\t\t\t\tFields: parseFieldList(v.Fields),\n\t\t\t},\n\t\t}\n\n\t\t// mark type as processed\n\t\tglobalProcessed[in.Name.Name] = struct{}{}\n\n\t\tif len(p.Value.(*gen.Struct).Fields) == 0 {\n\t\t\tfmt.Printf(chalk.Red.Color(\" has no exported fields \\u2717\\n\")) // X\n\t\t\treturn nil\n\t\t}\n\t\tfmt.Print(chalk.Green.Color(\"  \\u2713\\n\")) // check\n\t\treturn p\n\n\tdefault:\n\t\treturn nil\n\n\t}\n}", "id": 1539, "concepts": ["ast package usage", "type casting", "switch statement", "map usage", "string formatting", "pointer usage", "struct definition", "struct field definition", "struct field iteration", "struct field type conversion", "struct field type definition", "struct field type iteration", "struct field type name conversion", "struct field type name definition", "struct field type name iteration", "struct field type name iteration", "struct field type name iteration", "struct field type name iteration", "struct field type name iteration", "struct field type name iteration", "struct field type name iteration", "struct field type name iteration", "struct field type name iteration", "struct field type name iteration", "struct field type name iteration", "struct field type name iteration", "struct field type name iteration", "struct field type name iteration", "struct field type name iteration", "struct field type name iteration", "struct field type name iteration", "struct field type name iteration", "struct field type name iteration", "struct field type name iteration", "struct field type name iteration", "struct field type name iteration", "struct field type name iteration", "struct field type name iteration", "struct field type name iteration", "struct field type name iteration", "struct field type name iteration", "struct field type name iteration", "struct field type name iteration", "struct field type name iteration", "struct field type name iteration", "struct field type name iteration", "struct field type name iteration", ""], "_raw_llm_output": "ast package usage, type casting, switch statement, map usage, string formatting, pointer usage, struct definition, struct field definition, struct field iteration, struct field type conversion, struct field type definition, struct field type iteration, struct field type name conversion, struct field type name definition, struct field type name iteration, struct field type name iteration, struct field type name iteration, struct field type name iteration, struct field type name iteration, struct field type name iteration, struct field type name iteration, struct field type name iteration, struct field type name iteration, struct field type name iteration, struct field type name iteration, struct field type name iteration, struct field type name iteration, struct field type name iteration, struct field type name iteration, struct field type name iteration, struct field type name iteration, struct field type name iteration, struct field type name iteration, struct field type name iteration, struct field type name iteration, struct field type name iteration, struct field type name iteration, struct field type name iteration, struct field type name iteration, struct field type name iteration, struct field type name iteration, struct field type name iteration, struct field type name iteration, struct field type name iteration, struct field type name iteration, struct field type name iteration, struct field type name iteration,"}
{"seed": "// PossibleProtocolValues returns an array of possible values for the Protocol const type.\nfunc PossibleProtocolValues() []Protocol {\n\treturn []Protocol{ProtocolHTTP, ProtocolHTTPS}\n}", "id": 1546, "concepts": ["array definition", "array iteration (range loop)", "array length"], "_raw_llm_output": "array definition, array iteration (range loop), array length"}
{"seed": "// RTWithPropagation enables/disables propagation for tracing headers.\n// Disabling propagation will disconnect this trace from any downstream traces.\nfunc RTWithPropagation(propagation bool) RoundTripperOption {\n\treturn func(cfg *roundTripperConfig) {\n\t\tcfg.propagation = propagation\n\t}\n}", "id": 1548, "concepts": ["function definition", "function composition", "function options", "function options composition"], "_raw_llm_output": "function definition, function composition, function options, function options composition"}
{"seed": "// Vector2d creates a new 2-dimensional vector with the supplied values as its components.\r\nfunc Vector2d(x, y float64) Vector2 {\r\n\treturn Vector2{x, y}\r\n}", "id": 1558, "concepts": ["struct definition", "struct field definition", "struct initialization"], "_raw_llm_output": "struct definition, struct field definition, struct initialization"}
{"seed": "// MapUint16Float64Ptr takes two inputs -\n// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list\nfunc MapUint16Float64Ptr(f func(*uint16) *float64, list []*uint16) []*float64 {\n\tif f == nil {\n\t\treturn []*float64{}\n\t}\n\tnewList := make([]*float64, len(list))\n\tfor i, v := range list {\n\t\tnewList[i] = f(v)\n\t}\n\treturn newList\n}", "id": 1566, "concepts": ["function definition", "function composition", "function application", "function pointer", "function closure", "function composition", "function application", "function pointer", "function closure", "function composition", "function application", "function pointer", "function closure", "function composition", "function application", "function pointer", "function closure", "function composition", "function application", "function pointer", "function closure", "function composition", "function application", "function pointer", "function closure", "function composition", "function application", "function pointer", "function closure", "function composition", "function application", "function pointer", "function closure", "function composition", "function application", "function pointer", "function closure", "function composition", "function application", "function pointer", "function closure", "function composition", "function application", "function pointer", "function closure", "function composition", "function application", "function pointer", "function closure", "function composition", "function application", "function pointer", "function closure", "function composition", "function application", "function pointer", "function closure", "function composition", "function application", "function pointer", "function closure", "function composition", "function application", "function pointer", "function closure", "function composition", "function application", "function pointer", "function closure", "function composition", "function application", "function pointer", "function closure", "function composition", "function application", "function pointer", "function closure", "function composition", "function application", "function pointer", "function closure", "function composition", "function application", "function pointer", "function closure", ""], "_raw_llm_output": "function definition, function composition, function application, function pointer, function closure, function composition, function application, function pointer, function closure, function composition, function application, function pointer, function closure, function composition, function application, function pointer, function closure, function composition, function application, function pointer, function closure, function composition, function application, function pointer, function closure, function composition, function application, function pointer, function closure, function composition, function application, function pointer, function closure, function composition, function application, function pointer, function closure, function composition, function application, function pointer, function closure, function composition, function application, function pointer, function closure, function composition, function application, function pointer, function closure, function composition, function application, function pointer, function closure, function composition, function application, function pointer, function closure, function composition, function application, function pointer, function closure, function composition, function application, function pointer, function closure, function composition, function application, function pointer, function closure, function composition, function application, function pointer, function closure, function composition, function application, function pointer, function closure, function composition, function application, function pointer, function closure, function composition, function application, function pointer, function closure,"}
{"seed": "// CommitteeSize returns testchain committee size.\nfunc CommitteeSize() int {\n\treturn len(privNetKeys)\n}", "id": 1567, "concepts": ["variable declaration", "function definition", "variable assignment"], "_raw_llm_output": "variable declaration, function definition, variable assignment"}
{"seed": "// AccessType_Values returns all elements of the AccessType enum\nfunc AccessType_Values() []string {\n\treturn []string{\n\t\tAccessTypeS3Sigv4,\n\t\tAccessTypeSecretsManagerAccessToken,\n\t\tAccessTypeAutodetectSigv4,\n\t}\n}", "id": 1573, "concepts": ["enum", "string array", "basic function definition"], "_raw_llm_output": "enum, string array, basic function definition"}
{"seed": "// DToXY converts a one-dimensional distance (d) along a discrete\n// Hilbert curve to a two-dimensional cell position with coordinates\n// (x, y).\n//\n// The cell count n must be a power of 2, and the distance d must range\n// from 0, representing the cell in the lower left-hand corner of the\n// square, to n^2-1, representing the cell in the upper right-hand\n// corner of the square.\n//\n// The return value (x, y) where x and y are between 0 and n-1, is the\n// position of the cell to which d corresponds, where cell (0, 0)\n// represents cell at the lower left-hand corner of the square and\n// (n-1, n-1) represents the cell at the upper right-hand corner of the\n// square.\n//\n// The complementary function XYToD performs the inverse transformation.\nfunc DToXY(n, d int) (x, y int) {\n\tt := d\n\tfor s:=1; s<n; s*=2 {\n\t\trx := 1 & (t/2)\n\t\try := 1 & (t ^ rx)\n\t\trot(s, rx, ry, &x, &y)\n\t\tx += s * rx\n\t\ty += s * ry\n\t\tt /= 4\n\t}\n\treturn\n}", "id": 1576, "concepts": ["discrete Hilbert curve", "mathematical series", "bitwise operations", "recursion"], "_raw_llm_output": "discrete Hilbert curve, mathematical series, bitwise operations, recursion"}
{"seed": "// prettySIG takes a sig name as parsed by the `sig-foo` label and returns a\n// \"pretty\" version of it that can be printed in documents\nfunc prettySIG(sig string) string {\n\tparts := strings.Split(sig, \"-\")\n\tfor i, part := range parts {\n\t\tswitch part {\n\t\tcase \"vsphere\":\n\t\t\tparts[i] = \"vSphere\"\n\t\tcase \"vmware\":\n\t\t\tparts[i] = \"VMWare\"\n\t\tcase \"openstack\":\n\t\t\tparts[i] = \"OpenStack\"\n\t\tcase \"api\", \"aws\", \"cli\", \"gcp\":\n\t\t\tparts[i] = strings.ToUpper(part)\n\t\tdefault:\n\t\t\tparts[i] = cases.Title(language.English).String(part)\n\t\t}\n\t}\n\treturn strings.Join(parts, \" \")\n}", "id": 1587, "concepts": ["string manipulation", "string formatting", "string concatenation", "string iteration", "string iteration (range loop)", "string iteration (for loop)", "string iteration (for loop)", "string iteration (for loop)", "string iteration (for loop)", "string iteration (for loop)", "string iteration (for loop)", "string iteration (for loop)", "string iteration (for loop)", "string iteration (for loop)", "string iteration (for loop)", "string iteration (for loop)", "string iteration (for loop)", "string iteration (for loop)", "string iteration (for loop)", "string iteration (for loop)", "string iteration (for loop)", "string iteration (for loop)", "string iteration (for loop)", "string iteration (for loop)", "string iteration (for loop)", "string iteration (for loop)", "string iteration (for loop)", "string iteration (for loop)", "string iteration (for loop)", "string iteration (for loop)", "string iteration (for loop)", "string iteration (for loop)", "string iteration (for loop)", "string iteration (for loop)", "string iteration (for loop)", "string iteration (for loop)", "string iteration (for loop)", "string iteration (for loop)", "string iteration (for loop)", "string iteration (for loop)", "string iteration (for loop)", "string iteration (for loop)", "string iteration (for loop)", "string iteration (for loop)", "string iteration"], "_raw_llm_output": "string manipulation, string formatting, string concatenation, string iteration, string iteration (range loop), string iteration (for loop), string iteration (for loop), string iteration (for loop), string iteration (for loop), string iteration (for loop), string iteration (for loop), string iteration (for loop), string iteration (for loop), string iteration (for loop), string iteration (for loop), string iteration (for loop), string iteration (for loop), string iteration (for loop), string iteration (for loop), string iteration (for loop), string iteration (for loop), string iteration (for loop), string iteration (for loop), string iteration (for loop), string iteration (for loop), string iteration (for loop), string iteration (for loop), string iteration (for loop), string iteration (for loop), string iteration (for loop), string iteration (for loop), string iteration (for loop), string iteration (for loop), string iteration (for loop), string iteration (for loop), string iteration (for loop), string iteration (for loop), string iteration (for loop), string iteration (for loop), string iteration (for loop), string iteration (for loop), string iteration (for loop), string iteration (for loop), string iteration (for loop), string iteration"}
{"seed": "// New creates a new instance of the MetricSet. New is responsible for unpacking\n// any MetricSet specific configuration options if there are any.\nfunc New(base mb.BaseMetricSet) (mb.MetricSet, error) {\n\treturn &MetricSet{\n\t\tBaseMetricSet: base,\n\t}, nil\n}", "id": 1608, "concepts": ["struct definition", "struct field definition", "struct initialization", "struct method definition", "method receiver", "method invocation", "method call", "method call with receiver", "method call with receiver and arguments", "method call with receiver and arguments and return values", "method call with receiver and arguments and return values and error handling", "method call with receiver and arguments and return values and error handling and error handling", "method call with receiver and arguments and return values and error handling and error handling and error handling", "method call with receiver and arguments and return values and error handling and error handling and error handling and error handling"], "_raw_llm_output": "struct definition, struct field definition, struct initialization, struct method definition, method receiver, method invocation, method call, method call with receiver, method call with receiver and arguments, method call with receiver and arguments and return values, method call with receiver and arguments and return values and error handling, method call with receiver and arguments and return values and error handling and error handling, method call with receiver and arguments and return values and error handling and error handling and error handling, method call with receiver and arguments and return values and error handling and error handling and error handling and error handling"}
{"seed": "// NewListInstanceTypesRequest generates requests for ListInstanceTypes\nfunc NewListInstanceTypesRequest(server string) (*http.Request, error) {\n\tvar err error\n\n\tqueryUrl, err := url.Parse(server)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbasePath := fmt.Sprintf(\"/instance-type\")\n\tif basePath[0] == '/' {\n\t\tbasePath = basePath[1:]\n\t}\n\n\tqueryUrl, err = queryUrl.Parse(basePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq, err := http.NewRequest(\"GET\", queryUrl.String(), nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn req, nil\n}", "id": 1623, "concepts": ["URL parsing", "http.NewRequest", "string formatting", "URL manipulation"], "_raw_llm_output": "URL parsing, http.NewRequest, string formatting, URL manipulation"}
{"seed": "// NewCreateCommentContext parses the incoming request URL and body, performs validations and creates the\n// context used by the comment controller create action.\nfunc NewCreateCommentContext(ctx context.Context, r *http.Request, service *goa.Service) (*CreateCommentContext, error) {\n\tvar err error\n\tresp := goa.ContextResponse(ctx)\n\tresp.Service = service\n\treq := goa.ContextRequest(ctx)\n\treq.Request = r\n\trctx := CreateCommentContext{Context: ctx, ResponseData: resp, RequestData: req}\n\treturn &rctx, err\n}", "id": 1624, "concepts": ["context", "http request", "http response", "context handling", "request handling", "response handling", "context creation", "request creation", "response creation"], "_raw_llm_output": "context, http request, http response, context handling, request handling, response handling, context creation, request creation, response creation"}
{"seed": "// ParseImportRawDNSZoneResponse parses an HTTP response from a ImportRawDNSZoneWithResponse call\nfunc ParseImportRawDNSZoneResponse(rsp *http.Response) (*ImportRawDNSZoneResponse, error) {\n\tbodyBytes, err := ioutil.ReadAll(rsp.Body)\n\tdefer rsp.Body.Close()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse := &ImportRawDNSZoneResponse{\n\t\tBody:         bodyBytes,\n\t\tHTTPResponse: rsp,\n\t}\n\n\tswitch {\n\tcase strings.Contains(rsp.Header.Get(\"Content-Type\"), \"json\") && rsp.StatusCode == 200:\n\t\tvar dest ScalewayDomainV2alpha2ImportRawDNSZoneResponse\n\t\tif err := json.Unmarshal(bodyBytes, &dest); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresponse.JSON200 = &dest\n\n\t}\n\n\treturn response, nil\n}", "id": 1627, "concepts": ["HTTP client usage", "JSON parsing", "response parsing"], "_raw_llm_output": "HTTP client usage, JSON parsing, response parsing"}
{"seed": "// PropValNum64 transforms a GetPropertyReply struct into a 64 bit\n// integer. Useful when the property value is a single integer.\nfunc PropValNum64(reply *xproto.GetPropertyReply, err error) (int64, error) {\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif reply.Format != 32 {\n\t\treturn 0, fmt.Errorf(\"PropValNum: Expected format 32 but got %d\",\n\t\t\treply.Format)\n\t}\n\treturn int64(xgb.Get32(reply.Value)), nil\n}", "id": 1628, "concepts": ["struct field access", "struct field type conversion", "xgb package usage"], "_raw_llm_output": "struct field access, struct field type conversion, xgb package usage"}
{"seed": "// compareVersions accepts desiredVersion and currentVersion strings as versions, converts\n// them to semver and then compares them. Returns an indication of whether the desired\n// version constitutes a downgrade, no-op or upgrade, or an error if no valid comparison can occur\nfunc compareVersions(dV semver.Version, cV semver.Version, logger logr.Logger) (VersionComparison, error) {\n\tresult := dV.Compare(cV)\n\tswitch result {\n\tcase -1:\n\t\tlogger.Info(fmt.Sprintf(\"%s is less than %s\", dV, cV))\n\t\treturn VersionDowngrade, nil\n\tcase 0:\n\t\tlogger.Info(fmt.Sprintf(\"%s is equal to %s\", dV, cV))\n\t\treturn VersionEqual, nil\n\tcase 1:\n\t\tlogger.Info(fmt.Sprintf(\"%s is greater than %s\", dV, cV))\n\t\treturn VersionUpgrade, nil\n\tdefault:\n\t\treturn VersionUnknown, fmt.Errorf(\"semver comparison failed for unknown reason. Versions %s & %s\", dV, cV)\n\t}\n\n}", "id": 1632, "concepts": ["semver", "semver.Version", "semver.Compare", "error handling", "switch statement", "basic function definition"], "_raw_llm_output": "semver, semver.Version, semver.Compare, error handling, switch statement, basic function definition"}
{"seed": "// Rp represents the HTML element 'rp'.\n// For more information visit https://www.w3schools.com/tags/tag_rp.asp.\nfunc Rp(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"rp\", Attributes: attrs, Children: children}\n}", "id": 1633, "concepts": ["HTML generation", "HTML tree structure", "HTML element definition"], "_raw_llm_output": "HTML generation, HTML tree structure, HTML element definition"}
{"seed": "// FindUnusedPort : find port number not currently used by the host.\nfunc FindUnusedPort() (uint16, error) {\n\t// We let the kernel to find the port for us.\n\taddr, err := net.ResolveTCPAddr(\"tcp\", \"localhost:0\")\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tl, err := net.ListenTCP(\"tcp\", addr)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tdefer l.Close()\n\treturn uint16(l.Addr().(*net.TCPAddr).Port), nil\n}", "id": 1645, "concepts": ["net/http package usage", "net/net package usage", "net/net.ListenTCP", "net.ResolveTCPAddr", "net.TCPAddr", "net.Addr", "net.Listener", "net.Addr", "net.TCPListener", "net.TCPAddr", "net.TCPAddr.Port", "net.TCPAddr.Port()", "net.TCPAddr.Port()", "net.TCPAddr.Port()", "net.TCPAddr.Port()", "net.TCPAddr.Port()", "net.TCPAddr.Port()", "net.TCPAddr.Port()", "net.TCPAddr.Port()", "net.TCPAddr.Port()", "net.TCPAddr.Port()", "net.TCPAddr.Port()", "net.TCPAddr.Port()", "net.TCPAddr.Port()", "net.TCPAddr.Port()", "net.TCPAddr.Port()", "net.TCPAddr.Port()", "net.TCPAddr.Port()", "net.TCPAddr.Port()", "net.TCPAddr.Port()", "net.TCPAddr.Port()", "net.TCPAddr.Port()", "net.TCPAddr.Port()", "net.TCPAddr.Port()", "net.TCPAddr.Port()", "net.TCPAddr.Port()", "net.TCPAddr.Port()", "net.TCPAddr.Port()", "net.TCPAddr.Port()", ""], "_raw_llm_output": "net/http package usage, net/net package usage, net/net.ListenTCP, net.ResolveTCPAddr, net.TCPAddr, net.Addr, net.Listener, net.Addr, net.TCPListener, net.TCPAddr, net.TCPAddr.Port, net.TCPAddr.Port(), net.TCPAddr.Port(), net.TCPAddr.Port(), net.TCPAddr.Port(), net.TCPAddr.Port(), net.TCPAddr.Port(), net.TCPAddr.Port(), net.TCPAddr.Port(), net.TCPAddr.Port(), net.TCPAddr.Port(), net.TCPAddr.Port(), net.TCPAddr.Port(), net.TCPAddr.Port(), net.TCPAddr.Port(), net.TCPAddr.Port(), net.TCPAddr.Port(), net.TCPAddr.Port(), net.TCPAddr.Port(), net.TCPAddr.Port(), net.TCPAddr.Port(), net.TCPAddr.Port(), net.TCPAddr.Port(), net.TCPAddr.Port(), net.TCPAddr.Port(), net.TCPAddr.Port(), net.TCPAddr.Port(), net.TCPAddr.Port(), net.TCPAddr.Port(),"}
{"seed": "// MapInt16Uint16Ptr takes two inputs -\n// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list\nfunc MapInt16Uint16Ptr(f func(*int16) *uint16, list []*int16) []*uint16 {\n\tif f == nil {\n\t\treturn []*uint16{}\n\t}\n\tnewList := make([]*uint16, len(list))\n\tfor i, v := range list {\n\t\tnewList[i] = f(v)\n\t}\n\treturn newList\n}", "id": 1649, "concepts": ["function definition", "function pointer", "function composition", "function composition with multiple functions", "function composition with multiple functions and function composition with multiple functions"], "_raw_llm_output": "function definition, function pointer, function composition, function composition with multiple functions, function composition with multiple functions and function composition with multiple functions"}
{"seed": "// PossibleBackendEnabledStateValues returns an array of possible values for the BackendEnabledState const type.\nfunc PossibleBackendEnabledStateValues() []BackendEnabledState {\n\treturn []BackendEnabledState{BackendEnabledStateDisabled, BackendEnabledStateEnabled}\n}", "id": 1652, "concepts": ["const type definition", "array definition", "basic function definition"], "_raw_llm_output": "const type definition, array definition, basic function definition"}
{"seed": "// Code_ is a convenience wrapper for Code without the attrs argument.\nfunc Code_(children ...HTML) HTML {\n  return Code(nil, children...)\n}", "id": 1656, "concepts": ["function composition", "function argument handling", "function return value handling"], "_raw_llm_output": "function composition, function argument handling, function return value handling"}
{"seed": "// MixedStringContainsFold applies the ContainsFold predicate on the \"mixed_string\" field.\nfunc MixedStringContainsFold(v string) predicate.User {\n\treturn predicate.User(sql.FieldContainsFold(FieldMixedString, v))\n}", "id": 1658, "concepts": ["predicate.User", "sql.FieldContainsFold", "predicate.FieldContainsFold", "sql.FieldContainsFold", "predicate.FieldContainsFold", "predicate.FieldContainsFold", "predicate.FieldContainsFold"], "_raw_llm_output": "predicate.User, sql.FieldContainsFold, predicate.FieldContainsFold, sql.FieldContainsFold, predicate.FieldContainsFold, predicate.FieldContainsFold, predicate.FieldContainsFold"}
{"seed": "// Section_ is a convenience wrapper for Section without the attrs argument.\nfunc Section_(children ...HTML) HTML {\n  return Section(nil, children...)\n}", "id": 1659, "concepts": ["function composition", "function composition with variadic arguments", "function composition with named arguments"], "_raw_llm_output": "function composition, function composition with variadic arguments, function composition with named arguments"}
{"seed": "// New constructs an error message intended to be read by the CLI user. Holds context in the form of the invoked command (command),\n// the variables of the command (commandVars), the causal error (cause), and any suggested action the user might take to correct the problem (suggestedAction).\nfunc New(command string, commandVars interface{}, err error) *Error {\n\tvar actionableError *actionableerror.Error\n\tok := errors.As(err, &actionableError)\n\tif ok {\n\t\tlog.Err(actionableError.Cause).Send()\n\n\t\treturn &Error{\n\t\t\tCommand:         command,\n\t\t\tCommandVars:     commandVars,\n\t\t\tCause:           actionableError.Cause,\n\t\t\tSuggestedAction: actionableError.SuggestedAction,\n\t\t}\n\t}\n\n\tlog.Err(err).Send()\n\treturn &Error{\n\t\tCommand:     command,\n\t\tCommandVars: commandVars,\n\t\tCause:       err,\n\t}\n}", "id": 1662, "concepts": ["error handling (errors.As)", "interface usage", "error handling (errors.New)", "error handling (log.Err)", "error handling (log.Send)"], "_raw_llm_output": "error handling (errors.As), interface usage, error handling (errors.New), error handling (log.Err), error handling (log.Send)"}
{"seed": "// UpdateStatistics update statistics on an entity profile, depending on the statistic definition may cause entity to be ranked on various\n// leaderboards.\n// https://api.playfab.com/Documentation/Leaderboards/method/UpdateStatistics\nfunc UpdateStatistics(settings *playfab.Settings, postData *UpdateStatisticsRequestModel, entityToken string) (*UpdateStatisticsResponseModel, error) {\n    if entityToken == \"\" {\n        return nil, playfab.NewCustomError(\"entityToken should not be an empty string\", playfab.ErrorGeneric)\n    }\n    b, errMarshal := json.Marshal(postData)\n    if errMarshal != nil {\n        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)\n    }\n\n    sourceMap, err := playfab.Request(settings, b, \"/Statistic/UpdateStatistics\", \"X-EntityToken\", entityToken)\n    if err != nil {\n        return nil, err\n    }\n    \n    result := &UpdateStatisticsResponseModel{}\n\n    config := mapstructure.DecoderConfig{\n        DecodeHook: playfab.StringToDateTimeHook,\n        Result:     result,\n    }\n    \n    decoder, errDecoding := mapstructure.NewDecoder(&config)\n    if errDecoding != nil {\n        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)\n    }\n   \n    errDecoding = decoder.Decode(sourceMap)\n    if errDecoding != nil {\n        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)\n    }\n\n    return result, nil\n}", "id": 1665, "concepts": ["playfab API usage", "JSON marshaling", "JSON unmarshaling", "mapstructure usage", "error handling (errors.New)", "string formatting", "string manipulation", "JSON parsing", "map iteration", "map manipulation", "map lookup", "map deletion", "map creation", "map update", "map key lookup", "map key deletion", "map key creation", "map key update", "map key iteration", "map key manipulation", "map key comparison", "map key sorting", "map key ordering", "map key grouping", "map key filtering", "map key mapping", "map key reduction", "map key transformation", "map key mapping", "map key reduction", "map key transformation", "map key mapping", "map key reduction", "map key transformation", "map key mapping", "map key reduction", "map key transformation", "map key mapping", "map key reduction", "map key transformation", "map key mapping", "map key reduction", "map key transformation", "map key mapping", "map key reduction", "map key transformation", "map key mapping", "map key reduction", "map key transformation", "map key mapping", "map key reduction", "map key transformation", "map key mapping", "map key reduction", "map key transformation", "map key mapping", "map key reduction", "map key transformation", "map key mapping", "map key reduction", "map key transformation", "map key mapping", "map key reduction", "map key transformation", "map key mapping", ""], "_raw_llm_output": "playfab API usage, JSON marshaling, JSON unmarshaling, mapstructure usage, error handling (errors.New), string formatting, string manipulation, JSON parsing, map iteration, map manipulation, map lookup, map deletion, map creation, map update, map key lookup, map key deletion, map key creation, map key update, map key iteration, map key manipulation, map key comparison, map key sorting, map key ordering, map key grouping, map key filtering, map key mapping, map key reduction, map key transformation, map key mapping, map key reduction, map key transformation, map key mapping, map key reduction, map key transformation, map key mapping, map key reduction, map key transformation, map key mapping, map key reduction, map key transformation, map key mapping, map key reduction, map key transformation, map key mapping, map key reduction, map key transformation, map key mapping, map key reduction, map key transformation, map key mapping, map key reduction, map key transformation, map key mapping, map key reduction, map key transformation, map key mapping, map key reduction, map key transformation, map key mapping, map key reduction, map key transformation, map key mapping, map key reduction, map key transformation, map key mapping,"}
{"seed": "// PossibleRoutingRuleEnabledStateValues returns an array of possible values for the RoutingRuleEnabledState const type.\nfunc PossibleRoutingRuleEnabledStateValues() []RoutingRuleEnabledState {\n\treturn []RoutingRuleEnabledState{RoutingRuleEnabledStateDisabled, RoutingRuleEnabledStateEnabled}\n}", "id": 1672, "concepts": ["constant definition", "array definition"], "_raw_llm_output": "constant definition, array definition"}
{"seed": "// Article_ is a convenience wrapper for Article without the attrs argument.\nfunc Article_(children ...HTML) HTML {\n  return Article(nil, children...)\n}", "id": 1686, "concepts": ["function definition", "variadic argument", "function composition"], "_raw_llm_output": "function definition, variadic argument, function composition"}
{"seed": "// BetterHeroScoreLTE applies the LTE predicate on the \"better_hero_score\" field.\nfunc BetterHeroScoreLTE(v int) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.LTE(s.C(FieldBetterHeroScore), v))\n\t})\n}", "id": 1700, "concepts": ["sql package usage", "sql.Selector", "sql.C", "sql.LTE", "sql.Where", "sql.Predicate"], "_raw_llm_output": "sql package usage, sql.Selector, sql.C, sql.LTE, sql.Where, sql.Predicate"}
{"seed": "// NewModifyCryptokeyNoContent creates a ModifyCryptokeyNoContent with default headers values\nfunc NewModifyCryptokeyNoContent() *ModifyCryptokeyNoContent {\n\treturn &ModifyCryptokeyNoContent{}\n}", "id": 1701, "concepts": ["struct definition", "struct field definition", "struct initialization", "struct method definition", "method invocation"], "_raw_llm_output": "struct definition, struct field definition, struct initialization, struct method definition, method invocation"}
{"seed": "// MustExist takes and returns a directory path, creating the directory\n// if necessary. Any created directories have permission set to 700.\n// Panics if the directory cannot be created.\nfunc MustExist(dirpath string) string {\n\terr := os.MkdirAll(dirpath, 0700)\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"Couldn't create directory `%s` : %v\", dirpath, err))\n\t}\n\treturn dirpath\n}", "id": 1729, "concepts": ["os package usage", "panic", "error handling (idiomatic)", "directory creation"], "_raw_llm_output": "os package usage, panic, error handling (idiomatic), directory creation"}
{"seed": "// NewExternalCmd returns a callable that executes the named external command.\n//\n// An external command converts all arguments to strings, and does not accept\n// any option.\nfunc NewExternalCmd(name string) Callable {\n\treturn externalCmd{name}\n}", "id": 1753, "concepts": ["struct definition", "function definition", "external command execution"], "_raw_llm_output": "struct definition, function definition, external command execution"}
{"seed": "// ParseDeleteTemplateResponse parses an HTTP response from a DeleteTemplateWithResponse call\nfunc ParseDeleteTemplateResponse(rsp *http.Response) (*DeleteTemplateResponse, error) {\n\tbodyBytes, err := ioutil.ReadAll(rsp.Body)\n\tdefer rsp.Body.Close()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse := &DeleteTemplateResponse{\n\t\tBody:         bodyBytes,\n\t\tHTTPResponse: rsp,\n\t}\n\n\tswitch {\n\tcase strings.Contains(rsp.Header.Get(\"Content-Type\"), \"json\") && rsp.StatusCode == 200:\n\t\tvar dest Operation\n\t\tif err := json.Unmarshal(bodyBytes, &dest); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresponse.JSON200 = &dest\n\n\t}\n\n\treturn response, nil\n}", "id": 1768, "concepts": ["http.Response", "json.Unmarshal", "ioutil.ReadAll", "string manipulation"], "_raw_llm_output": "http.Response, json.Unmarshal, ioutil.ReadAll, string manipulation"}
{"seed": "// PossibleSkuNameValues returns an array of possible values for the SkuName const type.\nfunc PossibleSkuNameValues() []SkuName {\n\treturn []SkuName{SkuNameClassicAzureFrontDoor, SkuNamePremiumAzureFrontDoor, SkuNameStandardAzureFrontDoor}\n}", "id": 1783, "concepts": ["type definition", "array definition", "const definition", "array iteration"], "_raw_llm_output": "type definition, array definition, const definition, array iteration"}
{"seed": "// GetNotificationOccurrenceEventService returns an instance of the Notification_Occurrence_Event SoftLayer service\nfunc GetNotificationOccurrenceEventService(sess *session.Session) Notification_Occurrence_Event {\n\treturn Notification_Occurrence_Event{Session: sess}\n}", "id": 1786, "concepts": ["service instantiation", "session.Session", "struct definition"], "_raw_llm_output": "service instantiation, session.Session, struct definition"}
{"seed": "// Replace reports if the current go.mod has 'replace' directives.\r\n// It returns true if so.\r\n// The parses the 'go.mod' for the main module, and hence can report\r\n// true if the main module's 'go.mod' has ineffective replace directives.\r\n// Part of the use case is some people never want to check in a replace directive,\r\n// and this can be used to check that.\r\n// Rule: gomodvet-008\r\nfunc Replace(verbose bool) (bool, error) {\r\n\tmods, err := buildlist.Resolve()\r\n\tif err != nil {\r\n\t\treturn false, fmt.Errorf(\"replace: %v\", err)\r\n\t}\r\n\r\n\tflagged := false\r\n\tfor _, mod := range mods {\r\n\t\tif !mod.Main {\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\tif verbose {\r\n\t\t\tfmt.Printf(\"gomodvet: replacement: module %s: %+v\\n\", mod.Path, mod)\r\n\t\t}\r\n\t\tfile, err := modfile.Parse(mod.GoMod)\r\n\t\tif err != nil {\r\n\t\t\treturn false, fmt.Errorf(\"replace: %v\", err)\r\n\t\t}\r\n\t\tif len(file.Replace) > 0 {\r\n\t\t\tfmt.Printf(\"gomodvet-008: the main module has 'replace' directives\\n\")\r\n\t\t\tflagged = true\r\n\t\t}\r\n\t}\r\n\treturn flagged, nil\r\n}", "id": 1802, "concepts": ["parsing", "go.mod file parsing", "replace directives"], "_raw_llm_output": "parsing, go.mod file parsing, replace directives"}
{"seed": "// Marshal the FIDL payload in s into data and handles.\n//\n// s must be a pointer to a struct, since the primary object in a FIDL message\n// is always a struct.\n//\n// Marshal traverses the value s recursively, following nested type values via\n// reflection in order to encode the FIDL struct.\nfunc Marshal(s Payload, data []byte, handles []zx.Handle) (int, int, error) {\n\t// First, let's make sure we have the right type in s.\n\tt := reflect.TypeOf(s)\n\tif t.Kind() != reflect.Ptr {\n\t\treturn 0, 0, errors.New(\"expected a pointer\")\n\t}\n\tt = t.Elem()\n\tif t.Kind() != reflect.Struct {\n\t\treturn 0, 0, errors.New(\"primary object must be a struct\")\n\t}\n\n\t// Now, let's get the value of s, marshal the header into a starting\n\t// buffer, and then marshal the rest of the payload in s.\n\tv := reflect.ValueOf(s).Elem()\n\te := encoder{buffer: data[:0], handles: handles[:0]}\n\te.head = e.newObject(s.InlineSize())\n\tif err := e.marshalStructFields(t, v); err != nil {\n\t\treturn 0, 0, err\n\t}\n\treturn len(e.buffer), len(e.handles), nil\n}", "id": 1806, "concepts": ["reflect package usage", "FIDL encoding", "struct field iteration", "recursive function definition"], "_raw_llm_output": "reflect package usage, FIDL encoding, struct field iteration, recursive function definition"}
{"seed": "// CreatedAtNotIn applies the NotIn predicate on the \"created_at\" field.\nfunc CreatedAtNotIn(vs ...time.Time) predicate.User {\n\treturn predicate.User(sql.FieldNotIn(FieldCreatedAt, vs...))\n}", "id": 1810, "concepts": ["sql.FieldNotIn", "sql.FieldIn", "sql.FieldEq", "sql.FieldLt", "sql.FieldGt", "sql.FieldGte", "sql.FieldLte", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldIsNull", "sql.FieldIsNotNull", "sql.FieldBetween", "sql.FieldNotBetween", "sql.FieldIs", "sql.FieldIsNot", "sql.FieldIsOneOf", "sql.FieldIsNotOneOf", "sql.FieldIsAll", "sql.FieldIsNotAll", "sql.FieldIsAny", "sql.FieldIsNotAny", "sql.FieldIsAllOf", "sql.FieldIsNotAllOf", "sql.FieldIsAnyOf", "sql.FieldIsNotAnyOf", "sql.FieldIsNone", "sql.FieldIsNotNone", "sql.FieldIsOneOf", "sql.FieldIsNotOneOf", "sql.FieldIsAll", "sql.FieldIsNotAll", "sql.FieldIsAny", "sql.FieldIsNotAny", "sql.FieldIsAllOf", "sql.FieldIsNotAllOf", "sql.FieldIsAnyOf", "sql.FieldIsNotAnyOf", "sql.FieldIsNone", "sql.FieldIsNotNone", "sql.FieldIsOneOf", "sql.FieldIsNotOneOf", "sql."], "_raw_llm_output": "sql.FieldNotIn, sql.FieldIn, sql.FieldEq, sql.FieldLt, sql.FieldGt, sql.FieldGte, sql.FieldLte, sql.FieldLike, sql.FieldNotLike, sql.FieldIn, sql.FieldNotIn, sql.FieldIsNull, sql.FieldIsNotNull, sql.FieldBetween, sql.FieldNotBetween, sql.FieldIs, sql.FieldIsNot, sql.FieldIsOneOf, sql.FieldIsNotOneOf, sql.FieldIsAll, sql.FieldIsNotAll, sql.FieldIsAny, sql.FieldIsNotAny, sql.FieldIsAllOf, sql.FieldIsNotAllOf, sql.FieldIsAnyOf, sql.FieldIsNotAnyOf, sql.FieldIsNone, sql.FieldIsNotNone, sql.FieldIsOneOf, sql.FieldIsNotOneOf, sql.FieldIsAll, sql.FieldIsNotAll, sql.FieldIsAny, sql.FieldIsNotAny, sql.FieldIsAllOf, sql.FieldIsNotAllOf, sql.FieldIsAnyOf, sql.FieldIsNotAnyOf, sql.FieldIsNone, sql.FieldIsNotNone, sql.FieldIsOneOf, sql.FieldIsNotOneOf, sql."}
{"seed": "// Deduce where we left off in `fillTrickleRec`, returns the `depth`\n// with which new sub-graphs were being added and, within that depth,\n// in which `repeatNumber` of the total `depthRepeat` we should add.\nfunc trickleDepthInfo(node *h.FSNodeOverDag, maxlinks int) (depth int, repeatNumber int) {\n\tn := node.NumChildren()\n\n\tif n < maxlinks {\n\t\t// We didn't even added the initial `maxlinks` leaf nodes (`FillNodeLayer`).\n\t\treturn 0, 0\n\t}\n\n\tnonLeafChildren := n - maxlinks\n\t// The number of non-leaf child nodes added in `fillTrickleRec` (after\n\t// the `FillNodeLayer` call).\n\n\tdepth = nonLeafChildren/depthRepeat + 1\n\t// \"Deduplicate\" the added `depthRepeat` sub-graphs at each depth\n\t// (rounding it up since we may be on an unfinished depth with less\n\t// than `depthRepeat` sub-graphs).\n\n\trepeatNumber = nonLeafChildren % depthRepeat\n\t// What's left after taking full depths of `depthRepeat` sub-graphs\n\t// is the current `repeatNumber` we're at (this fractional part is\n\t// what we rounded up before).\n\n\treturn\n}", "id": 1813, "concepts": ["integer division", "integer modulus", "integer remainder", "integer rounding", "integer division", "integer modulus", "integer remainder", "integer rounding"], "_raw_llm_output": "integer division, integer modulus, integer remainder, integer rounding, integer division, integer modulus, integer remainder, integer rounding"}
{"seed": "// CommonPath returns the longest common path of both paths given.\nfunc CommonPath(path1, path2 string) string {\n\tparts1 := strings.Split(path1, \"/\")\n\tparts2 := strings.Split(path2, \"/\")\n\tmaxIdx := len(parts1)\n\tif len(parts2) < maxIdx {\n\t\tmaxIdx = len(parts2)\n\t}\n\n\tcommon := make([]string, 0, maxIdx)\n\tfor i := 0; i < maxIdx; i++ {\n\t\tif parts1[i] == parts2[i] {\n\t\t\tcommon = append(common, parts1[i])\n\t\t}\n\t}\n\n\treturn strings.Join(common, \"/\")\n}", "id": 1824, "concepts": ["string manipulation", "string splitting", "string joining", "string iteration", "slice iteration", "slice appending", "slice creation", "basic function definition"], "_raw_llm_output": "string manipulation, string splitting, string joining, string iteration, slice iteration, slice appending, slice creation, basic function definition"}
{"seed": "// NewGetSubscriptionsParamsWithContext creates a new GetSubscriptionsParams object\n// with the default values initialized, and the ability to set a context for a request\nfunc NewGetSubscriptionsParamsWithContext(ctx context.Context) *GetSubscriptionsParams {\n\tvar ()\n\treturn &GetSubscriptionsParams{\n\n\t\tContext: ctx,\n\t}\n}", "id": 1833, "concepts": ["context package usage", "struct definition", "method definition"], "_raw_llm_output": "context package usage, struct definition, method definition"}
{"seed": "// Determines whether the given error indicates that a sequence had too many or too many items matched a predicate.\nfunc IsTooManyItemsError(e error) bool {\n\t_, ok := e.(tooManyItemsError)\n\treturn ok\n}", "id": 1840, "concepts": ["error handling (type assertion)", "error wrapping"], "_raw_llm_output": "error handling (type assertion), error wrapping"}
{"seed": "// Creates a new empty ErrorCollection.\n// When `dup` is set, any duplicate error message is discarded\n// and not appended to the collection\nfunc NewErrorCollection(dup ...DuplicatationOptions) *ErrorCollection {\n\tec := &ErrorCollection{}\n\tec.Errors = []error{}\n\tec.Formatter = DefaultErrorFormatter\n\tif len(dup) != 0 {\n\t\tec.DuplicatationOptions = dup[0]\n\t}\n\treturn ec\n}", "id": 1841, "concepts": ["struct definition", "slice definition", "anonymous function", "error handling (idiomatic `if err != nil`", "`errors.Is`", "`errors.As`)", "standard library usage"], "_raw_llm_output": "struct definition, slice definition, anonymous function, error handling (idiomatic `if err != nil`, `errors.Is`, `errors.As`), standard library usage"}
{"seed": "// PossibleDynamicCompressionEnabledValues returns an array of possible values for the DynamicCompressionEnabled const type.\nfunc PossibleDynamicCompressionEnabledValues() []DynamicCompressionEnabled {\n\treturn []DynamicCompressionEnabled{DynamicCompressionEnabledDisabled, DynamicCompressionEnabledEnabled}\n}", "id": 1850, "concepts": ["enum type", "array", "function definition", "return statement", "basic types"], "_raw_llm_output": "enum type, array, function definition, return statement, basic types"}
{"seed": "// gcmAdd adds two elements of GF(2\u00b9\u00b2\u2078) and returns the sum.\nfunc gcmAdd(x, y *gcmFieldElement) gcmFieldElement {\n\t// Addition in a characteristic 2 field is just XOR.\n\treturn gcmFieldElement{x.low ^ y.low, x.high ^ y.high}\n}", "id": 1854, "concepts": ["XOR", "bitwise operations", "struct definition", "pointer usage"], "_raw_llm_output": "XOR, bitwise operations, struct definition, pointer usage"}
{"seed": "// NewLabelPropertiesWithDefaults instantiates a new LabelProperties object\n// This constructor will only assign default values to properties that have it defined,\n// but it doesn't guarantee that properties required by API are set\nfunc NewLabelPropertiesWithDefaults() *LabelProperties {\n\tthis := LabelProperties{}\n\treturn &this\n}", "id": 1879, "concepts": ["constructor", "default values", "struct initialization"], "_raw_llm_output": "constructor, default values, struct initialization"}
{"seed": "// DefaultExprHasSuffix applies the HasSuffix predicate on the \"default_expr\" field.\nfunc DefaultExprHasSuffix(v string) predicate.User {\n\treturn predicate.User(sql.FieldHasSuffix(FieldDefaultExpr, v))\n}", "id": 1887, "concepts": ["predicate.User", "sql.FieldHasSuffix", "basic function definition"], "_raw_llm_output": "predicate.User, sql.FieldHasSuffix, basic function definition"}
{"seed": "// createLogFile will create and return the open file handle for the file at provided filename, creating all directories\n// in the process.\nfunc createLogFile(logger *logrus.Logger, filename string) (*os.File, error) {\n\t// We extract and create the directory for interpolated filename, to handle nested tests where testname contains '/'\n\tdirName := filepath.Dir(filename)\n\terr := ensureDirectoryExists(logger, dirName)\n\tif err != nil {\n\t\treturn nil, errors.WithStackTrace(err)\n\t}\n\tfile, err := os.Create(filename)\n\tif err != nil {\n\t\treturn nil, errors.WithStackTrace(err)\n\t}\n\treturn file, nil\n}", "id": 1897, "concepts": ["os.Create", "os.MkdirAll", "errors.WithStackTrace", "error handling"], "_raw_llm_output": "os.Create, os.MkdirAll, errors.WithStackTrace, error handling"}
{"seed": "// ReadRentableMarketRates reads a full RentableMarketRate structure of data from the database based on the supplied Rows pointer.\nfunc ReadRentableMarketRates(rows *sql.Rows, a *RentableMarketRate) error {\n\treturn rows.Scan(&a.RMRID, &a.RTID, &a.BID, &a.MarketRate, &a.DtStart, &a.DtStop, &a.CreateTS, &a.CreateBy, &a.LastModTime, &a.LastModBy)\n}", "id": 1903, "concepts": ["sql package usage", "sql.Rows usage", "struct definition", "struct field access", "sql.Scan usage"], "_raw_llm_output": "sql package usage, sql.Rows usage, struct definition, struct field access, sql.Scan usage"}
{"seed": "// externalKeyPath returns the relative external derivation path /0/0/index.\nfunc externalKeyPath(index uint32) waddrmgr.DerivationPath {\n\treturn waddrmgr.DerivationPath{\n\t\tAccount: waddrmgr.DefaultAccountNum,\n\t\tBranch:  waddrmgr.ExternalBranch,\n\t\tIndex:   index,\n\t}\n}", "id": 1915, "concepts": ["derivation path", "waddrmgr package usage"], "_raw_llm_output": "derivation path, waddrmgr package usage"}
{"seed": "// Address_ is a convenience wrapper for Address without the attrs argument.\nfunc Address_(children ...HTML) HTML {\n  return Address(nil, children...)\n}", "id": 1929, "concepts": ["function definition", "variadic argument handling", "function composition"], "_raw_llm_output": "function definition, variadic argument handling, function composition"}
{"seed": "// ResolverDNSSECValidationStatus_Values returns all elements of the ResolverDNSSECValidationStatus enum\nfunc ResolverDNSSECValidationStatus_Values() []string {\n\treturn []string{\n\t\tResolverDNSSECValidationStatusEnabling,\n\t\tResolverDNSSECValidationStatusEnabled,\n\t\tResolverDNSSECValidationStatusDisabling,\n\t\tResolverDNSSECValidationStatusDisabled,\n\t\tResolverDNSSECValidationStatusUpdatingToUseLocalResourceSetting,\n\t\tResolverDNSSECValidationStatusUseLocalResourceSetting,\n\t}\n}", "id": 1934, "concepts": ["enum", "string concatenation", "string formatting", "standard library usage"], "_raw_llm_output": "enum, string concatenation, string formatting, standard library usage"}
{"seed": "// EncodeBool encodes a bool in the format parseRaw expects.\nfunc EncodeBool(b bool) string {\n\treturn strconv.FormatBool(b)\n}", "id": 1939, "concepts": ["strconv.FormatBool", "string formatting", "string conversion"], "_raw_llm_output": "strconv.FormatBool, string formatting, string conversion"}
{"seed": "// RunReaderFrom runs the given io.ReaderFrom over all inputs received from\n// env.Inputs(). Each input reader is closed after having read from it.\n// Processing stops on the first input, read, or close error, which is returned.\nfunc RunReaderFrom(rf io.ReaderFrom, env Environment) error {\n\tfor in := range env.Inputs() {\n\t\tif in.Err != nil {\n\t\t\treturn in.Err\n\t\t}\n\t\t_, err := rf.ReadFrom(in.ReadCloser)\n\t\tif cerr := in.ReadCloser.Close(); err == nil {\n\t\t\terr = cerr\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}", "id": 1950, "concepts": ["io.ReaderFrom", "io.ReadCloser", "io.Closer", "channel iteration", "error handling"], "_raw_llm_output": "io.ReaderFrom, io.ReadCloser, io.Closer, channel iteration, error handling"}
{"seed": "// CreatedAtNotNil applies the NotNil predicate on the \"created_at\" field.\nfunc CreatedAtNotNil() predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.NotNull(s.C(FieldCreatedAt)))\n\t})\n}", "id": 1964, "concepts": ["sql.Selector", "sql.NotNull", "sql.C", "sql.Where", "sql.Field", "predicate.User"], "_raw_llm_output": "sql.Selector, sql.NotNull, sql.C, sql.Where, sql.Field, predicate.User"}
{"seed": "// AllPromotionRules returns all the CandidatePromotionRules in a list\n// sorted by their priority.\nfunc AllPromotionRules() []CandidatePromotionRule {\n\treturn []CandidatePromotionRule{Must, Prefer, Neutral, PreferNot, MustNot}\n}", "id": 1980, "concepts": ["slice definition", "slice iteration (range loop)", "slice sorting", "basic function definition"], "_raw_llm_output": "slice definition, slice iteration (range loop), slice sorting, basic function definition"}
{"seed": "// Cite_ is a convenience wrapper for Cite without the attrs argument.\nfunc Cite_(children ...HTML) HTML {\n  return Cite(nil, children...)\n}", "id": 1984, "concepts": ["HTML tag definition", "HTML tag usage", "HTML tag attribute definition", "HTML tag attribute usage"], "_raw_llm_output": "HTML tag definition, HTML tag usage, HTML tag attribute definition, HTML tag attribute usage"}
{"seed": "// StrIsASNStr checks whether an ASN string really is an ASN of the form\n// \"asX\" or \"ASX\" where \"X\" is the ASN's number.\nfunc StrIsASNStr(asn string) bool {\n\t// check length.\n\tif len(asn) < 3 {\n\t\treturn false\n\t}\n\n\t// ensure \"AS\" or \"as\" prefix.\n\tif !strings.HasPrefix(asn, \"AS\") && !strings.HasPrefix(asn, \"as\") {\n\t\treturn false\n\t}\n\n\t// ensure number suffix.\n\tasnNumStr := asn[2:]\n\tif _, err := strconv.Atoi(asnNumStr); err != nil {\n\t\treturn false\n\t}\n\n\treturn true\n}", "id": 1988, "concepts": ["string manipulation", "string prefix check", "string suffix check", "string to integer conversion", "integer to string conversion", "string length check", "string prefix/suffix check", "string to integer conversion", "integer to string conversion", "string length check", "string prefix/suffix check", "string to integer conversion", "integer to string conversion", "string length check", "string prefix/suffix check", "string to integer conversion", "integer to string conversion", "string length check", "string prefix/suffix check", "string to integer conversion", "integer to string conversion", "string length check", "string prefix/suffix check", "string to integer conversion", "integer to string conversion", "string length check", "string prefix/suffix check", "string to integer conversion", "integer to string conversion", "string length check", "string prefix/suffix check", "string to integer conversion", "integer to string conversion", "string length check", "string prefix/suffix check", "string to integer conversion", "integer to string conversion", "string length check", "string prefix/suffix check", "string to integer conversion", "integer to string conversion", "string length check", "string prefix/suffix check", "string to integer conversion", "integer to string conversion", "string length check", "string prefix/suffix check", "string to integer conversion", "integer to string conversion", "string length check", "string prefix/suffix check", "string to integer conversion"], "_raw_llm_output": "string manipulation, string prefix check, string suffix check, string to integer conversion, integer to string conversion, string length check, string prefix/suffix check, string to integer conversion, integer to string conversion, string length check, string prefix/suffix check, string to integer conversion, integer to string conversion, string length check, string prefix/suffix check, string to integer conversion, integer to string conversion, string length check, string prefix/suffix check, string to integer conversion, integer to string conversion, string length check, string prefix/suffix check, string to integer conversion, integer to string conversion, string length check, string prefix/suffix check, string to integer conversion, integer to string conversion, string length check, string prefix/suffix check, string to integer conversion, integer to string conversion, string length check, string prefix/suffix check, string to integer conversion, integer to string conversion, string length check, string prefix/suffix check, string to integer conversion, integer to string conversion, string length check, string prefix/suffix check, string to integer conversion, integer to string conversion, string length check, string prefix/suffix check, string to integer conversion, integer to string conversion, string length check, string prefix/suffix check, string to integer conversion"}
{"seed": "// RepositoryExists checks if the Repository row exists.\nfunc RepositoryExists(ctx context.Context, exec boil.ContextExecutor, iD string) (bool, error) {\n\tvar exists bool\n\tsql := \"select exists(select 1 from `repositories` where `id`=? limit 1)\"\n\n\tif boil.IsDebug(ctx) {\n\t\twriter := boil.DebugWriterFrom(ctx)\n\t\tfmt.Fprintln(writer, sql)\n\t\tfmt.Fprintln(writer, iD)\n\t}\n\trow := exec.QueryRowContext(ctx, sql, iD)\n\n\terr := row.Scan(&exists)\n\tif err != nil {\n\t\treturn false, errors.Wrap(err, \"models: unable to check if repositories exists\")\n\t}\n\n\treturn exists, nil\n}", "id": 2000, "concepts": ["database query", "boil.ContextExecutor", "boil.DebugWriterFrom", "boil.IsDebug", "database query execution", "database query execution", "database query execution", "database query execution"], "_raw_llm_output": "database query, boil.ContextExecutor, boil.DebugWriterFrom, boil.IsDebug, database query execution, database query execution, database query execution, database query execution"}
{"seed": "// AllKeys returns the Subspace corresponding to all keys in a FoundationDB\n// database.\nfunc AllKeys() Subspace {\n\treturn subspace{}\n}", "id": 2011, "concepts": ["struct definition", "method definition", "interface definition", "basic function definition"], "_raw_llm_output": "struct definition, method definition, interface definition, basic function definition"}
{"seed": "// StoreMember persists a member inside a bucket identifying the channel\nfunc StoreMember(member api.Member) error {\n\treturn db.Update(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(member.ChannelID))\n\t\tif b == nil {\n\t\t\treturn fmt.Errorf(\"dbutils: bucket %s not created\", member.ChannelID)\n\t\t}\n\n\t\tvar buf bytes.Buffer\n\t\tenc := gob.NewEncoder(&buf)\n\t\tenc.Encode(member)\n\n\t\t// Persist bytes to users bucket.\n\t\treturn b.Put([]byte(member.ID), buf.Bytes())\n\t})\n}", "id": 2017, "concepts": ["encoding/gob", "gob.NewEncoder", "gob.Encode", "gob.Decode", "gob.Register", "encoding/json", "encoding/xml", "encoding/csv", "encoding/xml", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json", "encoding/json"], "_raw_llm_output": "encoding/gob, gob.NewEncoder, gob.Encode, gob.Decode, gob.Register, encoding/json, encoding/xml, encoding/csv, encoding/xml, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json, encoding/json"}
{"seed": "// NewSyncFile creates a wrapper around the given gkvlite.StoreFile that\n// only allows one write/truncate or any number of read/stat operations to\n// run at the same time. A waiting write/truncate will block new read/stat\n// operations from starting.\nfunc NewSyncFile(store gkvlite.StoreFile) gkvlite.StoreFile {\n\treturn &syncFile{store: store}\n}", "id": 2021, "concepts": ["sync.Mutex", "sync.WaitGroup", "sync.Once", "gkvlite.StoreFile"], "_raw_llm_output": "sync.Mutex, sync.WaitGroup, sync.Once, gkvlite.StoreFile"}
{"seed": "// IsNotExist returns true for a error that is for a path not existing.\nfunc IsNotExist(err error) bool {\n\treturn normalpath.ErrorEquals(err, errNotExist)\n}", "id": 2022, "concepts": ["error handling (error.Is)", "error handling (error.As)", "error handling (error.Error)", "error handling (error.Unwrap)", "error handling (error.Is)", "error handling (error.As)", "error handling (error.Error)", "error handling (error.Unwrap)", "error handling (error.Is)", "error handling (error.As)", "error handling (error.Error)", "error handling (error.Unwrap)", "error handling (error.Is)", "error handling (error.As)", "error handling (error.Error)", "error handling (error.Unwrap)", "error handling (error.Is)", "error handling (error.As)", "error handling (error.Error)", "error handling (error.Unwrap)", "error handling (error.Is)", "error handling (error.As)", "error handling (error.Error)", "error handling (error.Unwrap)", "error handling (error.Is)", "error handling (error.As)", "error handling (error.Error)", "error handling (error.Unwrap)", "error handling (error.Is)", "error handling (error.As)", "error handling (error.Error)", "error handling (error.Unwrap)", "error handling (error.Is)", "error handling (error.As)", "error handling (error.Error)", "error handling"], "_raw_llm_output": "error handling (error.Is), error handling (error.As), error handling (error.Error), error handling (error.Unwrap), error handling (error.Is), error handling (error.As), error handling (error.Error), error handling (error.Unwrap), error handling (error.Is), error handling (error.As), error handling (error.Error), error handling (error.Unwrap), error handling (error.Is), error handling (error.As), error handling (error.Error), error handling (error.Unwrap), error handling (error.Is), error handling (error.As), error handling (error.Error), error handling (error.Unwrap), error handling (error.Is), error handling (error.As), error handling (error.Error), error handling (error.Unwrap), error handling (error.Is), error handling (error.As), error handling (error.Error), error handling (error.Unwrap), error handling (error.Is), error handling (error.As), error handling (error.Error), error handling (error.Unwrap), error handling (error.Is), error handling (error.As), error handling (error.Error), error handling"}
{"seed": "// getTokenSignature gets the token signature using the encoded header, body, and secret key.\n// Return error if an error exists during signing.\nfunc getTokenSignature(header *Header, body *Body, secret *pbauth.Secret) (string, error) {\n\tif err := ValidateHeader(header); err != nil {\n\t\treturn \"\", err\n\t}\n\tif err := ValidateBody(body); err != nil {\n\t\treturn \"\", err\n\t}\n\tif err := ValidateSecret(secret); err != nil {\n\t\treturn \"\", err\n\t}\n\tif body.Permission == Admin && header.Alg != Hs512 {\n\t\treturn \"\", consts.ErrInvalidPermission\n\t}\n\tif header.TokenTyp != Jwt && header.TokenTyp != Jet {\n\t\treturn \"\", consts.ErrUnknownTokenType\n\t}\n\t// Token Signature = <encoded header>.<encoded body>.<hashed(<encoded header>.<encoded body>)>\n\t// 1. Encode the header\n\tencodedHeader, err := base64Encode(header)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\t// 2. Encode the body\n\tencodedBody, err := base64Encode(body)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\t// 3. Build <encoded header>.<encoded body>\n\t// 4. Build <hashed(<encoded header>.<encoded body>)>\n\t// 5. Build Token Signature = <encoded header>.<encoded body>.<hashed(<encoded header>.<encoded body>)>\n\treturn buildTokenSignature(encodedHeader, encodedBody, header.Alg, secret)\n}", "id": 2030, "concepts": ["base64 encoding", "string manipulation", "string concatenation", "string hashing", "string comparison", "string formatting", "string parsing", "string validation", "string manipulation", "string concatenation", "string hashing", "string comparison", "string formatting", "string parsing", "string validation", "string manipulation", "string concatenation", "string hashing", "string comparison", "string formatting", "string parsing", "string validation", "string manipulation", "string concatenation", "string hashing", "string comparison", "string formatting", "string parsing", "string validation", "string manipulation", "string concatenation", "string hashing", "string comparison", "string formatting", "string parsing", "string validation", "string manipulation", "string concatenation", "string hashing", "string comparison", "string formatting", "string parsing", "string validation", "string manipulation", "string concatenation", "string hashing", "string comparison", "string formatting", "string parsing", "string validation", "string manipulation", "string concatenation", "string hashing", "string comparison", "string formatting", "string parsing", "string validation", "string manipulation", "string concatenation", "string hashing", "string comparison", "string formatting", "string parsing", "string validation", "string manipulation", "string concatenation", "string hashing", "string comparison", "string formatting", "string parsing", "string validation", "string manipulation", "string concatenation", "string hashing", "string comparison", "string formatting", "string parsing", "string validation", "string manipulation", "string concatenation", "string"], "_raw_llm_output": "base64 encoding, string manipulation, string concatenation, string hashing, string comparison, string formatting, string parsing, string validation, string manipulation, string concatenation, string hashing, string comparison, string formatting, string parsing, string validation, string manipulation, string concatenation, string hashing, string comparison, string formatting, string parsing, string validation, string manipulation, string concatenation, string hashing, string comparison, string formatting, string parsing, string validation, string manipulation, string concatenation, string hashing, string comparison, string formatting, string parsing, string validation, string manipulation, string concatenation, string hashing, string comparison, string formatting, string parsing, string validation, string manipulation, string concatenation, string hashing, string comparison, string formatting, string parsing, string validation, string manipulation, string concatenation, string hashing, string comparison, string formatting, string parsing, string validation, string manipulation, string concatenation, string hashing, string comparison, string formatting, string parsing, string validation, string manipulation, string concatenation, string hashing, string comparison, string formatting, string parsing, string validation, string manipulation, string concatenation, string hashing, string comparison, string formatting, string parsing, string validation, string manipulation, string concatenation, string"}
{"seed": "// New creates a new Kolonish parser\nfunc New() *Kolonish {\n\treturn &Kolonish{}\n}", "id": 2050, "concepts": ["struct definition", "basic function definition"], "_raw_llm_output": "struct definition, basic function definition"}
{"seed": "// ReadNoteTypes reads a full NoteType structure from the database based on the supplied row object\nfunc ReadNoteTypes(rows *sql.Rows, a *NoteType) error {\n\treturn rows.Scan(&a.NTID, &a.BID, &a.Name, &a.CreateTS, &a.CreateBy, &a.LastModTime, &a.LastModBy)\n}", "id": 2055, "concepts": ["sql package usage", "sql.Rows", "sql.Scan", "struct field names"], "_raw_llm_output": "sql package usage, sql.Rows, sql.Scan, struct field names"}
{"seed": "// NewCreateSSLCertificateRequestWithBody generates requests for CreateSSLCertificate with any type of body\nfunc NewCreateSSLCertificateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {\n\tvar err error\n\n\tqueryUrl, err := url.Parse(server)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbasePath := fmt.Sprintf(\"/domain/v2alpha2/ssl-certificates\")\n\tif basePath[0] == '/' {\n\t\tbasePath = basePath[1:]\n\t}\n\n\tqueryUrl, err = queryUrl.Parse(basePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq, err := http.NewRequest(\"POST\", queryUrl.String(), body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Add(\"Content-Type\", contentType)\n\treturn req, nil\n}", "id": 2056, "concepts": ["url parsing", "http request generation", "io.Reader", "url.Parse", "http.NewRequest", "http.Request", "http.Header", "http.Request.Header", "http.Request.Header.Add", "http.Request.Header.Set", "http.Request.Body", "http.Request.Close", "io.Reader.Read", "io.Reader.Close", "io.Reader.ReadAt", "io.Reader.Seek", "io.Reader.Stat", "io.Reader.Write", "io.Reader.WriteTo", "io.Reader.ReadFrom", "io.Reader.ReadAtLeast", "io.Reader.ReadFull", "io.Reader.ReadSlice", "io.Reader.UnreadByte", "io.Reader.UnreadRune", "io.Reader.Unread", "io.Reader.Reset", "io.Reader.Seeker", "io.Reader.Size", "io.Reader.Close", "io.Reader.Stat", "io.Reader.Tee", "io.Reader.NewSectionReader", "io.Reader.LimitReader", "io.Reader.MultiReader", "io.Reader.Copy", "io.Reader.CopyN", "io.Reader.ReadFrom", "io.Reader.ReadAtLeast", "io.Reader.ReadFull", "io.Reader."], "_raw_llm_output": "url parsing, http request generation, io.Reader, url.Parse, http.NewRequest, http.Request, http.Header, http.Request.Header, http.Request.Header.Add, http.Request.Header.Set, http.Request.Body, http.Request.Close, io.Reader.Read, io.Reader.Close, io.Reader.ReadAt, io.Reader.Seek, io.Reader.Stat, io.Reader.Write, io.Reader.WriteTo, io.Reader.ReadFrom, io.Reader.ReadAtLeast, io.Reader.ReadFull, io.Reader.ReadSlice, io.Reader.UnreadByte, io.Reader.UnreadRune, io.Reader.Unread, io.Reader.Reset, io.Reader.Seeker, io.Reader.Size, io.Reader.Close, io.Reader.Stat, io.Reader.Tee, io.Reader.NewSectionReader, io.Reader.LimitReader, io.Reader.MultiReader, io.Reader.Copy, io.Reader.CopyN, io.Reader.ReadFrom, io.Reader.ReadAtLeast, io.Reader.ReadFull, io.Reader."}
{"seed": "// PossibleResourceTypeRegistrationPropertiesMarketplaceTypeValues returns the possible values for the ResourceTypeRegistrationPropertiesMarketplaceType const type.\nfunc PossibleResourceTypeRegistrationPropertiesMarketplaceTypeValues() []ResourceTypeRegistrationPropertiesMarketplaceType {\n\treturn []ResourceTypeRegistrationPropertiesMarketplaceType{\n\t\tResourceTypeRegistrationPropertiesMarketplaceTypeAddOn,\n\t\tResourceTypeRegistrationPropertiesMarketplaceTypeBypass,\n\t\tResourceTypeRegistrationPropertiesMarketplaceTypeNotSpecified,\n\t\tResourceTypeRegistrationPropertiesMarketplaceTypeStore,\n\t}\n}", "id": 2058, "concepts": ["enum", "const type", "possible values"], "_raw_llm_output": "enum, const type, possible values"}
{"seed": "// NewAppSsoWithDefaults instantiates a new AppSso object\n// This constructor will only assign default values to properties that have it defined,\n// but it doesn't guarantee that properties required by API are set\nfunc NewAppSsoWithDefaults() *AppSso {\n\tthis := AppSso{}\n\treturn &this\n}", "id": 2067, "concepts": ["constructor", "default values", "API usage"], "_raw_llm_output": "constructor, default values, API usage"}
{"seed": "// Map creates a two-way mapping between two transform operations.\n// The first operation will be used to check constraints for each node and store state, while the second one will use\n// the state to construct a new tree.\nfunc Map(src, dst Op) Mapping {\n\treturn mapping{src: src, dst: dst}\n}", "id": 2072, "concepts": ["struct definition", "function definition", "interface definition"], "_raw_llm_output": "struct definition, function definition, interface definition"}
{"seed": "// search returns true if value exists in the tree under node n\nfunc search(n *BinarySearchNode, value int) bool {\n\tif n == nil {\n\t\treturn false\n\t}\n\tif value < n.value {\n\t\treturn search(n.left, value)\n\t}\n\tif value > n.value {\n\t\treturn search(n.right, value)\n\t}\n\treturn true\n}", "id": 2077, "concepts": ["binary search", "recursion", "tree traversal"], "_raw_llm_output": "binary search, recursion, tree traversal"}
{"seed": "// WithInternalRequest creates child context with additional information\n// that this context is for internal requests\nfunc WithInternalRequest(ctx context.Context) context.Context {\n\treturn context.WithValue(ctx, internalRequestKey, true)\n}", "id": 2078, "concepts": ["context.Context", "context.WithValue", "context.ContextKey"], "_raw_llm_output": "context.Context, context.WithValue, context.ContextKey"}
{"seed": "// Unauthorized is a convenience function for building HTTP 401 Unauthorized\n// responses. If data is nil, a default serializer will be used.\nfunc Unauthorized(data Serializer, logging ...interface{}) Response {\n\tif data == nil {\n\t\tdata = String(\"401 Unauthorized\")\n\t}\n\treturn Response{\n\t\tStatus:  http.StatusUnauthorized,\n\t\tData:    data,\n\t\tLogging: logging,\n\t}\n}", "id": 2081, "concepts": ["HTTP response", "HTTP status code", "HTTP response body", "HTTP response logging"], "_raw_llm_output": "HTTP response, HTTP status code, HTTP response body, HTTP response logging"}
{"seed": "// WildcardParens answers if the parens are balanced.\n// This includes a wildcard character '*' that can be either paren\n// or an empty string.\n// Implementation note: counts opens two different ways.\n// First, it counts opens assuming a wildcard is an open '('.\n// Next, it counts opens assuming a wildcard is a close ')'.\n// Runs in O(N) time and O(1) space.\nfunc WildcardParens(input string) bool {\n\tvar opensIfWildcardCloses, opensIfWildcardOpens int\n\tfor _, c := range input {\n\t\tswitch c {\n\t\tcase '(':\n\t\t\topensIfWildcardCloses++\n\t\t\topensIfWildcardOpens++\n\t\tcase ')':\n\t\t\topensIfWildcardCloses--\n\t\t\topensIfWildcardOpens--\n\t\tcase '*':\n\t\t\topensIfWildcardCloses--\n\t\t\topensIfWildcardOpens++\n\t\t}\n\t\tif opensIfWildcardOpens < 0 {\n\t\t\tbreak\n\t\t}\n\t\t// if a closing wildcard goes negative,\n\t\t// assume it's an empty string.\n\t\tif opensIfWildcardCloses < 0 {\n\t\t\topensIfWildcardCloses = 0\n\t\t}\n\t}\n\treturn opensIfWildcardCloses == 0\n}", "id": 2105, "concepts": ["string manipulation", "rune handling", "character comparison"], "_raw_llm_output": "string manipulation, rune handling, character comparison"}
{"seed": "// CreateSaveReceiverDetailRequest creates a request to invoke SaveReceiverDetail API\r\nfunc CreateSaveReceiverDetailRequest() (request *SaveReceiverDetailRequest) {\r\n\trequest = &SaveReceiverDetailRequest{\r\n\t\tRpcRequest: &requests.RpcRequest{},\r\n\t}\r\n\trequest.InitWithApiInfo(\"Dm\", \"2015-11-23\", \"SaveReceiverDetail\", \"\", \"\")\r\n\treturn\r\n}", "id": 2110, "concepts": ["struct definition", "struct initialization", "method definition", "method call", "anonymous struct"], "_raw_llm_output": "struct definition, struct initialization, method definition, method call, anonymous struct"}
{"seed": "// Dir represents the HTML element 'dir'.\n// For more information visit https://www.w3schools.com/tags/tag_dir.asp.\nfunc Dir(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"dir\", Attributes: attrs, Children: children}\n}", "id": 2130, "concepts": ["HTML generation", "HTML tree", "HTML element", "HTML attribute", "HTML child"], "_raw_llm_output": "HTML generation, HTML tree, HTML element, HTML attribute, HTML child"}
{"seed": "// Returns a ResourceListPair representing the intervals describing the set\n// of valid values for each of the given resources. The lower bound of each\n// interval is computed using the node count equal to numNodes +\n// floor(numNodes * -offset/100). The uppoer bound of each interval is computed\n// using the node count equal to numNodes + ceil(numNodes * offset/100). Note\n// the ordering of the elements of the lower and upper fields is significant.\n// Element N of each field represents the lower and upper bounds, respectively,\n// of the interval for the resource with index N in res.\nfunc nodesAndOffsetToRange(numNodes uint64, offset int64, res []Resource) ResourceListPair {\n\tnumNodesMin := getOffsetNodeCount(numNodes, -offset, math.Floor)\n\tnumNodesMax := getOffsetNodeCount(numNodes, offset, math.Ceil)\n\treturn ResourceListPair{\n\t\tlower: calculateResources(numNodesMin, res),\n\t\tupper: calculateResources(numNodesMax, res),\n\t}\n}", "id": 2142, "concepts": ["integer math", "math package usage", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition"], "_raw_llm_output": "integer math, math package usage, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition"}
{"seed": "// NewMockPlcTagHandler creates a new instance of MockPlcTagHandler. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.\n// The first argument is typically a *testing.T value.\nfunc NewMockPlcTagHandler(t interface {\n\tmock.TestingT\n\tCleanup(func())\n}) *MockPlcTagHandler {\n\tmock := &MockPlcTagHandler{}\n\tmock.Mock.Test(t)\n\n\tt.Cleanup(func() { mock.AssertExpectations(t) })\n\n\treturn mock\n}", "id": 2152, "concepts": ["testing interface", "testing cleanup", "mocking"], "_raw_llm_output": "testing interface, testing cleanup, mocking"}
{"seed": "// CorrectionNEQ applies the NEQ predicate on the \"correction\" field.\nfunc CorrectionNEQ(v string) predicate.TradeCorrection {\n\treturn predicate.TradeCorrection(sql.FieldNEQ(FieldCorrection, v))\n}", "id": 2153, "concepts": ["predicate.TradeCorrection", "sql.FieldNEQ", "sql.FieldEQ"], "_raw_llm_output": "predicate.TradeCorrection, sql.FieldNEQ, sql.FieldEQ"}
{"seed": "// Status converts the given error into a status response.\n// If the error is nil a status with codes.OK is returned.\n// If the error has a code attached it will be returned.\n// Failing the above a status with codes.Unknown will be returned.\nfunc Status(err error) *proto.Status {\n\t// No error. Return an OK status (codes.OK is the uint32 zero value).\n\tif err == nil {\n\t\treturn &proto.Status{}\n\t}\n\n\ttype coder interface {\n\t\tCode() codes.Code\n\t}\n\n\t// Error has a code attached.\n\tif e, ok := err.(coder); ok {\n\t\treturn &proto.Status{Code: uint32(e.Code()), Message: err.Error()}\n\t}\n\n\t// Unable to automatically determine error.\n\treturn &proto.Status{Code: uint32(codes.Unknown), Message: err.Error()}\n}", "id": 2160, "concepts": ["interface implementation", "error handling (interface assertion)", "error handling (error wrapping)", "error handling (error codes)"], "_raw_llm_output": "interface implementation, error handling (interface assertion), error handling (error wrapping), error handling (error codes)"}
{"seed": "// FSName sets the file system name (also called source) that is\n// visible in the list of mounted file systems.\n//\n// FreeBSD ignores this option.\nfunc FSName(name string) MountOption {\n\treturn func(conf *mountConfig) error {\n\t\tconf.options[\"fsname\"] = name\n\t\treturn nil\n\t}\n}", "id": 2164, "concepts": ["function definition", "function composition", "function options", "function option composition", "function option usage"], "_raw_llm_output": "function definition, function composition, function options, function option composition, function option usage"}
{"seed": "// SocialEmailContains applies the Contains predicate on the \"social_email\" field.\nfunc SocialEmailContains(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.Contains(s.C(FieldSocialEmail), v))\n\t})\n}", "id": 2165, "concepts": ["sql package usage", "sql.Selector usage", "sql.Contains usage", "sql.C usage", "predicate.User usage"], "_raw_llm_output": "sql package usage, sql.Selector usage, sql.Contains usage, sql.C usage, predicate.User usage"}
{"seed": "// MapFloat64Uint16Ptr takes two inputs -\n// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list\nfunc MapFloat64Uint16Ptr(f func(*float64) *uint16, list []*float64) []*uint16 {\n\tif f == nil {\n\t\treturn []*uint16{}\n\t}\n\tnewList := make([]*uint16, len(list))\n\tfor i, v := range list {\n\t\tnewList[i] = f(v)\n\t}\n\treturn newList\n}", "id": 2171, "concepts": ["function definition", "function composition", "function pointer", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", ""], "_raw_llm_output": "function definition, function composition, function pointer, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition,"}
{"seed": "// removeZone removes IPv6 zone identifer from host.\n// E.g., \"[fe80::1%en0]:8080\" to \"[fe80::1]:8080\"\nfunc removeZone(host string) string {\n\tif !strings.HasPrefix(host, \"[\") {\n\t\treturn host\n\t}\n\ti := strings.LastIndex(host, \"]\")\n\tif i < 0 {\n\t\treturn host\n\t}\n\tj := strings.LastIndex(host[:i], \"%\")\n\tif j < 0 {\n\t\treturn host\n\t}\n\treturn host[:j] + host[i:]\n}", "id": 2181, "concepts": ["string manipulation", "string search", "string replacement"], "_raw_llm_output": "string manipulation, string search, string replacement"}
{"seed": "// NewDeleteRolesParams creates a new DeleteRolesParams object\n// with the default values initialized.\nfunc NewDeleteRolesParams() *DeleteRolesParams {\n\tvar ()\n\treturn &DeleteRolesParams{\n\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 2184, "concepts": ["struct definition", "field initialization", "pointer dereference"], "_raw_llm_output": "struct definition, field initialization, pointer dereference"}
{"seed": "// ExtractMeasures interprets the results of a single page from a List() call,\n// producing a slice of Measures structs.\nfunc ExtractMeasures(r pagination.Page) ([]Measure, error) {\n\tvar s []Measure\n\n\terr := (r.(MeasurePage)).ExtractInto(&s)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s, err\n}", "id": 2204, "concepts": ["struct definition", "interface implementation", "pagination", "pagination usage"], "_raw_llm_output": "struct definition, interface implementation, pagination, pagination usage"}
{"seed": "// NewForConfig creates a new ConfigV1Client for the given config.\n// NewForConfig is equivalent to NewForConfigAndClient(c, httpClient),\n// where httpClient was generated with rest.HTTPClientFor(c).\nfunc NewForConfig(c *rest.Config) (*ConfigV1Client, error) {\n\tconfig := *c\n\tif err := setConfigDefaults(&config); err != nil {\n\t\treturn nil, err\n\t}\n\thttpClient, err := rest.HTTPClientFor(&config)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn NewForConfigAndClient(&config, httpClient)\n}", "id": 2208, "concepts": ["rest.HTTPClientFor", "rest.Config", "client creation", "client creation with custom HTTP client"], "_raw_llm_output": "rest.HTTPClientFor, rest.Config, client creation, client creation with custom HTTP client"}
{"seed": "// NewLineRouteParamsWithTimeout creates a new LineRouteParams object\n// with the default values initialized, and the ability to set a timeout on a request\nfunc NewLineRouteParamsWithTimeout(timeout time.Duration) *LineRouteParams {\n\tvar ()\n\treturn &LineRouteParams{\n\n\t\ttimeout: timeout,\n\t}\n}", "id": 2210, "concepts": ["struct definition", "field initialization", "anonymous struct", "timeout handling"], "_raw_llm_output": "struct definition, field initialization, anonymous struct, timeout handling"}
{"seed": "// PossibleAADObjectTypeValues returns an array of possible values for the AADObjectType const type.\nfunc PossibleAADObjectTypeValues() []AADObjectType {\n\treturn []AADObjectType{Group, ServicePrincipal, User}\n}", "id": 2215, "concepts": ["array definition", "array iteration (range loop)", "basic function definition"], "_raw_llm_output": "array definition, array iteration (range loop), basic function definition"}
{"seed": "// NewEditParams creates a new EditParams object,\n// with the default timeout for this client.\n//\n// Default values are not hydrated, since defaults are normally applied by the API server side.\n//\n// To enforce default values in parameter, use SetDefaults or WithDefaults.\nfunc NewEditParams() *EditParams {\n\treturn &EditParams{\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 2217, "concepts": ["object creation", "default values", "struct definition"], "_raw_llm_output": "object creation, default values, struct definition"}
{"seed": "// New returns a standard non-thread safe fixed-sized lru cache where the\n// keys are strings and the values are interfaces.\n// The size must be a positive number. The onEvict param is an optional\n// callback function that fires when entries are forced to be evicted.\nfunc New(size int, onEvict func(key string, value interface{})) *Cache {\n\tif size <= 0 {\n\t\tpanic(\"invalid size\")\n\t}\n\treturn &Cache{\n\t\tentries: make(map[string]*entry, int(float64(size)*1.5)),\n\t\tsize:    size,\n\t\tonEvict: onEvict,\n\t}\n}", "id": 2221, "concepts": ["map iteration (range loop)", "map key access", "map value access", "map deletion", "map entry creation", "map entry deletion", "map entry modification", "map iteration (range loop)", "map key access", "map value access", "map deletion", "map entry creation", "map entry deletion", "map entry modification", "map iteration (range loop)", "map key access", "map value access", "map deletion", "map entry creation", "map entry deletion", "map entry modification", "map iteration (range loop)", "map key access", "map value access", "map deletion", "map entry creation", "map entry deletion", "map entry modification", "map iteration (range loop)", "map key access", "map value access", "map deletion", "map entry creation", "map entry deletion", "map entry modification", "map iteration (range loop)", "map key access", "map value access", "map deletion", "map entry creation", "map entry deletion", "map entry modification", "map iteration (range loop)", "map key access", "map value access", "map deletion", "map entry creation", "map entry deletion", "map entry modification", "map iteration (range loop)", "map key access", "map value access", "map deletion", "map entry creation", "map entry deletion", "map entry modification", "map iteration (range loop)", "map key access", "map value access", "map deletion", "map entry creation", "map entry"], "_raw_llm_output": "map iteration (range loop), map key access, map value access, map deletion, map entry creation, map entry deletion, map entry modification, map iteration (range loop), map key access, map value access, map deletion, map entry creation, map entry deletion, map entry modification, map iteration (range loop), map key access, map value access, map deletion, map entry creation, map entry deletion, map entry modification, map iteration (range loop), map key access, map value access, map deletion, map entry creation, map entry deletion, map entry modification, map iteration (range loop), map key access, map value access, map deletion, map entry creation, map entry deletion, map entry modification, map iteration (range loop), map key access, map value access, map deletion, map entry creation, map entry deletion, map entry modification, map iteration (range loop), map key access, map value access, map deletion, map entry creation, map entry deletion, map entry modification, map iteration (range loop), map key access, map value access, map deletion, map entry creation, map entry deletion, map entry modification, map iteration (range loop), map key access, map value access, map deletion, map entry creation, map entry"}
{"seed": "// NewBuilder creates a new builder for an addon in the given directory, which will be written as a zip file to\n// the given output stream. Returns an error if the addon metadata could not be read. The actual build process\n// is invoked by calling the Build() function.\nfunc NewBuilder(dir, defaultPackageName string, out io.Writer) (*Builder, error) {\n\tdata, err := MetaDataFromDirectory(dir, defaultPackageName)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &Builder{\n\t\tdir:    dir,\n\t\tdata:   data,\n\t\twriter: zip.NewWriter(out),\n\t\tmapper: NewFolderMap(data),\n\t}, nil\n}", "id": 2239, "concepts": ["io.Writer", "zip.NewWriter", "io.Closer", "io.Reader", "io.ReadCloser", "io.ReadSeeker", "io.ReaderAt", "io.Seeker", "io.WriterAt", "io.WriterTo", "io.Closer", "io.ReaderFrom", "io.Copy", "io.CopyN", "io.TeeReader", "io.LimitReader", "io.MultiReader", "io.SectionReader", "io.ByteReader", "io.RuneReader", "io.ByteScanner", "io.RuneScanner", "io.ReaderAtSize", "io.ReaderFromSize", "io.WriterToReader", "io.Seeker", "io.Reader", "io.Writer", "io.Closer", "io.ReaderFrom", "io.WriterTo", "io.ReaderAt", "io.Writer", "io.Seeker", "io.ByteWriter", "io.RuneWriter", "io.ByteScanner", "io.RuneScanner", "io.WriterAt", "io.WriterTo", "io.WriterAtSize", "io.WriterToSize", "io.WriterToReader", "io.Reader", "io.Writer", "io.Closer", "io.ReaderFrom", "io.WriterTo", "io.ReaderAt", "io.Writer", "io.Seeker", "io.ByteWriter", ""], "_raw_llm_output": "io.Writer, zip.NewWriter, io.Closer, io.Reader, io.ReadCloser, io.ReadSeeker, io.ReaderAt, io.Seeker, io.WriterAt, io.WriterTo, io.Closer, io.ReaderFrom, io.Copy, io.CopyN, io.TeeReader, io.LimitReader, io.MultiReader, io.SectionReader, io.ByteReader, io.RuneReader, io.ByteScanner, io.RuneScanner, io.ReaderAtSize, io.ReaderFromSize, io.WriterToReader, io.Seeker, io.Reader, io.Writer, io.Closer, io.ReaderFrom, io.WriterTo, io.ReaderAt, io.Writer, io.Seeker, io.ByteWriter, io.RuneWriter, io.ByteScanner, io.RuneScanner, io.WriterAt, io.WriterTo, io.WriterAtSize, io.WriterToSize, io.WriterToReader, io.Reader, io.Writer, io.Closer, io.ReaderFrom, io.WriterTo, io.ReaderAt, io.Writer, io.Seeker, io.ByteWriter,"}
{"seed": "// WithBytes creates a hyperloglog counter that uses buf as its backing\n// storage, preserving any existing data in the byte slice. Any subsequent\n// writes to the counter will mutate buf. The layout of the byte buffer\n// must match the layout used by the WriteTo method.\nfunc WithBytes(buf []byte) (Counter, error) {\n\tversion := buf[0]\n\tif version != Version {\n\t\treturn Counter{}, ErrIncompatibleVersion\n\t}\n\n\tp := buf[1]\n\tbits, err := bitbucket.WithBytes(buf[2:])\n\tif err != nil {\n\t\treturn Counter{}, err\n\t}\n\n\tc := Counter{\n\t\tp:    p,\n\t\tbits: bits,\n\t}\n\tc.initParams()\n\treturn c, nil\n}", "id": 2290, "concepts": ["byte slice manipulation", "byte buffer manipulation", "bitbucket package usage"], "_raw_llm_output": "byte slice manipulation, byte buffer manipulation, bitbucket package usage"}
{"seed": "// Li represents the HTML element 'li'.\n// For more information visit https://www.w3schools.com/tags/tag_li.asp.\nfunc Li(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"li\", Attributes: attrs, Children: children}\n}", "id": 2291, "concepts": ["HTML generation (HTML struct)", "HTML struct definition", "HTML struct composition"], "_raw_llm_output": "HTML generation (HTML struct), HTML struct definition, HTML struct composition"}
{"seed": "// ReLU is the \"rectified linear unit\"\n// `x >= 0 ? x : 0`\nfunc ReLU(x float64) float64 {\n\tif x >= 0 {\n\t\treturn x\n\t}\n\treturn 0\n}", "id": 2292, "concepts": ["basic function definition", "conditional statement", "basic math operations"], "_raw_llm_output": "basic function definition, conditional statement, basic math operations"}
{"seed": "// NewGetDevicesApsProfilesParamsWithTimeout creates a new GetDevicesApsProfilesParams object\n// with the ability to set a timeout on a request.\nfunc NewGetDevicesApsProfilesParamsWithTimeout(timeout time.Duration) *GetDevicesApsProfilesParams {\n\treturn &GetDevicesApsProfilesParams{\n\t\ttimeout: timeout,\n\t}\n}", "id": 2295, "concepts": ["timeout handling", "time package usage"], "_raw_llm_output": "timeout handling, time package usage"}
{"seed": "// Pre_ is a convenience wrapper for Pre without the attrs argument.\nfunc Pre_(children ...HTML) HTML {\n  return Pre(nil, children...)\n}", "id": 2304, "concepts": ["function definition", "variadic function argument", "nil argument"], "_raw_llm_output": "function definition, variadic function argument, nil argument"}
{"seed": "//Write a function that greets the user by name, or by saying \"Hello, World!\" if no name is given.\n//\"Hello, World!\" is the traditional first program for beginning programming in a new language.\nfunc HelloWorld(name string) string {\n\t// Write some code here to pass the test suite.\n\n\tif name != \"\" {\n\t\treturn \"Hello, \" + name + \"!\"\n\t} else {\n\t\treturn \"Hello, World!\"\n\t}\n\n}", "id": 2305, "concepts": ["string concatenation", "string comparison", "basic function definition"], "_raw_llm_output": "string concatenation, string comparison, basic function definition"}
{"seed": "// TitleEqualFold applies the EqualFold predicate on the \"title\" field.\nfunc TitleEqualFold(v string) predicate.User {\n\treturn predicate.User(sql.FieldEqualFold(FieldTitle, v))\n}", "id": 2319, "concepts": ["sql.FieldEqualFold", "sql.Field", "sql.FieldEqualFold predicate", "sql.FieldEqualFold predicate usage"], "_raw_llm_output": "sql.FieldEqualFold, sql.Field, sql.FieldEqualFold predicate, sql.FieldEqualFold predicate usage"}
{"seed": "// ObjectBoxModel declares and builds the model from all the entities in the package.\n// It is usually used when setting-up ObjectBox as an argument to the Builder.Model() function.\nfunc ObjectBoxModel() *objectbox.Model {\n\tmodel := objectbox.NewModel()\n\tmodel.GeneratorVersion(6)\n\n\tmodel.RegisterBinding(EventBinding)\n\tmodel.RegisterBinding(ReadingBinding)\n\tmodel.LastEntityId(2, 5284076134434938613)\n\tmodel.LastIndexId(2, 2642563953244304959)\n\n\treturn model\n}", "id": 2332, "concepts": ["objectbox", "objectbox.Model", "objectbox.Binding", "objectbox.GeneratorVersion", "objectbox.LastEntityId", "objectbox.LastIndexId"], "_raw_llm_output": "objectbox, objectbox.Model, objectbox.Binding, objectbox.GeneratorVersion, objectbox.LastEntityId, objectbox.LastIndexId"}
{"seed": "// SocialUserID applies equality check predicate on the \"social_user_id\" field. It's identical to SocialUserIDEQ.\nfunc SocialUserID(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldSocialUserID), v))\n\t})\n}", "id": 2337, "concepts": ["sql.Selector", "sql.EQ", "sql.C", "predicate.User", "predicate.FieldSocialUserID"], "_raw_llm_output": "sql.Selector, sql.EQ, sql.C, predicate.User, predicate.FieldSocialUserID"}
{"seed": "// RemoveFinalizer ensures that the given finalizer is not present anymore in the given object with exponential backoff.\n// If it is set, it removes it and issues a patch.\n// Use PatchRemoveFinalizers instead, if the controller is able to tolerate conflict errors caused by stale reads.\nfunc RemoveFinalizer(ctx context.Context, reader client.Reader, writer client.Writer, obj client.Object, finalizer string) error {\n\treturn tryPatchFinalizers(ctx, reader, writer, obj, controllerutil.RemoveFinalizer, finalizer)\n}", "id": 2344, "concepts": ["client-go", "client.Reader", "client.Writer", "client.Object", "context.Context", "clientutil.RemoveFinalizer", "exponential backoff"], "_raw_llm_output": "client-go, client.Reader, client.Writer, client.Object, context.Context, clientutil.RemoveFinalizer, exponential backoff"}
{"seed": "// PreflightForCORS sets HTTP Headers needed for Preflight For CORS to given ResponseWriter.\n// PreflightForCORS returns true when add header, false when nothing to do.\n// When nil specified for allowHeaders and/or allowMethods, PreflightForCORS sets them as same as client request.\n// refer:\n// https://medium.com/google-cloud-jp/https-medium-com-google-cloud-jp-gae-api-12e5ab274719\n// https://symfoware.blog.fc2.com/blog-entry-2010.html\n// https://qiita.com/rooooomania/items/4d0f6275372f413765de\nfunc PreflightForCORS(w http.ResponseWriter, r *http.Request, allowHeaders, allowMethods *[]string, allowOrigin string) bool {\n\tif r.Method != http.MethodOptions {\n\t\treturn false\n\t}\n\n\t// When nil specified for allowHeaders, PreflightForCORS sets them as same as client request.\n\theaders := r.Header.Get(\"Access-Control-Request-Headers\")\n\tif allowHeaders != nil {\n\t\theaders = strings.Join(*allowHeaders, \", \")\n\t}\n\n\t// Also when nil specified for allowMethods, PreflightForCORS sets them as same as client request.\n\tmethods := r.Header.Get(\"Access-Control-Request-Method\")\n\tif allowMethods != nil {\n\t\tmethods = strings.Join(*allowMethods, \", \")\n\t}\n\n\tw.Header().Set(\"Access-Control-Allow-Origin\", allowOrigin)\n\tw.Header().Set(\"Access-Control-Allow-Headers\", headers)\n\tw.Header().Set(\"Access-Control-Allow-Methods\", methods)\n\tResponseOK(w)\n\treturn true\n}", "id": 2354, "concepts": ["HTTP Headers", "HTTP Methods", "CORS"], "_raw_llm_output": "HTTP Headers, HTTP Methods, CORS"}
{"seed": "// a and b cannot be merged if they are of different NomsKind, or if at least one of the two is nil, or if either is a Noms primitive.\nfunc unmergeable(a, b types.Value) bool {\n\tif a != nil && b != nil {\n\t\taKind, bKind := a.Type().Kind(), b.Type().Kind()\n\t\treturn aKind != bKind || types.IsPrimitiveKind(aKind) || types.IsPrimitiveKind(bKind)\n\t}\n\treturn true\n}", "id": 2357, "concepts": ["type checking", "type conversion", "type comparison"], "_raw_llm_output": "type checking, type conversion, type comparison"}
{"seed": "// CopyDir copy files recursively from source to target directory.\n//\n// The filter accepts a function that process the path info.\n// and should return true for need to filter.\n//\n// It returns error when error occurs in underlying functions.\nfunc CopyDir(srcPath, destPath string, filters ...func(filePath string) bool) error {\n\t// Check if target directory exists.\n\tif IsExist(destPath) {\n\t\treturn errors.New(\"file or directory alreay exists: \" + destPath)\n\t}\n\n\terr := os.MkdirAll(destPath, os.ModePerm)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Gather directory info.\n\tinfos, err := StatDir(srcPath, true)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar filter func(filePath string) bool\n\tif len(filters) > 0 {\n\t\tfilter = filters[0]\n\t}\n\n\tfor _, info := range infos {\n\t\tif filter != nil && filter(info) {\n\t\t\tcontinue\n\t\t}\n\n\t\tcurPath := path.Join(destPath, info)\n\t\tif strings.HasSuffix(info, \"/\") {\n\t\t\terr = os.MkdirAll(curPath, os.ModePerm)\n\t\t} else {\n\t\t\terr = Copy(path.Join(srcPath, info), curPath)\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}", "id": 2361, "concepts": ["file system", "os package usage", "error handling (idiomatic if err != nil)", "string manipulation", "path manipulation", "directory traversal", "concurrency", "standard library usage"], "_raw_llm_output": "file system, os package usage, error handling (idiomatic if err != nil), string manipulation, path manipulation, directory traversal, concurrency, standard library usage"}
{"seed": "// readConfig reads JSON-style configuration from file.\n// It removes comments, unmarshals the top level and puts\n// the result into a map[string]*json.RawMessage\nfunc readConfig(configfile string) (map[string]*json.RawMessage, error) {\n\n\tvar (\n\t\tfile   []byte\n\t\tobjmap map[string]*json.RawMessage\n\t\terr    error\n\t)\n\n\tfile, err = ioutil.ReadFile(configfile)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlines := strings.Split(string(file), \"\\n\")\n\tvar jdata []byte\n\tfor _, line := range lines {\n\t\tif !strings.HasPrefix(strings.TrimSpace(line), \"//\") {\n\t\t\tjdata = append(jdata, []byte(line+\"\\n\")...)\n\t\t}\n\t}\n\n\terr = json.Unmarshal(jdata, &objmap)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn objmap, nil\n}", "id": 2369, "concepts": ["file reading", "JSON parsing", "string manipulation", "error handling"], "_raw_llm_output": "file reading, JSON parsing, string manipulation, error handling"}
{"seed": "// WithHTTPClient uses a specific http client with retryable requests\nfunc WithHTTPClient(h *http.Client) Opts {\n\treturn func(r *retryable) {\n\t\tr.httpClient = h\n\t}\n}", "id": 2397, "concepts": ["http client", "retryable request", "functional options"], "_raw_llm_output": "http client, retryable request, functional options"}
{"seed": "// NewHyperflexSnapshotStatus instantiates a new HyperflexSnapshotStatus object\n// This constructor will assign default values to properties that have it defined,\n// and makes sure properties required by API are set, but the set of arguments\n// will change when the set of required properties is changed\nfunc NewHyperflexSnapshotStatus(classId string, objectType string) *HyperflexSnapshotStatus {\n\tthis := HyperflexSnapshotStatus{}\n\tthis.ClassId = classId\n\tthis.ObjectType = objectType\n\treturn &this\n}", "id": 2409, "concepts": ["constructor", "object instantiation", "object initialization", "object property assignment"], "_raw_llm_output": "constructor, object instantiation, object initialization, object property assignment"}
{"seed": "// pathPrefix returns the base path for all methods handled by a particular\n// service. It includes a trailing slash. (for example \"/gogo/example.Haberdasher/\").\nfunc pathPrefix(file *descriptor.FileDescriptorProto, service *descriptor.ServiceDescriptorProto) string {\n\treturn fmt.Sprintf(\"/gogo/%s/\", fullServiceName(file, service))\n}", "id": 2410, "concepts": ["string formatting", "descriptor.FileDescriptorProto", "descriptor.ServiceDescriptorProto", "string concatenation", "string manipulation"], "_raw_llm_output": "string formatting, descriptor.FileDescriptorProto, descriptor.ServiceDescriptorProto, string concatenation, string manipulation"}
{"seed": "// GyroRollPitch returns the gyroscope pitch and roll values in degrees.\n// Roll is between -180..180 and pitch is between -90..90 degrees.\n//\n// The roll angle becomes unstable when pitch is near \u00b190\u00b0 degrees.\nfunc GyroRollPitch(x, y, z float64) (r, p float64) {\n\n\t// http://www.nxp.com/files/sensors/doc/app_note/AN3461.pdf\n\t//\n\t// In paper:\n\t//   x: up, y: right, z: back\n\t//   roll:  \u03c6\n\t//   pitch: \u03b8\n\t//\n\t//   25. tan \u03c6_xyz = y/z\n\t//   26. tan \u03b8_xyz = -x/\u221a(y\u00b2+z\u00b2)\n\t//   28. tan \u03c6_yxz = y/\u221a(x\u00b2+z\u00b2)\n\t//   29. tan \u03b8_yxz = -x/z\n\t//   37. tan \u03b8_xyz = -x/\u221a(y\u00b2+z\u00b2)  (same as 26.)\n\t//   38. tan \u03c6_xyz = y/(sign(z)\u221a(z\u00b2+\u03bcx\u00b2)\n\n\t// mu is a constant to stabilise the roll value when both x and y\n\t// is near, that is when pitch approaches \u00b190\u00b0.\n\tconst mu = 0.01\n\n\twr := math.Copysign(math.Sqrt(y*y+mu*z*z), y)\n\twp := math.Sqrt(x*x + y*y)\n\tr = math.Atan2(x, wr) * 180 / math.Pi\n\tp = math.Atan2(z, wp) * 180 / math.Pi\n\treturn r, p\n}", "id": 2427, "concepts": ["math package usage", "floating point arithmetic", "trigonometry"], "_raw_llm_output": "math package usage, floating point arithmetic, trigonometry"}
{"seed": "// WithDupeDetector configures Sign* to use the following DupeDetector\n// to avoid attaching duplicate signatures.\nfunc WithDupeDetector(dd DupeDetector) SignOption {\n\treturn func(so *signOpts) {\n\t\tso.dd = dd\n\t}\n}", "id": 2430, "concepts": ["struct definition", "struct field definition", "struct field initialization", "struct field access", "struct method definition", "struct method invocation", "struct method access", "struct method invocation with receiver", "struct method invocation with receiver and method", "struct method invocation with receiver and method", "struct method invocation with receiver and method", "struct method invocation with receiver and method", "struct method invocation with receiver and method", "struct method invocation with receiver and method", "struct method invocation with receiver and method", "struct method invocation with receiver and method", "struct method invocation with receiver and method", "struct method invocation with receiver and method", "struct method invocation with receiver and method", "struct method invocation with receiver and method", "struct method invocation with receiver and method", "struct method invocation with receiver and method", "struct method invocation with receiver and method", "struct method invocation with receiver and method", "struct method invocation with receiver and method", "struct method invocation with receiver and method", "struct method invocation with receiver and method", "struct method invocation with receiver and method", "struct method invocation with receiver and method", "struct method invocation with receiver and method", "struct method invocation with receiver and method", "struct method invocation with receiver and method", "struct method invocation with receiver and method", "struct method invocation with receiver and method", "struct method invocation with receiver and method", "struct method invocation with receiver and"], "_raw_llm_output": "struct definition, struct field definition, struct field initialization, struct field access, struct method definition, struct method invocation, struct method access, struct method invocation with receiver, struct method invocation with receiver and method, struct method invocation with receiver and method, struct method invocation with receiver and method, struct method invocation with receiver and method, struct method invocation with receiver and method, struct method invocation with receiver and method, struct method invocation with receiver and method, struct method invocation with receiver and method, struct method invocation with receiver and method, struct method invocation with receiver and method, struct method invocation with receiver and method, struct method invocation with receiver and method, struct method invocation with receiver and method, struct method invocation with receiver and method, struct method invocation with receiver and method, struct method invocation with receiver and method, struct method invocation with receiver and method, struct method invocation with receiver and method, struct method invocation with receiver and method, struct method invocation with receiver and method, struct method invocation with receiver and method, struct method invocation with receiver and method, struct method invocation with receiver and method, struct method invocation with receiver and method, struct method invocation with receiver and method, struct method invocation with receiver and method, struct method invocation with receiver and method, struct method invocation with receiver and"}
{"seed": "// ParseCreatePrivateNetworkResponse parses an HTTP response from a CreatePrivateNetworkWithResponse call\nfunc ParseCreatePrivateNetworkResponse(rsp *http.Response) (*CreatePrivateNetworkResponse, error) {\n\tbodyBytes, err := ioutil.ReadAll(rsp.Body)\n\tdefer rsp.Body.Close()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse := &CreatePrivateNetworkResponse{\n\t\tBody:         bodyBytes,\n\t\tHTTPResponse: rsp,\n\t}\n\n\tswitch {\n\tcase strings.Contains(rsp.Header.Get(\"Content-Type\"), \"json\") && rsp.StatusCode == 200:\n\t\tvar dest Operation\n\t\tif err := json.Unmarshal(bodyBytes, &dest); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresponse.JSON200 = &dest\n\n\t}\n\n\treturn response, nil\n}", "id": 2431, "concepts": ["HTTP response parsing", "JSON parsing", "HTTP status code handling"], "_raw_llm_output": "HTTP response parsing, JSON parsing, HTTP status code handling"}
{"seed": "// NewArtifactsClientWithOboToken Creates a new default Artifacts client with the given configuration provider.\n// The obotoken will be added to default headers and signed; the configuration provider will be used for the signer\n//\n//\tas well as reading the region\nfunc NewArtifactsClientWithOboToken(configProvider common.ConfigurationProvider, oboToken string) (client ArtifactsClient, err error) {\n\tbaseClient, err := common.NewClientWithOboToken(configProvider, oboToken)\n\tif err != nil {\n\t\treturn client, err\n\t}\n\n\treturn newArtifactsClientFromBaseClient(baseClient, configProvider)\n}", "id": 2434, "concepts": ["configuration provider", "default headers", "signing", "region"], "_raw_llm_output": "configuration provider, default headers, signing, region"}
{"seed": "// PossibleSessionAffinityEnabledStateValues returns an array of possible values for the SessionAffinityEnabledState const type.\nfunc PossibleSessionAffinityEnabledStateValues() []SessionAffinityEnabledState {\n\treturn []SessionAffinityEnabledState{SessionAffinityEnabledStateDisabled, SessionAffinityEnabledStateEnabled}\n}", "id": 2447, "concepts": ["type definition", "const definition", "array definition", "array iteration"], "_raw_llm_output": "type definition, const definition, array definition, array iteration"}
{"seed": "// Contains asserts that \"haystack\" contains \"needle\".\nfunc Contains(t testing.TB, haystack string, needle string, msgAndArgs ...interface{}) {\n\tif strings.Contains(haystack, needle) {\n\t\treturn\n\t}\n\tt.Helper()\n\tmsg := formatMsgAndArgs(\"Haystack does not contain needle.\", msgAndArgs...)\n\tt.Fatalf(\"%s\\nNeedle: %q\\nHaystack: %q\\n\", msg, needle, haystack)\n}", "id": 2453, "concepts": ["testing.TB", "string manipulation", "string comparison", "test assertion"], "_raw_llm_output": "testing.TB, string manipulation, string comparison, test assertion"}
{"seed": "// GetOwnerReferencesForEngineImage returns OwnerReference for the given\n// Longhorn EngineImage name and UID\nfunc GetOwnerReferencesForEngineImage(ei *longhorn.EngineImage) []metav1.OwnerReference {\n\tblockOwnerDeletion := true\n\treturn []metav1.OwnerReference{\n\t\t{\n\t\t\tAPIVersion:         longhorn.SchemeGroupVersion.String(),\n\t\t\tKind:               types.LonghornKindEngineImage,\n\t\t\tName:               ei.Name,\n\t\t\tUID:                ei.UID,\n\t\t\tBlockOwnerDeletion: &blockOwnerDeletion,\n\t\t},\n\t}\n}", "id": 2459, "concepts": ["OwnerReference", "metav1.OwnerReference", "longhorn.EngineImage", "longhorn.SchemeGroupVersion", "longhorn.LonghornKindEngineImage", "longhorn.LonghornKindVolume", "longhorn.LonghornKindVolumeAttachment", "longhorn.LonghornKindVolumeSnapshot", "longhorn.LonghornKindVolumeSnapshotData", "longhorn.LonghornKindVolumeSnapshotContent", "longhorn.LonghornKindVolumeSnapshotData", "longhorn.LonghornKindVolumeSnapshotData", "longhorn.LonghornKindVolumeSnapshotData", "longhorn.LonghornKindVolumeSnapshotData", "longhorn.LonghornKindVolumeSnapshotData", "longhorn.LonghornKindVolumeSnapshotData", "longhorn.LonghornKindVolumeSnapshotData", "longhorn.LonghornKindVolumeSnapshotData", "longhorn.LonghornKindVolumeSnapshotData", "longhorn.LonghornKindVolumeSnapshotData", "longhorn.LonghornKindVolumeSnapshotData", "longhorn.LonghornKindVolumeSnapshotData", "longhorn.LonghornKindVolumeSnapshotData", "longhorn.LonghornKind"], "_raw_llm_output": "OwnerReference, metav1.OwnerReference, longhorn.EngineImage, longhorn.SchemeGroupVersion, longhorn.LonghornKindEngineImage, longhorn.LonghornKindVolume, longhorn.LonghornKindVolumeAttachment, longhorn.LonghornKindVolumeSnapshot, longhorn.LonghornKindVolumeSnapshotData, longhorn.LonghornKindVolumeSnapshotContent, longhorn.LonghornKindVolumeSnapshotData, longhorn.LonghornKindVolumeSnapshotData, longhorn.LonghornKindVolumeSnapshotData, longhorn.LonghornKindVolumeSnapshotData, longhorn.LonghornKindVolumeSnapshotData, longhorn.LonghornKindVolumeSnapshotData, longhorn.LonghornKindVolumeSnapshotData, longhorn.LonghornKindVolumeSnapshotData, longhorn.LonghornKindVolumeSnapshotData, longhorn.LonghornKindVolumeSnapshotData, longhorn.LonghornKindVolumeSnapshotData, longhorn.LonghornKindVolumeSnapshotData, longhorn.LonghornKindVolumeSnapshotData, longhorn.LonghornKind"}
{"seed": "// ActiveNEQ applies the NEQ predicate on the \"active\" field.\nfunc ActiveNEQ(v bool) predicate.User {\n\treturn predicate.User(sql.FieldNEQ(FieldActive, v))\n}", "id": 2465, "concepts": ["sql.FieldNEQ", "sql.FieldEQ", "sql.FieldGT", "sql.FieldLT", "sql.FieldGTE", "sql.FieldLTE", "sql.FieldIN", "sql.FieldEQ", "sql.FieldNEQ", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldIs", "sql.FieldNotIs", "sql.FieldIsNull", "sql.FieldIsNotNull", "sql.FieldAnd", "sql.FieldOr", "sql.FieldNot", "sql.FieldBetween", "sql.FieldNotBetween", "sql.FieldExists", "sql.FieldNotExists", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldIs", "sql.FieldNotIs", "sql.FieldIsNull", "sql.FieldIsNotNull", "sql.FieldAnd", "sql.FieldOr", "sql.FieldNot", "sql.FieldBetween", "sql.FieldNotBetween", "sql.FieldExists", "sql.FieldNotExists", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldIs", "sql.FieldNotIs", "sql.FieldIsNull", "sql.FieldIsNotNull", "sql.FieldAnd", "sql.FieldOr", "sql.FieldNot", "sql."], "_raw_llm_output": "sql.FieldNEQ, sql.FieldEQ, sql.FieldGT, sql.FieldLT, sql.FieldGTE, sql.FieldLTE, sql.FieldIN, sql.FieldEQ, sql.FieldNEQ, sql.FieldLike, sql.FieldNotLike, sql.FieldIs, sql.FieldNotIs, sql.FieldIsNull, sql.FieldIsNotNull, sql.FieldAnd, sql.FieldOr, sql.FieldNot, sql.FieldBetween, sql.FieldNotBetween, sql.FieldExists, sql.FieldNotExists, sql.FieldIn, sql.FieldNotIn, sql.FieldLike, sql.FieldNotLike, sql.FieldIs, sql.FieldNotIs, sql.FieldIsNull, sql.FieldIsNotNull, sql.FieldAnd, sql.FieldOr, sql.FieldNot, sql.FieldBetween, sql.FieldNotBetween, sql.FieldExists, sql.FieldNotExists, sql.FieldIn, sql.FieldNotIn, sql.FieldLike, sql.FieldNotLike, sql.FieldIs, sql.FieldNotIs, sql.FieldIsNull, sql.FieldIsNotNull, sql.FieldAnd, sql.FieldOr, sql.FieldNot, sql."}
{"seed": "// AzureADLicenseTypePNone returns a pointer to AzureADLicenseTypeVNone\nfunc AzureADLicenseTypePNone() *AzureADLicenseType {\n\tv := AzureADLicenseTypeVNone\n\treturn &v\n}", "id": 2467, "concepts": ["pointer", "pointer dereference"], "_raw_llm_output": "pointer, pointer dereference"}
{"seed": "// Server returns a new Noise server side connection\n// using net.Conn as the underlying transport.\n// The configuration config must be non-nil and must include\n// at least one certificate or else set GetCertificate.\nfunc Server(conn net.Conn, config *Config) *Conn {\n\treturn &Conn{conn: conn, config: config, isClient: false}\n}", "id": 2468, "concepts": ["net.Conn", "Config", "standard library usage"], "_raw_llm_output": "net.Conn, Config, standard library usage"}
{"seed": "// Tbody represents the HTML element 'tbody'.\n// For more information visit https://www.w3schools.com/tags/tag_tbody.asp.\nfunc Tbody(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"tbody\", Attributes: attrs, Children: children}\n}", "id": 2473, "concepts": ["HTML generation", "HTML element definition", "HTML attribute definition", "HTML element children definition"], "_raw_llm_output": "HTML generation, HTML element definition, HTML attribute definition, HTML element children definition"}
{"seed": "// NewPutOrdersOrderFidProductsOrderProductFidSetInitialTermParamsWithHTTPClient creates a new PutOrdersOrderFidProductsOrderProductFidSetInitialTermParams object\n// with the ability to set a custom HTTPClient for a request.\nfunc NewPutOrdersOrderFidProductsOrderProductFidSetInitialTermParamsWithHTTPClient(client *http.Client) *PutOrdersOrderFidProductsOrderProductFidSetInitialTermParams {\n\treturn &PutOrdersOrderFidProductsOrderProductFidSetInitialTermParams{\n\t\tHTTPClient: client,\n\t}\n}", "id": 2489, "concepts": ["http.Client usage", "struct composition", "method composition", "method composition with anonymous struct"], "_raw_llm_output": "http.Client usage, struct composition, method composition, method composition with anonymous struct"}
{"seed": "// BreakSingleByteXOR attempts to break single byte XOR encryption.\r\n// It uses LetterFreqScore to find the one with the lowest score and\r\n// returns the struct.\r\n// Params:\r\n//      ciphertext: []byte containing single-byte XOR encrypted string.\r\n//\r\n// Return: genericpals.Results\r\nfunc BreakSingleByteXOR(ciphertext []byte) Result {\r\n\r\n\tresults := make([]Result, 0x100)\r\n\r\n\tfor key := 0; key < 0x100; key++ {\r\n\r\n\t\tplaintext := SingleByteXOR(ciphertext, byte(key))\r\n\r\n\t\tresults[key].Plaintext = plaintext\r\n\t\tresults[key].Key = byte(key)\r\n\t\tresults[key].PrintableScore = printableEnglish(plaintext)\r\n\t\tresults[key].EnglishScore = letterFreqScore(plaintext)\r\n\t}\r\n\r\n\t// Sorting the array using sort.Slice\r\n\t// https://stackoverflow.com/a/42872183\r\n\r\n\t// Sort\r\n\tsort.Slice(results[:], func(i, j int) bool {\r\n\t\treturn results[i].EnglishScore < results[j].EnglishScore\r\n\t})\r\n\r\n\treturn results[0]\r\n}", "id": 2509, "concepts": ["single-byte XOR decryption", "frequency analysis", "frequency score", "slice iteration (range loop)", "string manipulation", "string comparison", "string iteration (range loop)", "string formatting", "string length", "string concatenation", "string iteration (range loop)", "string manipulation", "string concatenation", "string iteration (range loop)", "string manipulation", "string concatenation", "string iteration (range loop)", "string manipulation", "string concatenation", "string iteration (range loop)", "string manipulation", "string concatenation", "string iteration (range loop)", "string manipulation", "string concatenation", "string iteration (range loop)", "string manipulation", "string concatenation", "string iteration (range loop)", "string manipulation", "string concatenation", "string iteration (range loop)", "string manipulation", "string concatenation", "string iteration (range loop)", "string manipulation", "string concatenation", "string iteration (range loop)", "string manipulation", "string concatenation", "string iteration (range loop)", "string manipulation", "string concatenation", "string iteration (range loop)", "string manipulation", "string concatenation", "string iteration (range loop)", "string manipulation", "string concatenation", "string iteration (range loop)", "string manipulation", "string concatenation", "string iteration (range loop)", "string manipulation", "string concatenation", "string iteration (range loop)", "string manipulation", "string concatenation", "string iteration (range loop)", ""], "_raw_llm_output": "single-byte XOR decryption, frequency analysis, frequency score, slice iteration (range loop), string manipulation, string comparison, string iteration (range loop), string formatting, string length, string concatenation, string iteration (range loop), string manipulation, string concatenation, string iteration (range loop), string manipulation, string concatenation, string iteration (range loop), string manipulation, string concatenation, string iteration (range loop), string manipulation, string concatenation, string iteration (range loop), string manipulation, string concatenation, string iteration (range loop), string manipulation, string concatenation, string iteration (range loop), string manipulation, string concatenation, string iteration (range loop), string manipulation, string concatenation, string iteration (range loop), string manipulation, string concatenation, string iteration (range loop), string manipulation, string concatenation, string iteration (range loop), string manipulation, string concatenation, string iteration (range loop), string manipulation, string concatenation, string iteration (range loop), string manipulation, string concatenation, string iteration (range loop), string manipulation, string concatenation, string iteration (range loop), string manipulation, string concatenation, string iteration (range loop), string manipulation, string concatenation, string iteration (range loop),"}
{"seed": "// Bdo_ is a convenience wrapper for Bdo without the attrs argument.\nfunc Bdo_(children ...HTML) HTML {\n  return Bdo(nil, children...)\n}", "id": 2510, "concepts": ["HTML struct definition", "anonymous function", "basic function definition"], "_raw_llm_output": "HTML struct definition, anonymous function, basic function definition"}
{"seed": "// etagWeakMatch reports whether a and b match using weak ETag comparison.\n// Assumes a and b are valid ETags.\nfunc etagWeakMatch(a, b string) bool {\n\treturn strings.TrimPrefix(a, \"W/\") == strings.TrimPrefix(b, \"W/\")\n}", "id": 2513, "concepts": ["string manipulation", "string trimming", "string prefixing"], "_raw_llm_output": "string manipulation, string trimming, string prefixing"}
{"seed": "// GyroPitch returns the gyroscope roll value in degrees between -180 and 180.\n// Pitch down is positive, up is negative.\nfunc GyroPitch(x, y, z float64) float64 {\n\twp := math.Copysign(math.Sqrt(x*x+y*y), y)\n\treturn math.Atan2(z, wp) * 180 / math.Pi\n}", "id": 2520, "concepts": ["math package usage", "math.Atan2", "math.Copysign", "math.Sqrt"], "_raw_llm_output": "math package usage, math.Atan2, math.Copysign, math.Sqrt"}
{"seed": "// NewCreateFeedBadRequest creates a CreateFeedBadRequest with default headers values\nfunc NewCreateFeedBadRequest() *CreateFeedBadRequest {\n\treturn &CreateFeedBadRequest{}\n}", "id": 2538, "concepts": ["struct definition", "struct initialization", "struct field access", "basic function definition"], "_raw_llm_output": "struct definition, struct initialization, struct field access, basic function definition"}
{"seed": "// generateIntDatum will generate a datum slice, every dimension is begin from 0, end with num - 1.\n// If dimension is x, num is y, the total number of datum is y^x. And This slice is sorted.\nfunc generateIntDatum(dimension, num int) ([]types.Datum, error) {\n\tlength := int(math.Pow(float64(num), float64(dimension)))\n\tret := make([]types.Datum, length)\n\tif dimension == 1 {\n\t\tfor i := 0; i < num; i++ {\n\t\t\tret[i] = types.NewIntDatum(int64(i))\n\t\t}\n\t} else {\n\t\tsc := &stmtctx.StatementContext{TimeZone: time.Local}\n\t\t// In this way, we can guarantee the datum is in order.\n\t\tfor i := 0; i < length; i++ {\n\t\t\tdata := make([]types.Datum, dimension)\n\t\t\tj := i\n\t\t\tfor k := 0; k < dimension; k++ {\n\t\t\t\tdata[dimension-k-1].SetInt64(int64(j % num))\n\t\t\t\tj = j / num\n\t\t\t}\n\t\t\tbytes, err := codec.EncodeKey(sc, nil, data...)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tret[i].SetBytes(bytes)\n\t\t}\n\t}\n\treturn ret, nil\n}", "id": 2542, "concepts": ["slice definition", "slice iteration (range loop)", "slice length", "slice append", "slice sorting", "slice iteration (range loop)", "slice iteration (range loop)", "slice iteration (range loop)", "slice iteration (range loop)", "slice iteration (range loop)", "slice iteration (range loop)", "slice iteration (range loop)", "slice iteration (range loop)", "slice iteration (range loop)", "slice iteration (range loop)", "slice iteration (range loop)", "slice iteration (range loop)", "slice iteration (range loop)", "slice iteration (range loop)", "slice iteration (range loop)", "slice iteration (range loop)", "slice iteration (range loop)", "slice iteration (range loop)", "slice iteration (range loop)", "slice iteration (range loop)", "slice iteration (range loop)", "slice iteration (range loop)", "slice iteration (range loop)", "slice iteration (range loop)", "slice iteration (range loop)", "slice iteration (range loop)", "slice iteration (range loop)", "slice iteration (range loop)", "slice iteration (range loop)", "slice iteration (range loop)", "slice iteration (range loop)", "slice iteration (range loop)", "slice iteration (range loop)", "slice iteration (range loop)", "slice iteration (range loop)", "slice iteration (range loop)", "slice iteration (range loop)", "slice iteration (range loop)", "slice iteration (range loop)", "slice iteration ("], "_raw_llm_output": "slice definition, slice iteration (range loop), slice length, slice append, slice sorting, slice iteration (range loop), slice iteration (range loop), slice iteration (range loop), slice iteration (range loop), slice iteration (range loop), slice iteration (range loop), slice iteration (range loop), slice iteration (range loop), slice iteration (range loop), slice iteration (range loop), slice iteration (range loop), slice iteration (range loop), slice iteration (range loop), slice iteration (range loop), slice iteration (range loop), slice iteration (range loop), slice iteration (range loop), slice iteration (range loop), slice iteration (range loop), slice iteration (range loop), slice iteration (range loop), slice iteration (range loop), slice iteration (range loop), slice iteration (range loop), slice iteration (range loop), slice iteration (range loop), slice iteration (range loop), slice iteration (range loop), slice iteration (range loop), slice iteration (range loop), slice iteration (range loop), slice iteration (range loop), slice iteration (range loop), slice iteration (range loop), slice iteration (range loop), slice iteration (range loop), slice iteration (range loop), slice iteration (range loop), slice iteration (range loop), slice iteration ("}
{"seed": "// NewColumnFamilyMetricsTotalDiskSpaceUsedByNameGetParams creates a new ColumnFamilyMetricsTotalDiskSpaceUsedByNameGetParams object,\n// with the default timeout for this client.\n//\n// Default values are not hydrated, since defaults are normally applied by the API server side.\n//\n// To enforce default values in parameter, use SetDefaults or WithDefaults.\nfunc NewColumnFamilyMetricsTotalDiskSpaceUsedByNameGetParams() *ColumnFamilyMetricsTotalDiskSpaceUsedByNameGetParams {\n\treturn &ColumnFamilyMetricsTotalDiskSpaceUsedByNameGetParams{\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 2543, "concepts": ["struct definition", "default values", "method definition", "timeout", "method chaining"], "_raw_llm_output": "struct definition, default values, method definition, timeout, method chaining"}
{"seed": "// mergeSequences recursively merges orig and fixed.\n// Items which exist in orig but not fixed are excluded.\n// Items which exist in fixed but not orig are included.\n// If items exist in both orig and fixed then the item from fixed is used unless both items are complex\n// (maps or sequences), in which case they are merged recursively.\nfunc mergeSequences(sequenceKey string, orig, fixed *goyaml.Node) *goyaml.Node {\n\tmerged := shallowCopyNode(orig)\n\torigContent := orig.Content\n\tfixedContent := fixed.Content\n\n\t// Drop items from original if they are not in fixed\n\tfor _, origItem := range origContent {\n\t\tif isItemInSequence(sequenceKey, origItem, fixed) {\n\t\t\tmerged.Content = append(merged.Content, origItem)\n\t\t}\n\t}\n\n\t// Update or add items from the fixed yaml which are not in the original\n\tfor _, fixedItem := range fixedContent {\n\t\tif mergedItemIndex := findItemInSequence(sequenceKey, fixedItem, merged); mergedItemIndex == -1 {\n\t\t\t// Add item\n\t\t\tmerged.Content = append(merged.Content, fixedItem)\n\t\t} else {\n\t\t\t// Update item\n\t\t\tmergedItem := merged.Content[mergedItemIndex]\n\t\t\tswitch {\n\t\t\tcase fixedItem.Kind != mergedItem.Kind:\n\t\t\t\tmerged.Content[mergedItemIndex] = fixedItem\n\t\t\tcase fixedItem.Kind == goyaml.MappingNode:\n\t\t\t\tmerged.Content[mergedItemIndex] = mergeMaps(mergedItem, fixedItem)\n\t\t\tcase fixedItem.Kind == goyaml.SequenceNode:\n\t\t\t\tmerged.Content[mergedItemIndex] = mergeSequences(sequenceKey, mergedItem, fixedItem)\n\t\t\t}\n\t\t}\n\t}\n\treturn merged\n}", "id": 2556, "concepts": ["recursion", "maps", "slices", "sequences", "map merging", "sequence merging", "yaml parsing"], "_raw_llm_output": "recursion, maps, slices, sequences, map merging, sequence merging, yaml parsing"}
{"seed": "// GetOwnerReferencesForVolume returns a list contains single OwnerReference for the\n// given volume UID and name\nfunc GetOwnerReferencesForVolume(v *longhorn.Volume) []metav1.OwnerReference {\n\treturn []metav1.OwnerReference{\n\t\t{\n\t\t\tAPIVersion: longhorn.SchemeGroupVersion.String(),\n\t\t\tKind:       types.LonghornKindVolume,\n\t\t\tUID:        v.UID,\n\t\t\tName:       v.Name,\n\t\t},\n\t}\n}", "id": 2562, "concepts": ["struct", "interface", "string formatting"], "_raw_llm_output": "struct, interface, string formatting"}
{"seed": "// BuildVolumeApplyConfiguration constructs an declarative configuration of the BuildVolume type for use with\n// apply.\nfunc BuildVolume() *BuildVolumeApplyConfiguration {\n\treturn &BuildVolumeApplyConfiguration{}\n}", "id": 2565, "concepts": ["struct definition", "struct field definition", "struct field initialization", "struct field access"], "_raw_llm_output": "struct definition, struct field definition, struct field initialization, struct field access"}
{"seed": "// transformMessagePayloadToShiritoriviewsMessagePayloadView builds a value of\n// type *shiritoriviews.MessagePayloadView from a value of type *MessagePayload.\nfunc transformMessagePayloadToShiritoriviewsMessagePayloadView(v *MessagePayload) *shiritoriviews.MessagePayloadView {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tres := &shiritoriviews.MessagePayloadView{\n\t\tMessage: &v.Message,\n\t}\n\n\treturn res\n}", "id": 2569, "concepts": ["type conversion", "struct field access"], "_raw_llm_output": "type conversion, struct field access"}
{"seed": "// Iframe_ is a convenience wrapper for Iframe without the attrs argument.\nfunc Iframe_(children ...HTML) HTML {\n  return Iframe(nil, children...)\n}", "id": 2581, "concepts": ["HTML", "function definition", "function argument", "function return value"], "_raw_llm_output": "HTML, function definition, function argument, function return value"}
{"seed": "// GenerateMessageID generates an RFC 2822-compliant Message-ID based on the\n// informational draft \"Recommendations for generating Message IDs\", for lack\n// of a better authoritative source.\nfunc GenerateMessageID() string {\n\tvar (\n\t\tnow   bytes.Buffer\n\t\tnonce []byte = make([]byte, 8)\n\t)\n\tbinary.Write(&now, binary.BigEndian, time.Now().UnixNano())\n\trand.Read(nonce)\n\thostname, err := os.Hostname()\n\tif err != nil {\n\t\thostname = \"localhost\"\n\t}\n\treturn fmt.Sprintf(\"<%s.%s@%s>\",\n\t\tbase36.EncodeBytes(now.Bytes()),\n\t\tbase36.EncodeBytes(nonce),\n\t\thostname)\n}", "id": 2597, "concepts": ["time package usage", "string formatting", "random number generation", "os package usage", "base36 encoding"], "_raw_llm_output": "time package usage, string formatting, random number generation, os package usage, base36 encoding"}
{"seed": "// toMSTimestamp converts time.Time to millisecond timestamp.\nfunc toMSTimestamp(t time.Time) int64 {\n\treturn t.UnixNano() / 1e6\n}", "id": 2605, "concepts": ["time package usage", "time.Time type", "time.UnixNano function"], "_raw_llm_output": "time package usage, time.Time type, time.UnixNano function"}
{"seed": "// NewMachineClientSet returns a clientset that will respond with the provided objects.\n// It's backed by a very simple object tracker that processes creates, updates and deletions as-is,\n// without applying any validations and/or defaults. It shouldn't be considered a replacement\n// for a real clientset and is mostly useful in simple unit tests.\nfunc NewMachineClientSet(objects ...runtime.Object) (*fakeuntyped.Clientset, *FakeObjectTracker) {\n\tvar scheme = runtime.NewScheme()\n\tvar codecs = serializer.NewCodecFactory(scheme)\n\n\tmetav1.AddToGroupVersion(scheme, schema.GroupVersion{Version: \"v1\"})\n\t_ = fakeuntyped.AddToScheme(scheme)\n\n\to := &FakeObjectTracker{\n\t\tFakeWatcher: watch.NewFake(),\n\t\tdelegatee:   k8stesting.NewObjectTracker(scheme, codecs.UniversalDecoder()),\n\t}\n\n\tfor _, obj := range objects {\n\t\tif err := o.Add(obj); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\n\tcs := &fakeuntyped.Clientset{}\n\tcs.Fake.AddReactor(\"*\", \"*\", k8stesting.ObjectReaction(o))\n\tcs.Fake.AddWatchReactor(\"*\", o.watchReactionFunc)\n\n\treturn cs, o\n}", "id": 2609, "concepts": ["fake clientset", "fake object tracker", "fake watcher", "fake object reaction"], "_raw_llm_output": "fake clientset, fake object tracker, fake watcher, fake object reaction"}
{"seed": "// getPreviousSnapshot ... gets the name of the config snapshot bucket object\n// created prior to the lastExecution time\n// Assumes snapshots are taken every three hours - gets snapshot older than\n// lastExecution time but less than three hours before lastExecution time\nfunc getPreviousSnapshot(\n\titems []*configservice.ConfigurationItem,\n\tt time.Time,\n\tbucket, region string,\n\tsvc s3iface.S3API) (*s3.Object, string, error) {\n\t// Get time from three hours before change...since snapshots are taken every\n\t// three hours, this will ensure we are looking in the correct folder by date\n\tprevTime := t.Add(time.Hour * time.Duration(-snapshotFrequency))\n\tyear, month, day := prevTime.Date()\n\taccount := aws.StringValue(items[0].AccountId)\n\tprefix := strings.Join([]string{\n\t\t\"awsconfig\",\n\t\t\"AWSLogs\",\n\t\taccount,\n\t\t\"Config\",\n\t\tregion,\n\t\tstrconv.Itoa(year),\n\t\tstrconv.Itoa(int(month)),\n\t\tstrconv.Itoa(day),\n\t\t\"ConfigSnapshot\",\n\t}, \"/\")\n\tinput := &s3.ListObjectsInput{\n\t\tBucket: aws.String(bucket),\n\t\tPrefix: aws.String(prefix),\n\t}\n\n\tresults, err := svc.ListObjects(input)\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\n\tfor _, o := range results.Contents {\n\t\tm := aws.TimeValue(o.LastModified)\n\t\tif m.After(prevTime) && m.Before(t) {\n\t\t\treturn getSnapshot(svc, bucket, o)\n\t\t}\n\t}\n\n\treturn nil, \"\", errors.New(\"snapshot not found\")\n}", "id": 2610, "concepts": ["string manipulation", "time handling", "time formatting", "date handling", "string conversion", "time comparison", "time arithmetic", "S3 API usage", "error handling (errors.New)", "concurrency (goroutines)", "standard library usage"], "_raw_llm_output": "string manipulation, time handling, time formatting, date handling, string conversion, time comparison, time arithmetic, S3 API usage, error handling (errors.New), concurrency (goroutines), standard library usage"}
{"seed": "// WithTset sets the settling period for the ADC.\nfunc WithTset(tset time.Duration) Option {\n\treturn func(a *ADC0832) {\n\t\ta.tset = tset\n\t}\n}", "id": 2612, "concepts": ["function definition", "function composition", "function options", "function parameters"], "_raw_llm_output": "function definition, function composition, function options, function parameters"}
{"seed": "// NewHyperflexMapClusterIdToProtectionInfoAllOfWithDefaults instantiates a new HyperflexMapClusterIdToProtectionInfoAllOf object\n// This constructor will only assign default values to properties that have it defined,\n// but it doesn't guarantee that properties required by API are set\nfunc NewHyperflexMapClusterIdToProtectionInfoAllOfWithDefaults() *HyperflexMapClusterIdToProtectionInfoAllOf {\n\tthis := HyperflexMapClusterIdToProtectionInfoAllOf{}\n\tvar classId string = \"hyperflex.MapClusterIdToProtectionInfo\"\n\tthis.ClassId = classId\n\tvar objectType string = \"hyperflex.MapClusterIdToProtectionInfo\"\n\tthis.ObjectType = objectType\n\treturn &this\n}", "id": 2617, "concepts": ["struct definition", "struct initialization", "struct field initialization"], "_raw_llm_output": "struct definition, struct initialization, struct field initialization"}
{"seed": "// setCondition updates the caffe2job to include the provided condition.\n// If the condition that we are about to add already exists\n// and has the same status and reason then we are not going to update.\nfunc setCondition(status *api.Caffe2JobStatus, condition api.Caffe2JobCondition) {\n\tcurrentCond := getCondition(*status, condition.Type)\n\n\t// Do nothing if condition doesn't change\n\tif currentCond != nil && currentCond.Status == condition.Status && currentCond.Reason == condition.Reason {\n\t\treturn\n\t}\n\n\t// Do not update lastTransitionTime if the status of the condition doesn't change.\n\tif currentCond != nil && currentCond.Status == condition.Status {\n\t\tcondition.LastTransitionTime = currentCond.LastTransitionTime\n\t}\n\n\t// Append the updated condition to the\n\tnewConditions := filterOutCondition(status.Conditions, condition.Type)\n\tstatus.Conditions = append(newConditions, condition)\n}", "id": 2619, "concepts": ["slice iteration (range loop)", "slice manipulation", "struct field access", "struct field assignment"], "_raw_llm_output": "slice iteration (range loop), slice manipulation, struct field access, struct field assignment"}
{"seed": "// FloatToString creates a binding that connects a Float data item to a String.\n// Changes to the Float will be pushed to the String and setting the string will parse and set the\n// Float if the parse was successful.\n//\n// Since: 2.0\nfunc FloatToString(v Float) String {\n\tstr := &stringFromFloat{from: v}\n\tv.AddListener(str)\n\treturn str\n}", "id": 2621, "concepts": ["binding", "listener", "data item", "string", "float"], "_raw_llm_output": "binding, listener, data item, string, float"}
{"seed": "// rename tries to os.Rename, but fall backs to copying from src\n// to dest and unlink the source if os.Rename fails.\n//\n// This function was copied from statik and is used under the terms of the\n// Apache license:\n//\n// Copyright 2014 Google Inc. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nfunc rename(debug *log.Logger, force bool, src, dest string) error {\n\t// Try to rename generated source.\n\tif err := os.Rename(src, dest); err == nil {\n\t\treturn nil\n\t}\n\t// If the rename failed (might do so due to temporary file residing on a\n\t// different device), try to copy byte by byte.\n\t/* #nosec */\n\trc, err := os.Open(src)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer func() {\n\t\terr = rc.Close()\n\t\tif err != nil {\n\t\t\tdebug.Printf(\"Error closing %q: %q\", src, err)\n\t\t}\n\t\terr = os.Remove(src)\n\t\tif err != nil {\n\t\t\tdebug.Printf(\"Error removing src %q: %q\", src, err)\n\t\t}\n\t}()\n\n\tif _, err = os.Stat(dest); !os.IsNotExist(err) {\n\t\tif force {\n\t\t\tif err = os.Remove(dest); err != nil {\n\t\t\t\treturn fmt.Errorf(\"file %q could not be deleted\", dest)\n\t\t\t}\n\t\t} else {\n\t\t\treturn fmt.Errorf(\"file %q already exists; use -f to overwrite\", dest)\n\t\t}\n\t}\n\n\twc, err := os.Create(dest)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer wc.Close()\n\n\tif _, err = io.Copy(wc, rc); err != nil {\n\t\t// Delete remains of failed copy attempt.\n\t\terr = os.Remove(dest)\n\t\tif err != nil {\n\t\t\tdebug.Printf(\"Error removing failed copy attempt: %q\", err)\n\t\t}\n\t}\n\treturn err\n}", "id": 2629, "concepts": ["file handling", "io.Copy", "os.Rename", "os.Create", "os.Open", "os.Stat", "os.Remove", "os.IsNotExist"], "_raw_llm_output": "file handling, io.Copy, os.Rename, os.Create, os.Open, os.Stat, os.Remove, os.IsNotExist"}
{"seed": "// NewGetMachineRolesListAllSpacesParamsWithContext creates a new GetMachineRolesListAllSpacesParams object\n// with the default values initialized, and the ability to set a context for a request\nfunc NewGetMachineRolesListAllSpacesParamsWithContext(ctx context.Context) *GetMachineRolesListAllSpacesParams {\n\tvar ()\n\treturn &GetMachineRolesListAllSpacesParams{\n\n\t\tContext: ctx,\n\t}\n}", "id": 2637, "concepts": ["context package usage", "function definition", "function return"], "_raw_llm_output": "context package usage, function definition, function return"}
{"seed": "// dollars converts an int64 price in cents into a human readable dollar\n// string.\n//\n// | Input     | Output          |\n// |-----------------------------|\n// | 130000000 | \"$1,300,000.00\" |\n// | 13000000  | \"$130,000.00\"   |\n// | 130000    | \"$1,300.00\"     |\n// | 13000     | \"$130.00\"       |\n// | 78        | \"$0.78\"         |\n// | 9         | \"$0.09\"         |\n// | 0         | \"$0.00\"         |\n// | -9        | \"-$0.09\"        |\n// | -78       | \"-$0.78\"        |\n// | -13000000 | \"-$130,000.00\"  |\nfunc dollars(cents int64) string {\n\t// Get the value in dollars.\n\tdollars := float64(cents) / 100\n\n\t// Initialize the buffer to store the string result.\n\tvar buf bytes.Buffer\n\n\t// Check for a negative value.\n\tif dollars < 0 {\n\t\tbuf.WriteString(\"-\")\n\t\t// Convert the negative value to a positive value.\n\t\t// The code below can only handle positive values.\n\t\tdollars = 0 - dollars\n\t}\n\tbuf.WriteString(\"$\")\n\n\t// Convert the dollar value into a string and split it into a\n\t// integer and decimal. This is done so that commas can be added\n\t// to the integer.\n\tvar (\n\t\tf       = strconv.FormatFloat(dollars, 'f', -1, 64)\n\t\ts       = strings.Split(f, \".\")\n\t\tinteger = s[0]\n\n\t\t// The value may or may not have a decimal. Default to 0.\n\t\tdecimal = \".00\"\n\t)\n\tif len(s) > 1 {\n\t\t// The value includes a decimal. Overwrite the default.\n\t\tdecimal = \".\" + s[1]\n\t}\n\n\t// Write the integer to the buffer one character at a time. Commas\n\t// are inserted in their appropriate places.\n\t//\n\t// Examples\n\t// \"100000\" to \"100,000\"\n\t// \"1000000\" to \"1,000,000\"\n\tfor i, c := range integer {\n\t\t// A comma should be inserted if the character index is divisible\n\t\t// by 3 when counting from the right side of the string.\n\t\tdivByThree := (len(integer)-i)%3 == 0\n\n\t\t// A comma should never be inserted for the first character.\n\t\t// Ex: \"100000\" should not be \",100,000\"\n\t\tif divByThree && i > 0 {\n\t\t\tbuf.WriteString(\",\")\n\t\t}\n\n\t\t// Write the character to the buffer.\n\t\tbuf.WriteRune(c)\n\t}\n\n\t// Write the decimal to the buffer.\n\tbuf.WriteString(decimal)\n\n\treturn buf.String()\n}", "id": 2639, "concepts": ["string formatting", "string manipulation", "string concatenation", "string conversion", "string iteration", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation"], "_raw_llm_output": "string formatting, string manipulation, string concatenation, string conversion, string iteration, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation"}
{"seed": "// Base_ is a convenience wrapper for Base without the attrs argument.\nfunc Base_() HTML {\n  return Base(nil)\n}", "id": 2641, "concepts": ["function definition", "function call", "function return value", "function argument"], "_raw_llm_output": "function definition, function call, function return value, function argument"}
{"seed": "// \u30af\u30ed\u30fc\u30b8\u30e3(\u95a2\u6570\u9589\u65b9): \u5916\u5074\u306e\u5909\u6570\u3092\u8a18\u61b6\u3057\u305f\u95a2\u6570\n// \u3053\u306e\u95a2\u6570\u306e\u5834\u5408, pi\u3092\u8a18\u61b6\nfunc circleArea(pi float64) func(radius float64) float64 {\n\treturn func(radius float64) float64 {\n\t\treturn pi * radius * radius\n\t}\n}", "id": 2655, "concepts": ["closure", "function definition", "function return"], "_raw_llm_output": "closure, function definition, function return"}
{"seed": "// ParseSourceRanges validates the sourceRanges string provided by the user.\n// Expects valid IPv4/IPv6 CIDR blocks delimited by a comma. i.e. 10.16.16.0/24, 203.19.42.0/25, 2001:db8:fd00:1000:dead:beef:cafe:2/64\nfunc ParseSourceRanges(sourceRanges string) ([]*net.IPNet, error) {\n\tvar sourceIPNetRanges []*net.IPNet\n\tfor _, sourceRange := range strings.Split(sourceRanges, \",\") {\n\t\t_, ipNet, err := net.ParseCIDR(sourceRange)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tsourceIPNetRanges = append(sourceIPNetRanges, ipNet)\n\t}\n\treturn sourceIPNetRanges, nil\n}", "id": 2669, "concepts": ["net.ParseCIDR", "net.IPNet", "strings.Split", "error handling (errors.New)", "string manipulation", "basic function definition"], "_raw_llm_output": "net.ParseCIDR, net.IPNet, strings.Split, error handling (errors.New), string manipulation, basic function definition"}
{"seed": "// Crawl uses fetcher to recursively crawl\n// pages starting with url, to a maximum of depth.\n//\u9012\u5f52\u722c\u53d6\uff0c\u4e0eUrlstate\u4e00\u8d77\u4f7f\u7528\uff0c\u5185\u90e8\u4f7f\u7528sync.WaitGroup\u6765\u5b9e\u73b0\u591agoroutine\u7684\u7b49\u5f85\nfunc Crawl(url string, depth int, fetcher Fetcher, urlState UrlState) {\n\tif depth <= 0 {\n\t\treturn\n\t}\n\turlState.mutex.Lock()\n\tif urlState.filter[url]{\n\t\tdefer urlState.mutex.Unlock()\n\t\treturn \n\t}\n\t\n\turlState.filter[url] = true\n\n\turlState.mutex.Unlock()\n\tbody, urls, err := fetcher.Fetch(url)\n\tif err != nil {\n\t\turlState.mutex.Lock()\n\t\tfmt.Println(err)\n\t\tdelete(urlState.filter, url)\n\t\tdefer urlState.mutex.Unlock()\n\t\treturn\n\t}\n\tfmt.Printf(\"found: %s %q\\n\", url, body)\n\tvar wg sync.WaitGroup\n\tfor _, u := range urls {\n\t\twg.Add(1)\n\t\tgo func(u string){\n\t\t\tdefer wg.Done()\n\t\t\tCrawl(u, depth-1, fetcher, urlState)\n\t\t}(u)\n\t}\n\twg.Wait()\n\treturn\n}", "id": 2679, "concepts": ["concurrency", "sync.WaitGroup", "sync.Mutex", "sync.Once", "sync.Map", "sync.Pool", "sync.Cond", "sync.RWMutex", "sync.Once", "sync.WaitGroup", "sync.atomic", "sync.Pool", "sync.Map", "sync.Cond", "sync.RWMutex", "sync.Once", "sync.WaitGroup", "sync.atomic", "sync.Pool", "sync.Map", "sync.Cond", "sync.RWMutex", "sync.Once", "sync.WaitGroup", "sync.atomic", "sync.Pool", "sync.Map", "sync.Cond", "sync.RWMutex", "sync.Once", "sync.WaitGroup", "sync.atomic", "sync.Pool", "sync.Map", "sync.Cond", "sync.RWMutex", "sync.Once", "sync.WaitGroup", "sync.atomic", "sync.Pool", "sync.Map", "sync.Cond", "sync.RWMutex", "sync.Once", "sync.WaitGroup", "sync.atomic", "sync.Pool", "sync.Map", "sync.Cond", "sync.RWMutex", "sync.Once", "sync.WaitGroup", "sync.atomic", "sync.Pool", "sync.Map", "sync.Cond", "sync.RWMutex", "sync.Once", "sync.WaitGroup", "sync.atomic", ""], "_raw_llm_output": "concurrency, sync.WaitGroup, sync.Mutex, sync.Once, sync.Map, sync.Pool, sync.Cond, sync.RWMutex, sync.Once, sync.WaitGroup, sync.atomic, sync.Pool, sync.Map, sync.Cond, sync.RWMutex, sync.Once, sync.WaitGroup, sync.atomic, sync.Pool, sync.Map, sync.Cond, sync.RWMutex, sync.Once, sync.WaitGroup, sync.atomic, sync.Pool, sync.Map, sync.Cond, sync.RWMutex, sync.Once, sync.WaitGroup, sync.atomic, sync.Pool, sync.Map, sync.Cond, sync.RWMutex, sync.Once, sync.WaitGroup, sync.atomic, sync.Pool, sync.Map, sync.Cond, sync.RWMutex, sync.Once, sync.WaitGroup, sync.atomic, sync.Pool, sync.Map, sync.Cond, sync.RWMutex, sync.Once, sync.WaitGroup, sync.atomic, sync.Pool, sync.Map, sync.Cond, sync.RWMutex, sync.Once, sync.WaitGroup, sync.atomic,"}
{"seed": "// NewGetMarketsRegionIDHistoryParamsWithContext creates a new GetMarketsRegionIDHistoryParams object\n// with the default values initialized, and the ability to set a context for a request\nfunc NewGetMarketsRegionIDHistoryParamsWithContext(ctx context.Context) *GetMarketsRegionIDHistoryParams {\n\tvar (\n\t\tdatasourceDefault = string(\"tranquility\")\n\t)\n\treturn &GetMarketsRegionIDHistoryParams{\n\t\tDatasource: &datasourceDefault,\n\n\t\tContext: ctx,\n\t}\n}", "id": 2683, "concepts": ["context package usage", "struct initialization", "pointer receivers", "method receivers"], "_raw_llm_output": "context package usage, struct initialization, pointer receivers, method receivers"}
{"seed": "// NewPointerFromSignalArgument will return an unsafe pointer to the given\n// object. This is primarily used in conjunction with MethodBindPtrCall.\nfunc NewPointerFromSignalArgument(obj SignalArgument) Pointer {\n\treturn Pointer{base: unsafe.Pointer(obj.getBase())}\n}", "id": 2689, "concepts": ["unsafe package usage", "pointer manipulation"], "_raw_llm_output": "unsafe package usage, pointer manipulation"}
{"seed": "// scanETag determines if a syntactically valid ETag is present at s. If so,\n// the ETag and remaining text after consuming ETag is returned. Otherwise,\n// it returns \"\", \"\".\nfunc scanETag(s string) (etag string, remain string) {\n\tstart := 0\n\n\tif len(s) >= 2 && s[0] == 'W' && s[1] == '/' {\n\t\tstart = 2\n\t}\n\n\tif len(s[start:]) < 2 || s[start] != '\"' {\n\t\treturn \"\", \"\"\n\t}\n\n\t// ETag is either W/\"text\" or \"text\".\n\t// See RFC 7232 2.3.\n\tfor i := start + 1; i < len(s); i++ {\n\t\tc := s[i]\n\t\tswitch {\n\t\t// Character values allowed in ETags.\n\t\tcase c == 0x21 || c >= 0x23 && c <= 0x7E || c >= 0x80:\n\t\tcase c == '\"':\n\t\t\treturn s[:i+1], s[i+1:]\n\t\tdefault:\n\t\t\treturn \"\", \"\"\n\t\t}\n\t}\n\n\treturn \"\", \"\"\n}", "id": 2690, "concepts": ["string manipulation", "string iteration", "string comparison"], "_raw_llm_output": "string manipulation, string iteration, string comparison"}
{"seed": "// MustRandUint64 returns a new random uint64 or panics\nfunc MustRandUint64() uint64 {\n\tr, err := NewRandUint64()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn r\n}", "id": 2694, "concepts": ["panic", "error handling", "error wrapping", "random number generation"], "_raw_llm_output": "panic, error handling, error wrapping, random number generation"}
{"seed": "// ParseOrHashWorkerID tries to parse the string s as a canonical worker ID representation.\n// If it fails, it treats s as an unconstrained string and hashes it to a worker ID value.\n// In either case, it returns a WorkerID value.\nfunc ParseOrHashWorkerID(s string) WorkerID {\n\tid, err := ParseWorkerID(s)\n\tif err != nil {\n\t\treturn HashWorkerID(s)\n\t}\n\treturn id\n}", "id": 2695, "concepts": ["string manipulation", "error handling (idiomatic)", "integer hashing"], "_raw_llm_output": "string manipulation, error handling (idiomatic), integer hashing"}
{"seed": "// envWithoutExecutorConfig returns os.Environ without executor specific entries.\n// Marathon does not support custom executor env and all task env are passed\n// as executor env. This means environment are setup before executor startup.\nfunc envWithoutExecutorConfig() (env []string) {\n\tfor _, variable := range os.Environ() {\n\t\tif !strings.HasPrefix(variable, strings.ToUpper(EnvironmentPrefix)) {\n\t\t\tenv = append(env, variable)\n\t\t} else {\n\n\t\t}\n\t}\n\treturn env\n}", "id": 2707, "concepts": ["string manipulation", "os.Environ", "string prefix check"], "_raw_llm_output": "string manipulation, os.Environ, string prefix check"}
{"seed": "// NewSlopeOptions constructs SlopeOptions with default values.\nfunc NewSlopeOptions() *SlopeOptions {\n\topts := NewGeneralOptions()\n\talg := NewAlgorithmOptions()\n\treturn &SlopeOptions{\n\t\tPercent:          false,\n\t\tScale:            1.0,\n\t\tGeneralOptions:   *opts,\n\t\tAlgorithmOptions: *alg,\n\t}\n}", "id": 2715, "concepts": ["struct composition", "struct initialization", "pointer receivers", "method receivers", "method definition"], "_raw_llm_output": "struct composition, struct initialization, pointer receivers, method receivers, method definition"}
{"seed": "// NewMethodArgFromPointer will return a MethodArg from the\n// given unsafe pointer. This is primarily used in conjunction with MethodBindPtrCall.\nfunc NewMethodArgFromPointer(ptr Pointer) MethodArg {\n\n\treturn MethodArg{base: (*C.godot_method_arg)(ptr.getBase())}\n}", "id": 2720, "concepts": ["unsafe package usage", "method binding"], "_raw_llm_output": "unsafe package usage, method binding"}
{"seed": "// TimeoutHandler returns an http.Handler that runs h with a timeout\n// determined by timeoutFunc. The new http.Handler calls h.ServeHTTP to handle\n// each request, but if a call runs for longer than its time limit, the\n// handler responds with a 503 Service Unavailable error and the message\n// provided. (If msg is empty, a suitable default message with be sent.) After\n// the handler times out, writes by h to its http.ResponseWriter will return\n// http.ErrHandlerTimeout. If timeoutFunc returns a nil timeout channel, no\n// timeout will be enforced.\nfunc TimeoutHandler(h http.Handler, timeoutFunc func(*http.Request) (timeout <-chan time.Time, msg string)) http.Handler {\n\treturn &timeoutHandler{h, timeoutFunc}\n}", "id": 2736, "concepts": ["http.Handler", "http.ResponseWriter", "http.Request", "timeout", "channels", "anonymous function", "concurrency", "standard library usage"], "_raw_llm_output": "http.Handler, http.ResponseWriter, http.Request, timeout, channels, anonymous function, concurrency, standard library usage"}
{"seed": "// IsMap returns true if the given Value is a map.\nfunc IsMap(val Value) bool {\n\tr := reflect.Indirect(reflect.ValueOf(val))\n\treturn r.Kind() == reflect.Map\n}", "id": 2737, "concepts": ["reflect package usage"], "_raw_llm_output": "reflect package usage"}
{"seed": "// MakeURIParser returns a function that takes a string with `html` and returns a list of URIs that match a given regex pattern.\n// If the parsed URI is a relative URL, the `domain` URL is used to resolve it to an absolute path.\nfunc MakeURIParser(tag, element string, domain *url.URL, filterPattern string) func(html string) []*url.URL {\n\n\tmatchFilter := utils.MakeRegexMatcher(filterPattern)\n\n\treturn func(html string) []*url.URL {\n\n\t\tpaths := ParseHTMLElementValues(html, tag, element)\n\t\turls := []*url.URL{}\n\n\t\tvar uri *url.URL\n\t\tvar err error\n\n\t\tfor _, path := range paths {\n\t\t\turi, err = url.Parse(path)\n\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Invalid url path: %v\", path)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif !uri.IsAbs() {\n\t\t\t\turi = domain.ResolveReference(uri)\n\t\t\t}\n\n\t\t\tif matchFilter(uri.String()) {\n\t\t\t\turls = append(urls, uri)\n\t\t\t}\n\t\t}\n\n\t\treturn urls\n\t}\n}", "id": 2739, "concepts": ["url.Parse", "url.URL", "url.URL.ResolveReference", "url.URL.IsAbs", "url.URL.String", "string manipulation", "regex matching", "function composition", "function definition", "basic function definition"], "_raw_llm_output": "url.Parse, url.URL, url.URL.ResolveReference, url.URL.IsAbs, url.URL.String, string manipulation, regex matching, function composition, function definition, basic function definition"}
{"seed": "// ByUserID orders the results by the user_id field.\nfunc ByUserID(opts ...sql.OrderTermOption) OrderOption {\n\treturn sql.OrderByField(FieldUserID, opts...).ToFunc()\n}", "id": 2750, "concepts": ["sql.OrderTermOption", "sql.OrderByField", "sql.OrderOption", "sql.OrderTerm", "sql.OrderTermOptionFunc", "sql.OrderTermFunc", "sql.OrderTermOptionFunc", "sql.OrderTermFunc", "sql.OrderTermOptionFunc", "sql.OrderTermFunc", "sql.OrderTermOptionFunc", "sql.OrderTermFunc", "sql.OrderTermOptionFunc", "sql.OrderTermFunc", "sql.OrderTermOptionFunc", "sql.OrderTermFunc", "sql.OrderTermOptionFunc", "sql.OrderTermFunc", "sql.OrderTermOptionFunc", "sql.OrderTermFunc", "sql.OrderTermOptionFunc", "sql.OrderTermFunc", "sql.OrderTermOptionFunc", "sql.OrderTermFunc", "sql.OrderTermOptionFunc", "sql.OrderTermFunc", "sql.OrderTermOptionFunc", "sql.OrderTermFunc", "sql.OrderTermOptionFunc", "sql.OrderTermFunc", "sql.OrderTermOptionFunc", "sql.OrderTermFunc", "sql.OrderTermOptionFunc", "sql.OrderTermFunc", "sql.OrderTermOptionFunc", "sql.OrderTermFunc", "sql.OrderTermOptionFunc", "sql.OrderTermFunc", "sql.OrderTermOptionFunc", "sql.OrderTermFunc", ""], "_raw_llm_output": "sql.OrderTermOption, sql.OrderByField, sql.OrderOption, sql.OrderTerm, sql.OrderTermOptionFunc, sql.OrderTermFunc, sql.OrderTermOptionFunc, sql.OrderTermFunc, sql.OrderTermOptionFunc, sql.OrderTermFunc, sql.OrderTermOptionFunc, sql.OrderTermFunc, sql.OrderTermOptionFunc, sql.OrderTermFunc, sql.OrderTermOptionFunc, sql.OrderTermFunc, sql.OrderTermOptionFunc, sql.OrderTermFunc, sql.OrderTermOptionFunc, sql.OrderTermFunc, sql.OrderTermOptionFunc, sql.OrderTermFunc, sql.OrderTermOptionFunc, sql.OrderTermFunc, sql.OrderTermOptionFunc, sql.OrderTermFunc, sql.OrderTermOptionFunc, sql.OrderTermFunc, sql.OrderTermOptionFunc, sql.OrderTermFunc, sql.OrderTermOptionFunc, sql.OrderTermFunc, sql.OrderTermOptionFunc, sql.OrderTermFunc, sql.OrderTermOptionFunc, sql.OrderTermFunc, sql.OrderTermOptionFunc, sql.OrderTermFunc, sql.OrderTermOptionFunc, sql.OrderTermFunc,"}
{"seed": "// Open opens a connection to the database specified by the driver name and a\n// driver-specific data source name, and returns a new client attached to it.\n// Optional parameters can be added for configuring the client.\nfunc Open(driverName, dataSourceName string, options ...Option) (*Client, error) {\n\tswitch driverName {\n\tcase dialect.MySQL, dialect.Postgres, dialect.SQLite:\n\t\tdrv, err := sql.Open(driverName, dataSourceName)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn NewClient(append(options, Driver(drv))...), nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unsupported driver: %q\", driverName)\n\t}\n}", "id": 2753, "concepts": ["sql package usage", "sql.Open", "sql.DB", "sql.Rows", "sql.Result", "sql.Tx", "sql.Stmt", "sql.NullString", "sql.NullInt64", "sql.NullBool", "sql.NullFloat64", "sql.NullTime", "sql.Rows.Next", "sql.Rows.Scan", "sql.Rows.Err", "sql.Rows.Close", "sql.DB.Query", "sql.DB.Exec", "sql.DB.Begin", "sql.DB.Commit", "sql.DB.Rollback", "sql.DB.Close", "sql.Tx.Commit", "sql.Tx.Rollback", "sql.Tx.Close", "sql.Stmt.Close", "sql.NullString.Valid", "sql.NullInt64.Valid", "sql.NullBool.Valid", "sql.NullFloat64.Valid", "sql.NullTime.Valid", "sql.NullString.Scan", "sql.NullInt64.Scan", "sql.NullBool.Scan", "sql.NullFloat64.Scan", "sql.NullTime.Scan", "sql.NullString.Value", "sql.NullInt64.Value", "sql.NullBool.Value", "sql.NullFloat64.Value", "sql.NullTime"], "_raw_llm_output": "sql package usage, sql.Open, sql.DB, sql.Rows, sql.Result, sql.Tx, sql.Stmt, sql.NullString, sql.NullInt64, sql.NullBool, sql.NullFloat64, sql.NullTime, sql.Rows.Next, sql.Rows.Scan, sql.Rows.Err, sql.Rows.Close, sql.DB.Query, sql.DB.Exec, sql.DB.Begin, sql.DB.Commit, sql.DB.Rollback, sql.DB.Close, sql.Tx.Commit, sql.Tx.Rollback, sql.Tx.Close, sql.Stmt.Close, sql.NullString.Valid, sql.NullInt64.Valid, sql.NullBool.Valid, sql.NullFloat64.Valid, sql.NullTime.Valid, sql.NullString.Scan, sql.NullInt64.Scan, sql.NullBool.Scan, sql.NullFloat64.Scan, sql.NullTime.Scan, sql.NullString.Value, sql.NullInt64.Value, sql.NullBool.Value, sql.NullFloat64.Value, sql.NullTime"}
{"seed": "// Listing represents the HTML element 'listing'.\n// For more information visit https://www.w3schools.com/tags/tag_listing.asp.\nfunc Listing(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"listing\", Attributes: attrs, Children: children}\n}", "id": 2754, "concepts": ["HTML generation", "HTML element definition", "HTML attribute definition", "HTML tree generation"], "_raw_llm_output": "HTML generation, HTML element definition, HTML attribute definition, HTML tree generation"}
{"seed": "// Bgsound_ is a convenience wrapper for Bgsound without the attrs argument.\nfunc Bgsound_(children ...HTML) HTML {\n  return Bgsound(nil, children...)\n}", "id": 2769, "concepts": ["HTML", "HTML element definition", "HTML element attribute definition"], "_raw_llm_output": "HTML, HTML element definition, HTML element attribute definition"}
{"seed": "// CreateTestSqliteDB returns a TestSQLiteDB which can be used in tests\n// as a clean sqlite database. All migrations are ran on the db before.\n//\n// Callers should call close on the returned *TestSQLiteDB.\nfunc CreateTestSqliteDB(t *testing.T) *TestSQLiteDB {\n\tdir, err := ioutil.TempDir(\"\", \"accounts-sqlite\")\n\tif err != nil {\n\t\tt.Fatalf(\"sqlite test: %v\", err)\n\t}\n\n\tctx, cancelFunc := context.WithCancel(context.Background())\n\n\tdb, err := SQLiteConnection(log.NewNopLogger(), filepath.Join(dir, \"accounts.db\")).Connect(ctx)\n\tif err != nil {\n\t\tt.Fatalf(\"sqlite test: %v\", err)\n\t}\n\n\t// Don't allow idle connections so we can verify all are closed at the end of testing\n\tdb.SetMaxIdleConns(0)\n\n\treturn &TestSQLiteDB{DB: db, Dir: dir, shutdown: cancelFunc}\n}", "id": 2777, "concepts": ["sqlite", "context", "testing", "database connection", "database migration"], "_raw_llm_output": "sqlite, context, testing, database connection, database migration"}
{"seed": "// GetKubeClient is a convenience method for creating kubernetes config and client\n// for a given kubeconfig\nfunc GetKubeClient(kubeconfig string) (*kubernetes.Clientset, *restclient.Config, error) {\n\tconfig, err := clientcmd.BuildConfigFromFlags(\"\", kubeconfig)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"could not get kubernetes config from kubeconfig '%s': %v\", kubeconfig, err)\n\t}\n\n\tclientset, err := kubernetes.NewForConfig(config)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"could not get kubernetes client: %s\", err)\n\t}\n\treturn clientset, config, nil\n}", "id": 2779, "concepts": ["clientcmd package usage", "kubernetes.NewForConfig", "kubernetes.Clientset"], "_raw_llm_output": "clientcmd package usage, kubernetes.NewForConfig, kubernetes.Clientset"}
{"seed": "// SocialPayloadEQ applies the EQ predicate on the \"social_payload\" field.\nfunc SocialPayloadEQ(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldSocialPayload), v))\n\t})\n}", "id": 2781, "concepts": ["sql.Selector", "sql.EQ", "predicate.User"], "_raw_llm_output": "sql.Selector, sql.EQ, predicate.User"}
{"seed": "// Sub returns a new Subspace whose prefix is the encoding of the provided\n// element(s). If any of the elements are not a valid tuple.TupleElement, a\n// runtime panic will occur.\nfunc Sub(el ...tuple.TupleElement) Subspace {\n\treturn subspace{tuple.Tuple(el).Pack()}\n}", "id": 2788, "concepts": ["tuple.Tuple", "tuple.TupleElement", "runtime panic", "Subspace"], "_raw_llm_output": "tuple.Tuple, tuple.TupleElement, runtime panic, Subspace"}
{"seed": "/* \u83b7\u53d6\u6570\u636e\u5e93\u914d\u7f6e\u6587\u4ef6\n\u901a\u8fc7\u7ed9\u5b9a\u7684 key \u4ece sync.Map \u4e2d\u83b7\u53d6\u4e00\u4e2a\u6570\u636e\u5e93\u914d\u7f6e\u4fe1\u606f\nParams:\n    _dynamicKey: \u83b7\u53d6\u914d\u7f6e\u6587\u4ef6\u7684key\n        string-> 127.0.0.1:3306\nReturn:\n    *setting.DBConfig: \u6570\u636e\u5e93\u914d\u7f6e\u4fe1\u606f\n    bool: \u662f\u5426\u83b7\u53d6\u6210\u529f\n*/\nfunc GetDynamicConfig(_dynamicKey string) (*setting.DBConfig, bool) {\n\tdbConfigInterface, ok := dynamicConfigMap.Load(_dynamicKey)\n\tif !ok {\n\t\treturn nil, ok\n\t}\n\n\tdbConfig := dbConfigInterface.(interface{}).(*setting.DBConfig)\n\n\treturn dbConfig, ok\n}", "id": 2792, "concepts": ["sync.Map", "interface", "dynamic key"], "_raw_llm_output": "sync.Map, interface, dynamic key"}
{"seed": "// newFollowerCollection converts projected type FollowerCollection to service\n// type FollowerCollection.\nfunc newFollowerCollection(vres followingviews.FollowerCollectionView) FollowerCollection {\n\tres := make(FollowerCollection, len(vres))\n\tfor i, n := range vres {\n\t\tres[i] = newFollower(n)\n\t}\n\treturn res\n}", "id": 2801, "concepts": ["type conversion", "interface conversion", "type conversion", "type assertion"], "_raw_llm_output": "type conversion, interface conversion, type conversion, type assertion"}
{"seed": "// MixedStringEqualFold applies the EqualFold predicate on the \"mixed_string\" field.\nfunc MixedStringEqualFold(v string) predicate.User {\n\treturn predicate.User(sql.FieldEqualFold(FieldMixedString, v))\n}", "id": 2815, "concepts": ["predicate", "predicate definition", "predicate usage"], "_raw_llm_output": "predicate, predicate definition, predicate usage"}
{"seed": "// NewColumnFamilyMetricsTotalDiskSpaceUsedByNameGetParamsWithHTTPClient creates a new ColumnFamilyMetricsTotalDiskSpaceUsedByNameGetParams object\n// with the ability to set a custom HTTPClient for a request.\nfunc NewColumnFamilyMetricsTotalDiskSpaceUsedByNameGetParamsWithHTTPClient(client *http.Client) *ColumnFamilyMetricsTotalDiskSpaceUsedByNameGetParams {\n\treturn &ColumnFamilyMetricsTotalDiskSpaceUsedByNameGetParams{\n\t\tHTTPClient: client,\n\t}\n}", "id": 2820, "concepts": ["function definition", "function composition", "function composition with anonymous function", "function composition with named function", "function composition with anonymous function with named return value", "function composition with anonymous function with named return value and named function", "function composition with named function with named return value", "function composition with named function with named return value and named function", "function composition with named function with named return value and anonymous function", "function composition with named function with named return value and anonymous function with named return value", "function composition with named function with anonymous function with named return value", "function composition with named function with anonymous function with named return value and named function", "function composition with named function with anonymous function with named return value and anonymous function", "function composition with named function with anonymous function with named return value and anonymous function with named return value", "function composition with named function with anonymous function with anonymous function with named return value", "function composition with named function with anonymous function with anonymous function with named return value and named function", "function composition with named function with anonymous function with anonymous function with named return value and anonymous function", "function composition with named function with anonymous function with anonymous function with named return value and anonymous function with named return value", "function composition with named function with anonymous function with anonymous function with anonymous function with named return value", ""], "_raw_llm_output": "function definition, function composition, function composition with anonymous function, function composition with named function, function composition with anonymous function with named return value, function composition with anonymous function with named return value and named function, function composition with named function with named return value, function composition with named function with named return value and named function, function composition with named function with named return value and anonymous function, function composition with named function with named return value and anonymous function with named return value, function composition with named function with anonymous function with named return value, function composition with named function with anonymous function with named return value and named function, function composition with named function with anonymous function with named return value and anonymous function, function composition with named function with anonymous function with named return value and anonymous function with named return value, function composition with named function with anonymous function with anonymous function with named return value, function composition with named function with anonymous function with anonymous function with named return value and named function, function composition with named function with anonymous function with anonymous function with named return value and anonymous function, function composition with named function with anonymous function with anonymous function with named return value and anonymous function with named return value, function composition with named function with anonymous function with anonymous function with anonymous function with named return value,"}
{"seed": "// Action_Values returns all elements of the Action enum\nfunc Action_Values() []string {\n\treturn []string{\n\t\tActionAllow,\n\t\tActionBlock,\n\t\tActionAlert,\n\t}\n}", "id": 2823, "concepts": ["enum", "string concatenation"], "_raw_llm_output": "enum, string concatenation"}
{"seed": "// IsSendError returns whether the error is a SendError.\nfunc IsSendError(err error) bool {\n\t_, ok := err.(*SendError)\n\treturn ok\n}", "id": 2824, "concepts": ["error handling (type assertion)", "error handling (type switch)", "error handling (type assertion)", "error handling (type assertion)"], "_raw_llm_output": "error handling (type assertion), error handling (type switch), error handling (type assertion), error handling (type assertion)"}
{"seed": "// GetPhysical returns physical from an instant time with millisecond precision.\nfunc GetPhysical(t time.Time) int64 {\n\treturn t.UnixNano() / int64(time.Millisecond)\n}", "id": 2840, "concepts": ["time package usage", "time.Time", "time.UnixNano", "integer division"], "_raw_llm_output": "time package usage, time.Time, time.UnixNano, integer division"}
{"seed": "// NewDeleteRolesParamsWithHTTPClient creates a new DeleteRolesParams object\n// with the default values initialized, and the ability to set a custom HTTPClient for a request\nfunc NewDeleteRolesParamsWithHTTPClient(client *http.Client) *DeleteRolesParams {\n\tvar ()\n\treturn &DeleteRolesParams{\n\t\tHTTPClient: client,\n\t}\n}", "id": 2856, "concepts": ["http.Client", "function definition", "function parameter", "function return value"], "_raw_llm_output": "http.Client, function definition, function parameter, function return value"}
{"seed": "// SaveConfig stores the given configuration conf in the given\n// file using toml encoding.\n// If there is any encoding or IO error, SaveConfig() returns an error.\nfunc SaveConfig(file string, conf AppConfig) error {\n\tvar confBuf bytes.Buffer\n\n\te := toml.NewEncoder(&confBuf)\n\tif err := e.Encode(conf); err != nil {\n\t\treturn err\n\t}\n\treturn utils.WriteFile(file, confBuf.Bytes(), 0644)\n}", "id": 2860, "concepts": ["toml encoding", "file writing", "error handling", "io.Writer usage", "io.Reader usage", "io.Writer usage", "io.Reader usage", "io.Writer usage", "io.Reader usage", "io.Writer usage", "io.Reader usage", "io.Writer usage", "io.Reader usage", "io.Writer usage", "io.Reader usage", "io.Writer usage", "io.Reader usage", "io.Writer usage", "io.Reader usage", "io.Writer usage", "io.Reader usage", "io.Writer usage", "io.Reader usage", "io.Writer usage", "io.Reader usage", "io.Writer usage", "io.Reader usage", "io.Writer usage", "io.Reader usage", "io.Writer usage", "io.Reader usage", "io.Writer usage", "io.Reader usage", "io.Writer usage", "io.Reader usage", "io.Writer usage", "io.Reader usage", "io.Writer usage", "io.Reader usage", "io.Writer usage", "io.Reader usage", "io.Writer usage", "io.Reader usage", "io.Writer usage", "io.Reader usage", "io.Writer usage", "io.Reader usage", "io.Writer usage", "io.Reader usage", "io.Writer usage", "io.Reader usage", "io.Writer usage", "io"], "_raw_llm_output": "toml encoding, file writing, error handling, io.Writer usage, io.Reader usage, io.Writer usage, io.Reader usage, io.Writer usage, io.Reader usage, io.Writer usage, io.Reader usage, io.Writer usage, io.Reader usage, io.Writer usage, io.Reader usage, io.Writer usage, io.Reader usage, io.Writer usage, io.Reader usage, io.Writer usage, io.Reader usage, io.Writer usage, io.Reader usage, io.Writer usage, io.Reader usage, io.Writer usage, io.Reader usage, io.Writer usage, io.Reader usage, io.Writer usage, io.Reader usage, io.Writer usage, io.Reader usage, io.Writer usage, io.Reader usage, io.Writer usage, io.Reader usage, io.Writer usage, io.Reader usage, io.Writer usage, io.Reader usage, io.Writer usage, io.Reader usage, io.Writer usage, io.Reader usage, io.Writer usage, io.Reader usage, io.Writer usage, io.Reader usage, io.Writer usage, io.Reader usage, io.Writer usage, io"}
{"seed": "// PropValNum transforms a GetPropertyReply struct into an unsigned\n// integer. Useful when the property value is a single integer.\nfunc PropValNum(reply *xproto.GetPropertyReply, err error) (uint, error) {\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif reply.Format != 32 {\n\t\treturn 0, fmt.Errorf(\"PropValNum: Expected format 32 but got %d\",\n\t\t\treply.Format)\n\t}\n\treturn uint(xgb.Get32(reply.Value)), nil\n}", "id": 2878, "concepts": ["error handling (idiomatic if err != nil)", "xproto package usage", "integer conversion", "bitwise operations"], "_raw_llm_output": "error handling (idiomatic if err != nil), xproto package usage,\ninteger conversion, bitwise operations"}
{"seed": "// getDependencies populates dependencies recursively.\n//\n// srcDir is the root directory for all golang source code.\n// importPath is like github.com/google/btree. The getDependencies call will populate dependencies which btree package depends on.\n// dependencies will be a map from unquoted import path to a set of quoted dependencies.\nfunc getDependencies(srcDir, importPath string, dependencies map[string]map[string]bool, maxDepth int) error {\n\tif callerFunctionName(maxDepth) == callerFunctionName(0) {\n\t\treturn nil\n\t}\n\tif dependencies[importPath] != nil {\n\t\treturn nil\n\t}\n\tdependencies[importPath] = make(map[string]bool)\n\n\t// Stop if the directory doesn't exist.\n\t// It could be because it's an built-in package or the package hasn't been downloaded.\n\tdirectory := filepath.Join(srcDir, importPath)\n\tif _, err := os.Stat(directory); os.IsNotExist(err) {\n\t\treturn nil\n\t} else if err != nil {\n\t\treturn err\n\t}\n\n\tfiles, err := ioutil.ReadDir(directory)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tnext := make(map[string]bool)\n\tfor _, file := range files {\n\t\tif file.IsDir() || strings.HasPrefix(file.Name(), \".\") {\n\t\t\tcontinue\n\t\t}\n\t\tfilename := file.Name()\n\t\tif filepath.Ext(filename) == \".go\" {\n\t\t\tast, err := parser.ParseFile(token.NewFileSet(), filepath.Join(directory, filename), nil, parser.ImportsOnly)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tfor _, im := range ast.Imports {\n\t\t\t\tnextImportPath := im.Path.Value\n\t\t\t\tdependencies[importPath][nextImportPath] = true\n\n\t\t\t\tnextImportPathUnquoted, err := strconv.Unquote(nextImportPath)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogger.Println(err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tnext[nextImportPathUnquoted] = true\n\t\t\t}\n\t\t}\n\t}\n\n\tfor n := range next {\n\t\tif err := getDependencies(srcDir, n, dependencies, maxDepth); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}", "id": 2898, "concepts": ["file reading", "directory reading", "file parsing", "import path handling", "map iteration", "recursion", "string manipulation", "string conversion", "string comparison", "string formatting", "string concatenation", "string splitting", "string joining", "string trimming", "string length", "string index", "string substring", "string prefix", "string suffix", "string contains", "string replace", "string trim", "string to lower case", "string to upper case", "string to title case", "string to capitalize", "string to snake case", "string to camel case", "string to pascal case", "string to kebab case", "string to kebab case", "string to snake case", "string to camel case", "string to pascal case", "string to snake case", "string to camel case", "string to pascal case", "string to snake case", "string to camel case", "string to pascal case", "string to snake case", "string to camel case", "string to pascal case", "string to snake case", "string to camel case", "string to pascal case", "string to snake case", "string to camel case", "string to pascal case", "string to snake case", "string to camel case", "string to pascal case", "string to snake case", "string to camel case", "string to pascal case", "string to snake case", "string to camel case", ""], "_raw_llm_output": "file reading, directory reading, file parsing, import path handling, map iteration, recursion, string manipulation, string conversion, string comparison, string formatting, string concatenation, string splitting, string joining, string trimming, string length, string index, string substring, string prefix, string suffix, string contains, string replace, string trim, string to lower case, string to upper case, string to title case, string to capitalize, string to snake case, string to camel case, string to pascal case, string to kebab case, string to kebab case, string to snake case, string to camel case, string to pascal case, string to snake case, string to camel case, string to pascal case, string to snake case, string to camel case, string to pascal case, string to snake case, string to camel case, string to pascal case, string to snake case, string to camel case, string to pascal case, string to snake case, string to camel case, string to pascal case, string to snake case, string to camel case, string to pascal case, string to snake case, string to camel case, string to pascal case, string to snake case, string to camel case,"}
{"seed": "// NewGray16 returns a new Gray16 with the given bounds.\nfunc NewGray16(r image.Rectangle) *Gray16 {\n\tw, h := r.Dx(), r.Dy()\n\tpix := make([]uint16, w*h)\n\treturn &Gray16{\n\t\tPix:    pix,\n\t\tStride: w,\n\t\tRect:   r,\n\t}\n}", "id": 2908, "concepts": ["image package usage", "struct definition", "basic function definition"], "_raw_llm_output": "image package usage, struct definition, basic function definition"}
{"seed": "// SocialNameLT applies the LT predicate on the \"social_name\" field.\nfunc SocialNameLT(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.LT(s.C(FieldSocialName), v))\n\t})\n}", "id": 2918, "concepts": ["sql.Selector", "sql.LT", "sql.C", "predicate.User", "sql.Where"], "_raw_llm_output": "sql.Selector, sql.LT, sql.C, predicate.User, sql.Where"}
{"seed": "// Q represents the HTML element 'q'.\n// For more information visit https://www.w3schools.com/tags/tag_q.asp.\nfunc Q(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"q\", Attributes: attrs, Children: children}\n}", "id": 2920, "concepts": ["HTML generation", "HTML tree traversal", "HTML element definition"], "_raw_llm_output": "HTML generation, HTML tree traversal, HTML element definition"}
{"seed": "// GenerateTag uses the ID of an IGDB object type and the ID of an IGDB\n// object to generate a Tag addressed to that object. Negative ID values\n// are considered invalid.\nfunc GenerateTag(typeID tagType, objectID int) (Tag, error) {\n\tif typeID < 0 || objectID < 0 {\n\t\treturn 0, ErrNegativeID\n\t}\n\n\ttag := int(typeID) << 28\n\ttag |= objectID\n\n\treturn Tag(tag), nil\n}", "id": 2924, "concepts": ["bit shifting", "integer bitwise operations", "integer comparison", "error handling (idiomatic `if err != nil`", "`errors.Is`", "`errors.As`)"], "_raw_llm_output": "bit shifting, integer bitwise operations, integer comparison, error handling (idiomatic `if err != nil`, `errors.Is`, `errors.As`)"}
{"seed": "// ProfileHandler will pass the call from /debug/pprof/profile to pprof.\nfunc profile(c echo.Context) error {\n\tpprof.Profile(c.Response().Writer, c.Request())\n\treturn nil\n}", "id": 2927, "concepts": ["pprof package usage", "echo package usage"], "_raw_llm_output": "pprof package usage, echo package usage"}
{"seed": "// NewCancelWorkflowExecutionParamsWithHTTPClient creates a new CancelWorkflowExecutionParams object\n// with the default values initialized, and the ability to set a custom HTTPClient for a request\nfunc NewCancelWorkflowExecutionParamsWithHTTPClient(client *http.Client) *CancelWorkflowExecutionParams {\n\tvar ()\n\treturn &CancelWorkflowExecutionParams{\n\t\tHTTPClient: client,\n\t}\n}", "id": 2931, "concepts": ["HTTP client usage", "function definition", "function parameters", "struct definition"], "_raw_llm_output": "HTTP client usage, function definition, function parameters, struct definition"}
{"seed": "// castCVKRrange convert C vkrange_t to GO TVKRange.\nfunc castCVKRrange(vr C.vkrange_t) TVKRange {\n\treturn TVKRange{\n\t\tMin: uint64(vr.min),\n\t\tMax: uint64(vr.max),\n\t}\n}", "id": 2951, "concepts": ["C.vkrange_t", "GO TVKRange", "C.uint64_t", "uint64 conversion", "C.uint64_t", "uint64 conversion"], "_raw_llm_output": "C.vkrange_t, GO TVKRange, C.uint64_t, uint64 conversion, C.uint64_t, uint64 conversion"}
{"seed": "// ParseDeleteSecurityGroupResponse parses an HTTP response from a DeleteSecurityGroupWithResponse call\nfunc ParseDeleteSecurityGroupResponse(rsp *http.Response) (*DeleteSecurityGroupResponse, error) {\n\tbodyBytes, err := ioutil.ReadAll(rsp.Body)\n\tdefer rsp.Body.Close()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse := &DeleteSecurityGroupResponse{\n\t\tBody:         bodyBytes,\n\t\tHTTPResponse: rsp,\n\t}\n\n\tswitch {\n\tcase strings.Contains(rsp.Header.Get(\"Content-Type\"), \"json\") && rsp.StatusCode == 200:\n\t\tvar dest Operation\n\t\tif err := json.Unmarshal(bodyBytes, &dest); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresponse.JSON200 = &dest\n\n\t}\n\n\treturn response, nil\n}", "id": 2958, "concepts": ["HTTP response parsing", "JSON parsing", "error handling", "switch statement", "HTTP response status code handling", "JSON response handling"], "_raw_llm_output": "HTTP response parsing, JSON parsing, error handling, switch statement, HTTP response status code handling, JSON response handling"}
{"seed": "// New creates a new *Module with the given update count provider. By default,\n// the module will refresh the update counts every hour. The refresh interval\n// can be configured using `Every`.\nfunc New(provider Provider) *Module {\n\tm := &Module{\n\t\tprovider:  provider,\n\t\tscheduler: timing.NewScheduler(),\n\t}\n\n\tm.notifyFn, m.notifyCh = notifier.New()\n\tm.outputFunc.Set(func(info Info) bar.Output {\n\t\tif info.Updates == 1 {\n\t\t\treturn outputs.Text(\"1 update\")\n\t\t}\n\t\treturn outputs.Textf(\"%d updates\", info.Updates)\n\t})\n\n\tm.Every(time.Hour)\n\n\treturn m\n}", "id": 2961, "concepts": ["struct definition", "function definition", "method definition", "anonymous function", "interface definition", "standard library usage", "concurrency", "timing package usage", "scheduler usage", "channel usage", "mutex usage", "error handling"], "_raw_llm_output": "struct definition, function definition, method definition, anonymous function, interface definition, standard library usage, concurrency, timing package usage, scheduler usage, channel usage, mutex usage, error handling"}
{"seed": "// NewFetchIntegrationFormParamsWithContext creates a new FetchIntegrationFormParams object\n// with the ability to set a context for a request.\nfunc NewFetchIntegrationFormParamsWithContext(ctx context.Context) *FetchIntegrationFormParams {\n\treturn &FetchIntegrationFormParams{\n\t\tContext: ctx,\n\t}\n}", "id": 2963, "concepts": ["context package usage", "context.Context", "function composition"], "_raw_llm_output": "context package usage, context.Context, function composition"}
{"seed": "// GetRecentPostCodeNoLogin returns codes of recent posts (usually 12 posts) of\n// the given user name without login status.\nfunc GetRecentPostCodeNoLogin(username string) (codes []string, err error) {\n\tui, err := GetUserInfoNoLogin(username)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tfor _, node := range ui.EdgeOwnerToTimelineMedia.Edges {\n\t\tcodes = append(codes, node.Node.Shortcode)\n\t}\n\treturn\n}", "id": 2965, "concepts": ["network request", "JSON parsing", "error handling", "interface usage", "struct usage"], "_raw_llm_output": "network request, JSON parsing, error handling, interface usage, struct usage"}
{"seed": "// Samp_ is a convenience wrapper for Samp without the attrs argument.\nfunc Samp_(children ...HTML) HTML {\n  return Samp(nil, children...)\n}", "id": 2966, "concepts": ["function definition", "function argument handling", "function return value handling", "function argument type", "function return value type"], "_raw_llm_output": "function definition, function argument handling, function return value handling, function argument type, function return value type"}
{"seed": "// UpdatedAtLTE applies the LTE predicate on the \"updated_at\" field.\nfunc UpdatedAtLTE(v time.Time) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.LTE(s.C(FieldUpdatedAt), v))\n\t})\n}", "id": 2975, "concepts": ["sql.Selector", "sql.C", "sql.LTE", "predicate.User", "basic function definition"], "_raw_llm_output": "sql.Selector, sql.C, sql.LTE, predicate.User, basic function definition"}
{"seed": "// DateTimeGTE applies the GTE predicate on the \"dateTime\" field.\nfunc DateTimeGTE(v time.Time) predicate.Bulk {\n\treturn predicate.Bulk(func(s *sql.Selector) {\n\t\ts.Where(sql.GTE(s.C(FieldDateTime), v))\n\t})\n}", "id": 2982, "concepts": ["sql.Selector", "sql.GTE", "sql.C", "sql.Where", "sql.Bulk"], "_raw_llm_output": "sql.Selector, sql.GTE, sql.C, sql.Where, sql.Bulk"}
{"seed": "// IsStdin returns true if r is standard input.\nfunc IsStdin(r io.Reader) bool {\n\tif f, ok := r.(*os.File); ok {\n\t\treturn f.Fd() == uintptr(syscall.Stdin)\n\t}\n\treturn false\n}", "id": 2985, "concepts": ["os.File usage", "syscall package usage", "io.Reader interface"], "_raw_llm_output": "os.File usage, syscall package usage, io.Reader interface"}
{"seed": "// DefaultExprEqualFold applies the EqualFold predicate on the \"default_expr\" field.\nfunc DefaultExprEqualFold(v string) predicate.User {\n\treturn predicate.User(sql.FieldEqualFold(FieldDefaultExpr, v))\n}", "id": 2992, "concepts": ["sql.FieldEqualFold", "predicate.User", "struct composition"], "_raw_llm_output": "sql.FieldEqualFold, predicate.User, struct composition"}
{"seed": "// useCached checks if downloadTime plus maxAge is before/after the current time.\n// return true if the cached image should be used, false otherwise.\nfunc useCached(downloadTime time.Time, maxAge int) bool {\n\tfreshnessLifetime := int(time.Now().Sub(downloadTime).Seconds())\n\tif maxAge > 0 && freshnessLifetime < maxAge {\n\t\treturn true\n\t}\n\treturn false\n}", "id": 3012, "concepts": ["time handling (time.Now", "time.Sub)", "integer comparison"], "_raw_llm_output": "time handling (time.Now, time.Sub), integer comparison"}
{"seed": "// newEntry returns a PolicyEntry representing the specified parameters in\n// network byte-order.\nfunc newEntry(authType uint8, proxyPort uint16, flags policyEntryFlags) PolicyEntry {\n\treturn PolicyEntry{\n\t\tProxyPortNetwork: byteorder.HostToNetwork16(proxyPort),\n\t\tFlags:            flags,\n\t\tAuthType:         authType,\n\t}\n}", "id": 3014, "concepts": ["byte order conversion", "struct definition", "bitwise operations"], "_raw_llm_output": "byte order conversion, struct definition, bitwise operations"}
{"seed": "// IsMethodIdempotent reports whether the HTTP method is considered idempotent.\n// See https://datatracker.ietf.org/doc/html/rfc9110#section-9.2.2\nfunc IsMethodIdempotent(m string) bool {\n\tif IsMethodSafe(m) {\n\t\treturn true\n\t}\n\n\tswitch m {\n\tcase MethodPut, MethodDelete:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}", "id": 3026, "concepts": ["string comparison", "switch statement", "boolean logic"], "_raw_llm_output": "string comparison, switch statement, boolean logic"}
{"seed": "// pickActiveDatabase returns the database the current profile is logged into.\n//\n// If logged into multiple databases, returns an error unless one specified\n// explicitly via --db flag.\nfunc pickActiveDatabase(cf *CLIConf) (*tlsca.RouteToDatabase, error) {\n\tprofile, err := cf.ProfileStatus()\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\n\tactiveDatabases, err := profile.DatabasesForCluster(cf.SiteName)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\n\tif len(activeDatabases) == 0 {\n\t\treturn nil, trace.NotFound(\"Please login using 'tsh db login' first\")\n\t}\n\n\tname := cf.DatabaseService\n\tif name == \"\" {\n\t\tif len(activeDatabases) > 1 {\n\t\t\tvar services []string\n\t\t\tfor _, database := range activeDatabases {\n\t\t\t\tservices = append(services, database.ServiceName)\n\t\t\t}\n\t\t\treturn nil, trace.BadParameter(\"Multiple databases are available (%v), please specify one using CLI argument\",\n\t\t\t\tstrings.Join(services, \", \"))\n\t\t}\n\t\tname = activeDatabases[0].ServiceName\n\t}\n\tfor _, db := range activeDatabases {\n\t\tif db.ServiceName == name {\n\t\t\t// If database user or name were provided on the CLI,\n\t\t\t// override the default ones.\n\t\t\tif cf.DatabaseUser != \"\" {\n\t\t\t\tdb.Username = cf.DatabaseUser\n\t\t\t}\n\t\t\tif cf.DatabaseName != \"\" {\n\t\t\t\tdb.Database = cf.DatabaseName\n\t\t\t}\n\t\t\treturn &db, nil\n\t\t}\n\t}\n\treturn nil, trace.NotFound(\"Not logged into database %q\", name)\n}", "id": 3031, "concepts": ["slice iteration (range loop)", "map iteration (range loop)", "string formatting", "string manipulation", "error handling (errors.Is)", "standard library usage"], "_raw_llm_output": "slice iteration (range loop), map iteration (range loop), string formatting, string manipulation, error handling (errors.Is), standard library usage"}
{"seed": "// LatestHeroScoreIn applies the In predicate on the \"latest_hero_score\" field.\nfunc LatestHeroScoreIn(vs ...int) predicate.User {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.User(func(s *sql.Selector) {\n\t\t// if not arguments were provided, append the FALSE constants,\n\t\t// since we can't apply \"IN ()\". This will make this predicate falsy.\n\t\tif len(vs) == 0 {\n\t\t\ts.Where(sql.False())\n\t\t\treturn\n\t\t}\n\t\ts.Where(sql.In(s.C(FieldLatestHeroScore), v...))\n\t})\n}", "id": 3033, "concepts": ["sql.Selector", "sql.In", "sql.False", "sql.C", "sql.Where", "sql.In predicate", "sql.Selector predicate"], "_raw_llm_output": "sql.Selector, sql.In, sql.False, sql.C, sql.Where, sql.In predicate, sql.Selector predicate"}
{"seed": "// Ul represents the HTML element 'ul'.\n// For more information visit https://www.w3schools.com/tags/tag_ul.asp.\nfunc Ul(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"ul\", Attributes: attrs, Children: children}\n}", "id": 3042, "concepts": ["HTML generation", "HTML tree structure", "HTML element definition"], "_raw_llm_output": "HTML generation, HTML tree structure, HTML element definition"}
{"seed": "// GetOwnerReferencesForBackingImageDataSource returns OwnerReference for the given\n// backing image data source name and UID\nfunc GetOwnerReferencesForBackingImageDataSource(backingImageDataSource *longhorn.BackingImageDataSource) []metav1.OwnerReference {\n\tcontroller := true\n\tblockOwnerDeletion := true\n\treturn []metav1.OwnerReference{\n\t\t{\n\t\t\tAPIVersion:         longhorn.SchemeGroupVersion.String(),\n\t\t\tKind:               types.LonghornKindBackingImageDataSource,\n\t\t\tName:               backingImageDataSource.Name,\n\t\t\tUID:                backingImageDataSource.UID,\n\t\t\tController:         &controller,\n\t\t\tBlockOwnerDeletion: &blockOwnerDeletion,\n\t\t},\n\t}\n}", "id": 3044, "concepts": ["struct definition", "struct field access", "struct field assignment", "struct field initialization", "struct field pointer", "struct field pointer assignment", "struct field pointer initialization", "struct field pointer nil check", "struct field pointer nil check assignment", "struct field pointer nil check initialization", "struct field pointer nil check assignment", "struct field pointer nil check initialization", "struct field pointer nil check assignment", "struct field pointer nil check initialization", "struct field pointer nil check assignment", "struct field pointer nil check initialization", "struct field pointer nil check assignment", "struct field pointer nil check initialization", "struct field pointer nil check assignment", "struct field pointer nil check initialization", "struct field pointer nil check assignment", "struct field pointer nil check initialization", "struct field pointer nil check assignment", "struct field pointer nil check initialization", "struct field pointer nil check assignment", "struct field pointer nil check initialization", "struct field pointer nil check assignment", "struct field pointer nil check initialization", "struct field pointer nil check assignment", "struct field pointer nil check initialization", "struct field pointer nil check assignment", "struct field pointer nil check initialization", "struct field pointer nil check assignment", "struct field pointer nil check initialization", "struct field pointer nil check assignment", "struct field pointer nil check initialization", "struct field pointer nil check assignment", "struct field pointer nil check initialization", "struct field pointer nil check assignment", "struct field pointer"], "_raw_llm_output": "struct definition, struct field access, struct field assignment, struct field initialization, struct field pointer, struct field pointer assignment, struct field pointer initialization, struct field pointer nil check, struct field pointer nil check assignment, struct field pointer nil check initialization, struct field pointer nil check assignment, struct field pointer nil check initialization, struct field pointer nil check assignment, struct field pointer nil check initialization, struct field pointer nil check assignment, struct field pointer nil check initialization, struct field pointer nil check assignment, struct field pointer nil check initialization, struct field pointer nil check assignment, struct field pointer nil check initialization, struct field pointer nil check assignment, struct field pointer nil check initialization, struct field pointer nil check assignment, struct field pointer nil check initialization, struct field pointer nil check assignment, struct field pointer nil check initialization, struct field pointer nil check assignment, struct field pointer nil check initialization, struct field pointer nil check assignment, struct field pointer nil check initialization, struct field pointer nil check assignment, struct field pointer nil check initialization, struct field pointer nil check assignment, struct field pointer nil check initialization, struct field pointer nil check assignment, struct field pointer nil check initialization, struct field pointer nil check assignment, struct field pointer nil check initialization, struct field pointer nil check assignment, struct field pointer"}
{"seed": "/* Calculates the start of the given interval\n\tformula: (n+2^k-1) mod 2^m\n\texponent: The exponent k of the given formula\n\tmodExp: The exponent m of the given formula\n\tid: n in the given formula\n\tReturns the start of the interval\n*/\nfunc calcStart(exponent int, modExp int, id big.Int) big.Int {\n\tbase2 := big.NewInt(int64(2))\n\tk := big.NewInt(int64(exponent))\n\n\ttmp := big.NewInt(int64(0))\n\ttmp.Exp(base2, k, nil)\n\n\tsum := big.NewInt(int64(0))\n\tsum.Add(tmp, &id)\n\n\tmodExponent := big.NewInt(int64(modExp))\n\tmod := big.NewInt(int64(0))\n\tmod.Exp(base2, modExponent, nil)\n\n\tret := big.NewInt(int64(0))\n\n\tret.Mod(sum, mod)\n\n\treturn *ret\n}", "id": 3047, "concepts": ["big.Int", "big.NewInt", "big.Exp", "big.Mod", "big.Add"], "_raw_llm_output": "big.Int, big.NewInt, big.Exp, big.Mod, big.Add"}
{"seed": "/*\nGetDefaultFilePath creates a file path from a file name by prepending\nthe default test directory name and appending the default golden file\nsuffix.  If the passed name is \"foo.json\", the resulting file path\nwill be \"./testdata/foo.json.goldenfile\".\n*/\nfunc GetDefaultFilePath(name string) string {\n\treturn filepath.Join(DefaultTestDirectory, name+DefaultGoldenFileSuffix)\n}", "id": 3051, "concepts": ["filepath package usage", "string concatenation", "string manipulation"], "_raw_llm_output": "filepath package usage, string concatenation, string manipulation"}
{"seed": "// NewListAlertableEventTypeParams creates a new ListAlertableEventTypeParams object\n// with the default values initialized.\nfunc NewListAlertableEventTypeParams() *ListAlertableEventTypeParams {\n\tvar ()\n\treturn &ListAlertableEventTypeParams{\n\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 3064, "concepts": ["struct initialization", "struct field initialization", "struct field assignment"], "_raw_llm_output": "struct initialization, struct field initialization, struct field assignment"}
{"seed": "// newFollowerView projects result type Follower to projected type FollowerView\n// using the \"default\" view.\nfunc newFollowerView(res *Follower) *followingviews.FollowerView {\n\tvres := &followingviews.FollowerView{\n\t\tID:   &res.ID,\n\t\tName: &res.Name,\n\t}\n\tif res.Avatar != nil {\n\t\tvres.Avatar = transformAvatarToFollowingviewsAvatarView(res.Avatar)\n\t}\n\treturn vres\n}", "id": 3065, "concepts": ["type casting", "interface usage", "pointer handling", "type conversion"], "_raw_llm_output": "type casting, interface usage, pointer handling, type conversion"}
{"seed": "//\u6b63\u786e\u5904\u7406\u8fd4\u56denil\u7ed9\u63a5\u53e3\u7684\u65b9\u6cd5,\u8fd4\u56de\u65f6go\u5c31\u786e\u5b9a\u4e86\u63a5\u53e3\u662f\u4e0d\u662fnil\nfunc rightFunc() IPeople {\n\n\treturn nil\n}", "id": 3066, "concepts": ["interface", "nil interface", "interface conversion"], "_raw_llm_output": "interface, nil interface, interface conversion"}
{"seed": "// NewSparseAPICheck returns a new  SparseAPICheck.\nfunc NewSparseAPICheck() *SparseAPICheck {\n\treturn &SparseAPICheck{}\n}", "id": 3073, "concepts": ["struct definition", "struct field initialization"], "_raw_llm_output": "struct definition, struct field initialization"}
{"seed": "// SocialTypeHasSuffix applies the HasSuffix predicate on the \"social_type\" field.\nfunc SocialTypeHasSuffix(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.HasSuffix(s.C(FieldSocialType), v))\n\t})\n}", "id": 3075, "concepts": ["sql package usage", "sql.Selector", "sql.C", "sql.HasSuffix", "predicate.User"], "_raw_llm_output": "sql package usage, sql.Selector, sql.C, sql.HasSuffix, predicate.User"}
{"seed": "// IsZeroNumber will return true when type of the data is numeric and it's has 0 value\nfunc IsZeroNumber(data interface{}) bool {\n\tif data == nil {\n\t\treturn true\n\t}\n\n\tif value, ok := data.(float32); ok {\n\t\treturn value == 0\n\t}\n\tif value, ok := data.(float64); ok {\n\t\treturn value == 0\n\t}\n\n\tif value, ok := data.(int); ok {\n\t\treturn value == 0\n\t}\n\tif value, ok := data.(int8); ok {\n\t\treturn value == 0\n\t}\n\tif value, ok := data.(int16); ok {\n\t\treturn value == 0\n\t}\n\tif value, ok := data.(int32); ok {\n\t\treturn value == 0\n\t}\n\tif value, ok := data.(int64); ok {\n\t\treturn value == 0\n\t}\n\n\tif value, ok := data.(uint); ok {\n\t\treturn value == 0\n\t}\n\tif value, ok := data.(uint8); ok {\n\t\treturn value == 0\n\t}\n\tif value, ok := data.(uint16); ok {\n\t\treturn value == 0\n\t}\n\tif value, ok := data.(uint32); ok {\n\t\treturn value == 0\n\t}\n\tif value, ok := data.(uint64); ok {\n\t\treturn value == 0\n\t}\n\tif value, ok := data.(uintptr); ok {\n\t\treturn value == 0\n\t}\n\n\tif value, ok := data.(complex64); ok {\n\t\tvalue128 := complex128(value)\n\t\treturn math.Float64bits(real(value128)) == 0 && math.Float64bits(imag(value128)) == 0\n\t}\n\tif value, ok := data.(complex128); ok {\n\t\treturn math.Float64bits(real(value)) == 0 && math.Float64bits(imag(value)) == 0\n\t}\n\n\treturn false\n}", "id": 3077, "concepts": ["type assertion", "type switch", "type conversion", "type checking", "type casting", "type comparison", "type equality", "type identity", "type existence", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", "type existence check", ""], "_raw_llm_output": "type assertion, type switch, type conversion, type checking, type casting, type comparison, type equality, type identity, type existence, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check, type existence check,"}
{"seed": "// UserAsApplicationKeyResponseIncludedItem is a convenience function that returns User wrapped in ApplicationKeyResponseIncludedItem.\nfunc UserAsApplicationKeyResponseIncludedItem(v *User) ApplicationKeyResponseIncludedItem {\n\treturn ApplicationKeyResponseIncludedItem{User: v}\n}", "id": 3079, "concepts": ["struct definition", "anonymous function", "function definition"], "_raw_llm_output": "struct definition, anonymous function, function definition"}
{"seed": "// queueName returns a SQS queue name matching the given source instance.\nfunc queueName(src *v1alpha1.AWSS3Source) string {\n\treturn \"s3-events_\" + src.Spec.ARN.Resource\n}", "id": 3084, "concepts": ["string concatenation", "string formatting", "string manipulation"], "_raw_llm_output": "string concatenation, string formatting, string manipulation"}
{"seed": "// FloatHash CRCs a byte array and converts the CRC into a float64, for easier\n// datapoint usage.\nfunc FloatHash(data []byte) float64 {\n\treturn float64(crc.CRC(crc.InitialCRC, data))\n}", "id": 3091, "concepts": ["CRC", "float64 conversion", "byte array manipulation"], "_raw_llm_output": "CRC, float64 conversion, byte array manipulation"}
{"seed": "// WithUpgradeAnnotations is an Option that configures Upgrade annotations\n// to enable custom action.Upgrade fields to be set based on the value of\n// annotations found in the custom resource watched by this reconciler.\n// Duplicate annotation names will result in an error.\nfunc WithUpgradeAnnotations(as ...annotation.Upgrade) Option {\n\treturn func(r *Reconciler) error {\n\t\tr.annotSetupOnce.Do(r.setupAnnotationMaps)\n\n\t\tfor _, a := range as {\n\t\t\tname := a.Name()\n\t\t\tif _, ok := r.annotations[name]; ok {\n\t\t\t\treturn fmt.Errorf(\"annotation %q already exists\", name)\n\t\t\t}\n\n\t\t\tr.annotations[name] = struct{}{}\n\t\t\tr.upgradeAnnotations[name] = a\n\t\t}\n\t\treturn nil\n\t}\n}", "id": 3096, "concepts": ["struct field", "map", "standard library usage", "concurrency", "error handling"], "_raw_llm_output": "struct field, map, standard library usage, concurrency, error handling"}
{"seed": "// NewNiatelemetryNveVni instantiates a new NiatelemetryNveVni object\n// This constructor will assign default values to properties that have it defined,\n// and makes sure properties required by API are set, but the set of arguments\n// will change when the set of required properties is changed\nfunc NewNiatelemetryNveVni(classId string, objectType string) *NiatelemetryNveVni {\n\tthis := NiatelemetryNveVni{}\n\tthis.ClassId = classId\n\tthis.ObjectType = objectType\n\treturn &this\n}", "id": 3100, "concepts": ["constructor", "struct definition", "basic function definition", "pointer handling"], "_raw_llm_output": "constructor, struct definition, basic function definition, pointer handling"}
{"seed": "// WithIgnoreUndefined tells Parse to ignore undefined flags that it encounters\n// in config files. By default, if Parse encounters an undefined flag in a\n// config file, it will return an error. Note that this setting does not apply\n// to undefined flags passed as arguments.\nfunc WithIgnoreUndefined(ignore bool) Option {\n\treturn func(c *Context) {\n\t\tc.ignoreUndefined = ignore\n\t}\n}", "id": 3105, "concepts": ["struct field", "struct field initialization", "struct field access", "function definition", "function call", "function return", "function parameter", "function parameter initialization", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", "function parameter access", ""], "_raw_llm_output": "struct field, struct field initialization, struct field access, function definition, function call, function return, function parameter, function parameter initialization, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access, function parameter access,"}
{"seed": "// SameElements returns True if the two given string slices contain the same\n// elements, even in different order.\nfunc SameElements(a0, b0 []string) bool {\n  // shallow copy input arrays\n  a := append([]string(nil), a0...)\n  b := append([]string(nil), b0...)\n\n  if a == nil && b == nil {\n    return true\n  }\n  if a == nil || b == nil {\n    return false\n  }\n  if len(a) != len(b) {\n    return false\n  }\n\n  sort.Strings(a)\n  sort.Strings(b)\n  for i := range a {\n    if a[i] != b[i] {\n      return false\n    }\n  }\n  return true\n}", "id": 3107, "concepts": ["slice iteration (range loop)", "string manipulation", "sort.Strings", "slice comparison"], "_raw_llm_output": "slice iteration (range loop), string manipulation, sort.Strings, slice comparison"}
{"seed": "// Unmarshal a CBE document from a reader, creating an object of the same type as the template.\n// If template is nil, an interface type will be returned.\n// If opts is nil, default options will be used.\nfunc UnmarshalCBE(reader io.Reader, template interface{}, opts *options.CBEUnmarshalerOptions) (decoded interface{}, err error) {\n\treturn NewCBEUnmarshaler(opts).Unmarshal(reader, template)\n}", "id": 3108, "concepts": ["interface", "struct", "pointer", "method", "io.Reader", "io.Writer", "fmt.Sprintf", "io.Closer", "io.ReaderFrom", "io.WriterTo", "io.Seeker", "io.ReadSeeker", "io.ReadCloser", "io.WriteCloser", "io.ReadWriteCloser", "io.ReadWriteSeeker", "io.ReadWriteSeekerCloser", "io.ReadSeekerCloser", "io.ReadSeekerWriter", "io.ReadSeekerWriterCloser", "io.ReadSeekerWriterTo", "io.ReadSeekerWriterToCloser", "io.ReadSeekerWriterToCloser", "io.ReadSeekerWriterToCloser", "io.ReadSeekerWriterToCloser", "io.ReadSeekerWriterToCloser", "io.ReadSeekerWriterToCloser", "io.ReadSeekerWriterToCloser", "io.ReadSeekerWriterToCloser", "io.ReadSeekerWriterToCloser", "io.ReadSeekerWriterToCloser", "io.ReadSeekerWriterToCloser", "io.ReadSeekerWriterToCloser", "io.ReadSeekerWriterToCloser", "io.ReadSeekerWriterToCloser", "io.ReadSeekerWriterToCloser", "io.ReadSeekerWriterToCloser", "io.ReadSeekerWriterToCloser"], "_raw_llm_output": "interface, struct, pointer, method, io.Reader, io.Writer, fmt.Sprintf, io.Closer, io.ReaderFrom, io.WriterTo, io.Seeker, io.ReadSeeker, io.ReadCloser, io.WriteCloser, io.ReadWriteCloser, io.ReadWriteSeeker, io.ReadWriteSeekerCloser, io.ReadSeekerCloser, io.ReadSeekerWriter, io.ReadSeekerWriterCloser, io.ReadSeekerWriterTo, io.ReadSeekerWriterToCloser, io.ReadSeekerWriterToCloser, io.ReadSeekerWriterToCloser, io.ReadSeekerWriterToCloser, io.ReadSeekerWriterToCloser, io.ReadSeekerWriterToCloser, io.ReadSeekerWriterToCloser, io.ReadSeekerWriterToCloser, io.ReadSeekerWriterToCloser, io.ReadSeekerWriterToCloser, io.ReadSeekerWriterToCloser, io.ReadSeekerWriterToCloser, io.ReadSeekerWriterToCloser, io.ReadSeekerWriterToCloser, io.ReadSeekerWriterToCloser, io.ReadSeekerWriterToCloser, io.ReadSeekerWriterToCloser"}
{"seed": "// getValidUpgrades returns a slice containing the valid protocols\n// that a connection can upgrade to.\nfunc getValidUpgrades() []string {\n\tupgrades := make([]string, len(validUpgrades))\n\ti := 0\n\tfor u := range validUpgrades {\n\t\tupgrades[i] = u\n\t\ti++\n\t}\n\treturn upgrades\n}", "id": 3119, "concepts": ["map iteration (range loop)", "slice creation", "map iteration (range loop)"], "_raw_llm_output": "map iteration (range loop), slice creation, map iteration (range loop)"}
{"seed": "// HeaderTrustHandlerSigner returns a Signer that can be used to sign an\n// edge context HTTP header using TrustHeaderSignature.SignEdgeContextHeader.\nfunc HeaderTrustHandlerSigner(handler httpbp.TrustHeaderSignature, duration time.Duration) Signer {\n\treturn func(s string) (string, error) {\n\t\th := httpbp.EdgeContextHeaders{EdgeRequest: s}\n\t\treturn handler.SignEdgeContextHeader(h, duration)\n\t}\n}", "id": 3124, "concepts": ["httpbp package usage", "edge context headers", "edge context signing", "anonymous function", "function definition"], "_raw_llm_output": "httpbp package usage, edge context headers, edge context signing, anonymous function, function definition"}
{"seed": "// absoluteTimeIntervalSince1970() returns the number of seconds from\n// the Unix epoch (1970-01-01T00:00:00+00:00) to the Core Foundation\n// absolute reference date (2001-01-01T00:00:00+00:00). It should be\n// exactly 978307200.\nfunc absoluteTimeIntervalSince1970() int64 {\n\treturn int64(C.kCFAbsoluteTimeIntervalSince1970)\n}", "id": 3128, "concepts": ["CGO", "C.kCFAbsoluteTimeIntervalSince1970", "integer conversion"], "_raw_llm_output": "CGO, C.kCFAbsoluteTimeIntervalSince1970, integer conversion"}
{"seed": "// NewTSVReader returns a new TSVReader that begins to read lines from the\n// io.Reader passed as parameter. The channels returned by methods Lines and\n// Errors must be consumed afterwards.\nfunc NewTSVReader(r io.Reader) *TSVReader {\n\tret := &TSVReader{\n\t\treader:   csv.NewReader(r),\n\t\tlineChan: make(chan []string),\n\t\terrChan:  make(chan error),\n\t}\n\n\tret.reader.Comma = '\\t'\n\tgo ret.Read()\n\treturn ret\n}", "id": 3129, "concepts": ["io.Reader", "csv.NewReader", "goroutines", "channels", "error handling"], "_raw_llm_output": "io.Reader, csv.NewReader, goroutines, channels, error handling"}
{"seed": "// NewGetDeploymentTargetOperatingSystemNamesListAllParamsWithContext creates a new GetDeploymentTargetOperatingSystemNamesListAllParams object\n// with the default values initialized, and the ability to set a context for a request\nfunc NewGetDeploymentTargetOperatingSystemNamesListAllParamsWithContext(ctx context.Context) *GetDeploymentTargetOperatingSystemNamesListAllParams {\n\n\treturn &GetDeploymentTargetOperatingSystemNamesListAllParams{\n\n\t\tContext: ctx,\n\t}\n}", "id": 3150, "concepts": ["context package usage", "function definition", "basic function parameters"], "_raw_llm_output": "context package usage, function definition, basic function parameters"}
{"seed": "// CreateMetaPipelineCRDs creates the Tekton CRDs needed to execute the meta pipeline.\n// The meta pipeline is responsible to checkout the source repository at the right revision, allows Jenkins-X Apps\n// to modify the pipeline (via modifying the configuration on the file system) and finally triggering the actual\n// pipeline build.\n// An error is returned in case the creation of the Tekton CRDs fails.\nfunc CreateMetaPipelineCRDs(params CRDCreationParameters) (*tekton.CRDWrapper, error) {\n\tparsedPipeline, err := createPipeline(params)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tlabels, err := buildLabels(params)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpipeline, tasks, structure, err := parsedPipeline.GenerateCRDs(params.PipelineName, params.BuildNumber, params.ResourceName, params.Namespace, params.PodTemplates, params.VersionsDir, nil, params.SourceDir, labels, params.DefaultImage)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trevision := params.PullRef.BaseSha\n\tif revision == \"\" {\n\t\trevision = params.PullRef.BaseBranch\n\t}\n\tresources := []*pipelineapi.PipelineResource{tekton.GenerateSourceRepoResource(params.ResourceName, &params.GitInfo, revision)}\n\trun := tekton.CreatePipelineRun(resources, pipeline.Name, pipeline.APIVersion, labels, params.ServiceAccount, nil, nil, nil)\n\n\ttektonCRDs, err := tekton.NewCRDWrapper(pipeline, tasks, resources, structure, run)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn tektonCRDs, nil\n}", "id": 3158, "concepts": ["error handling (idiomatic)", "struct definition", "map", "function definition", "function call", "string formatting", "string manipulation", "string comparison", "string concatenation", "string length", "string index", "string slice", "string rune handling", "string conversion", "error handling (errors.New)", "error handling (errors.Is)", "error handling (errors.As)", "error handling (panic)", "error handling (recover)", "error handling (defer)", "error handling (if err != nil)", "error handling (if err != nil)", "error handling (if err != nil)", "error handling (if err != nil)", "error handling (if err != nil)", "error handling (if err != nil)", "error handling (if err != nil)", "error handling (if err != nil)", "error handling (if err != nil)", "error handling (if err != nil)", "error handling (if err != nil)", "error handling (if err != nil)", "error handling (if err != nil)", "error handling (if err != nil)", "error handling (if err != nil)", "error handling (if err != nil)", "error handling (if err != nil)", "error handling (if err != nil)", "error handling (if err != nil)", "error handling (if err != nil)", "error handling (if err != nil)", "error handling ("], "_raw_llm_output": "error handling (idiomatic), struct definition, map, function definition, function call, string formatting, string manipulation, string comparison, string concatenation, string length, string index, string slice, string rune handling, string conversion, error handling (errors.New), error handling (errors.Is), error handling (errors.As), error handling (panic), error handling (recover), error handling (defer), error handling (if err != nil), error handling (if err != nil), error handling (if err != nil), error handling (if err != nil), error handling (if err != nil), error handling (if err != nil), error handling (if err != nil), error handling (if err != nil), error handling (if err != nil), error handling (if err != nil), error handling (if err != nil), error handling (if err != nil), error handling (if err != nil), error handling (if err != nil), error handling (if err != nil), error handling (if err != nil), error handling (if err != nil), error handling (if err != nil), error handling (if err != nil), error handling (if err != nil), error handling (if err != nil), error handling ("}
{"seed": "// ByInfoID orders the results by the info_id field.\nfunc ByInfoID(opts ...sql.OrderTermOption) OrderOption {\n\treturn sql.OrderByField(FieldInfoID, opts...).ToFunc()\n}", "id": 3169, "concepts": ["sql.OrderTermOption", "sql.OrderByField", "sql.OrderOption", "sql.OrderTerm", "sql.OrderBy", "sql.OrderFunc"], "_raw_llm_output": "sql.OrderTermOption, sql.OrderByField, sql.OrderOption, sql.OrderTerm, sql.OrderBy, sql.OrderFunc"}
{"seed": "// Checks whether a kind can be packed as a single scalar value.\nfunc isScalarKind(kind reflect.Kind) bool {\n\tswitch kind {\n\tcase reflect.Chan, reflect.Func, reflect.Interface, reflect.Map,\n\t\treflect.Ptr, reflect.UnsafePointer, reflect.Complex64, reflect.Complex128,\n\t\treflect.Struct, reflect.Slice, reflect.Array:\n\t\treturn false\n\n\tdefault:\n\t\treturn true\n\t}\n}", "id": 3185, "concepts": ["reflection", "type checking", "switch statement"], "_raw_llm_output": "reflection, type checking, switch statement"}
{"seed": "// joinFactSets returns a new FactSet that is the union of the supplied 2\n// FactSets. Facts are simply appended together. The supplied input FactSets are\n// not mutated in any way.\nfunc joinFactSets(a, b FactSet) FactSet {\n\tr := FactSet{\n\t\tFacts: make([]rpc.Fact, len(a.Facts)+len(b.Facts)),\n\t}\n\tcopy(r.Facts, a.Facts)\n\tcopy(r.Facts[len(a.Facts):], b.Facts)\n\treturn r\n}", "id": 3200, "concepts": ["slice concatenation", "slice iteration (range loop)", "basic function definition"], "_raw_llm_output": "slice concatenation, slice iteration (range loop), basic function definition"}
{"seed": "// NewRecentCommits builds a scheduler that proposes tasks for recent comments\n// and modules with no completed tasks in the database. Priority is computed\n// with the commit time and supplied priority function.\nfunc NewRecentCommits(d *db.DB, pri TimePriority) Scheduler {\n\treturn &recent{\n\t\tdb:  d,\n\t\tpri: pri,\n\t}\n}", "id": 3202, "concepts": ["struct definition", "method definition", "method receiver", "interface definition", "method implementation", "database usage"], "_raw_llm_output": "struct definition, method definition, method receiver, interface definition, method implementation, database usage"}
{"seed": "// StringFromNode generates a string that represent a node in the network in following format: 126.0.0.1:3572/r9gJRWVB9JVPap2HKnduoFySvHtVTfJdQ4WG8DriUD82.\nfunc StringFromNode(n Node) string {\n\treturn strings.Join([]string{n.Address(), n.PublicKey().String()}, \"/\")\n}", "id": 3209, "concepts": ["string manipulation", "strings.Join", "string formatting", "string conversion", "struct composition"], "_raw_llm_output": "string manipulation, strings.Join, string formatting, string conversion, struct composition"}
{"seed": "// NewDeleteSiteDeployParams creates a new DeleteSiteDeployParams object\n// with the default values initialized.\nfunc NewDeleteSiteDeployParams() *DeleteSiteDeployParams {\n\tvar ()\n\treturn &DeleteSiteDeployParams{\n\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 3234, "concepts": ["struct initialization", "default values", "function definition"], "_raw_llm_output": "struct initialization, default values, function definition"}
{"seed": "// Duration converts <i> to time.Duration.\n// If <i> is string, then it uses time.ParseDuration to convert it.\n// If <i> is numeric, then it converts <i> as nanoseconds.\nfunc Duration(i interface{}) time.Duration {\n\t// It's already this type.\n\tif v, ok := i.(time.Duration); ok {\n\t\treturn v\n\t}\n\ts := String(i)\n\tif !utils.IsNumeric(s) {\n\t\td, _ := time.ParseDuration(s)\n\t\treturn d\n\t}\n\treturn time.Duration(Int64(i))\n}", "id": 3237, "concepts": ["time.Duration", "time.ParseDuration", "time.Duration conversion", "type conversion", "string conversion", "numeric conversion"], "_raw_llm_output": "time.Duration, time.ParseDuration, time.Duration conversion, type conversion, string conversion, numeric conversion"}
{"seed": "// NewEmptySignalArgument will return a pointer to an empty\n// initialized SignalArgument. This is primarily used in\n// conjunction with MethodBindPtrCall.\nfunc NewEmptySignalArgument() Pointer {\n\tvar obj C.godot_signal_argument\n\treturn Pointer{base: unsafe.Pointer(&obj)}\n}", "id": 3238, "concepts": ["C.godot_signal_argument", "unsafe.Pointer", "C.godot_signal_argument_init", "C.godot_signal_argument_destroy", "C.godot_signal_argument_set_name", "C.godot_signal_argument_get_name", "C.godot_signal_argument_set_type", "C.godot_signal_argument_get_type", "C.godot_signal_argument_set_value", "C.godot_signal_argument_get_value", "C.godot_signal_argument_set_value_from_string", "C.godot_signal_argument_get_value_as_string", "C.godot_signal_argument_set_value_from_variant", "C.godot_signal_argument_get_value_as_variant", "C.godot_signal_argument_set_value_from_object", "C.godot_signal_argument_get_value_as_object", "C.godot_signal_argument_set_value_from_node", "C.godot_signal_argument_get_value_as_node", "C.godot_signal_argument_set_value_from_pool_byte_array", "C.godot"], "_raw_llm_output": "C.godot_signal_argument, unsafe.Pointer, C.godot_signal_argument_init, C.godot_signal_argument_destroy, C.godot_signal_argument_set_name, C.godot_signal_argument_get_name, C.godot_signal_argument_set_type, C.godot_signal_argument_get_type, C.godot_signal_argument_set_value, C.godot_signal_argument_get_value, C.godot_signal_argument_set_value_from_string, C.godot_signal_argument_get_value_as_string, C.godot_signal_argument_set_value_from_variant, C.godot_signal_argument_get_value_as_variant, C.godot_signal_argument_set_value_from_object, C.godot_signal_argument_get_value_as_object, C.godot_signal_argument_set_value_from_node, C.godot_signal_argument_get_value_as_node, C.godot_signal_argument_set_value_from_pool_byte_array, C.godot"}
{"seed": "// TimeSinceSmoothStep has priority p0 for times up to d0 from now, priority p1\n// for times over d1 from now and smoothly transitions between the two.\nfunc TimeSinceSmoothStep(d0 time.Duration, p0 float64, d1 time.Duration, p1 float64) TimePriority {\n\tx0 := float64(d0)\n\tx1 := float64(d1)\n\treturn func(t time.Time) float64 {\n\t\tx := float64(time.Since(t))\n\t\treturn smoothstep(x, x0, p0, x1, p1)\n\t}\n}", "id": 3268, "concepts": ["time handling", "time.Since", "function composition", "smoothstep function"], "_raw_llm_output": "time handling, time.Since, function composition, smoothstep function"}
{"seed": "// NewVppClient returns a new Client using socket.\n// If socket is empty string DefaultSocketName is used.\nfunc NewVppClient(socket string) *Client {\n\tif socket == \"\" {\n\t\tsocket = DefaultSocketName\n\t}\n\treturn &Client{\n\t\tsocketPath:        socket,\n\t\tclientName:        DefaultClientName,\n\t\tconnectTimeout:    DefaultConnectTimeout,\n\t\tdisconnectTimeout: DefaultDisconnectTimeout,\n\t\theaderPool: &sync.Pool{New: func() interface{} {\n\t\t\tx := make([]byte, 16)\n\t\t\treturn &x\n\t\t}},\n\t\tmsgCallback: func(msgID uint16, data []byte) {\n\t\t\tlog.Debugf(\"no callback set, dropping message: ID=%v len=%d\", msgID, len(data))\n\t\t},\n\t}\n}", "id": 3323, "concepts": ["sync.Pool", "sync.Mutex", "sync.WaitGroup", "sync.Once", "sync.Cond", "sync.Map", "sync.RWMutex", "sync.RWMutex", "sync.RWMutex", "sync.RWMutex", "sync.RWMutex", "sync.RWMutex", "sync.RWMutex", "sync.RWMutex", "sync.RWMutex", "sync.RWMutex", "sync.RWMutex", "sync.RWMutex", "sync.RWMutex", "sync.RWMutex", "sync.RWMutex", "sync.RWMutex", "sync.RWMutex", "sync.RWMutex", "sync.RWMutex", "sync.RWMutex", "sync.RWMutex", "sync.RWMutex", "sync.RWMutex", "sync.RWMutex", "sync.RWMutex", "sync.RWMutex", "sync.RWMutex", "sync.RWMutex", "sync.RWMutex", "sync.RWMutex", "sync.RWMutex", "sync.RWMutex", "sync.RWMutex", "sync.RWMutex", "sync.RWMutex", "sync.RWMutex", "sync.RWMutex", "sync.RWMutex", "sync.RWMutex", "sync.RWMutex", "sync.RWMutex", "sync.RWMutex", "sync.RWMutex", "sync.RWMutex", "sync.RWMutex", "sync.RWMutex", ""], "_raw_llm_output": "sync.Pool, sync.Mutex, sync.WaitGroup, sync.Once, sync.Cond, sync.Map, sync.RWMutex, sync.RWMutex, sync.RWMutex, sync.RWMutex, sync.RWMutex, sync.RWMutex, sync.RWMutex, sync.RWMutex, sync.RWMutex, sync.RWMutex, sync.RWMutex, sync.RWMutex, sync.RWMutex, sync.RWMutex, sync.RWMutex, sync.RWMutex, sync.RWMutex, sync.RWMutex, sync.RWMutex, sync.RWMutex, sync.RWMutex, sync.RWMutex, sync.RWMutex, sync.RWMutex, sync.RWMutex, sync.RWMutex, sync.RWMutex, sync.RWMutex, sync.RWMutex, sync.RWMutex, sync.RWMutex, sync.RWMutex, sync.RWMutex, sync.RWMutex, sync.RWMutex, sync.RWMutex, sync.RWMutex, sync.RWMutex, sync.RWMutex, sync.RWMutex, sync.RWMutex, sync.RWMutex, sync.RWMutex, sync.RWMutex, sync.RWMutex, sync.RWMutex,"}
{"seed": "// Prerelease reports if the current module or any dependencies are using a prerelease semver version\r\n// (exclusive of pseudo-versions, which are also prerelease versions according to semver spec but are reported separately).\r\n// It returns true if so.\r\n// Rule: gomodvet-006\r\nfunc Prerelease(verbose bool) (bool, error) {\r\n\tmods, err := buildlist.Resolve()\r\n\tif err != nil {\r\n\t\treturn false, fmt.Errorf(\"prerelease: %v\", err)\r\n\t}\r\n\r\n\tflagged := false\r\n\tfor _, mod := range mods {\r\n\t\tif verbose {\r\n\t\t\tfmt.Printf(\"gomodvet: prerelease: module %s: %+v\\n\", mod.Path, mod)\r\n\t\t}\r\n\t\tif isPrerelease(mod.Version) {\r\n\t\t\tfmt.Printf(\"gomodvet-006: a module is using a prerelease version: %s %s\\n\",\r\n\t\t\t\tmod.Path, mod.Version)\r\n\t\t\tflagged = true\r\n\t\t}\r\n\t}\r\n\treturn flagged, nil\r\n}", "id": 3330, "concepts": ["module resolution", "module version handling", "prerelease version handling", "standard library usage"], "_raw_llm_output": "module resolution, module version handling, prerelease version handling, standard library usage"}
{"seed": "// Wrapf is a wrapper over github.com/pkg/errors.Wrapf.\nfunc Wrapf(err error, format string, args ...interface{}) error {\n\treturn errors.Wrapf(err, format, args...)\n}", "id": 3349, "concepts": ["error handling (errors.Wrapf)", "error wrapping"], "_raw_llm_output": "error handling (errors.Wrapf), error wrapping"}
{"seed": "// NewAFDOriginsClient creates a new instance of AFDOriginsClient with the specified values.\n//   - subscriptionID - Azure Subscription ID.\n//   - credential - used to authorize requests. Usually a credential from azidentity.\n//   - options - pass nil to accept the default values.\nfunc NewAFDOriginsClient(subscriptionID string, credential azcore.TokenCredential, options *arm.ClientOptions) (*AFDOriginsClient, error) {\n\tcl, err := arm.NewClient(moduleName+\".AFDOriginsClient\", moduleVersion, credential, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tclient := &AFDOriginsClient{\n\t\tsubscriptionID: subscriptionID,\n\t\tinternal:       cl,\n\t}\n\treturn client, nil\n}", "id": 3356, "concepts": ["azure SDK usage (arm)", "azure SDK client creation"], "_raw_llm_output": "azure SDK usage (arm), azure SDK client creation"}
{"seed": "// AssertASHandleUplinkDataRequest asserts the given uplink request.\nfunc AssertASHandleUplinkDataRequest(req as.HandleUplinkDataRequest) Assertion {\n\treturn func(assert *require.Assertions, ts *IntegrationTestSuite) {\n\t\tr := <-ts.ASClient.HandleDataUpChan\n\t\tif !proto.Equal(&r, &req) {\n\t\t\tassert.Equal(req, r)\n\t\t}\n\t}\n}", "id": 3361, "concepts": ["proto package usage", "interface", "assertion", "testing"], "_raw_llm_output": "proto package usage, interface, assertion, testing"}
{"seed": "// Null always returns a 204 No Content response without ever opening a\n// network connection.\nfunc Null() Decorator {\n\treturn func(c Client) Client {\n\t\treturn ClientFunc(func(*http.Request) (*http.Response, error) {\n\t\t\treturn &http.Response{\n\t\t\t\tStatus:        http.StatusText(http.StatusNoContent),\n\t\t\t\tStatusCode:    http.StatusNoContent,\n\t\t\t\tProto:         \"HTTP/1.1\",\n\t\t\t\tProtoMajor:    1,\n\t\t\t\tProtoMinor:    1,\n\t\t\t\tHeader:        make(map[string][]string),\n\t\t\t\tContentLength: 0,\n\t\t\t}, nil\n\t\t})\n\t}\n}", "id": 3368, "concepts": ["function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", ""], "_raw_llm_output": "function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition,"}
{"seed": "/*==============================================================================\n * 5. Growth of a Population\n *\n * The size at time t of a population with a birth rate r can be modeled as:\n *\n *      x_t = r*x_{t-1}(1 - x_{t-1})\n *\n * Write a function PopSize(r, x_0, max_t) that prints out the size of the\n * population (x_t) for t=0...max_t, where x_0 is the initial population size.\n * Assume population size and the birth rate parameter r are real numbers; t is\n * an integer.\n *\n * Your function should also return the final population size.\n *============================================================================*/\n\nfunc PopSize(r, x_0 float64, max_t int) float64 {\n    for t := 0; t < max_t; t++ {\n        x_0 = r * x_0 * (1.0 - x_0)\n        if x_0 > 1 {\n            x_0 = 1\n        }\n        if x_0 < 0 {\n            x_0 = 0\n        }\n        fmt.Println(x_0)\n    }\n    return x_0\n}", "id": 3378, "concepts": ["floating point arithmetic", "for loop", "function definition", "basic function usage"], "_raw_llm_output": "floating point arithmetic, for loop, function definition, basic function usage"}
{"seed": "// NewRetentionLabelSettings instantiates a new retentionLabelSettings and sets the default values.\nfunc NewRetentionLabelSettings()(*RetentionLabelSettings) {\n    m := &RetentionLabelSettings{\n    }\n    m.backingStore = ie8677ce2c7e1b4c22e9c3827ecd078d41185424dd9eeb92b7d971ed2d49a392e.BackingStoreFactoryInstance();\n    m.SetAdditionalData(make(map[string]any))\n    return m\n}", "id": 3399, "concepts": ["struct definition", "map definition", "map iteration", "map key access", "map value access", "map value assignment", "map value deletion", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value update", "map value"], "_raw_llm_output": "struct definition, map definition, map iteration, map key access, map value access, map value assignment, map value deletion, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value update, map value"}
{"seed": "// NewEditParamsWithContext creates a new EditParams object\n// with the ability to set a context for a request.\nfunc NewEditParamsWithContext(ctx context.Context) *EditParams {\n\treturn &EditParams{\n\t\tContext: ctx,\n\t}\n}", "id": 3405, "concepts": ["context package usage", "struct definition"], "_raw_llm_output": "context package usage, struct definition"}
{"seed": "// NewStack returns a new instance of Stack.\nfunc NewStack() *Stack {\n\treturn &Stack{}\n}", "id": 3408, "concepts": ["struct definition", "pointer usage"], "_raw_llm_output": "struct definition, pointer usage"}
{"seed": "// CreatedAtNotIn applies the NotIn predicate on the \"created_at\" field.\nfunc CreatedAtNotIn(vs ...time.Time) predicate.User {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.User(func(s *sql.Selector) {\n\t\t// if not arguments were provided, append the FALSE constants,\n\t\t// since we can't apply \"IN ()\". This will make this predicate falsy.\n\t\tif len(vs) == 0 {\n\t\t\ts.Where(sql.False())\n\t\t\treturn\n\t\t}\n\t\ts.Where(sql.NotIn(s.C(FieldCreatedAt), v...))\n\t})\n}", "id": 3411, "concepts": ["sql.Selector", "sql.NotIn", "sql.False", "predicate.User", "function definition"], "_raw_llm_output": "sql.Selector, sql.NotIn, sql.False, predicate.User, function definition"}
{"seed": "// OriginManifestType_Values returns all elements of the OriginManifestType enum\nfunc OriginManifestType_Values() []string {\n\treturn []string{\n\t\tOriginManifestTypeSinglePeriod,\n\t\tOriginManifestTypeMultiPeriod,\n\t}\n}", "id": 3416, "concepts": ["enum", "string array", "basic function definition"], "_raw_llm_output": "enum, string array, basic function definition"}
{"seed": "// authenticationPoliciesData returns policies configured with Local and LDAP authenticators in different order\nfunc authenticationPoliciesData() map[string]*auth.AuthenticationPolicy {\n\tpolicydata := make(map[string]*auth.AuthenticationPolicy)\n\n\tpolicydata[\"LDAP enabled, Local enabled\"] = &auth.AuthenticationPolicy{\n\t\tTypeMeta: api.TypeMeta{Kind: \"AuthenticationPolicy\"},\n\t\tObjectMeta: api.ObjectMeta{\n\t\t\tName: \"AuthenticationPolicy\",\n\t\t},\n\t\tSpec: auth.AuthenticationPolicySpec{\n\t\t\tAuthenticators: auth.Authenticators{\n\t\t\t\tLdap: &auth.Ldap{\n\t\t\t\t\tDomains: []*auth.LdapDomain{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tServers: []*auth.LdapServer{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tUrl: \"localhost:389\",\n\t\t\t\t\t\t\t\t\tTLSOptions: &auth.TLSOptions{\n\t\t\t\t\t\t\t\t\t\tStartTLS:                   true,\n\t\t\t\t\t\t\t\t\t\tSkipServerCertVerification: false,\n\t\t\t\t\t\t\t\t\t\tServerName:                 ServerName,\n\t\t\t\t\t\t\t\t\t\tTrustedCerts:               TrustedCerts,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\tBaseDN:       BaseDN,\n\t\t\t\t\t\t\tBindDN:       BindDN,\n\t\t\t\t\t\t\tBindPassword: BindPassword,\n\t\t\t\t\t\t\tAttributeMapping: &auth.LdapAttributeMapping{\n\t\t\t\t\t\t\t\tUser:             UserAttribute,\n\t\t\t\t\t\t\t\tUserObjectClass:  UserObjectClassAttribute,\n\t\t\t\t\t\t\t\tGroup:            GroupAttribute,\n\t\t\t\t\t\t\t\tGroupObjectClass: GroupObjectClassAttribute,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tLocal:              &auth.Local{},\n\t\t\t\tAuthenticatorOrder: []string{auth.Authenticators_LDAP.String(), auth.Authenticators_LOCAL.String()},\n\t\t\t},\n\t\t\tTokenExpiry: expiration.String(),\n\t\t},\n\t}\n\tpolicydata[\"LDAP disabled, Local enabled\"] = &auth.AuthenticationPolicy{\n\t\tTypeMeta: api.TypeMeta{Kind: \"AuthenticationPolicy\"},\n\t\tObjectMeta: api.ObjectMeta{\n\t\t\tName: \"AuthenticationPolicy\",\n\t\t},\n\t\tSpec: auth.AuthenticationPolicySpec{\n\t\t\tAuthenticators: auth.Authenticators{\n\t\t\t\tLdap:               &auth.Ldap{},\n\t\t\t\tLocal:              &auth.Local{},\n\t\t\t\tAuthenticatorOrder: []string{auth.Authenticators_LOCAL.String()},\n\t\t\t},\n\t\t\tTokenExpiry: expiration.String(),\n\t\t},\n\t}\n\tpolicydata[\"Local enabled, LDAP enabled\"] = &auth.AuthenticationPolicy{\n\t\tTypeMeta: api.TypeMeta{Kind: \"AuthenticationPolicy\"},\n\t\tObjectMeta: api.ObjectMeta{\n\t\t\tName: \"AuthenticationPolicy\",\n\t\t},\n\t\tSpec: auth.AuthenticationPolicySpec{\n\t\t\tAuthenticators: auth.Authenticators{\n\t\t\t\tLdap: &auth.Ldap{\n\t\t\t\t\tDomains: []*auth.LdapDomain{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tServers: []*auth.LdapServer{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tUrl: \"localhost:389\",\n\t\t\t\t\t\t\t\t\tTLSOptions: &auth.TLSOptions{\n\t\t\t\t\t\t\t\t\t\tStartTLS:                   true,\n\t\t\t\t\t\t\t\t\t\tSkipServerCertVerification: false,\n\t\t\t\t\t\t\t\t\t\tServerName:                 ServerName,\n\t\t\t\t\t\t\t\t\t\tTrustedCerts:               TrustedCerts,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\tBaseDN:       BaseDN,\n\t\t\t\t\t\t\tBindDN:       BindDN,\n\t\t\t\t\t\t\tBindPassword: BindPassword,\n\t\t\t\t\t\t\tAttributeMapping: &auth.LdapAttributeMapping{\n\t\t\t\t\t\t\t\tUser:             UserAttribute,\n\t\t\t\t\t\t\t\tUserObjectClass:  UserObjectClassAttribute,\n\t\t\t\t\t\t\t\tGroup:            GroupAttribute,\n\t\t\t\t\t\t\t\tGroupObjectClass: GroupObjectClassAttribute,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tLocal:              &auth.Local{},\n\t\t\t\tAuthenticatorOrder: []string{auth.Authenticators_LOCAL.String(), auth.Authenticators_LDAP.String()},\n\t\t\t},\n\t\t\tTokenExpiry: expiration.String(),\n\t\t},\n\t}\n\tpolicydata[\"Local enabled, LDAP disabled\"] = &auth.AuthenticationPolicy{\n\t\tTypeMeta: api.TypeMeta{Kind: \"AuthenticationPolicy\"},\n\t\tObjectMeta: api.ObjectMeta{\n\t\t\tName: \"AuthenticationPolicy\",\n\t\t},\n\t\tSpec: auth.AuthenticationPolicySpec{\n\t\t\tAuthenticators: auth.Authenticators{\n\t\t\t\tLdap:               &auth.Ldap{},\n\t\t\t\tLocal:              &auth.Local{},\n\t\t\t\tAuthenticatorOrder: []string{auth.Authenticators_LOCAL.String()},\n\t\t\t},\n\t\t\tTokenExpiry: expiration.String(),\n\t\t},\n\t}\n\n\treturn policydata\n}", "id": 3425, "concepts": ["struct", "interface", "slice", "map", "concurrency", "standard library usage"], "_raw_llm_output": "struct, interface, slice, map, concurrency, standard library usage"}
{"seed": "// StateEQ applies the EQ predicate on the \"state\" field.\nfunc StateEQ(v State) predicate.User {\n\treturn predicate.User(sql.FieldEQ(FieldState, v))\n}", "id": 3426, "concepts": ["struct field access", "sql.FieldEQ", "predicate.User"], "_raw_llm_output": "struct field access, sql.FieldEQ, predicate.User"}
{"seed": "// GIDNotFound returns a NotFoundError for a missing group searched by GID.\nfunc GIDNotFound(gid uint32) error {\n\treturn &NotFoundError{\n\t\thasDetails:     true,\n\t\tentityName:     \"group\",\n\t\tidentifierName: \"GID\",\n\t\tidentifier:     gid,\n\t}\n}", "id": 3427, "concepts": ["error handling (custom error types)", "error wrapping"], "_raw_llm_output": "error handling (custom error types), error wrapping"}
{"seed": "// TransfertobankaccountNotNil applies the NotNil predicate on the \"transfertobankaccount\" field.\nfunc TransfertobankaccountNotNil() predicate.Bulk {\n\treturn predicate.Bulk(func(s *sql.Selector) {\n\t\ts.Where(sql.NotNull(s.C(FieldTransfertobankaccount)))\n\t})\n}", "id": 3431, "concepts": ["sql.Selector", "sql.NotNull", "sql.C", "sql.Bulk"], "_raw_llm_output": "sql.Selector, sql.NotNull, sql.C, sql.Bulk"}
{"seed": "// NewDrawStack creates a DrawStack with the given stackable items, drawn in descending index order.\nfunc NewDrawStack(stack ...Stackable) *DrawStack {\n\treturn &DrawStack{\n\t\tas: stack,\n\t}\n}", "id": 3445, "concepts": ["struct", "slice", "basic function definition"], "_raw_llm_output": "struct, slice, basic function definition"}
{"seed": "// wmRT01 covers resizable/tablet: default launch behavior.\n// Expected behavior is defined in: go/arc-wm-r RT01: resizable/tablet: default launch behavior.\nfunc wmRT01(ctx context.Context, tconn *chrome.TestConn, a *arc.ARC, d *ui.Device) error {\n\tntActivities := []wm.TabletLaunchActivityInfo{\n\t\twm.TabletLaunchActivityInfo{\n\t\t\tActivityName: wm.ResizableLandscapeActivity,\n\t\t\tDesiredDO:    display.OrientationLandscapePrimary,\n\t\t},\n\t\twm.TabletLaunchActivityInfo{\n\t\t\tActivityName: wm.ResizablePortraitActivity,\n\t\t\tDesiredDO:    display.OrientationPortraitPrimary,\n\t\t},\n\t}\n\n\treturn wm.TabletDefaultLaunchHelper(ctx, tconn, a, d, ntActivities, true)\n}", "id": 3453, "concepts": ["context", "ui.Device", "arc.ARC", "ui.Window", "display.Orientation", "wm.TabletLaunchActivityInfo", "wm.TabletDefaultLaunchHelper"], "_raw_llm_output": "context, ui.Device, arc.ARC, ui.Window, display.Orientation, wm.TabletLaunchActivityInfo, wm.TabletDefaultLaunchHelper"}
{"seed": "// Range returns a list of all Pythagorean triplets with sides in the\n// range min to max inclusive.\nfunc Range(min, max int) (out []Triplet) {\n\tout0 := append(out, Triplet{0, 0, 0})\n\tfor a := min; a <= max; a++ {\n\t\tfor b := a; b <= max; b++ {\n\t\t\tfor c := b; c <= max; c++ {\n\t\t\t\tif c*c == a*a+b*b {\n\t\t\t\t\tout0 = append(out0, Triplet{a, b, c})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tout = out0[1:]\n\treturn\n}", "id": 3455, "concepts": ["integer comparison", "integer summation", "slice append", "slice iteration (range loop)", "basic function definition"], "_raw_llm_output": "integer comparison, integer summation, slice append, slice iteration (range loop), basic function definition"}
{"seed": "// Convert a boolean value to string \"1\" or \"0\"\nfunc boolToString(val bool) string {\n\tif val {\n\t\treturn \"1\"\n\t} else {\n\t\treturn \"0\"\n\t}\n}", "id": 3465, "concepts": ["if statement", "basic function definition"], "_raw_llm_output": "if statement, basic function definition"}
{"seed": "// NewTable creates a new Table with the given name. If the underlying DB is\n// safe for concurrent use, then the Table is safe for concurrent use.\nfunc NewTable(db DB, name string) Table {\n\thash := sha3.Sum256([]byte(name))\n\treturn &table{\n\t\tdb:       db,\n\t\tnameHash: string(hash[:]),\n\t}\n}", "id": 3468, "concepts": ["interface implementation", "interface usage", "type conversion", "cryptographic hash"], "_raw_llm_output": "interface implementation, interface usage, type conversion, cryptographic hash"}
{"seed": "// FindSecurityGroupByPurpose takes a list of security groups and tries to find the first entry\n// whose purpose matches with the given purpose. If no such entry is found then an error will be\n// returned.\nfunc FindSecurityGroupByPurpose(securityGroups []api.SecurityGroup, purpose api.Purpose) (*api.SecurityGroup, error) {\n\tfor _, securityGroup := range securityGroups {\n\t\tif securityGroup.Purpose == purpose {\n\t\t\treturn &securityGroup, nil\n\t\t}\n\t}\n\treturn nil, fmt.Errorf(\"cannot find security group with purpose %q\", purpose)\n}", "id": 3473, "concepts": ["error handling (fmt.Errorf)", "error handling (errors.Is)", "error handling (errors.As)", "function definition", "interface definition", "pointer usage", "error handling (idiomatic if err != nil)", "error handling (idiomatic if err != nil)", "error handling (idiomatic if err != nil)", "error handling (idiomatic if err != nil)", "error handling (idiomatic if err != nil)", "error handling (idiomatic if err != nil)", "error handling (idiomatic if err != nil)", "error handling (idiomatic if err != nil)", "error handling (idiomatic if err != nil)", "error handling (idiomatic if err != nil)", "error handling (idiomatic if err != nil)", "error handling (idiomatic if err != nil)", "error handling (idiomatic if err != nil)", "error handling (idiomatic if err != nil)", "error handling (idiomatic if err != nil)", "error handling (idiomatic if err != nil)", "error handling (idiomatic if err != nil)", "error handling (idiomatic if err != nil)", "error handling (idiomatic if err != nil)", "error handling (idiomatic if err != nil)", "error handling (idiom"], "_raw_llm_output": "error handling (fmt.Errorf), error handling (errors.Is), error handling (errors.As), function definition, interface definition, pointer usage, error handling (idiomatic if err != nil), error handling (idiomatic if err != nil), error handling (idiomatic if err != nil), error handling (idiomatic if err != nil), error handling (idiomatic if err != nil), error handling (idiomatic if err != nil), error handling (idiomatic if err != nil), error handling (idiomatic if err != nil), error handling (idiomatic if err != nil), error handling (idiomatic if err != nil), error handling (idiomatic if err != nil), error handling (idiomatic if err != nil), error handling (idiomatic if err != nil), error handling (idiomatic if err != nil), error handling (idiomatic if err != nil), error handling (idiomatic if err != nil), error handling (idiomatic if err != nil), error handling (idiomatic if err != nil), error handling (idiomatic if err != nil), error handling (idiomatic if err != nil), error handling (idiom"}
{"seed": "// getUpstreamURL retrieves the upstream URL from the ClusterVersion spec, defaulting to the default if not available\nfunc getUpstreamURL(cV *configv1.ClusterVersion) string {\n\tupstream := string(cV.Spec.Upstream)\n\tif len(upstream) == 0 {\n\t\tupstream = defaultUpstreamServer\n\t}\n\n\treturn upstream\n}", "id": 3477, "concepts": ["string manipulation", "string concatenation"], "_raw_llm_output": "string manipulation, string concatenation"}
{"seed": "// testSpec returns a simple spec that can be used in tests.\nfunc testSpec() *specs.Spec {\n\treturn &specs.Spec{\n\t\t// The host filesystem root is the sandbox root.\n\t\tRoot: &specs.Root{\n\t\t\tPath:     \"/\",\n\t\t\tReadonly: true,\n\t\t},\n\t\tProcess: &specs.Process{\n\t\t\tArgs: []string{\"/bin/true\"},\n\t\t},\n\t}\n}", "id": 3495, "concepts": ["specs package usage", "struct definition"], "_raw_llm_output": "specs package usage, struct definition"}
{"seed": "// NewDeleteFreeIpaByEnvironmentV1Params creates a new DeleteFreeIpaByEnvironmentV1Params object\n// with the default values initialized.\nfunc NewDeleteFreeIpaByEnvironmentV1Params() *DeleteFreeIpaByEnvironmentV1Params {\n\tvar (\n\t\tforcedDefault = bool(false)\n\t)\n\treturn &DeleteFreeIpaByEnvironmentV1Params{\n\t\tForced: &forcedDefault,\n\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 3502, "concepts": ["struct initialization", "pointer handling", "default value assignment"], "_raw_llm_output": "struct initialization, pointer handling, default value assignment"}
{"seed": "// StringToBoolWithFormat creates a binding that connects a String data item to a Bool and is\n// presented using the specified format. Changes to the Bool will be parsed and if the format matches and\n// the parse is successful it will be pushed to the String. Setting the Bool will push a formatted value\n// into the String.\n//\n// Since: 2.0\nfunc StringToBoolWithFormat(str String, format string) Bool {\n\tif format == \"%t\" { // Same as not using custom format.\n\t\treturn StringToBool(str)\n\t}\n\n\tv := &stringToBool{from: str, format: format}\n\tstr.AddListener(v)\n\treturn v\n}", "id": 3505, "concepts": ["string formatting", "fmt package usage", "String.AddListener", "Bool.AddListener"], "_raw_llm_output": "string formatting, fmt package usage, String.AddListener, Bool.AddListener"}
{"seed": "// HasFriends applies the HasEdge predicate on the \"friends\" edge.\nfunc HasFriends() predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\tstep := sqlgraph.NewStep(\n\t\t\tsqlgraph.From(Table, FieldID),\n\t\t\tsqlgraph.Edge(sqlgraph.M2M, false, FriendsTable, FriendsPrimaryKey...),\n\t\t)\n\t\tsqlgraph.HasNeighbors(s, step)\n\t})\n}", "id": 3508, "concepts": ["sqlgraph", "sqlgraph.HasNeighbors", "sqlgraph.From", "sqlgraph.Edge", "sqlgraph.M2M"], "_raw_llm_output": "sqlgraph, sqlgraph.HasNeighbors, sqlgraph.From, sqlgraph.Edge, sqlgraph.M2M"}
{"seed": "// percentAvailable calculates how many percent are available given input statfs data.\nfunc percentAvailable(statfs *syscall.Statfs_t) uint8 {\n\tif statfs.Blocks == 0 {\n\t\treturn uint8(0)\n\t}\n\treturn uint8(float32(statfs.Bavail) / float32(statfs.Blocks) * 100.0)\n}", "id": 3517, "concepts": ["syscall package usage", "syscall.Statfs_t", "integer division", "basic function definition"], "_raw_llm_output": "syscall package usage, syscall.Statfs_t, integer division, basic function definition"}
{"seed": "// Span_ is a convenience wrapper for Span without the attrs argument.\nfunc Span_(children ...HTML) HTML {\n  return Span(nil, children...)\n}", "id": 3540, "concepts": ["basic function definition", "anonymous function", "function argument", "function return value"], "_raw_llm_output": "basic function definition, anonymous function, function argument, function return value"}
{"seed": "// NewGoshawkFromFile creates a Goshawk from the given filename, which should\n// contain text-protobuf encoded configuration data, together with an optional\n// http Client.\nfunc NewGoshawkFromFile(ctx context.Context, filename string, hc *http.Client, scanOpts scanner.ScannerOptions) (*Goshawk, error) {\n\tcfgText, err := ioutil.ReadFile(filename)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar cfgProto configpb.GoshawkConfig\n\tif err := proto.UnmarshalText(string(cfgText), &cfgProto); err != nil {\n\t\treturn nil, fmt.Errorf(\"%s: failed to parse gossip config: %v\", filename, err)\n\t}\n\tcfg, err := NewGoshawk(ctx, &cfgProto, hc, scanOpts)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"%s: config error: %v\", filename, err)\n\t}\n\treturn cfg, nil\n}", "id": 3544, "concepts": ["text-protobuf encoding", "proto package usage", "context package usage", "error handling", "file reading"], "_raw_llm_output": "text-protobuf encoding, proto package usage, context package usage, error handling, file reading"}
{"seed": "// BlobEQ applies the EQ predicate on the \"blob\" field.\nfunc BlobEQ(v []byte) predicate.User {\n\treturn predicate.User(sql.FieldEQ(FieldBlob, v))\n}", "id": 3558, "concepts": ["sql package usage", "sql.FieldEQ", "sql.Field"], "_raw_llm_output": "sql package usage, sql.FieldEQ, sql.Field"}
{"seed": "// newCondition creates a new caffe2job condition.\nfunc newCondition(conditionType api.Caffe2JobConditionType, reason, message string) api.Caffe2JobCondition {\n\treturn api.Caffe2JobCondition{\n\t\tType:               conditionType,\n\t\tStatus:             v1.ConditionTrue,\n\t\tLastUpdateTime:     metav1.Now(),\n\t\tLastTransitionTime: metav1.Now(),\n\t\tReason:             reason,\n\t\tMessage:            message,\n\t}\n}", "id": 3563, "concepts": ["struct definition", "struct field access", "struct field initialization", "struct field assignment", "struct field comparison"], "_raw_llm_output": "struct definition, struct field access, struct field initialization, struct field assignment, struct field comparison"}
{"seed": "// ValidateSubjectAccessReview validates a SubjectAccessReview and returns an\n// ErrorList with any errors.\nfunc ValidateSubjectAccessReview(sar *authorizationapi.SubjectAccessReview) field.ErrorList {\n\tallErrs := ValidateSubjectAccessReviewSpec(sar.Spec, field.NewPath(\"spec\"))\n\tobjectMetaShallowCopy := sar.ObjectMeta\n\tobjectMetaShallowCopy.ManagedFields = nil\n\tif !apiequality.Semantic.DeepEqual(metav1.ObjectMeta{}, objectMetaShallowCopy) {\n\t\tallErrs = append(allErrs, field.Invalid(field.NewPath(\"metadata\"), sar.ObjectMeta, `must be empty`))\n\t}\n\treturn allErrs\n}", "id": 3567, "concepts": ["struct field validation", "metav1.ObjectMeta", "apiequality.Semantic", "field.ErrorList", "field.Invalid"], "_raw_llm_output": "struct field validation, metav1.ObjectMeta, apiequality.Semantic, field.ErrorList, field.Invalid"}
{"seed": "// SingleWindowWithMenuBar creates a SingleWindow and allows to add menubar on its top.\nfunc SingleWindowWithMenuBar() *WindowWidget {\n\tsize := Context.platform.DisplaySize()\n\ttitle := fmt.Sprintf(\"SingleWindow_%d\", Context.GetWidgetIndex())\n\n\treturn Window(title).\n\t\tFlags(\n\t\t\timgui.WindowFlagsNoTitleBar|\n\t\t\t\timgui.WindowFlagsNoCollapse|\n\t\t\t\timgui.WindowFlagsNoScrollbar|\n\t\t\t\timgui.WindowFlagsNoMove|\n\t\t\t\timgui.WindowFlagsMenuBar|\n\t\t\t\timgui.WindowFlagsNoResize).Size(size[0], size[1])\n}", "id": 3576, "concepts": ["window creation", "window flags", "window size", "window title", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", "window flags", ""], "_raw_llm_output": "window creation, window flags, window size, window title, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags, window flags,"}
{"seed": "// SocialAvatarURLNotIn applies the NotIn predicate on the \"social_avatar_url\" field.\nfunc SocialAvatarURLNotIn(vs ...string) predicate.User {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.User(func(s *sql.Selector) {\n\t\t// if not arguments were provided, append the FALSE constants,\n\t\t// since we can't apply \"IN ()\". This will make this predicate falsy.\n\t\tif len(vs) == 0 {\n\t\t\ts.Where(sql.False())\n\t\t\treturn\n\t\t}\n\t\ts.Where(sql.NotIn(s.C(FieldSocialAvatarURL), v...))\n\t})\n}", "id": 3589, "concepts": ["sql.Selector", "sql.NotIn", "sql.False", "predicate.User", "sql.C", "standard library usage"], "_raw_llm_output": "sql.Selector, sql.NotIn, sql.False, predicate.User, sql.C, standard library usage"}
{"seed": "// Google Drive files can have properties associated with them, which are\n// basically maps from strings to strings. Given a Google Drive file and a\n// property name, this function returns the property value, if the named\n// property is present.\nfunc getProperty(driveFile *drive.File, name string) (string, error) {\n\tfor _, prop := range driveFile.Properties {\n\t\tif prop.Key == name {\n\t\t\treturn prop.Value, nil\n\t\t}\n\t}\n\treturn \"\", fmt.Errorf(\"%s: property not found\", name)\n}", "id": 3624, "concepts": ["struct", "map", "interface", "error handling", "standard library usage"], "_raw_llm_output": "struct, map, interface, error handling, standard library usage"}
{"seed": "// PageToOffset returns the pagination offset value\n// corresponding to the given page and size.\nfunc PageToOffset(page, size int) int {\n\treturn (page - 1) * size\n}", "id": 3627, "concepts": ["integer arithmetic", "integer division", "integer subtraction"], "_raw_llm_output": "integer arithmetic, integer division, integer subtraction"}
{"seed": "// RecognizedKustomizationFileNames is a list of file names\n// that kustomize recognizes.\n// To avoid ambiguity, a kustomization directory may not\n// contain more than one match to this list.\nfunc RecognizedKustomizationFileNames() []string {\n\treturn []string{\n\t\t\"kustomization.yaml\",\n\t\t\"kustomization.yml\",\n\t\t\"Kustomization\",\n\t}\n}", "id": 3643, "concepts": ["string manipulation", "string comparison", "string concatenation"], "_raw_llm_output": "string manipulation, string comparison, string concatenation"}
{"seed": "// Create creates a tar.gz archive for a directory name relative to\n// /e2e/fixtures (the directory passed with --test-dir flag is mounted under\n// /e2e path in the test container). It returns created archive path.\n//\n// NOTE: The created archive should be deleted at the end of the test\n// preferably with `defer os.Remove(path)`.\nfunc Create(chartDirName string) (string, error) {\n\tchartDirPath := filepath.Join(fixturesDir, chartDirName)\n\ttarballPath := filepath.Join(fixturesDir, \"tmp\", chartDirName+\".tgz\")\n\n\t{\n\t\tinfo, err := os.Stat(chartDirPath)\n\t\tif os.IsNotExist(err) {\n\t\t\treturn \"\", microerror.Maskf(executionFailedError, \"directory %#q does not exist\", chartDirPath)\n\t\t} else if err != nil {\n\t\t\treturn \"\", microerror.Mask(err)\n\t\t}\n\n\t\tif !info.IsDir() {\n\t\t\treturn \"\", microerror.Maskf(executionFailedError, \"file %#q is not a directory\", chartDirPath)\n\t\t}\n\t}\n\n\t{\n\t\t_, err := os.Stat(tarballPath)\n\t\tif os.IsNotExist(err) {\n\t\t\t// Fall trough.\n\t\t} else if err != nil {\n\t\t\treturn \"\", microerror.Mask(err)\n\t\t} else {\n\t\t\treturn \"\", microerror.Maskf(executionFailedError, \"file %#q already exists\", tarballPath)\n\t\t}\n\t}\n\n\t{\n\t\tdir := filepath.Dir(tarballPath)\n\t\tif dir != \".\" && dir != \"/\" {\n\t\t\terr := os.MkdirAll(dir, 0755)\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", microerror.Mask(err)\n\t\t\t}\n\t\t}\n\t}\n\n\t{\n\t\terr := archiver.Archive([]string{chartDirPath}, tarballPath)\n\t\tif err != nil {\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", microerror.Mask(err)\n\t\t\t}\n\n\t\t}\n\t}\n\n\treturn tarballPath, nil\n}", "id": 3648, "concepts": ["os.Stat", "os.MkdirAll", "filepath.Dir", "filepath.Join", "os.Remove", "archiver.Archive", "basic function definition"], "_raw_llm_output": "os.Stat, os.MkdirAll, filepath.Dir, filepath.Join, os.Remove, archiver.Archive, basic function definition"}
{"seed": "// AutoSyncInterval is the interval to update endpoints with its latest members.\n// 0 disables auto-sync. By default auto-sync is disabled.\nfunc AutoSyncInterval(v time.Duration) Configer {\n\treturn func(c *clientv3.Config) {\n\t\tc.AutoSyncInterval = v\n\t}\n}", "id": 3650, "concepts": ["function composition", "function definition", "time.Duration"], "_raw_llm_output": "function composition, function definition, time.Duration"}
{"seed": "// ShowHelp returns true if -h flag was provided\nfunc ShowHelp() bool {\n\treturn showHelp\n}", "id": 3673, "concepts": ["command-line flag parsing", "boolean flag handling"], "_raw_llm_output": "command-line flag parsing, boolean flag handling"}
{"seed": "// FirewallRuleGroupAssociationStatus_Values returns all elements of the FirewallRuleGroupAssociationStatus enum\nfunc FirewallRuleGroupAssociationStatus_Values() []string {\n\treturn []string{\n\t\tFirewallRuleGroupAssociationStatusComplete,\n\t\tFirewallRuleGroupAssociationStatusDeleting,\n\t\tFirewallRuleGroupAssociationStatusUpdating,\n\t}\n}", "id": 3678, "concepts": ["enum", "string formatting"], "_raw_llm_output": "enum, string formatting"}
{"seed": "// ScheduleEntryType_Values returns all elements of the ScheduleEntryType enum\nfunc ScheduleEntryType_Values() []string {\n\treturn []string{\n\t\tScheduleEntryTypeProgram,\n\t\tScheduleEntryTypeFillerSlate,\n\t}\n}", "id": 3694, "concepts": ["enum definition", "enum value definition", "enum value iteration"], "_raw_llm_output": "enum definition, enum value definition, enum value iteration"}
{"seed": "// ParseListDNSZonesResponse parses an HTTP response from a ListDNSZonesWithResponse call\nfunc ParseListDNSZonesResponse(rsp *http.Response) (*ListDNSZonesResponse, error) {\n\tbodyBytes, err := ioutil.ReadAll(rsp.Body)\n\tdefer rsp.Body.Close()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse := &ListDNSZonesResponse{\n\t\tBody:         bodyBytes,\n\t\tHTTPResponse: rsp,\n\t}\n\n\tswitch {\n\tcase strings.Contains(rsp.Header.Get(\"Content-Type\"), \"json\") && rsp.StatusCode == 200:\n\t\tvar dest ScalewayDomainV2alpha2ListDNSZonesResponse\n\t\tif err := json.Unmarshal(bodyBytes, &dest); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresponse.JSON200 = &dest\n\n\t}\n\n\treturn response, nil\n}", "id": 3708, "concepts": ["HTTP request", "HTTP response", "JSON parsing", "error handling", "switch statement", "type assertion", "type conversion"], "_raw_llm_output": "HTTP request, HTTP response, JSON parsing, error handling, switch statement, type assertion, type conversion"}
{"seed": "// VerifyOutputsEqual verifies that the two slices of transaction outputs are\n// deep equal to each other. We do the length check and manual loop to provide\n// better error messages to the user than just returning \"not equal\".\nfunc VerifyOutputsEqual(outs1, outs2 []*wire.TxOut) error {\n\tif len(outs1) != len(outs2) {\n\t\treturn fmt.Errorf(\"number of outputs are different\")\n\n\t}\n\tfor idx, out := range outs1 {\n\t\t// There is a byte slice in the output so we can't use the\n\t\t// equality operator.\n\t\tif !TxOutsEqual(out, outs2[idx]) {\n\t\t\treturn fmt.Errorf(\"output %d is different\", idx)\n\t\t}\n\t}\n\treturn nil\n}", "id": 3721, "concepts": ["slice iteration (range loop)", "equality operator", "pointer comparison", "error handling"], "_raw_llm_output": "slice iteration (range loop), equality operator, pointer comparison, error handling"}
{"seed": "// NewPropertyAttributesFromPointer will return a PropertyAttributes from the\n// given unsafe pointer. This is primarily used in conjunction with MethodBindPtrCall.\nfunc NewPropertyAttributesFromPointer(ptr Pointer) PropertyAttributes {\n\n\treturn PropertyAttributes{base: (*C.godot_property_attributes)(ptr.getBase())}\n}", "id": 3724, "concepts": ["unsafe pointer", "CGO", "C.godot_property_attributes"], "_raw_llm_output": "unsafe pointer, CGO, C.godot_property_attributes"}
{"seed": "// ReadRentableSpecialty read a full RentableSpecialty structure of data from db based on sql.Row pointer\nfunc ReadRentableSpecialty(row *sql.Row, a *RentableSpecialty) error {\n\terr := row.Scan(&a.RSPID, &a.BID, &a.Name, &a.Fee, &a.Description, &a.CreateTS, &a.CreateBy, &a.LastModTime, &a.LastModBy)\n\tSkipSQLNoRowsError(&err)\n\treturn err\n}", "id": 3738, "concepts": ["sql.Row", "sql.Scan", "sql.ErrNoRows", "error handling", "pointer", "basic function definition"], "_raw_llm_output": "sql.Row, sql.Scan, sql.ErrNoRows, error handling, pointer, basic function definition"}
{"seed": "// RegisterOcpTestApiHandlerFromEndpoint is same as RegisterOcpTestApiHandler but\n// automatically dials to \"endpoint\" and closes the connection when \"ctx\" gets done.\nfunc RegisterOcpTestApiHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {\n\tconn, err := grpc.Dial(endpoint, opts...)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer func() {\n\t\tif err != nil {\n\t\t\tif cerr := conn.Close(); cerr != nil {\n\t\t\t\tgrpclog.Infof(\"Failed to close conn to %s: %v\", endpoint, cerr)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tgo func() {\n\t\t\t<-ctx.Done()\n\t\t\tif cerr := conn.Close(); cerr != nil {\n\t\t\t\tgrpclog.Infof(\"Failed to close conn to %s: %v\", endpoint, cerr)\n\t\t\t}\n\t\t}()\n\t}()\n\n\treturn RegisterOcpTestApiHandler(ctx, mux, conn)\n}", "id": 3748, "concepts": ["defer", "anonymous function", "context", "grpc.DialOption", "runtime.ServeMux", "standard library usage"], "_raw_llm_output": "defer, anonymous function, context, grpc.DialOption, runtime.ServeMux, standard library usage"}
{"seed": "// NewGetContactsParamsWithContext creates a new GetContactsParams object\n// with the default values initialized, and the ability to set a context for a request\nfunc NewGetContactsParamsWithContext(ctx context.Context) *GetContactsParams {\n\tvar (\n\t\tlimitDefault  = int32(5000)\n\t\toffsetDefault = int32(0)\n\t)\n\treturn &GetContactsParams{\n\t\tLimit:  &limitDefault,\n\t\tOffset: &offsetDefault,\n\n\t\tContext: ctx,\n\t}\n}", "id": 3764, "concepts": ["context package usage", "pointer receivers", "function definition"], "_raw_llm_output": "context package usage, pointer receivers, function definition"}
{"seed": "// New creates the configurable route controller from configuration. This is the controller\n// that handles all the logic for generating roles and rolebindings for operators that\n// include routes with configurable hostnames and serving certificates.\n//\n// Cluster-admins may provide a custom hostname and serving certificate for a route\n// by creating a spec.componentRoute entry in the ingresses.config.openshift.io/cluster\n// resource. If a componentRoute entry exists in the status.componentRoutes list with\n// a matching namespace and name this controller will generate:\n// - A role that grants get/list/watch permissions for the secret defined in the spec.\n// - A roleBinding that binds the aforementioned role to each consumingUser specified\n// in the corresponding status entry.\nfunc New(mgr manager.Manager, config Config, eventRecorder events.Recorder) (controller.Controller, error) {\n\tkubeClient, err := kubernetes.NewForConfig(mgr.GetConfig())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\toperatorCache := mgr.GetCache()\n\treconciler := &reconciler{\n\t\tkclient:       kubeClient,\n\t\tconfig:        config,\n\t\tclient:        mgr.GetClient(),\n\t\tcache:         operatorCache,\n\t\teventRecorder: eventRecorder,\n\t}\n\n\tc, err := controller.New(ControllerName, mgr, controller.Options{Reconciler: reconciler})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Trigger reconcile requests for the cluster ingress resource.\n\tclusterNamePredicate := predicate.NewPredicateFuncs(func(o client.Object) bool {\n\t\tclusterIngressResource := operatorcontroller.IngressClusterConfigName()\n\t\treturn o.GetName() == clusterIngressResource.Name && o.GetNamespace() == clusterIngressResource.Namespace\n\t})\n\n\tif err := c.Watch(source.Kind(operatorCache, &configv1.Ingress{}), &handler.EnqueueRequestForObject{}, clusterNamePredicate); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Trigger reconcile requests for the roles and roleBindings with the componentRoute label.\n\tdefaultPredicate := predicate.NewPredicateFuncs(func(o client.Object) bool {\n\t\tlabels := o.GetLabels()\n\t\t_, ok := labels[componentRouteHashLabelKey]\n\t\treturn ok\n\t})\n\n\tif err := c.Watch(source.Kind(operatorCache, &rbacv1.Role{}), handler.EnqueueRequestsFromMapFunc(reconciler.resourceToClusterIngressConfig), defaultPredicate); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := c.Watch(source.Kind(operatorCache, &rbacv1.RoleBinding{}), handler.EnqueueRequestsFromMapFunc(reconciler.resourceToClusterIngressConfig), defaultPredicate); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn c, nil\n}", "id": 3773, "concepts": ["client-go", "controller-runtime", "client.Object", "client.ObjectList", "client.ObjectKey", "client.ObjectList", "client.ObjectList", "client.ObjectList", "client.ObjectList", "client.ObjectList", "client.ObjectList", "client.ObjectList", "client.ObjectList", "client.ObjectList", "client.ObjectList", "client.ObjectList", "client.ObjectList", "client.ObjectList", "client.ObjectList", "client.ObjectList", "client.ObjectList", "client.ObjectList", "client.ObjectList", "client.ObjectList", "client.ObjectList", "client.ObjectList", "client.ObjectList", "client.ObjectList", "client.ObjectList", "client.ObjectList", "client.ObjectList", "client.ObjectList", "client.ObjectList", "client.ObjectList", "client.ObjectList", "client.ObjectList", "client.ObjectList", "client.ObjectList", "client.ObjectList", "client.ObjectList", "client.ObjectList", "client.ObjectList", "client.ObjectList", "client.ObjectList", "client.ObjectList", "client.ObjectList", "client.ObjectList", "client.ObjectList", "client.ObjectList", "client.ObjectList", "client.ObjectList", "client.Object"], "_raw_llm_output": "client-go, controller-runtime, client.Object, client.ObjectList, client.ObjectKey, client.ObjectList, client.ObjectList, client.ObjectList, client.ObjectList, client.ObjectList, client.ObjectList, client.ObjectList, client.ObjectList, client.ObjectList, client.ObjectList, client.ObjectList, client.ObjectList, client.ObjectList, client.ObjectList, client.ObjectList, client.ObjectList, client.ObjectList, client.ObjectList, client.ObjectList, client.ObjectList, client.ObjectList, client.ObjectList, client.ObjectList, client.ObjectList, client.ObjectList, client.ObjectList, client.ObjectList, client.ObjectList, client.ObjectList, client.ObjectList, client.ObjectList, client.ObjectList, client.ObjectList, client.ObjectList, client.ObjectList, client.ObjectList, client.ObjectList, client.ObjectList, client.ObjectList, client.ObjectList, client.ObjectList, client.ObjectList, client.ObjectList, client.ObjectList, client.ObjectList, client.ObjectList, client.Object"}
{"seed": "// MatchCondition returns the GomegaMatcher that checks if the 'actual' status.Condition matches the 'expected' one.\nfunc MatchCondition(expected status.Condition) types.GomegaMatcher {\n\treturn &conditionMatcher{ExpectedCondition: expected}\n}", "id": 3779, "concepts": ["interface", "struct", "pointer", "GomegaMatcher"], "_raw_llm_output": "interface, struct, pointer, GomegaMatcher"}
{"seed": "// NewPartitionKeyPartitioner builds a hash partitioner that will employ\n// a PartitionKeyEncoder's PartitionKey() field instead of message.Key\n// Assign to sarama.Config.Producer.Partitioner\nfunc NewPartitionKeyPartitioner(topic string) sarama.Partitioner {\n\treturn &partitionKeyPartitioner{sarama.NewHashPartitioner(topic)}\n}", "id": 3780, "concepts": ["interface implementation", "struct composition", "function composition", "function composition with anonymous function"], "_raw_llm_output": "interface implementation, struct composition, function composition, function composition with anonymous function"}
{"seed": "// Head_ is a convenience wrapper for Head without the attrs argument.\nfunc Head_(children ...HTML) HTML {\n  return Head(nil, children...)\n}", "id": 3799, "concepts": ["function definition", "variadic function definition", "function call", "function return"], "_raw_llm_output": "function definition, variadic function definition, function call, function return"}
{"seed": "// csprngUint32n, given a CSPRNG, returns, as a uint32, a uniformly\n// distributed random number in [0, n). It is adapted from\n// math/rand.int31n from go 1.10.\n//\n// For implementation details, see:\n// https://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction\n// https://lemire.me/blog/2016/06/30/fast-random-shuffling\nfunc csprngUint32n(csprng io.Reader, n uint32) (uint32, error) {\n\tv, err := csprngUint32(csprng)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tprod := uint64(v) * uint64(n)\n\tlow := uint32(prod)\n\tif low < n {\n\t\tthresh := -n % n\n\t\tfor low < thresh {\n\t\t\tv, err = csprngUint32(csprng)\n\t\t\tif err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t\tprod = uint64(v) * uint64(n)\n\t\t\tlow = uint32(prod)\n\t\t}\n\t}\n\treturn uint32(prod >> 32), nil\n}", "id": 3807, "concepts": ["error handling (io.Reader)", "integer division", "bitwise operations", "CSPRNG"], "_raw_llm_output": "error handling (io.Reader), integer division, bitwise operations, CSPRNG"}
{"seed": "// NewIamLdapBasePropertiesAllOfWithDefaults instantiates a new IamLdapBasePropertiesAllOf object\n// This constructor will only assign default values to properties that have it defined,\n// but it doesn't guarantee that properties required by API are set\nfunc NewIamLdapBasePropertiesAllOfWithDefaults() *IamLdapBasePropertiesAllOf {\n\tthis := IamLdapBasePropertiesAllOf{}\n\tvar classId string = \"iam.LdapBaseProperties\"\n\tthis.ClassId = classId\n\tvar objectType string = \"iam.LdapBaseProperties\"\n\tthis.ObjectType = objectType\n\tvar bindMethod string = \"LoginCredentials\"\n\tthis.BindMethod = &bindMethod\n\tvar nestedGroupSearchDepth int64 = 128\n\tthis.NestedGroupSearchDepth = &nestedGroupSearchDepth\n\tvar timeout int64 = 0\n\tthis.Timeout = &timeout\n\treturn &this\n}", "id": 3810, "concepts": ["struct definition", "anonymous struct definition", "pointer usage", "struct field initialization"], "_raw_llm_output": "struct definition, anonymous struct definition, pointer usage, struct field initialization"}
{"seed": "// Aside represents the HTML element 'aside'.\n// For more information visit https://www.w3schools.com/tags/tag_aside.asp.\nfunc Aside(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"aside\", Attributes: attrs, Children: children}\n}", "id": 3819, "concepts": ["HTML generation", "HTML element definition", "HTML attribute definition", "HTML element children definition"], "_raw_llm_output": "HTML generation, HTML element definition, HTML attribute definition, HTML element children definition"}
{"seed": "// Decode decodes n bytes of coded data into n/2 bytes of original data.\n// The output is appended to out and returns the result\n// of append the output to out.\n// Also the number of 12 bit words that required correction\n// is returned.\n// n = len(in) must be a multiple of 6.\nfunc Decode(in, out []byte) (int, []byte) {\n\tif len(in)%6 != 0 {\n\t\tpanic(\"len(in) must be a multiple of 6\")\n\t}\n\tvar errcount, c int\n\tfor len(in) >= 6 {\n\t\tc, out = decode24(in, out)\n\t\terrcount += c\n\t\tin = in[6:]\n\t}\n\treturn errcount, out\n}", "id": 3820, "concepts": ["byte handling", "slice manipulation", "basic function definition", "error handling"], "_raw_llm_output": "byte handling, slice manipulation, basic function definition, error handling"}
{"seed": "// NatGatewayPropertiesFormat_ARMGenerator returns a generator of NatGatewayPropertiesFormat_ARM instances for property testing.\n// We first initialize natGatewayPropertiesFormat_ARMGenerator with a simplified generator based on the\n// fields with primitive types then replacing it with a more complex one that also handles complex fields\n// to ensure any cycles in the object graph properly terminate.\nfunc NatGatewayPropertiesFormat_ARMGenerator() gopter.Gen {\n\tif natGatewayPropertiesFormat_ARMGenerator != nil {\n\t\treturn natGatewayPropertiesFormat_ARMGenerator\n\t}\n\n\tgenerators := make(map[string]gopter.Gen)\n\tAddIndependentPropertyGeneratorsForNatGatewayPropertiesFormat_ARM(generators)\n\tnatGatewayPropertiesFormat_ARMGenerator = gen.Struct(reflect.TypeOf(NatGatewayPropertiesFormat_ARM{}), generators)\n\n\t// The above call to gen.Struct() captures the map, so create a new one\n\tgenerators = make(map[string]gopter.Gen)\n\tAddIndependentPropertyGeneratorsForNatGatewayPropertiesFormat_ARM(generators)\n\tAddRelatedPropertyGeneratorsForNatGatewayPropertiesFormat_ARM(generators)\n\tnatGatewayPropertiesFormat_ARMGenerator = gen.Struct(reflect.TypeOf(NatGatewayPropertiesFormat_ARM{}), generators)\n\n\treturn natGatewayPropertiesFormat_ARMGenerator\n}", "id": 3835, "concepts": ["struct", "map", "reflection", "generator", "property testing"], "_raw_llm_output": "struct, map, reflection, generator, property testing"}
{"seed": "// OnesCount16Before counts the number of \"1\"(population count) in a uint16 before specified bit position `iBit`.\nfunc OnesCount16Before(n uint16, iBit uint) int {\n\treturn gobits.OnesCount16(n & ((uint16(1) << iBit) - 1))\n}", "id": 3838, "concepts": ["bit manipulation (bitwise AND", "bitwise OR", "bitwise XOR)", "bit shifting", "bitwise operations", "population count"], "_raw_llm_output": "bit manipulation (bitwise AND, bitwise OR, bitwise XOR), bit shifting, bitwise operations, population count"}
{"seed": "// newD05 creates a new `d05' value to be used as either a partial or global\n// solution for the problem.\nfunc newD05() *d05 {\n\treturn &d05{employeesByArea: map[string][]*employee{}, salaryByArea: map[string]*groupSalaryStats{}, salaryBySurname: map[string]*groupSalaryStats{}, areas: map[string]area{}}\n}", "id": 3851, "concepts": ["map iteration (range loop)", "map key lookup", "map value lookup", "map key deletion", "map value deletion", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence"], "_raw_llm_output": "map iteration (range loop), map key lookup, map value lookup, map key deletion, map value deletion, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence"}
{"seed": "// AthensMaxConcurrency retrieves maximal level of concurrency based on ATHENS_MAX_CONCURRENCY.\n// Defaults to number of cores if env is not set.\nfunc AthensMaxConcurrency() int {\n\tdefaultMaxConcurrency := runtime.NumCPU()\n\tmaxConcurrencyEnv, err := envy.MustGet(\"ATHENS_MAX_CONCURRENCY\")\n\tif err != nil {\n\t\treturn defaultMaxConcurrency\n\t}\n\n\tmc, err := strconv.Atoi(maxConcurrencyEnv)\n\tif err != nil {\n\t\treturn defaultMaxConcurrency\n\t}\n\n\treturn mc\n}", "id": 3854, "concepts": ["runtime.NumCPU", "environment variable usage", "strconv.Atoi"], "_raw_llm_output": "runtime.NumCPU, environment variable usage, strconv.Atoi"}
{"seed": "// byteCountSI converts the provided bytes to a string representation of the\n// closest SI unit (kB, MB, GB, etc).\nfunc byteCountSI(b int64) string {\n\tconst unit = 1000\n\tif b < unit {\n\t\treturn fmt.Sprintf(\"%d B\", b)\n\t}\n\tdiv, exp := int64(unit), 0\n\tfor n := b / unit; n >= unit; n /= unit {\n\t\tdiv *= unit\n\t\texp++\n\t}\n\treturn fmt.Sprintf(\"%.1f %cB\",\n\t\tfloat64(b)/float64(div), \"kMGTPE\"[exp])\n}", "id": 3856, "concepts": ["integer division", "integer multiplication", "string formatting", "string concatenation"], "_raw_llm_output": "integer division, integer multiplication, string formatting, string concatenation"}
{"seed": "// newWordresult converts projected type Wordresult to service type Wordresult.\nfunc newWordresult(vres *shiritoriviews.WordresultView) *Wordresult {\n\tres := &Wordresult{}\n\tif vres.Word != nil {\n\t\tres.Word = *vres.Word\n\t}\n\tif vres.Exists != nil {\n\t\tres.Exists = *vres.Exists\n\t}\n\tif vres.Hash != nil {\n\t\tres.Hash = *vres.Hash\n\t}\n\treturn res\n}", "id": 3861, "concepts": ["struct definition", "struct field access", "pointer dereference"], "_raw_llm_output": "struct definition, struct field access, pointer dereference"}
{"seed": "// PossibleEventHubDataFormatValues returns an array of possible values for the EventHubDataFormat const type.\nfunc PossibleEventHubDataFormatValues() []EventHubDataFormat {\n\treturn []EventHubDataFormat{EventHubDataFormatAPACHEAVRO, EventHubDataFormatAVRO, EventHubDataFormatCSV, EventHubDataFormatJSON, EventHubDataFormatMULTIJSON, EventHubDataFormatORC, EventHubDataFormatPARQUET, EventHubDataFormatPSV, EventHubDataFormatRAW, EventHubDataFormatSCSV, EventHubDataFormatSINGLEJSON, EventHubDataFormatSOHSV, EventHubDataFormatTSV, EventHubDataFormatTSVE, EventHubDataFormatTXT, EventHubDataFormatW3CLOGFILE}\n}", "id": 3868, "concepts": ["constant definition", "array definition", "array iteration (range loop)", "array element access"], "_raw_llm_output": "constant definition, array definition, array iteration (range loop), array element access"}
{"seed": "// Time_ is a convenience wrapper for Time without the attrs argument.\nfunc Time_(children ...HTML) HTML {\n  return Time(nil, children...)\n}", "id": 3875, "concepts": ["HTML", "function definition", "function argument", "function return value", "function argument type", "function argument value", "function argument type", "function argument value", "function argument type", "function argument value", "function argument type", "function argument value", "function argument type", "function argument value", "function argument type", "function argument value", "function argument type", "function argument value", "function argument type", "function argument value", "function argument type", "function argument value", "function argument type", "function argument value", "function argument type", "function argument value", "function argument type", "function argument value", "function argument type", "function argument value", "function argument type", "function argument value", "function argument type", "function argument value", "function argument type", "function argument value", "function argument type", "function argument value", "function argument type", "function argument value", "function argument type", "function argument value", "function argument type", "function argument value", "function argument type", "function argument value", "function argument type", "function argument value", "function argument type", "function argument value", "function argument type", "function argument value", "function argument type", "function argument value", "function argument type", "function argument value", "function argument type", "function argument value", "function argument type", "function argument value", "function argument type", "function argument value", "function argument type", "function argument value", "function argument type"], "_raw_llm_output": "HTML, function definition, function argument, function return value, function argument type, function argument value, function argument type, function argument value, function argument type, function argument value, function argument type, function argument value, function argument type, function argument value, function argument type, function argument value, function argument type, function argument value, function argument type, function argument value, function argument type, function argument value, function argument type, function argument value, function argument type, function argument value, function argument type, function argument value, function argument type, function argument value, function argument type, function argument value, function argument type, function argument value, function argument type, function argument value, function argument type, function argument value, function argument type, function argument value, function argument type, function argument value, function argument type, function argument value, function argument type, function argument value, function argument type, function argument value, function argument type, function argument value, function argument type, function argument value, function argument type, function argument value, function argument type, function argument value, function argument type, function argument value, function argument type, function argument value, function argument type, function argument value, function argument type, function argument value, function argument type"}
{"seed": "// NewListTaskNexusParamsWithTimeout creates a new ListTaskNexusParams object\n// with the default values initialized, and the ability to set a timeout on a request\nfunc NewListTaskNexusParamsWithTimeout(timeout time.Duration) *ListTaskNexusParams {\n\n\treturn &ListTaskNexusParams{\n\n\t\ttimeout: timeout,\n\t}\n}", "id": 3882, "concepts": ["struct initialization", "timeout handling", "function definition", "basic function definition"], "_raw_llm_output": "struct initialization, timeout handling, function definition, basic function definition"}
{"seed": "// findInDir looks for a file named name in dir or any of its subdirectories if\n// recurse is true. if recurse is false, scan only the directory dir.\n// If no matching file is found, an empty string is returned.\n//\n// The file SHOULD have the following name, per\n// https://tools.ietf.org/html/rfc7950#section-5.2:\n// module-or-submodule-name ['@' revision-date] '.yang'\n// where revision-date = 4DIGIT \"-\" 2DIGIT \"-\" 2DIGIT\n//\n// If a perfect name match is found, then that file's path is returned.\n// Else if file(s) with otherwise matching names but which contain a\n// revision-date pattern exactly matching the above are found, then path of the\n// one with the latest date is returned.\nfunc findInDir(dir, name string, recurse bool) string {\n\tfis, err := ioutil.ReadDir(dir)\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\n\tvar revisions []string\n\tmname := strings.TrimSuffix(name, \".yang\")\n\tfor _, fi := range fis {\n\t\tswitch {\n\t\tcase !fi.IsDir():\n\t\t\tif fn := fi.Name(); fn == name {\n\t\t\t\treturn filepath.Join(dir, name)\n\t\t\t} else if strings.HasPrefix(fn, mname) && revisionDateSuffixRegex.MatchString(strings.TrimPrefix(fn, mname)) {\n\t\t\t\trevisions = append(revisions, fn)\n\t\t\t}\n\t\tcase recurse:\n\t\t\tif n := findInDir(filepath.Join(dir, fi.Name()), name, recurse); n != \"\" {\n\t\t\t\treturn n\n\t\t\t}\n\t\t}\n\t}\n\tif len(revisions) == 0 {\n\t\treturn \"\"\n\t}\n\tsort.Strings(revisions)\n\treturn filepath.Join(dir, revisions[len(revisions)-1])\n}", "id": 3886, "concepts": ["string manipulation", "string matching", "regexp", "io.ReadDir", "filepath.Join", "filepath.IsDir", "filepath.Walk", "filepath.WalkDir", "filepath.WalkDirFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.Walk"], "_raw_llm_output": "string manipulation, string matching, regexp, io.ReadDir, filepath.Join, filepath.IsDir, filepath.Walk, filepath.WalkDir, filepath.WalkDirFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.Walk"}
{"seed": "// GetStandardChannelRole converts a given string value for role into one of the predefined channel role constants.\nfunc GetStandardChannelRole(role string) string {\n\tswitch role {\n\tcase ChannelRoleMember:\n\t\treturn ChannelRoleMember\n\tcase ChannelRoleCareNav:\n\t\treturn ChannelRoleCareNav\n\tcase ChannelRoleModerator:\n\t\treturn ChannelRoleModerator\n\tcase ChannelRoleTriage:\n\t\treturn ChannelRoleTriage\n\tcase ChannelRoleAutoResponder:\n\t\treturn ChannelRoleAutoResponder\n\tdefault:\n\t\treturn ChannelRoleUnknown\n\t}\n}", "id": 3887, "concepts": ["switch statement", "string comparison", "basic function definition"], "_raw_llm_output": "switch statement, string comparison, basic function definition"}
{"seed": "// SensorFor returns a Sensor for the given ev3 port name and driver. If the\n// sensor driver does not match the driver string, a Sensor for the port\n// is returned with a DriverMismatch error.\n// If port is empty, the first sensor satisfying the driver name is returned.\nfunc SensorFor(port, driver string) (*Sensor, error) {\n\tid, err := deviceIDFor(port, driver, (*Sensor)(nil), -1)\n\tif id == -1 {\n\t\treturn nil, err\n\t}\n\treturn &Sensor{id: id}, err\n}", "id": 3891, "concepts": ["error handling (idiomatic if err != nil)", "error wrapping", "error handling (errors.Is)", "error handling (errors.As)", "error handling (errors.New)", "error handling (errors.Unwrap)", "error handling (errors.Errorf)", "error handling (errors.Wrap)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrap"], "_raw_llm_output": "error handling (idiomatic if err != nil), error wrapping, error handling (errors.Is), error handling (errors.As), error handling (errors.New), error handling (errors.Unwrap), error handling (errors.Errorf), error handling (errors.Wrap), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrap"}
{"seed": "// Iframe represents the HTML element 'iframe'.\n// For more information visit https://www.w3schools.com/tags/tag_iframe.asp.\nfunc Iframe(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"iframe\", Attributes: attrs, Children: children}\n}", "id": 3892, "concepts": ["HTML generation", "HTML tree traversal", "HTML element definition"], "_raw_llm_output": "HTML generation, HTML tree traversal, HTML element definition"}
{"seed": "// DropOptionalHasPrefix applies the HasPrefix predicate on the \"drop_optional\" field.\nfunc DropOptionalHasPrefix(v string) predicate.User {\n\treturn predicate.User(sql.FieldHasPrefix(FieldDropOptional, v))\n}", "id": 3895, "concepts": ["predicate.User", "sql.FieldHasPrefix"], "_raw_llm_output": "predicate.User, sql.FieldHasPrefix"}
{"seed": "// NewBuyDomainRequestWithBody generates requests for BuyDomain with any type of body\nfunc NewBuyDomainRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {\n\tvar err error\n\n\tqueryUrl, err := url.Parse(server)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbasePath := fmt.Sprintf(\"/domain/v2alpha2/domains\")\n\tif basePath[0] == '/' {\n\t\tbasePath = basePath[1:]\n\t}\n\n\tqueryUrl, err = queryUrl.Parse(basePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq, err := http.NewRequest(\"POST\", queryUrl.String(), body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Add(\"Content-Type\", contentType)\n\treturn req, nil\n}", "id": 3897, "concepts": ["http request generation", "url parsing", "url manipulation", "http request body generation"], "_raw_llm_output": "http request generation, url parsing, url manipulation, http request body generation"}
{"seed": "// NewPatientClient returns a client for the Patient from the given config.\nfunc NewPatientClient(c config) *PatientClient {\n\treturn &PatientClient{config: c}\n}", "id": 3901, "concepts": ["struct definition", "struct initialization", "pointer usage", "method definition"], "_raw_llm_output": "struct definition, struct initialization, pointer usage, method definition"}
{"seed": "// NewTokenHasPrefix applies the HasPrefix predicate on the \"new_token\" field.\nfunc NewTokenHasPrefix(v string) predicate.User {\n\treturn predicate.User(sql.FieldHasPrefix(FieldNewToken, v))\n}", "id": 3908, "concepts": ["interface", "function composition", "predicate composition", "predicate composition with function composition"], "_raw_llm_output": "interface, function composition, predicate composition, predicate composition with function composition"}
{"seed": "// ControlSubject returns monitoring subjects used by the Service.\n// Providing a verb is mandatory (it should be one of Ping, Info or Stats).\n// Depending on whether kind and id are provided, ControlSubject will return one of the following:\n//   - verb only: subject used to monitor all available services\n//   - verb and kind: subject used to monitor services with the provided name\n//   - verb, name and id: subject used to monitor an instance of a service with the provided ID\nfunc ControlSubject(verb Verb, name, id string) (string, error) {\n\tverbStr := verb.String()\n\tif verbStr == \"\" {\n\t\treturn \"\", fmt.Errorf(\"%w: %q\", ErrVerbNotSupported, verbStr)\n\t}\n\tif name == \"\" && id != \"\" {\n\t\treturn \"\", ErrServiceNameRequired\n\t}\n\tif name == \"\" && id == \"\" {\n\t\treturn fmt.Sprintf(\"%s.%s\", APIPrefix, verbStr), nil\n\t}\n\tif id == \"\" {\n\t\treturn fmt.Sprintf(\"%s.%s.%s\", APIPrefix, verbStr, name), nil\n\t}\n\treturn fmt.Sprintf(\"%s.%s.%s.%s\", APIPrefix, verbStr, name, id), nil\n}", "id": 3913, "concepts": ["string formatting", "fmt package usage", "error handling (errors.New)", "error wrapping (fmt.Errorf)", "string concatenation", "string comparison", "string manipulation", "string conversion", "string parsing", "string validation", "string formatting", "string interpolation", "string manipulation", "string concatenation", "string comparison", "string conversion", "string parsing", "string validation", "string formatting", "string interpolation", "string manipulation", "string concatenation", "string comparison", "string conversion", "string parsing", "string validation", "string formatting", "string interpolation", "string manipulation", "string concatenation", "string comparison", "string conversion", "string parsing", "string validation", "string formatting", "string interpolation", "string manipulation", "string concatenation", "string comparison", "string conversion", "string parsing", "string validation", "string formatting", "string interpolation", "string manipulation", "string concatenation", "string comparison", "string conversion", "string parsing", "string validation", "string formatting", "string interpolation", "string manipulation", "string concatenation", "string comparison", "string conversion", "string parsing", "string validation", "string formatting", "string interpolation", "string manipulation", "string concatenation", "string comparison", "string conversion", "string parsing", "string validation", "string formatting", "string interpolation", "string manipulation", "string concatenation", "string comparison", "string conversion", "string parsing", "string validation", "string formatting", "string interpolation", "string manipulation", "string concatenation", "string comparison"], "_raw_llm_output": "string formatting, fmt package usage, error handling (errors.New), error wrapping (fmt.Errorf), string concatenation, string comparison, string manipulation, string conversion, string parsing, string validation, string formatting, string interpolation, string manipulation, string concatenation, string comparison, string conversion, string parsing, string validation, string formatting, string interpolation, string manipulation, string concatenation, string comparison, string conversion, string parsing, string validation, string formatting, string interpolation, string manipulation, string concatenation, string comparison, string conversion, string parsing, string validation, string formatting, string interpolation, string manipulation, string concatenation, string comparison, string conversion, string parsing, string validation, string formatting, string interpolation, string manipulation, string concatenation, string comparison, string conversion, string parsing, string validation, string formatting, string interpolation, string manipulation, string concatenation, string comparison, string conversion, string parsing, string validation, string formatting, string interpolation, string manipulation, string concatenation, string comparison, string conversion, string parsing, string validation, string formatting, string interpolation, string manipulation, string concatenation, string comparison, string conversion, string parsing, string validation, string formatting, string interpolation, string manipulation, string concatenation, string comparison"}
{"seed": "// WithEnvVarPrefix tells Parse to try to set flags from environment variables\n// with the given prefix. Flag names are matched to environment variables with\n// the given prefix, followed by an underscore, followed by the capitalized flag\n// names, with separator characters like periods or hyphens replaced with\n// underscores. By default, flags are not set from environment variables at all.\nfunc WithEnvVarPrefix(prefix string) Option {\n\treturn func(c *Context) {\n\t\tc.envVarPrefix = prefix\n\t}\n}", "id": 3918, "concepts": ["struct field access", "string manipulation", "string formatting", "function definition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition"], "_raw_llm_output": "struct field access, string manipulation, string formatting, function definition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition"}
{"seed": "// NewInlineObject26 instantiates a new InlineObject26 object\n// This constructor will assign default values to properties that have it defined,\n// and makes sure properties required by API are set, but the set of arguments\n// will change when the set of required properties is changed\nfunc NewInlineObject26(category MessageCategoriesIdJsonCategory) *InlineObject26 {\n\tthis := InlineObject26{}\n\tthis.Category = category\n\treturn &this\n}", "id": 3919, "concepts": ["constructor", "default values", "API usage"], "_raw_llm_output": "constructor, default values, API usage"}
{"seed": "// DMessageEmbedExistsGP checks if the DMessageEmbed row exists. Panics on error.\nfunc DMessageEmbedExistsGP(id int64) bool {\n\te, err := DMessageEmbedExists(boil.GetDB(), id)\n\tif err != nil {\n\t\tpanic(boil.WrapErr(err))\n\t}\n\n\treturn e\n}", "id": 3920, "concepts": ["database query", "boil package usage"], "_raw_llm_output": "database query, boil package usage"}
{"seed": "// StateIn applies the In predicate on the \"state\" field.\nfunc StateIn(vs ...State) predicate.User {\n\treturn predicate.User(sql.FieldIn(FieldState, vs...))\n}", "id": 3927, "concepts": ["sql.FieldIn", "sql.FieldNotIn", "sql.FieldEq", "sql.FieldNeq", "sql.FieldGt", "sql.FieldGte", "sql.FieldLt", "sql.FieldLte", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldEq", "sql.FieldNeq", "sql.FieldGt", "sql.FieldGte", "sql.FieldLt", "sql.FieldLte", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldEq", "sql.FieldNeq", "sql.FieldGt", "sql.FieldGte", "sql.FieldLt", "sql.FieldLte", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldEq", "sql.FieldNeq", "sql.FieldGt", "sql.FieldGte", "sql.FieldLt", "sql.FieldLte", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldEq", "sql.FieldNeq", "sql.FieldGt", "sql.FieldGte", "sql.FieldLt", "sql."], "_raw_llm_output": "sql.FieldIn, sql.FieldNotIn, sql.FieldEq, sql.FieldNeq, sql.FieldGt, sql.FieldGte, sql.FieldLt, sql.FieldLte, sql.FieldLike, sql.FieldNotLike, sql.FieldIn, sql.FieldNotIn, sql.FieldEq, sql.FieldNeq, sql.FieldGt, sql.FieldGte, sql.FieldLt, sql.FieldLte, sql.FieldLike, sql.FieldNotLike, sql.FieldIn, sql.FieldNotIn, sql.FieldEq, sql.FieldNeq, sql.FieldGt, sql.FieldGte, sql.FieldLt, sql.FieldLte, sql.FieldLike, sql.FieldNotLike, sql.FieldIn, sql.FieldNotIn, sql.FieldEq, sql.FieldNeq, sql.FieldGt, sql.FieldGte, sql.FieldLt, sql.FieldLte, sql.FieldLike, sql.FieldNotLike, sql.FieldIn, sql.FieldNotIn, sql.FieldEq, sql.FieldNeq, sql.FieldGt, sql.FieldGte, sql.FieldLt, sql."}
{"seed": "// NewV1SciNameAndIds instantiates a new V1SciNameAndIds object\n// This constructor will assign default values to properties that have it defined,\n// and makes sure properties required by API are set, but the set of arguments\n// will change when the set of required properties is changed\nfunc NewV1SciNameAndIds() *V1SciNameAndIds {\n\tthis := V1SciNameAndIds{}\n\treturn &this\n}", "id": 3929, "concepts": ["constructor", "default values", "API usage"], "_raw_llm_output": "constructor, default values, API usage"}
{"seed": "// IDLTE applies the LTE predicate on the ID field.\nfunc IDLTE(id string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.LTE(s.C(FieldID), id))\n\t})\n}", "id": 3936, "concepts": ["sql package usage", "sql.Selector usage", "sql.C usage", "sql.LTE usage", "sql.Where usage"], "_raw_llm_output": "sql package usage, sql.Selector usage, sql.C usage, sql.LTE usage, sql.Where usage"}
{"seed": "// NewNameLTE applies the LTE predicate on the \"new_name\" field.\nfunc NewNameLTE(v string) predicate.User {\n\treturn predicate.User(sql.FieldLTE(FieldNewName, v))\n}", "id": 3941, "concepts": ["sql package usage", "predicate.User", "sql.FieldLTE"], "_raw_llm_output": "sql package usage, predicate.User, sql.FieldLTE"}
{"seed": "// PossiblePreflightOptionValues returns the possible values for the PreflightOption const type.\nfunc PossiblePreflightOptionValues() []PreflightOption {\n\treturn []PreflightOption{\n\t\tPreflightOptionContinueDeploymentOnFailure,\n\t\tPreflightOptionDefaultValidationOnly,\n\t\tPreflightOptionNone,\n\t}\n}", "id": 3951, "concepts": ["enumerations", "const", "type definition"], "_raw_llm_output": "enumerations, const, type definition"}
{"seed": "// NewAlertingEventTypeFilter instantiates a new AlertingEventTypeFilter object\n// This constructor will assign default values to properties that have it defined,\n// and makes sure properties required by API are set, but the set of arguments\n// will change when the set of required properties is changed\nfunc NewAlertingEventTypeFilter() *AlertingEventTypeFilter {\n\tthis := AlertingEventTypeFilter{}\n\treturn &this\n}", "id": 3955, "concepts": ["constructor", "default values", "API usage"], "_raw_llm_output": "constructor, default values, API usage"}
{"seed": "// NewImportProviderDNSZoneRequestWithBody generates requests for ImportProviderDNSZone with any type of body\nfunc NewImportProviderDNSZoneRequestWithBody(server string, dnsZone string, contentType string, body io.Reader) (*http.Request, error) {\n\tvar err error\n\n\tvar pathParam0 string\n\n\tpathParam0, err = runtime.StyleParam(\"simple\", false, \"dns_zone\", dnsZone)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tqueryUrl, err := url.Parse(server)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbasePath := fmt.Sprintf(\"/domain/v2alpha2/dns-zones/%s/import-provider\", pathParam0)\n\tif basePath[0] == '/' {\n\t\tbasePath = basePath[1:]\n\t}\n\n\tqueryUrl, err = queryUrl.Parse(basePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq, err := http.NewRequest(\"POST\", queryUrl.String(), body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Add(\"Content-Type\", contentType)\n\treturn req, nil\n}", "id": 3956, "concepts": ["URL parsing", "URL query string handling", "URL path parameter handling", "HTTP request generation"], "_raw_llm_output": "URL parsing, URL query string handling, URL path parameter handling, HTTP request generation"}
{"seed": "// New returns a proxy with the given configuration source.\n//\n// The ConfigWatcher can be used to update the configuration of the proxy.\n// Whenever a new configuration is detected, the proxy will reconfigure itself.\nfunc New(client *api.Client, cw ConfigWatcher, logger *log.Logger) (*Proxy, error) {\n\treturn &Proxy{\n\t\tclient:     client,\n\t\tcfgWatcher: cw,\n\t\tstopChan:   make(chan struct{}),\n\t\tlogger:     logger,\n\t}, nil\n}", "id": 3962, "concepts": ["struct definition", "method definition", "anonymous struct", "method receiver", "method call", "pointer receiver", "method chaining", "method return value", "method return value (error)", "method return value (error)", "method return value (error)", "method return value (error)", "method return value (error)", "method return value (error)", "method return value (error)", "method return value (error)", "method return value (error)", "method return value (error)", "method return value (error)", "method return value (error)", "method return value (error)", "method return value (error)", "method return value (error)", "method return value (error)", "method return value (error)", "method return value (error)", "method return value (error)", "method return value (error)", "method return value (error)", "method return value (error)", "method return value (error)", "method return value (error)", "method return value (error)", "method return value (error)", "method return value (error)", "method return value (error)", "method return value (error)", "method return value (error)", "method return value (error)", "method return value (error)", "method return value (error)", "method return value (error)", "method return value (error)", "method return value (error)", "method return value (error)", "method return value (error)", "method return"], "_raw_llm_output": "struct definition, method definition, anonymous struct, method receiver, method call, pointer receiver, method chaining, method return value, method return value (error), method return value (error), method return value (error), method return value (error), method return value (error), method return value (error), method return value (error), method return value (error), method return value (error), method return value (error), method return value (error), method return value (error), method return value (error), method return value (error), method return value (error), method return value (error), method return value (error), method return value (error), method return value (error), method return value (error), method return value (error), method return value (error), method return value (error), method return value (error), method return value (error), method return value (error), method return value (error), method return value (error), method return value (error), method return value (error), method return value (error), method return value (error), method return value (error), method return value (error), method return value (error), method return value (error), method return value (error), method return value (error), method return"}
{"seed": "// NewPcloudSapGetParamsWithHTTPClient creates a new PcloudSapGetParams object\n// with the ability to set a custom HTTPClient for a request.\nfunc NewPcloudSapGetParamsWithHTTPClient(client *http.Client) *PcloudSapGetParams {\n\treturn &PcloudSapGetParams{\n\t\tHTTPClient: client,\n\t}\n}", "id": 3978, "concepts": ["struct definition", "pointer usage", "method definition", "HTTPClient usage"], "_raw_llm_output": "struct definition, pointer usage, method definition, HTTPClient usage"}
{"seed": "// NewCancelWorkflowExecutionParamsWithContext creates a new CancelWorkflowExecutionParams object\n// with the default values initialized, and the ability to set a context for a request\nfunc NewCancelWorkflowExecutionParamsWithContext(ctx context.Context) *CancelWorkflowExecutionParams {\n\tvar ()\n\treturn &CancelWorkflowExecutionParams{\n\n\t\tContext: ctx,\n\t}\n}", "id": 3984, "concepts": ["context package usage", "struct initialization"], "_raw_llm_output": "context package usage, struct initialization"}
{"seed": "// NewTimeLineServiceJSONClient creates a JSON client that implements the TimeLineService interface.\n// It communicates using JSON and can be configured with a custom HTTPClient.\nfunc NewTimeLineServiceJSONClient(addr string, client HTTPClient) TimeLineService {\n\tprefix := urlBase(addr) + TimeLineServicePathPrefix\n\turls := [2]string{\n\t\tprefix + \"GetTimeLine\",\n\t\tprefix + \"GetSubscribedTimeLine\",\n\t}\n\tif httpClient, ok := client.(*http.Client); ok {\n\t\treturn &timeLineServiceJSONClient{\n\t\t\tclient: withoutRedirects(httpClient),\n\t\t\turls:   urls,\n\t\t}\n\t}\n\treturn &timeLineServiceJSONClient{\n\t\tclient: client,\n\t\turls:   urls,\n\t}\n}", "id": 3999, "concepts": ["interface implementation", "HTTPClient interface", "HTTPClient implementation", "HTTPClient usage", "URL manipulation", "string manipulation", "JSON encoding/decoding", "standard library usage"], "_raw_llm_output": "interface implementation, HTTPClient interface, HTTPClient implementation, HTTPClient usage, URL manipulation, string manipulation, JSON encoding/decoding, standard library usage"}
{"seed": "// NewUpdateZoneProjectsUsingPUTParamsWithTimeout creates a new UpdateZoneProjectsUsingPUTParams object\n// with the ability to set a timeout on a request.\nfunc NewUpdateZoneProjectsUsingPUTParamsWithTimeout(timeout time.Duration) *UpdateZoneProjectsUsingPUTParams {\n\treturn &UpdateZoneProjectsUsingPUTParams{\n\t\ttimeout: timeout,\n\t}\n}", "id": 4000, "concepts": ["timeout handling", "time.Duration", "basic function definition"], "_raw_llm_output": "timeout handling, time.Duration, basic function definition"}
{"seed": "// Draw adds the given renderable to the global draw stack.\n//\n// If the draw stack has only one stackable, the item will be added to that\n// stackable with the input layers as its argument. Otherwise, the item will be added\n// to the layers[0]th stackable, with remaining layers supplied to the stackable\n// as arguments.\n//\n// If zero layers are provided, it will add to the zeroth stack layer and\n// give nothing to the stackable's argument.\nfunc Draw(r Renderable, layers ...int) (Renderable, error) {\n\treturn GlobalDrawStack.Draw(r, layers...)\n}", "id": 4013, "concepts": ["method definition", "method receiver", "method argument", "method return value", "method chaining", "method composition", "method overriding", "method overloading", "method overriding", "method chaining", "method composition", "method overriding", "method overloading", "method chaining", "method composition", "method overriding", "method overloading", "method chaining", "method composition", "method overriding", "method overloading", "method chaining", "method composition", "method overriding", "method overloading", "method chaining", "method composition", "method overriding", "method overloading", "method chaining", "method composition", "method overriding", "method overloading", "method chaining", "method composition", "method overriding", "method overloading", "method chaining", "method composition", "method overriding", "method overloading", "method chaining", "method composition", "method overriding", "method overloading", "method chaining", "method composition", "method overriding", "method overloading", "method chaining", "method composition", "method overriding", "method overloading", "method chaining", "method composition", "method overriding", "method overloading", "method chaining", "method composition", "method overriding", "method overloading", "method chaining", "method composition", "method overriding", "method overloading", "method chaining", "method composition", "method overriding", "method overloading", "method chaining", "method composition", "method overriding", "method overloading", "method chaining", "method composition", "method overriding", "method overloading", "method chaining", "method composition"], "_raw_llm_output": "method definition, method receiver, method argument, method return value, method chaining, method composition, method overriding, method overloading, method overriding, method chaining, method composition, method overriding, method overloading, method chaining, method composition, method overriding, method overloading, method chaining, method composition, method overriding, method overloading, method chaining, method composition, method overriding, method overloading, method chaining, method composition, method overriding, method overloading, method chaining, method composition, method overriding, method overloading, method chaining, method composition, method overriding, method overloading, method chaining, method composition, method overriding, method overloading, method chaining, method composition, method overriding, method overloading, method chaining, method composition, method overriding, method overloading, method chaining, method composition, method overriding, method overloading, method chaining, method composition, method overriding, method overloading, method chaining, method composition, method overriding, method overloading, method chaining, method composition, method overriding, method overloading, method chaining, method composition, method overriding, method overloading, method chaining, method composition, method overriding, method overloading, method chaining, method composition, method overriding, method overloading, method chaining, method composition"}
{"seed": "// GetProject returns project ID by prioritizing the value from OvfImportTestProperties.\n// If not set, the value from testconfig.Project is used\nfunc GetProject(props *OvfImportTestProperties, testProjectConfig *testconfig.Project) string {\n\tif props.Project != \"\" {\n\t\treturn props.Project\n\t}\n\treturn testProjectConfig.TestProjectID\n}", "id": 4022, "concepts": ["struct", "map", "string manipulation"], "_raw_llm_output": "struct, map, string manipulation"}
{"seed": "// IsTypeInterface reports whether v is an interface.\nfunc IsTypeInterface(t reflect.Type) bool {\n\tif t == reflect.TypeOf(nil) {\n\t\treturn false\n\t}\n\treturn t.Kind() == reflect.Interface\n}", "id": 4023, "concepts": ["reflect package usage", "type checking"], "_raw_llm_output": "reflect package usage, type checking"}
{"seed": "// fixedInt26ToFloat converts a fixed int 26:6 precision to a float32.\nfunc fixedInt26ToFloat(fixedInt fixed.Int26_6) float32 {\n\tvar result float32\n\ti := int32(fixedInt)\n\tresult += float32(i >> 6)\n\tresult += float32(i&0x003F) / float32(64.0)\n\treturn result\n}", "id": 4025, "concepts": ["bitwise operations", "integer division", "integer shifting", "integer masking"], "_raw_llm_output": "bitwise operations, integer division, integer shifting, integer masking"}
{"seed": "// PossibleDataLakeAnalyticsAccountStatusValues returns an array of possible values for the DataLakeAnalyticsAccountStatus const type.\nfunc PossibleDataLakeAnalyticsAccountStatusValues() []DataLakeAnalyticsAccountStatus {\n\treturn []DataLakeAnalyticsAccountStatus{Canceled, Creating, Deleted, Deleting, Failed, Patching, Resuming, Running, Succeeded, Suspending, Undeleting}\n}", "id": 4033, "concepts": ["array", "const type", "array iteration"], "_raw_llm_output": "array, const type, array iteration"}
{"seed": "// TestFrontMatterKeywords tests if keywords are present and correctly\n// formatted in all published markdown frontmatters.\nfunc TestFrontMatterKeywords(t *testing.T) {\n\tfilepath.Walk(\"/docs\", func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\tt.Error(err.Error(), \"-\", path)\n\t\t}\n\t\tpublished, mdBytes, err := isPublishedMarkdown(path)\n\t\tif err != nil {\n\t\t\tt.Error(err.Error(), \"-\", path)\n\t\t}\n\t\tif published == false {\n\t\t\treturn nil\n\t\t}\n\t\terr = testFrontMatterKeywords(mdBytes)\n\t\tif err != nil {\n\t\t\tt.Error(err.Error(), \"-\", path)\n\t\t}\n\t\treturn nil\n\t})\n}", "id": 4040, "concepts": ["file system traversal", "file reading", "frontmatter parsing", "testing", "error handling"], "_raw_llm_output": "file system traversal, file reading, frontmatter parsing, testing, error handling"}
{"seed": "// FanOutIn is useful to quickly parallelize a group of tasks.\n//\n// You pass it a function which is expected to push simple `func() error`\n// closures into the provided chan. Each function will be executed in parallel\n// and their error results will be collated.\n//\n// The function blocks until all functions are executed, and an\n// errors.MultiError is returned if one or more of your fan-out tasks failed,\n// otherwise this function returns nil.\nfunc FanOutIn(gen func(chan<- func() error)) error {\n\tfunchan := make(chan func() error)\n\tgo func() {\n\t\tdefer close(funchan)\n\t\tgen(funchan)\n\t}()\n\n\terrchan := make(chan error)\n\tgrp := sync.WaitGroup{}\n\tfor fn := range funchan {\n\t\tgrp.Add(1)\n\t\tfn := fn\n\t\tgo func() {\n\t\t\tdefer grp.Done()\n\t\t\tif err := fn(); err != nil {\n\t\t\t\terrchan <- err\n\t\t\t}\n\t\t}()\n\t}\n\tgo func() {\n\t\tgrp.Wait()\n\t\tclose(errchan)\n\t}()\n\treturn errors.MultiErrorFromErrors(errchan)\n}", "id": 4051, "concepts": ["fan-out", "fan-in", "sync.WaitGroup", "sync.Mutex", "error handling", "concurrency", "standard library usage"], "_raw_llm_output": "fan-out, fan-in, sync.WaitGroup, sync.Mutex, error handling, concurrency, standard library usage"}
{"seed": "// NewGeoipConfig2 instantiates a new GeoipConfig2 object\n// This constructor will assign default values to properties that have it defined,\n// and makes sure properties required by API are set, but the set of arguments\n// will change when the set of required properties is changed\nfunc NewGeoipConfig2(type_ TypeType, name string) *GeoipConfig2 {\n\tthis := GeoipConfig2{}\n\tthis.Type = type_\n\tthis.Name = name\n\treturn &this\n}", "id": 4059, "concepts": ["constructor", "method definition", "type definition", "struct definition", "method invocation", "method chaining"], "_raw_llm_output": "constructor, method definition, type definition, struct definition, method invocation, method chaining"}
{"seed": "// indirect returns the value that v points to, or concrete\n// element underlying an interface.\nfunc indirect(v reflect.Value) reflect.Value {\nloop:\n\tfor v.IsValid() {\n\t\tswitch av := v; av.Kind() {\n\t\tcase reflect.Ptr:\n\t\t\tv = av.Elem()\n\t\tcase reflect.Interface:\n\t\t\tv = av.Elem()\n\t\tdefault:\n\t\t\tbreak loop\n\t\t}\n\t}\n\treturn v\n}", "id": 4062, "concepts": ["reflection", "pointer handling", "interface handling"], "_raw_llm_output": "reflection, pointer handling, interface handling"}
{"seed": "// IndexOfDoubleByteToken gets the index of the double-byte token with the given string value.\n// If there's no token with the given value, the third return value will be false.\nfunc IndexOfDoubleByteToken(token string) (byte, byte, bool) {\n\tval, ok := mdDoubleByteTokenIndex[token]\n\treturn val.dictionary, val.index, ok\n}", "id": 4073, "concepts": ["map iteration", "map lookup", "map value access", "map key access"], "_raw_llm_output": "map iteration, map lookup, map value access, map key access"}
{"seed": "// stack returns a formatted stack trace of all goroutines\n// It calls runtime.Stack with a large enough buffer to capture the entire trace.\nfunc stack() []byte {\n\tbuf := make([]byte, 1024)\n\tfor {\n\t\tn := runtime.Stack(buf, true)\n\t\tif n < len(buf) {\n\t\t\treturn buf[:n]\n\t\t}\n\t\tbuf = make([]byte, 2*len(buf))\n\t}\n}", "id": 4078, "concepts": ["runtime.Stack", "runtime.Goroutine", "stack trace"], "_raw_llm_output": "runtime.Stack, runtime.Goroutine, stack trace"}
{"seed": "// NewState creates a new state for Ops to work on.\n// It stores variables, flags and anything that necessary\n// for transformation steps to persist data.\nfunc NewState() *State {\n\treturn &State{}\n}", "id": 4081, "concepts": ["struct definition", "struct field definition", "struct initialization"], "_raw_llm_output": "struct definition, struct field definition, struct initialization"}
{"seed": "// I logs message under tag with priority PriorityInfo to w.\nfunc I(w Writer, tag Tag, message string) error {\n\treturn w.Write(PriorityInfo, tag, message)\n}", "id": 4093, "concepts": ["interface", "method definition", "method implementation"], "_raw_llm_output": "interface, method definition, method implementation"}
{"seed": "// Thead_ is a convenience wrapper for Thead without the attrs argument.\nfunc Thead_(children ...HTML) HTML {\n  return Thead(nil, children...)\n}", "id": 4102, "concepts": ["HTML struct definition", "anonymous function", "struct field definition", "function definition", "function call", "function return"], "_raw_llm_output": "HTML struct definition, anonymous function, struct field definition, function definition, function call, function return"}
{"seed": "// NewMessageCard creates a new message card with fields required by the\n// legacy message card format already predefined\nfunc NewMessageCard() MessageCard {\n\t// define expected values to meet Office 365 Connector card requirements\n\t// https://docs.microsoft.com/en-us/outlook/actionable-messages/message-card-reference#card-fields\n\tmsgCard := MessageCard{\n\t\tType:    \"MessageCard\",\n\t\tContext: \"https://schema.org/extensions\",\n\t}\n\n\treturn msgCard\n}", "id": 4107, "concepts": ["struct definition", "struct field definition", "basic function definition"], "_raw_llm_output": "struct definition, struct field definition, basic function definition"}
{"seed": "// BytesString returns a string representation of the hash that is represented in bytes.\nfunc BytesString(hash []byte) string {\n\treturn fmt.Sprintf(\"%X\", hash)\n}", "id": 4116, "concepts": ["string formatting", "fmt package usage"], "_raw_llm_output": "string formatting, fmt package usage"}
{"seed": "// UPCEANReader_decodeDigit Attempts to decode a single UPC/EAN-encoded digit.\n//\n// @param row row of black/white values to decode\n// @param counters the counts of runs of observed black/white/black/... values\n// @param rowOffset horizontal offset to start decoding from\n// @param patterns the set of patterns to use to decode -- sometimes different encodings\n// for the digits 0-9 are used, and this indicates the encodings for 0 to 9 that should\n// be used\n// @return horizontal offset of first pixel beyond the decoded digit\n// @throws NotFoundException if digit cannot be decoded\nfunc upceanReader_decodeDigit(row *gozxing.BitArray, counters []int, rowOffset int, patterns [][]int) (int, error) {\n\te := RecordPattern(row, rowOffset, counters)\n\tif e != nil {\n\t\treturn 0, e\n\t}\n\tbestVariance := UPCEANReader_MAX_AVG_VARIANCE // worst variance we'll accept\n\tbestMatch := -1\n\tmax := len(patterns)\n\tfor i := 0; i < max; i++ {\n\t\tpattern := patterns[i]\n\t\tvariance := PatternMatchVariance(counters, pattern, UPCEANReader_MAX_INDIVIDUAL_VARIANCE)\n\t\tif variance < bestVariance {\n\t\t\tbestVariance = variance\n\t\t\tbestMatch = i\n\t\t}\n\t}\n\tif bestMatch < 0 {\n\t\treturn 0, gozxing.NewNotFoundException()\n\t}\n\treturn bestMatch, nil\n}", "id": 4122, "concepts": ["error handling (gozxing.NewNotFoundException)", "integer division", "integer summation", "slice iteration (range loop)", "array indexing", "array iteration (range loop)", "array manipulation", "slice manipulation", "slice iteration (range loop)", "slice manipulation", "slice iteration (range loop)", "slice manipulation", "slice iteration (range loop)", "slice manipulation", "slice iteration (range loop)", "slice manipulation", "slice iteration (range loop)", "slice manipulation", "slice iteration (range loop)", "slice manipulation", "slice iteration (range loop)", "slice manipulation", "slice iteration (range loop)", "slice manipulation", "slice iteration (range loop)", "slice manipulation", "slice iteration (range loop)", "slice manipulation", "slice iteration (range loop)", "slice manipulation", "slice iteration (range loop)", "slice manipulation", "slice iteration (range loop)", "slice manipulation", "slice iteration (range loop)", "slice manipulation", "slice iteration (range loop)", "slice manipulation", "slice iteration (range loop)", "slice manipulation", "slice iteration (range loop)", "slice manipulation", "slice iteration (range loop)", "slice manipulation", "slice iteration (range loop)", "slice manipulation", "slice iteration (range loop)", "slice manipulation", "slice iteration (range loop)", "slice manipulation", "slice iteration (range loop)", "slice manipulation", "slice iteration (range loop)", "slice manipulation", "slice iteration (range loop)", "slice manipulation", ""], "_raw_llm_output": "error handling (gozxing.NewNotFoundException), integer division, integer summation, slice iteration (range loop), array indexing, array iteration (range loop), array manipulation, slice manipulation, slice iteration (range loop), slice manipulation, slice iteration (range loop), slice manipulation, slice iteration (range loop), slice manipulation, slice iteration (range loop), slice manipulation, slice iteration (range loop), slice manipulation, slice iteration (range loop), slice manipulation, slice iteration (range loop), slice manipulation, slice iteration (range loop), slice manipulation, slice iteration (range loop), slice manipulation, slice iteration (range loop), slice manipulation, slice iteration (range loop), slice manipulation, slice iteration (range loop), slice manipulation, slice iteration (range loop), slice manipulation, slice iteration (range loop), slice manipulation, slice iteration (range loop), slice manipulation, slice iteration (range loop), slice manipulation, slice iteration (range loop), slice manipulation, slice iteration (range loop), slice manipulation, slice iteration (range loop), slice manipulation, slice iteration (range loop), slice manipulation, slice iteration (range loop), slice manipulation, slice iteration (range loop), slice manipulation, slice iteration (range loop), slice manipulation, slice iteration (range loop), slice manipulation,"}
{"seed": "// AssertNCHandleUplinkMetaDataRequest asserts the given uplink meta-data request.\nfunc AssertNCHandleUplinkMetaDataRequest(req nc.HandleUplinkMetaDataRequest) Assertion {\n\treturn func(assert *require.Assertions, ts *IntegrationTestSuite) {\n\t\tr := <-ts.NCClient.HandleUplinkMetaDataChan\n\t\tif !proto.Equal(&r, &req) {\n\t\t\tassert.Equal(req, r)\n\t\t}\n\t}\n}", "id": 4139, "concepts": ["proto package usage", "proto.Equal", "channel handling"], "_raw_llm_output": "proto package usage, proto.Equal, channel handling"}
{"seed": "// jsonMarshalFileTmp marshals v to the temporary file p + \".*.tmp\" and\n// returns the file name.\n//\n// Note: .tmp is the same suffix used by Builder. indexserver knows to clean\n// them up.\nfunc jsonMarshalTmpFile(v interface{}, p string) (_ string, err error) {\n\tb, err := json.Marshal(v)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tf, err := ioutil.TempFile(filepath.Dir(p), filepath.Base(p)+\".*.tmp\")\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer func() {\n\t\tf.Close()\n\t\tif err != nil {\n\t\t\t_ = os.Remove(f.Name())\n\t\t}\n\t}()\n\n\tif err := f.Chmod(0o666 &^ umask); err != nil {\n\t\treturn \"\", err\n\t}\n\tif _, err := f.Write(b); err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn f.Name(), f.Close()\n}", "id": 4141, "concepts": ["ioutil.TempFile", "ioutil.WriteFile", "os.Remove", "os.Chmod", "os.File.Write", "os.File.Close", "os.File.Name", "json.Marshal", "json.Unmarshal", "os.Open", "os.Stat", "os.Create", "os.Mkdir", "os.MkdirAll", "os.RemoveAll", "os.IsNotExist", "os.IsPermission", "os.IsExist", "os.IsPathSeparator", "os.IsPathSeparator", "os.IsPathSeparator", "os.IsPathSeparator", "os.IsPathSeparator", "os.IsPathSeparator", "os.IsPathSeparator", "os.IsPathSeparator", "os.IsPathSeparator", "os.IsPathSeparator", "os.IsPathSeparator", "os.IsPathSeparator", "os.IsPathSeparator", "os.IsPathSeparator", "os.IsPathSeparator", "os.IsPathSeparator", "os.IsPathSeparator", "os.IsPathSeparator", "os.IsPathSeparator", "os.IsPathSeparator", "os.IsPathSeparator", "os.IsPathSeparator", "os.IsPathSeparator", "os.IsPathSeparator", "os.IsPathSeparator", "os.IsPathSeparator", "os.IsPathSeparator", "os.IsPathSeparator", "os."], "_raw_llm_output": "ioutil.TempFile, ioutil.WriteFile, os.Remove, os.Chmod, os.File.Write, os.File.Close, os.File.Name, json.Marshal, json.Unmarshal, os.Open, os.Stat, os.Create, os.Mkdir, os.MkdirAll, os.RemoveAll, os.IsNotExist, os.IsPermission, os.IsExist, os.IsPathSeparator, os.IsPathSeparator, os.IsPathSeparator, os.IsPathSeparator, os.IsPathSeparator, os.IsPathSeparator, os.IsPathSeparator, os.IsPathSeparator, os.IsPathSeparator, os.IsPathSeparator, os.IsPathSeparator, os.IsPathSeparator, os.IsPathSeparator, os.IsPathSeparator, os.IsPathSeparator, os.IsPathSeparator, os.IsPathSeparator, os.IsPathSeparator, os.IsPathSeparator, os.IsPathSeparator, os.IsPathSeparator, os.IsPathSeparator, os.IsPathSeparator, os.IsPathSeparator, os.IsPathSeparator, os.IsPathSeparator, os.IsPathSeparator, os.IsPathSeparator, os."}
{"seed": "// BufferEQ applies the EQ predicate on the \"buffer\" field.\nfunc BufferEQ(v []byte) predicate.User {\n\treturn predicate.User(sql.FieldEQ(FieldBuffer, v))\n}", "id": 4156, "concepts": ["predicate.User", "sql.FieldEQ", "byte slice"], "_raw_llm_output": "predicate.User, sql.FieldEQ, byte slice"}
{"seed": "// NewRandInt32 generates a new random int32 number or an error in case of\n// entropy exhaustion\nfunc NewRandInt32() (int32, error) {\n\tvar b [4]byte\n\t_, err := rand.Read(b[:])\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn int32(uint32(b[0]) | uint32(b[1])<<8 | uint32(b[2])<<16 | uint32(b[3])<<24), nil\n}", "id": 4158, "concepts": ["cryptography", "random number generation", "error handling"], "_raw_llm_output": "cryptography, random number generation, error handling"}
{"seed": "// BetterHeroScoreNEQ applies the NEQ predicate on the \"better_hero_score\" field.\nfunc BetterHeroScoreNEQ(v int) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldBetterHeroScore), v))\n\t})\n}", "id": 4164, "concepts": ["sql.Selector", "sql.NEQ", "sql.C", "sql.Where", "predicate.User", "sql.FieldBetterHeroScore"], "_raw_llm_output": "sql.Selector, sql.NEQ, sql.C, sql.Where, predicate.User, sql.FieldBetterHeroScore"}
{"seed": "// interarrivalAnalysis returns the maximum likelihood estimated\n// distribution for the times between events and the Anderson-Darling\n// test for how closely the data matches this distribution. ad will be\n// nil if there is no time between any of the events.\n//\n// events must be strictly monotonically increasing.\nfunc interarrivalAnalysis(events []int) (mle *GeometricDist, ad *AndersonDarlingTestResult) {\n\tinterarrivalTimes := make([]int, len(events)-1)\n\tsum := 0\n\tfor i := 0; i < len(events)-1; i++ {\n\t\tdelta := events[i+1] - events[i] - 1\n\t\tinterarrivalTimes[i] = delta\n\t\tsum += delta\n\t}\n\n\t// Compute maximum likelihood estimate of geometric\n\t// distribution underlying interarrivalTimes.\n\tmle = &GeometricDist{P: float64(len(interarrivalTimes)) / float64(len(interarrivalTimes)+sum)}\n\tif mle.P == 1 {\n\t\t// This happens if there are no gaps between events.\n\t\t// In this case Anderson-Darling is undefined because\n\t\t// the CDF is 1.\n\t\treturn\n\t}\n\n\t// Compute Anderson-Darling goodness-of-fit for the observed\n\t// distribution against the theoretical distribution.\n\tvar err error\n\tad, err = AndersonDarlingTest(interarrivalTimes, mle)\n\tif err != nil {\n\t\tlog.Fatal(\"Anderson-Darling test failed: \", err)\n\t}\n\n\treturn\n}", "id": 4167, "concepts": ["slice iteration (range loop)", "integer summation", "basic function definition", "struct definition", "pointer usage", "error handling"], "_raw_llm_output": "slice iteration (range loop), integer summation, basic function definition, struct definition, pointer usage, error handling"}
{"seed": "// NewMacOSMinimumOperatingSystem instantiates a new macOSMinimumOperatingSystem and sets the default values.\nfunc NewMacOSMinimumOperatingSystem()(*MacOSMinimumOperatingSystem) {\n    m := &MacOSMinimumOperatingSystem{\n    }\n    m.backingStore = ie8677ce2c7e1b4c22e9c3827ecd078d41185424dd9eeb92b7d971ed2d49a392e.BackingStoreFactoryInstance();\n    m.SetAdditionalData(make(map[string]any))\n    return m\n}", "id": 4173, "concepts": ["struct definition", "map definition", "map iteration", "map key access", "map value access", "map value update", "map value deletion", "map value assignment", "map value type conversion", "map value type assertion", "map value type switch", "map value type switch case", "map value type switch default", "map value type switch fallthrough", "map value type switch break", "map value type switch continue", "map value type switch return", "map value type switch fallthrough", "map value type switch break", "map value type switch continue", "map value type switch return", "map value type switch fallthrough", "map value type switch break", "map value type switch continue", "map value type switch return", "map value type switch fallthrough", "map value type switch break", "map value type switch continue", "map value type switch return", "map value type switch fallthrough", "map value type switch break", "map value type switch continue", "map value type switch return", "map value type switch fallthrough", "map value type switch break", "map value type switch continue", "map value type switch return", "map value type switch fallthrough", "map value type switch break", "map value type switch continue", "map value type switch return", "map value type switch fallthrough", "map value type switch break", "map value type switch continue", "map value type switch return"], "_raw_llm_output": "struct definition, map definition, map iteration, map key access, map value access, map value update, map value deletion, map value assignment, map value type conversion, map value type assertion, map value type switch, map value type switch case, map value type switch default, map value type switch fallthrough, map value type switch break, map value type switch continue, map value type switch return, map value type switch fallthrough, map value type switch break, map value type switch continue, map value type switch return, map value type switch fallthrough, map value type switch break, map value type switch continue, map value type switch return, map value type switch fallthrough, map value type switch break, map value type switch continue, map value type switch return, map value type switch fallthrough, map value type switch break, map value type switch continue, map value type switch return, map value type switch fallthrough, map value type switch break, map value type switch continue, map value type switch return, map value type switch fallthrough, map value type switch break, map value type switch continue, map value type switch return, map value type switch fallthrough, map value type switch break, map value type switch continue, map value type switch return"}
{"seed": "// SocialNameEQ applies the EQ predicate on the \"social_name\" field.\nfunc SocialNameEQ(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldSocialName), v))\n\t})\n}", "id": 4182, "concepts": ["sql.Selector", "sql.EQ", "sql.C", "predicate.User", "anonymous function", "function definition"], "_raw_llm_output": "sql.Selector, sql.EQ, sql.C, predicate.User, anonymous function, function definition"}
{"seed": "// NewOperationroomClient returns a client for the Operationroom from the given config.\nfunc NewOperationroomClient(c config) *OperationroomClient {\n\treturn &OperationroomClient{config: c}\n}", "id": 4210, "concepts": ["struct definition", "struct field access", "basic function definition"], "_raw_llm_output": "struct definition, struct field access, basic function definition"}
{"seed": "// Bdo represents the HTML element 'bdo'.\n// For more information visit https://www.w3schools.com/tags/tag_bdo.asp.\nfunc Bdo(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"bdo\", Attributes: attrs, Children: children}\n}", "id": 4218, "concepts": ["HTML generation", "HTML generation with attributes", "HTML generation with children"], "_raw_llm_output": "HTML generation, HTML generation with attributes, HTML generation with children"}
{"seed": "// PrivateLinkServiceConnectionState_STATUSGenerator returns a generator of PrivateLinkServiceConnectionState_STATUS instances for property testing.\nfunc PrivateLinkServiceConnectionState_STATUSGenerator() gopter.Gen {\n\tif privateLinkServiceConnectionState_STATUSGenerator != nil {\n\t\treturn privateLinkServiceConnectionState_STATUSGenerator\n\t}\n\n\tgenerators := make(map[string]gopter.Gen)\n\tAddIndependentPropertyGeneratorsForPrivateLinkServiceConnectionState_STATUS(generators)\n\tprivateLinkServiceConnectionState_STATUSGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServiceConnectionState_STATUS{}), generators)\n\n\treturn privateLinkServiceConnectionState_STATUSGenerator\n}", "id": 4223, "concepts": ["struct", "map", "reflect", "property testing", "generator"], "_raw_llm_output": "struct, map, reflect, property testing, generator"}
{"seed": "// Meet in the middle algorithm: docs/meet-in-the-middle.md\n\n// NewerRevisionsToVerify returns a list of revisions to perform append-only verifications against.\n// The relying party / sender is assured that if there is an entity running the\n// OlderRevisionsToVerify algorithm, they will have at least one revision in\n// common.\n//\n// `created` is the (earliest) revision a data item was found in the map.\n//    It is OK to use the revision at which an item was fetched, but the\n//    algorithm will be more efficient if it starts with the revision at which\n//    an item was submitted to the map.\n// `verified` is the latest revision of a successfully verified consistency proof by this client.\n//    When verified > created, previously verified revisions are omitted from the results.\n// `current` is the current revision of the map. Selected revisions will be <= current.\nfunc NewerRevisionsToVerify(created, current, verified uint64) []uint64 {\n\tret := []uint64{} // b[i] = b-b mod 2\u2071+ 2\u2071\n\tif created < 1 {\n\t\tcreated = 1 // Revision 0 is empty.\n\t}\n\tfor r := created; r <= current; r = next(r) {\n\t\tif r <= verified {\n\t\t\tcontinue\n\t\t}\n\t\tret = append(ret, r)\n\t}\n\treturn ret\n}", "id": 4230, "concepts": ["integer arithmetic", "bitwise operations", "slice iteration (range loop)", "basic function definition"], "_raw_llm_output": "integer arithmetic, bitwise operations, slice iteration (range loop), basic function definition"}
{"seed": "// CreateAmazonResourceEvidenceFromDiscriminatorValue creates a new instance of the appropriate class based on discriminator value\nfunc CreateAmazonResourceEvidenceFromDiscriminatorValue(parseNode i878a80d2330e89d26896388a3f487eef27b0a0e6c010c493bf80be1452208f91.ParseNode)(i878a80d2330e89d26896388a3f487eef27b0a0e6c010c493bf80be1452208f91.Parsable, error) {\n    return NewAmazonResourceEvidence(), nil\n}", "id": 4233, "concepts": ["interface implementation", "interface definition", "interface usage", "type assertion"], "_raw_llm_output": "interface implementation, interface definition, interface usage, type assertion"}
{"seed": "// isDeployedWithinK8s returns true if the adapter is running\n// inside a kubernetes cluster\nfunc isDeployedWithinK8s() bool {\n\treturn os.Getenv(\"KUBERNETES_SERVICE_HOST\") != \"\"\n}", "id": 4234, "concepts": ["environment variable usage", "string comparison"], "_raw_llm_output": "environment variable usage, string comparison"}
{"seed": "// RemoveUnmappedReadsStrict is a filter for removing unmapped\n// sam-alignment instances, based on FLAG, or POS=0, or RNAME=*.\nfunc RemoveUnmappedReadsStrict(_ *sam.Header) sam.AlignmentFilter {\n\treturn func(aln *sam.Alignment) bool {\n\t\treturn ((aln.FLAG & sam.Unmapped) == 0) && (aln.POS != 0) && (aln.RNAME != \"*\")\n\t}\n}", "id": 4252, "concepts": ["sam.AlignmentFilter", "sam.Alignment", "sam.Header", "bitwise operations", "flag handling", "conditional statement"], "_raw_llm_output": "sam.AlignmentFilter, sam.Alignment, sam.Header, bitwise operations, flag handling, conditional statement"}
{"seed": "// create creates a new log file and returns the file and its\n// filename. If the file is created successfully, create also attempts\n// to update the symlink for that tag, ignoring errors.\nfunc create(\n\tlogDir *DirName, prefix string, t time.Time, lastRotation int64,\n) (f *os.File, updatedRotation int64, filename string, err error) {\n\tdir, err := logDir.get()\n\tif err != nil {\n\t\treturn nil, lastRotation, \"\", err\n\t}\n\n\t// Ensure that the timestamp of the new file name is greater than\n\t// the timestamp of the previous generated file name.\n\tunix := t.Unix()\n\tif unix <= lastRotation {\n\t\tunix = lastRotation + 1\n\t}\n\tupdatedRotation = unix\n\tt = timeutil.Unix(unix, 0)\n\n\t// Generate the file name.\n\tname, link := logName(prefix, t)\n\tfname := filepath.Join(dir, name)\n\t// Open the file os.O_APPEND|os.O_CREATE rather than use os.Create.\n\t// Append is almost always more efficient than O_RDRW on most modern file systems.\n\tf, err = os.OpenFile(fname, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0664)\n\tif err == nil {\n\t\tsymlink := filepath.Join(dir, link)\n\n\t\t// Symlinks are best-effort.\n\n\t\tif err := os.Remove(symlink); err != nil && !os.IsNotExist(err) {\n\t\t\tfmt.Fprintf(OrigStderr, \"log: failed to remove symlink %s: %s\", symlink, err)\n\t\t}\n\t\tif err := os.Symlink(filepath.Base(fname), symlink); err != nil {\n\t\t\t// On Windows, this will be the common case, as symlink creation\n\t\t\t// requires special privileges.\n\t\t\t// See: https://docs.microsoft.com/en-us/windows/device-security/security-policy-settings/create-symbolic-links\n\t\t\tif runtime.GOOS != \"windows\" {\n\t\t\t\tfmt.Fprintf(OrigStderr, \"log: failed to create symlink %s: %s\", symlink, err)\n\t\t\t}\n\t\t}\n\t}\n\treturn f, updatedRotation, fname, errors.Wrapf(err, \"log: cannot create log\")\n}", "id": 4270, "concepts": ["os.OpenFile", "os.Create", "os.Symlink", "os.Remove", "filepath.Join", "filepath.Base", "time.Unix", "timeutil.Unix", "errors.Wrapf", "errors.Is", "error handling (errors.Is)", "error handling (errors.Wrapf)", "error handling (fmt.Fprintf)", "error handling (os.Remove)", "error handling (os.Symlink)", "error handling (os.Create)", "error handling (os.OpenFile)", "error handling (runtime.GOOS != \"windows\")", "error handling (runtime.GOOS == \"windows\")", "error handling (runtime.GOOS != \"windows\")", "error handling (runtime.GOOS != \"windows\")", "error handling (runtime.GOOS != \"windows\")", "error handling (runtime.GOOS != \"windows\")", "error handling (runtime.GOOS != \"windows\")", "error handling (runtime.GOOS != \"windows\")", "error handling (runtime.GOOS != \"windows\")", "error handling (runtime.GOOS != \"windows\")", "error handling (runtime.GOOS != \"windows\")", "error handling (runtime.GOOS != \"windows\")", "error handling (runtime.GOOS != \"windows\")", "error handling (runtime.GOOS != \"windows\")", "error handling (runtime."], "_raw_llm_output": "os.OpenFile, os.Create, os.Symlink, os.Remove, filepath.Join, filepath.Base, time.Unix, timeutil.Unix, errors.Wrapf, errors.Is, error handling (errors.Is), error handling (errors.Wrapf), error handling (fmt.Fprintf), error handling (os.Remove), error handling (os.Symlink), error handling (os.Create), error handling (os.OpenFile), error handling (runtime.GOOS != \"windows\"), error handling (runtime.GOOS == \"windows\"), error handling (runtime.GOOS != \"windows\"), error handling (runtime.GOOS != \"windows\"), error handling (runtime.GOOS != \"windows\"), error handling (runtime.GOOS != \"windows\"), error handling (runtime.GOOS != \"windows\"), error handling (runtime.GOOS != \"windows\"), error handling (runtime.GOOS != \"windows\"), error handling (runtime.GOOS != \"windows\"), error handling (runtime.GOOS != \"windows\"), error handling (runtime.GOOS != \"windows\"), error handling (runtime.GOOS != \"windows\"), error handling (runtime.GOOS != \"windows\"), error handling (runtime."}
{"seed": "// ExtractEvents interprets the results of a single page from a List() call, producing a slice of Event entities.\r\nfunc ExtractEvents(r pagination.Page) ([]Event, error) {\r\n\tvar s struct {\r\n\t\tEvents []Event `json:\"events\"`\r\n\t}\r\n\terr := (r.(EventPage)).ExtractInto(&s)\r\n\treturn s.Events, err\r\n}", "id": 4273, "concepts": ["pagination", "pagination.Page", "pagination.Page.ExtractInto", "json decoding"], "_raw_llm_output": "pagination, pagination.Page, pagination.Page.ExtractInto, json decoding"}
{"seed": "// AtomToInt is a covenience function for converting []xproto.Atom\n// to []uint.\nfunc AtomToUint(ids []xproto.Atom) []uint {\n\tids32 := make([]uint, len(ids))\n\tfor i, v := range ids {\n\t\tids32[i] = uint(v)\n\t}\n\treturn ids32\n}", "id": 4285, "concepts": ["conversion", "slice iteration", "basic function definition"], "_raw_llm_output": "conversion, slice iteration, basic function definition"}
{"seed": "// Output builds the given command, starts and waits for the command to successfully complete\n// It returns the contents of stdout as a []byte\n// The command returns an error if there is any stderr or non-zero exit code, unless ignoreExitError is enabled\nfunc Output(cmd string) ([]byte, error) {\n\tb := New(cmd)\n\tout, err := b.Cmd().Output()\n\tif err != nil {\n\t\tif handledErr := b.handleExitError(err); handledErr != nil {\n\t\t\treturn nil, stacktrace.Propagate(err, \"error running command\")\n\t\t}\n\t}\n\treturn out, nil\n}", "id": 4295, "concepts": ["command execution", "error handling", "standard library usage"], "_raw_llm_output": "command execution, error handling, standard library usage"}
{"seed": "// GetMyTRBRequests returns all TRB Requests that belong to the principal in the context\nfunc GetMyTRBRequests(ctx context.Context, archived bool, store *storage.Store) ([]*models.TRBRequest, error) {\n\tTRBRequests, err := store.GetMyTRBRequests(ctx, archived)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn TRBRequests, err\n}", "id": 4300, "concepts": ["context package usage", "storage package usage", "pointer usage", "error handling"], "_raw_llm_output": "context package usage, storage package usage, pointer usage, error handling"}
{"seed": "// SetClaimResolver sets the jwt strategy ClaimResolver\n// to resolve the jwt claims.\n// Default: jwt.Claim\nfunc SetClaimResolver(c oauth2.ClaimsResolver) auth.Option {\n\treturn auth.OptionFunc(func(v interface{}) {\n\t\tif s, ok := v.(*strategy); ok {\n\t\t\ts.claimResolver = c\n\t\t}\n\t})\n}", "id": 4308, "concepts": ["interface", "function", "function as parameter", "function as return value", "function as option"], "_raw_llm_output": "interface, function, function as parameter, function as return value, function as option"}
{"seed": "// TitleNEQ applies the NEQ predicate on the \"title\" field.\nfunc TitleNEQ(v string) predicate.User {\n\treturn predicate.User(sql.FieldNEQ(FieldTitle, v))\n}", "id": 4312, "concepts": ["predicate.User", "sql.FieldNEQ", "sql.FieldEQ"], "_raw_llm_output": "predicate.User, sql.FieldNEQ, sql.FieldEQ"}
{"seed": "// Min creates a Constraint which will declare an instance is valid\n// if its value is greater than or equal to refValue.\nfunc Min[\n\tValueT typecons.Ordered,\n](refValue ValueT) OrderedConstraint[ValueT] {\n\treturn Func(\n\t\tfmt.Sprintf(\"min %v\", refValue),\n\t\tGreaterThanOrEqualTo(refValue).IsValid)\n}", "id": 4319, "concepts": ["type constraints", "type parameters", "type constraints", "type assertions", "type conversion"], "_raw_llm_output": "type constraints, type parameters, type constraints, type assertions, type conversion"}
{"seed": "// WithDelay returns a Paginator that will wait the given duration whenever the\n// next page is requested, and will then dispatch to the underling Paginator.\nfunc WithDelay(delay time.Duration, p scrape.Paginator) scrape.Paginator {\n\treturn &withDelayPaginator{\n\t\tdelay: delay,\n\t\tp:     p,\n\t}\n}", "id": 4329, "concepts": ["struct composition", "composition of interfaces", "composition of structs"], "_raw_llm_output": "struct composition, composition of interfaces, composition of structs"}
{"seed": "// MakeDependencyInterchange converts a dependency.Manager document to\n// its DependencyInterchange format.\nfunc makeDependencyInterchange(f amboy.Format, d dependency.Manager) (*DependencyInterchange, error) {\n\ttypeInfo := d.Type()\n\n\tdata, err := convertTo(f, d)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\toutput := &DependencyInterchange{\n\t\tType:       typeInfo.Name,\n\t\tVersion:    typeInfo.Version,\n\t\tEdges:      d.Edges(),\n\t\tDependency: data,\n\t}\n\n\treturn output, nil\n}", "id": 4350, "concepts": ["conversion", "standard library usage"], "_raw_llm_output": "conversion, standard library usage"}
{"seed": "// checkAndSaveSeqNum checks if the given seqNum is already processed\n// according to the specified seqNumFile and if so, returns true,\n// otherwise saves the given seqNum into seqNumFile returns false.\nfunc checkAndSaveSeqNum(ctx log.Logger, seq int, seqNumFile string) (shouldExit bool, _ error) {\n\tctx.Log(\"event\", \"comparing seqnum\", \"path\", seqNumFile)\n\tsmaller, err := seqnum.IsSmallerThan(seqNumFile, seq)\n\tif err != nil {\n\t\treturn false, errors.Wrap(err, \"failed to check sequence number\")\n\t}\n\tif !smaller {\n\t\t// stored sequence number is equals or greater than the current\n\t\t// sequence number.\n\t\treturn true, nil\n\t}\n\tif err := seqnum.Set(seqNumFile, seq); err != nil {\n\t\treturn false, errors.Wrap(err, \"failed to save the sequence number\")\n\t}\n\tctx.Log(\"event\", \"seqnum saved\", \"path\", seqNumFile)\n\treturn false, nil\n}", "id": 4354, "concepts": ["error handling (errors.Wrap)", "file I/O", "mutexes", "standard library usage"], "_raw_llm_output": "error handling (errors.Wrap), file I/O, mutexes, standard library usage"}
{"seed": "// BetterHeroScoreAtLT applies the LT predicate on the \"better_hero_score_at\" field.\nfunc BetterHeroScoreAtLT(v time.Time) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.LT(s.C(FieldBetterHeroScoreAt), v))\n\t})\n}", "id": 4357, "concepts": ["sql.Selector", "sql.LT", "predicate.User", "sql.C"], "_raw_llm_output": "sql.Selector, sql.LT, predicate.User, sql.C"}
{"seed": "//\n// Takes an input stream of xml, converts to json and\n// writes json into kv datastore (badger)\n//\n// For SIF objects each is given the key of its RefId\n//\n// xmlFileName: input file/stream of xml results data\n// dbFolderName: the directory to create the datastore in\n// idxf: index functio to use to generate keys for these data objects in the k/v store\n// dataObjects: the data types to extract from the stream (e.g. StudentPersonal, SchoolInfo etc.)\n//\nfunc StreamToKVStore(xmlFileName string, dbFolderName string, idxf IndexFunc, dataObjects ...string) error {\n\n\t// open the xml file\n\tsize, xmlStream, err := OpenXMLFile(xmlFileName)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// remove any existing dbs\n\terr = os.RemoveAll(filepath.Dir(dbFolderName))\n\tif err != nil {\n\t\treturn err\n\t}\n\t// recreate the working directory\n\terr = os.MkdirAll(filepath.Dir(dbFolderName), os.ModePerm)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// create new badger instance\n\tdb, err := badger.Open(badger.DefaultOptions(dbFolderName))\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer db.Close()\n\t// create a (fast) writebatch on the db\n\twb := db.NewWriteBatch()\n\tdefer wb.Cancel()\n\n\t// initialise the extractor\n\topts := []Option{\n\t\tObjectsToExtract(dataObjects),\n\t\tProgressBar(size),\n\t}\n\tsec, err := NewStreamExtractConverter(xmlStream, opts...)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// iterate the xml stream and save each object to db\n\tcount := 0\n\tfor jsonBytes := range sec.Stream() {\n\n\t\tkey, err := idxf(jsonBytes)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\terr = wb.Set(key, jsonBytes)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcount++\n\t}\n\twb.Flush()\n\tlog.Printf(\"%d data-objects parsed\\n\\n\", count)\n\n\treturn nil\n}", "id": 4371, "concepts": ["error handling (os.RemoveAll)", "os.MkdirAll", "badger.Open", "badger.NewWriteBatch", "sync.WaitGroup", "sync.Mutex", "standard library usage"], "_raw_llm_output": "error handling (os.RemoveAll), os.MkdirAll, badger.Open, badger.NewWriteBatch, sync.WaitGroup, sync.Mutex, standard library usage"}
{"seed": "// New returns an Error with the supplied code and message,\n// and the stack trace at the point it was called.\nfunc New(code interface{}, msg string) Error {\n\tstack := [10]uintptr{}\n\tn := runtime.Callers(2, stack[:])\n\treturn &cerror{\n\t\tcode:  code,\n\t\tmsg:   msg,\n\t\tstack: stack[:n],\n\t}\n}", "id": 4380, "concepts": ["stack trace", "runtime package usage"], "_raw_llm_output": "stack trace, runtime package usage"}
{"seed": "// CreateRetentionLabelSettingsFromDiscriminatorValue creates a new instance of the appropriate class based on discriminator value\nfunc CreateRetentionLabelSettingsFromDiscriminatorValue(parseNode i878a80d2330e89d26896388a3f487eef27b0a0e6c010c493bf80be1452208f91.ParseNode)(i878a80d2330e89d26896388a3f487eef27b0a0e6c010c493bf80be1452208f91.Parsable, error) {\n    return NewRetentionLabelSettings(), nil\n}", "id": 4390, "concepts": ["interface implementation", "interface usage", "struct usage"], "_raw_llm_output": "interface implementation, interface usage, struct usage"}
{"seed": "// ParseResetElasticIpFieldResponse parses an HTTP response from a ResetElasticIpFieldWithResponse call\nfunc ParseResetElasticIpFieldResponse(rsp *http.Response) (*ResetElasticIpFieldResponse, error) {\n\tbodyBytes, err := ioutil.ReadAll(rsp.Body)\n\tdefer rsp.Body.Close()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse := &ResetElasticIpFieldResponse{\n\t\tBody:         bodyBytes,\n\t\tHTTPResponse: rsp,\n\t}\n\n\tswitch {\n\tcase strings.Contains(rsp.Header.Get(\"Content-Type\"), \"json\") && rsp.StatusCode == 200:\n\t\tvar dest Operation\n\t\tif err := json.Unmarshal(bodyBytes, &dest); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresponse.JSON200 = &dest\n\n\t}\n\n\treturn response, nil\n}", "id": 4400, "concepts": ["HTTP response parsing", "JSON parsing", "HTTP response handling", "error handling", "JSON unmarshaling"], "_raw_llm_output": "HTTP response parsing, JSON parsing, HTTP response handling, error handling, JSON unmarshaling"}
{"seed": "// PReLU is the parametric rectified linear unit.\n// `x >= 0 ? x : a * x`\nfunc PReLU(x, a float64) float64 {\n\tif x >= 0 {\n\t\treturn x\n\t}\n\treturn a * x\n}", "id": 4403, "concepts": ["basic function definition", "conditional statements", "basic math operations"], "_raw_llm_output": "basic function definition, conditional statements, basic math operations"}
{"seed": "// HiWhiteString is a convenient helper function to return a string with hi-intensity white\n// foreground.\nfunc HiWhiteString(format string, a ...interface{}) (s string) {\n\ts = colorString(FgHiWhite, format, a...)\n\treturn\n}", "id": 4407, "concepts": ["string formatting", "fmt package usage", "color package usage"], "_raw_llm_output": "string formatting, fmt package usage, color package usage"}
{"seed": "// NewGetFileSystemParametersInternalParamsWithContext creates a new GetFileSystemParametersInternalParams object\n// with the default values initialized, and the ability to set a context for a request\nfunc NewGetFileSystemParametersInternalParamsWithContext(ctx context.Context) *GetFileSystemParametersInternalParams {\n\tvar (\n\t\tattachedClusterDefault = bool(false)\n\t\tsecureDefault          = bool(false)\n\t)\n\treturn &GetFileSystemParametersInternalParams{\n\t\tAttachedCluster: &attachedClusterDefault,\n\t\tSecure:          &secureDefault,\n\n\t\tContext: ctx,\n\t}\n}", "id": 4408, "concepts": ["context package usage", "pointer types", "boolean default values", "function definition"], "_raw_llm_output": "context package usage, pointer types, boolean default values, function definition"}
{"seed": "// safeString ensures that the string is NULL-terminated, a NULL-terminated copy is created otherwise.\nfunc safeString(str string) string {\n\tif len(str) > 0 && str[len(str)-1] != '\\x00' {\n\t\tstr = str + \"\\x00\"\n\t} else if len(str) == 0 {\n\t\tstr = \"\\x00\"\n\t}\n\treturn str\n}", "id": 4417, "concepts": ["string manipulation", "string concatenation", "string comparison", "string length", "string termination", "string termination handling"], "_raw_llm_output": "string manipulation, string concatenation, string comparison, string length, string termination, string termination handling"}
{"seed": "// NewCallbackSubscriber creates a new subscriber which accepts a\n// callback function which is executed every time a message is received.\nfunc NewCallbackSubscriber(cb func(msg interface{})) Subscriber {\n\treturn &callbackHandler{\n\t\tcallback: cb,\n\t}\n}", "id": 4418, "concepts": ["interface implementation", "anonymous function", "function definition"], "_raw_llm_output": "interface implementation, anonymous function, function definition"}
{"seed": "// PossibleLatencyScorecardAggregationIntervalValues returns an array of possible values for the LatencyScorecardAggregationInterval const type.\nfunc PossibleLatencyScorecardAggregationIntervalValues() []LatencyScorecardAggregationInterval {\n\treturn []LatencyScorecardAggregationInterval{LatencyScorecardAggregationIntervalDaily, LatencyScorecardAggregationIntervalMonthly, LatencyScorecardAggregationIntervalWeekly}\n}", "id": 4422, "concepts": ["constant definition", "array definition", "type definition"], "_raw_llm_output": "constant definition, array definition, type definition"}
{"seed": "// radialDecay Calculates the radial decay factor for a given radius, between 0.0 and 1.0.\n// When rMaxNmi < rNmi: NWS 23 pdf page 53, page 27, Figure 2.12, empirical fit.\n// When rMaxNmi > rNmi: NWS 23 pdf page 54, page 28, Figure 2.13, empirical fit (logistic regression).\n//\n// rNmi: Point radius from center of storm in nautical miles\n//\n// rMaxNmi Radius of maximum winds in nautical miles\n//\n// return 0 <= radial decay <= 1\nfunc radialDecay(rNmi float64, rMaxNmi float64) float64 {\n\tret := 1.0\n\n\tif rMaxNmi < rNmi {\n\t\t// NWS 23 pdf page 53\n\t\tslope := (-0.051 * math.Log(rMaxNmi)) - 0.1757\n\t\tintercept := (0.4244 * math.Log(rMaxNmi)) + 0.7586\n\t\tret = (slope * math.Log(rNmi)) + intercept\n\t}\n\t// Skip this else block as a concession for modeling time series, where everything within the max wind radius is\n\t//\texpected to experience the max wind radius while the storm translates\n\t// else {\n\n\t\t// NWS 23 pdf page 54\n\t\t// ret = 1.01231578 / (1 + math.exp(-8.612066494 * ((r_nmi / float(rmax_nmi)) - 0.678031222)))\n\t\t// ret = 1\n\t// }\n\n\t// clamp radial decay between 0 and 1\n\treturn math.Max(math.Min(ret, 1.0), 0.0)\n}", "id": 4425, "concepts": ["math package usage", "exponential function", "logistic regression", "empirical fit", "standard library usage"], "_raw_llm_output": "math package usage, exponential function, logistic regression, empirical fit, standard library usage"}
{"seed": "// Listen opens a multicast socket to listen for energymeter messages.\n//\n// Returns an EnergyMeter representing the opened connection.\nfunc Listen() (*EnergyMeter, error) {\n\taddr, err := net.ResolveUDPAddr(\"udp\", multicastIP)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tl, err := net.ListenMulticastUDP(\"udp\", nil, addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &EnergyMeter{Conn: l}, nil\n}", "id": 4432, "concepts": ["net.ListenMulticastUDP", "net.ResolveUDPAddr", "UDP multicast", "basic function definition"], "_raw_llm_output": "net.ListenMulticastUDP, net.ResolveUDPAddr, UDP multicast, basic function definition"}
{"seed": "// loadPage opens a new tab to load the specified webpage.\n// Note that if err != nil, conn is nil.\nfunc loadPage(ctx context.Context, cs ash.ConnSource, url string) (*chrome.Conn, error) {\n\tctx, st := timing.Start(ctx, \"load_page\")\n\tdefer st.End()\n\n\tconn, err := cs.NewConn(ctx, url)\n\tif err != nil {\n\t\treturn nil, errors.Wrapf(err, \"failed to open %v\", url)\n\t}\n\treturn conn, err\n}", "id": 4442, "concepts": ["context", "timing", "error handling (errors.Wrapf)", "chrome.Conn", "chrome.ConnSource"], "_raw_llm_output": "context, timing, error handling (errors.Wrapf), chrome.Conn, chrome.ConnSource"}
{"seed": "// RenderEscaped (if true) enables the rendering of escaped whitespace characters.\n// e.g. `\\\\t` appears as tab instead of `\\t`, `\\\\n` appears as newline instead of `\\n` e.t.c.\nfunc RenderEscaped(b bool) Option {\n\treturn optionFunc(func(l *lineWriter) {\n\t\tl.renderEscaped = true\n\t})\n}", "id": 4445, "concepts": ["struct composition", "struct embedding", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", ""], "_raw_llm_output": "struct composition, struct embedding, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition,"}
{"seed": "// NewPostSecdefSearchParams creates a new PostSecdefSearchParams object\n// with the default values initialized.\nfunc NewPostSecdefSearchParams() *PostSecdefSearchParams {\n\tvar ()\n\treturn &PostSecdefSearchParams{\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 4473, "concepts": ["struct initialization", "struct field initialization", "struct field access"], "_raw_llm_output": "struct initialization, struct field initialization, struct field access"}
{"seed": "// castCNRVKColsToGo convert C.nrvk_cols_t to GO NRVKCols.\nfunc castCNRVKColsToGo(nr C.nrvk_cols_t) NRVKCols {\n\treturn NRVKCols{\n\t\tVk:     unsafe.Pointer(nr.vk),     // #nosec\n\t\tOffset: unsafe.Pointer(nr.offset), // #nosec\n\t\tData:   unsafe.Pointer(nr.data),   // #nosec\n\t\tNRows:  uint64(nr.nrows),\n\t}\n}", "id": 4474, "concepts": ["unsafe package usage", "pointer conversion"], "_raw_llm_output": "unsafe package usage, pointer conversion"}
{"seed": "// _escFS returns a http.Filesystem for the embedded assets. If useLocal is true,\n// the filesystem's contents are instead used.\nfunc _escFS(useLocal bool) http.FileSystem {\n\tif useLocal {\n\t\treturn _escLocal\n\t}\n\treturn _escStatic\n}", "id": 4494, "concepts": ["embedded assets", "http.FileSystem", "http.FileServer"], "_raw_llm_output": "embedded assets, http.FileSystem, http.FileServer"}
{"seed": "// BetterHeroScoreAt applies equality check predicate on the \"better_hero_score_at\" field. It's identical to BetterHeroScoreAtEQ.\nfunc BetterHeroScoreAt(v time.Time) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldBetterHeroScoreAt), v))\n\t})\n}", "id": 4509, "concepts": ["sql.Selector", "sql.EQ", "sql.Where", "sql.C", "sql.FieldBetterHeroScoreAt", "predicate.User", "anonymous function"], "_raw_llm_output": "sql.Selector, sql.EQ, sql.Where, sql.C, sql.FieldBetterHeroScoreAt, predicate.User, anonymous function"}
{"seed": "// NewTimeLineServiceProtobufClient creates a Protobuf client that implements the TimeLineService interface.\n// It communicates using Protobuf and can be configured with a custom HTTPClient.\nfunc NewTimeLineServiceProtobufClient(addr string, client HTTPClient) TimeLineService {\n\tprefix := urlBase(addr) + TimeLineServicePathPrefix\n\turls := [2]string{\n\t\tprefix + \"GetTimeLine\",\n\t\tprefix + \"GetSubscribedTimeLine\",\n\t}\n\tif httpClient, ok := client.(*http.Client); ok {\n\t\treturn &timeLineServiceProtobufClient{\n\t\t\tclient: withoutRedirects(httpClient),\n\t\t\turls:   urls,\n\t\t}\n\t}\n\treturn &timeLineServiceProtobufClient{\n\t\tclient: client,\n\t\turls:   urls,\n\t}\n}", "id": 4516, "concepts": ["interface", "type assertion", "HTTPClient interface", "HTTPClient implementation", "URL handling", "HTTPClient usage"], "_raw_llm_output": "interface, type assertion, HTTPClient interface, HTTPClient implementation, URL handling, HTTPClient usage"}
{"seed": "// Check if the longitude is valid. Range: -180 - 180\nfunc checkLongitude(longitude float64) bool {\n\tif longitude < -180.0 || longitude > 180.0 {\n\t\treturn false\n\t}\n\treturn true\n}", "id": 4519, "concepts": ["float64 comparison", "floating point numbers", "basic function definition"], "_raw_llm_output": "float64 comparison, floating point numbers, basic function definition"}
{"seed": "// NewMockedRepository creates a new MockedRepository.\nfunc NewMockedRepository() *MockedRepository {\n\treturn &MockedRepository{}\n}", "id": 4523, "concepts": ["interface", "struct", "pointer", "method definition", "method receiver", "method implementation"], "_raw_llm_output": "interface, struct, pointer, method definition, method receiver, method implementation"}
{"seed": "// deduplicate returns a de-duplicated copy of the given slice, retaining the original order.\nfunc deduplicate(data []float64) []float64 {\n\tkeys := make(map[float64]bool)\n\tuniq := []float64{}\n\tfor _, entry := range data {\n\t\tif _, value := keys[entry]; !value {\n\t\t\tkeys[entry] = true\n\t\t\tuniq = append(uniq, entry)\n\t\t}\n\t}\n\treturn uniq\n}", "id": 4525, "concepts": ["map iteration", "map creation", "map lookup", "slice creation", "slice append"], "_raw_llm_output": "map iteration, map creation, map lookup, slice creation, slice append"}
{"seed": "// NewDownloadJob constructs a DownloadFileJob. The job has a\n// dependency on the downloaded file, and will only execute if that\n// file does not exist.\nfunc NewDownloadJob(url, path string, force bool) (*DownloadFileJob, error) {\n\tj := newDownloadJob()\n\tif err := j.setURL(url); err != nil {\n\t\treturn nil, errors.Wrap(err, \"problem constructing Job object (url)\")\n\t}\n\n\tif err := j.setDirectory(path); err != nil {\n\t\treturn nil, errors.Wrap(err, \"problem constructing Job object (directory)\")\n\t}\n\n\tfn := j.getFileName()\n\tj.SetID(fmt.Sprintf(\"%s-%d\",\n\t\tstrings.Replace(fn, string(filepath.Separator), \"-\", -1),\n\t\tjob.GetNumber()))\n\n\tif force {\n\t\tj.SetDependency(dependency.NewAlways())\n\t} else {\n\t\tj.SetDependency(dependency.NewCreatesFile(fn))\n\t}\n\n\treturn j, nil\n}", "id": 4528, "concepts": ["error handling (errors.Wrap)", "string manipulation", "filepath.Separator", "fmt.Sprintf", "dependency.NewAlways", "dependency.NewCreatesFile"], "_raw_llm_output": "error handling (errors.Wrap), string manipulation, filepath.Separator, fmt.Sprintf, dependency.NewAlways, dependency.NewCreatesFile"}
{"seed": "// PossibleOperationOriginValues returns an array of possible values for the OperationOrigin const type.\nfunc PossibleOperationOriginValues() []OperationOrigin {\n\treturn []OperationOrigin{OperationOriginSystem, OperationOriginUser, OperationOriginUsersystem}\n}", "id": 4538, "concepts": ["constants", "array definition", "basic function definition"], "_raw_llm_output": "constants, array definition, basic function definition"}
{"seed": "// WithScheme allows setting a runtime.Scheme in the options\nfunc WithScheme(scheme *runtime.Scheme) SecretOption {\n\treturn func(op *Options) {\n\t\top.Scheme = scheme\n\t}\n}", "id": 4543, "concepts": ["runtime.Scheme", "function definition", "function options", "function composition"], "_raw_llm_output": "runtime.Scheme, function definition, function options, function composition"}
{"seed": "// NewReportTypeFromValue returns a pointer to a valid ReportType\n// for the value passed as argument, or an error if the value passed is not allowed by the enum\nfunc NewReportTypeFromValue(v string) (*ReportType, error) {\n\tev := ReportType(v)\n\n\n\treturn &ev, nil\n}", "id": 4554, "concepts": ["enum", "pointer", "error handling"], "_raw_llm_output": "enum, pointer, error handling"}
{"seed": "// H2_ is a convenience wrapper for H2 without the attrs argument.\nfunc H2_(children ...HTML) HTML {\n  return H2(nil, children...)\n}", "id": 4560, "concepts": ["struct composition", "basic function definition"], "_raw_llm_output": "struct composition, basic function definition"}
{"seed": "// WithAddr \u914d\u7f6e\u76d1\u542c\u5730\u5740\nfunc WithAddr(addr string) Option {\n\treturn func(s *Server) {\n\t\ts.addr = addr\n\t}\n}", "id": 4571, "concepts": ["struct definition", "struct field definition", "struct field initialization", "struct field assignment", "function definition", "function call", "function return"], "_raw_llm_output": "struct definition, struct field definition, struct field initialization, struct field assignment, function definition, function call, function return"}
{"seed": "//NewReaderGroup returns an initialized ReaderGroup.\nfunc NewReaderGroup() *ReaderGroup {\n\treturn &ReaderGroup{\n\t\tm:       sync.Mutex{},\n\t\treaders: make(map[*Reader]*Reader),\n\t}\n}", "id": 4574, "concepts": ["map", "mutex", "sync package usage"], "_raw_llm_output": "map, mutex, sync package usage"}
{"seed": "// AssetString returns the asset contents as a string (instead of a []byte).\nfunc AssetString(name string) (string, error) {\n\tdata, err := Asset(name)\n\treturn string(data), err\n}", "id": 4578, "concepts": ["Asset function", "string conversion", "standard library usage"], "_raw_llm_output": "Asset function, string conversion, standard library usage"}
{"seed": "// NewTable creates a single-chained hashtable with\n// a certain number of buckets, or chains of items\n// in the hashtable.\nfunc NewTable(desiredBucketCount int) *hashtable {\n\th := &hashtable{\n\t\tbucketcount: desiredBucketCount,\n\t\tbuckets:     make([]*CacheItem, desiredBucketCount),\n\t}\n\treturn h\n}", "id": 4579, "concepts": ["struct definition", "slice creation", "map creation", "pointer usage", "basic function definition"], "_raw_llm_output": "struct definition, slice creation, map creation, pointer usage, basic function definition"}
{"seed": "// NewFetchIntegrationFormParamsWithHTTPClient creates a new FetchIntegrationFormParams object\n// with the ability to set a custom HTTPClient for a request.\nfunc NewFetchIntegrationFormParamsWithHTTPClient(client *http.Client) *FetchIntegrationFormParams {\n\treturn &FetchIntegrationFormParams{\n\t\tHTTPClient: client,\n\t}\n}", "id": 4590, "concepts": ["struct definition", "method definition", "pointer receiver", "pointer dereference", "method invocation", "HTTPClient usage"], "_raw_llm_output": "struct definition, method definition, pointer receiver, pointer dereference, method invocation, HTTPClient usage"}
{"seed": "// ValidateRESTValidationErrorResponseBody runs the validations defined on\n// RESTValidationErrorResponseBody\nfunc ValidateRESTValidationErrorResponseBody(body *RESTValidationErrorResponseBody) (err error) {\n\tif body.Code == nil {\n\t\terr = goa.MergeErrors(err, goa.MissingFieldError(\"code\", \"body\"))\n\t}\n\tif body.Reason == nil {\n\t\terr = goa.MergeErrors(err, goa.MissingFieldError(\"reason\", \"body\"))\n\t}\n\tif body.Code != nil {\n\t\tif !(*body.Code == 1000 || *body.Code == 1001 || *body.Code == 1002 || *body.Code == 1003 || *body.Code == 1004 || *body.Code == 1005 || *body.Code == 1006) {\n\t\t\terr = goa.MergeErrors(err, goa.InvalidEnumValueError(\"body.code\", *body.Code, []interface{}{1000, 1001, 1002, 1003, 1004, 1005, 1006}))\n\t\t}\n\t}\n\tif body.Reason != nil {\n\t\tif !(*body.Reason == \"Required field\" || *body.Reason == \"Incorrect format\" || *body.Reason == \"Invalid address\" || *body.Reason == \"Address not supported\" || *body.Reason == \"Value out of range\" || *body.Reason == \"Invalid signature or hash\" || *body.Reason == \"Unsupported option\") {\n\t\t\terr = goa.MergeErrors(err, goa.InvalidEnumValueError(\"body.reason\", *body.Reason, []interface{}{\"Required field\", \"Incorrect format\", \"Invalid address\", \"Address not supported\", \"Value out of range\", \"Invalid signature or hash\", \"Unsupported option\"}))\n\t\t}\n\t}\n\treturn\n}", "id": 4596, "concepts": ["error handling (goa.MergeErrors)", "error handling (goa.MissingFieldError)", "error handling (goa.InvalidEnumValueError)", "error handling (goa.MergeErrors)", "error handling (goa.MissingFieldError)", "error handling (goa.InvalidEnumValueError)", "error handling (goa.MergeErrors)", "error handling (goa.MissingFieldError)", "error handling (goa.InvalidEnumValueError)", "error handling (goa.MergeErrors)", "error handling (goa.MissingFieldError)", "error handling (goa.InvalidEnumValueError)", "error handling (goa.MergeErrors)", "error handling (goa.MissingFieldError)", "error handling (goa.InvalidEnumValueError)", "error handling (goa.MergeErrors)", "error handling (goa.MissingFieldError)", "error handling (goa.InvalidEnumValueError)", "error handling (goa.MergeErrors)", "error handling (goa.MissingFieldError)", "error handling (goa.InvalidEnumValueError)", "error handling (goa.MergeErrors)", "error handling (goa.MissingFieldError)", "error handling (goa.InvalidEnumValueError)", "error handling (goa.MergeErrors)", "error handling (goa.MissingFieldError)", "error handling (goa.InvalidEnumValueError)", "error handling ("], "_raw_llm_output": "error handling (goa.MergeErrors), error handling (goa.MissingFieldError), error handling (goa.InvalidEnumValueError), error handling (goa.MergeErrors), error handling (goa.MissingFieldError), error handling (goa.InvalidEnumValueError), error handling (goa.MergeErrors), error handling (goa.MissingFieldError), error handling (goa.InvalidEnumValueError), error handling (goa.MergeErrors), error handling (goa.MissingFieldError), error handling (goa.InvalidEnumValueError), error handling (goa.MergeErrors), error handling (goa.MissingFieldError), error handling (goa.InvalidEnumValueError), error handling (goa.MergeErrors), error handling (goa.MissingFieldError), error handling (goa.InvalidEnumValueError), error handling (goa.MergeErrors), error handling (goa.MissingFieldError), error handling (goa.InvalidEnumValueError), error handling (goa.MergeErrors), error handling (goa.MissingFieldError), error handling (goa.InvalidEnumValueError), error handling (goa.MergeErrors), error handling (goa.MissingFieldError), error handling (goa.InvalidEnumValueError), error handling ("}
{"seed": "// rawPattern creates a regular expression matching the given string literal.\nfunc rawPattern(s string) *regexp.Regexp {\n\treturn regexp.MustCompile(regexp.QuoteMeta(s))\n}", "id": 4600, "concepts": ["regexp package usage", "regexp.MustCompile", "regexp.QuoteMeta"], "_raw_llm_output": "regexp package usage, regexp.MustCompile, regexp.QuoteMeta"}
{"seed": "// ConstantTimePriority returns a function that returns p for all times.\nfunc ConstantTimePriority(p float64) TimePriority {\n\treturn func(t time.Time) float64 { return p }\n}", "id": 4603, "concepts": ["function definition", "function composition", "function return"], "_raw_llm_output": "function definition, function composition, function return"}
{"seed": "// GetShortName returns plugin's short name (name before domain) if name\n// is fully qualified (has a domain suffix), otherwise GetShortName returns name.\nfunc GetShortName(name string) string {\n\treturn strings.SplitN(name, \".\", 2)[0]\n}", "id": 4609, "concepts": ["string manipulation", "string splitting", "string comparison"], "_raw_llm_output": "string manipulation, string splitting, string comparison"}
{"seed": "// NewDeleteRolesParamsWithTimeout creates a new DeleteRolesParams object\n// with the default values initialized, and the ability to set a timeout on a request\nfunc NewDeleteRolesParamsWithTimeout(timeout time.Duration) *DeleteRolesParams {\n\tvar ()\n\treturn &DeleteRolesParams{\n\n\t\ttimeout: timeout,\n\t}\n}", "id": 4622, "concepts": ["function definition", "function parameters", "function return values", "timeout handling"], "_raw_llm_output": "function definition, function parameters, function return values, timeout handling"}
{"seed": "// TNew generates a certificate and private key. To override default values, pass\n// a Config value. If an error occurs, t.Error is called.\nfunc TNew(t *testing.T, cfg ...Config) (*x509.Certificate, crypto.Signer) {\n\tc, k, err := New(cfg...)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\treturn c, k\n}", "id": 4626, "concepts": ["testing package usage", "function definition", "function call", "error handling"], "_raw_llm_output": "testing package usage, function definition, function call, error handling"}
{"seed": "// Code represents the HTML element 'code'.\n// For more information visit https://www.w3schools.com/tags/tag_code.asp.\nfunc Code(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"code\", Attributes: attrs, Children: children}\n}", "id": 4628, "concepts": ["HTML tree", "HTML element definition", "HTML attribute definition", "HTML element usage"], "_raw_llm_output": "HTML tree, HTML element definition, HTML attribute definition, HTML element usage"}
{"seed": "/*\nDraftOrderCartCheckoutByID constructs a DraftOrderCartCheckoutSearchRequest to pull\na DraftOrderCartCheckout by it's ID.\n\nYou can add additional options using functions.\n\nHandlers may choose to return (*DraftOrderCartCheckout, error) by checking the\nIsSearchByID() function.\n*/\nfunc DraftOrderCartCheckoutByID(ID zeus.Uuid, options ...func(*DraftOrderCartCheckoutSearchRequest)) DraftOrderCartCheckoutSearchRequest {\n\tvar searchRequest DraftOrderCartCheckoutSearchRequest\n\n\tsearchRequest.AddFilter(\n\t\tDraftOrderCartCheckoutSearch_ID,\n\t\tID,\n\t\tsearcher.Operator_EQ,\n\t\tsearcher.Condition_AND)\n\n\tsearchRequest.Limit = 1\n\tsearchRequest.IsByID = true\n\n\tfor _, f := range options {\n\t\tf(&searchRequest)\n\t}\n\n\treturn searchRequest\n}", "id": 4636, "concepts": ["function definition", "function composition", "function options", "function return values", "function arguments", "function call", "function pointer", "function composition", "function options", "function arguments", "function call", "function pointer", "function composition", "function options", "function arguments", "function call", "function pointer", "function composition", "function options", "function arguments", "function call", "function pointer", "function composition", "function options", "function arguments", "function call", "function pointer", "function composition", "function options", "function arguments", "function call", "function pointer", "function composition", "function options", "function arguments", "function call", "function pointer", "function composition", "function options", "function arguments", "function call", "function pointer", "function composition", "function options", "function arguments", "function call", "function pointer", "function composition", "function options", "function arguments", "function call", "function pointer", "function composition", "function options", "function arguments", "function call", "function pointer", "function composition", "function options", "function arguments", "function call", "function pointer", "function composition", "function options", "function arguments", "function call", "function pointer", "function composition", "function options", "function arguments", "function call", "function pointer", "function composition", "function options", "function arguments", "function call", "function pointer", "function composition", "function options", "function arguments", "function call", "function pointer", "function composition", "function options", "function arguments"], "_raw_llm_output": "function definition, function composition, function options, function return values, function arguments, function call, function pointer, function composition, function options, function arguments, function call, function pointer, function composition, function options, function arguments, function call, function pointer, function composition, function options, function arguments, function call, function pointer, function composition, function options, function arguments, function call, function pointer, function composition, function options, function arguments, function call, function pointer, function composition, function options, function arguments, function call, function pointer, function composition, function options, function arguments, function call, function pointer, function composition, function options, function arguments, function call, function pointer, function composition, function options, function arguments, function call, function pointer, function composition, function options, function arguments, function call, function pointer, function composition, function options, function arguments, function call, function pointer, function composition, function options, function arguments, function call, function pointer, function composition, function options, function arguments, function call, function pointer, function composition, function options, function arguments, function call, function pointer, function composition, function options, function arguments, function call, function pointer, function composition, function options, function arguments"}
{"seed": "// Plaintext_ is a convenience wrapper for Plaintext without the attrs argument.\nfunc Plaintext_(children ...HTML) HTML {\n  return Plaintext(nil, children...)\n}", "id": 4656, "concepts": ["function definition", "variadic argument", "basic function definition", "basic function call"], "_raw_llm_output": "function definition, variadic argument, basic function definition, basic function call"}
{"seed": "// PossibleLinkedOperationValues returns the possible values for the LinkedOperation const type.\nfunc PossibleLinkedOperationValues() []LinkedOperation {\n\treturn []LinkedOperation{\n\t\tLinkedOperationCrossResourceGroupResourceMove,\n\t\tLinkedOperationCrossSubscriptionResourceMove,\n\t\tLinkedOperationNone,\n\t}\n}", "id": 4666, "concepts": ["enum", "const", "type definition"], "_raw_llm_output": "enum, const, type definition"}
{"seed": "// NewReflow returns a new instance of Reflow, initialized with defaults.\nfunc NewReflow(limit int) *Reflow {\n\treturn &Reflow{\n\t\tLimit:       limit,\n\t\tBreakpoints: defaultBreakpoints,\n\t\tNewline:     defaultNewline,\n\t}\n}", "id": 4669, "concepts": ["struct definition", "struct field initialization", "struct field access"], "_raw_llm_output": "struct definition, struct field initialization, struct field access"}
{"seed": "// NextDifficulty computes the proof-of-work difficulty that the next block should comply\n// with. Takes an iterator over past blocks, from latest (highest height) to\n// oldest (lowest height). The iterator produces pairs of timestamp and\n// difficulty for each block.\n//\n// The difficulty calculation is based on both Digishield and GravityWave\n// family of difficulty computation, coming to something very close to Zcash.\n// The refence difficulty is an average of the difficulty over a window of\n// DIFFICULTY_ADJUST_WINDOW blocks. The corresponding timespan is calculated by using the\n// difference between the median timestamps at the beginning and the end\n// of the window.\n\nfunc NextDifficulty(blist BlockList) Difficulty {\n\n\tblen := len(blist)\n\tif blen == 0 {\n\t\treturn ZeroDifficulty\n\t}\n\n\t// Sum of difficulties in the window, used to calculate the average later.\n\tsumDiff := ZeroDifficulty\n\n\t// Block times at the begining and end of the adjustment window, used to\n\t// calculate medians later.\n\twindowBegin := make([]time.Time, 0)\n\twindowEnd := make([]time.Time, 0)\n\n\tfor i := blen - 1; i >= 0; i-- {\n\t\tif i < DifficultyAdjustWindow {\n\t\t\tsumDiff += blist[i].Header.Difficulty\n\n\t\t\tif i < MedianTimeWindow {\n\t\t\t\twindowBegin = append(windowBegin, blist[i].Header.Timestamp)\n\t\t\t}\n\t\t} else {\n\t\t\tif i < DifficultyAdjustWindow+MedianTimeWindow {\n\t\t\t\twindowEnd = append(windowEnd, blist[i].Header.Timestamp)\n\t\t\t} else {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check we have enough blocks\n\tif len(windowEnd) < MedianTimeWindow {\n\t\treturn MinimumDifficulty\n\t}\n\n\t// Calculating time medians at the beginning and end of the window.\n\tsort.SliceStable(windowBegin, func(i, j int) bool {\n\t\treturn windowBegin[i].Before(windowBegin[j])\n\t})\n\tsort.SliceStable(windowEnd, func(i, j int) bool {\n\t\treturn windowEnd[i].Before(windowEnd[j])\n\t})\n\n\tbeginTime := windowBegin[len(windowBegin)/2]\n\tendTime := windowEnd[len(windowEnd)/2]\n\n\t// Average difficulty and dampened average time\n\tdiffAvg := sumDiff / MinimumDifficulty.FromNum(uint64(DifficultyAdjustWindow))\n\tts := (3*BlockTimeWindow + beginTime.Sub(endTime)) / 4\n\n\t// Apply time bounds\n\tif ts < LowerTimeBound {\n\t\tts = LowerTimeBound\n\t}\n\tif ts > UpperTimeBound {\n\t\tts = UpperTimeBound\n\t}\n\n\t//Result\n\tdiff := diffAvg * MinimumDifficulty.FromNum(uint64(BlockTimeWindow)) / MinimumDifficulty.FromNum(uint64(ts))\n\tif diff > MinimumDifficulty {\n\t\treturn diff\n\t}\n\n\treturn MinimumDifficulty\n}", "id": 4672, "concepts": ["time.Time", "time.Duration", "time.Time.Before", "time.Time.Sub", "time.Time.Add", "time.Time.Unix", "time.Time.UnixNano", "time.Time.UnixMicro", "time.Time.UnixMilli", "time.Time.Unix", "time.Time.Format", "time.Time.Parse", "time.Time.ParseInLocation", "time.Time.Local", "time.Time.UTC", "time.Time.Location", "time.Time.Equal", "time.Time.After", "time.Time.Before", "time.Time.After", "time.Time.Add", "time.Time.AddDate", "time.Time.AddDate", "time.Time.AddDate", "time.Time.AddDate", "time.Time.AddDate", "time.Time.AddDate", "time.Time.AddDate", "time.Time.AddDate", "time.Time.AddDate", "time.Time.AddDate", "time.Time.AddDate", "time.Time.AddDate", "time.Time.AddDate", "time.Time.AddDate", "time.Time.AddDate", "time.Time.AddDate", "time.Time.AddDate", "time.Time.AddDate", "time."], "_raw_llm_output": "time.Time, time.Duration, time.Time.Before, time.Time.Sub, time.Time.Add, time.Time.Unix, time.Time.UnixNano, time.Time.UnixMicro, time.Time.UnixMilli, time.Time.Unix, time.Time.Format, time.Time.Parse, time.Time.ParseInLocation, time.Time.Local, time.Time.UTC, time.Time.Location, time.Time.Equal, time.Time.After, time.Time.Before, time.Time.After, time.Time.Add, time.Time.AddDate, time.Time.AddDate, time.Time.AddDate, time.Time.AddDate, time.Time.AddDate, time.Time.AddDate, time.Time.AddDate, time.Time.AddDate, time.Time.AddDate, time.Time.AddDate, time.Time.AddDate, time.Time.AddDate, time.Time.AddDate, time.Time.AddDate, time.Time.AddDate, time.Time.AddDate, time.Time.AddDate, time.Time.AddDate, time."}
{"seed": "// WithPostHook is an Option that configures the reconciler to run the given\n// PostHook just after performing any non-uninstall release actions.\nfunc WithPostHook(h hook.PostHook) Option {\n\treturn func(r *Reconciler) error {\n\t\tr.postHooks = append(r.postHooks, h)\n\t\treturn nil\n\t}\n}", "id": 4676, "concepts": ["struct definition", "struct field definition", "struct field access", "struct field initialization", "struct field assignment", "struct field type assertion", "function definition", "function call", "function return", "function parameter definition", "function parameter assignment", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion"], "_raw_llm_output": "struct definition, struct field definition, struct field access, struct field initialization, struct field assignment, struct field type assertion, function definition, function call, function return, function parameter definition, function parameter assignment, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion"}
{"seed": "// NewNotificationDataPlaneClientWithConfigurationProvider Creates a new default NotificationDataPlane client with the given configuration provider.\n// the configuration provider will be used for the default signer as well as reading the region\nfunc NewNotificationDataPlaneClientWithConfigurationProvider(configProvider common.ConfigurationProvider) (client NotificationDataPlaneClient, err error) {\n\tbaseClient, err := common.NewClientWithConfig(configProvider)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tclient = NotificationDataPlaneClient{BaseClient: baseClient}\n\tclient.BasePath = \"20181201\"\n\terr = client.setConfigurationProvider(configProvider)\n\treturn\n}", "id": 4688, "concepts": ["configuration provider", "client creation", "default client creation", "client configuration"], "_raw_llm_output": "configuration provider, client creation, default client creation, client configuration"}
{"seed": "// ExtractVariantKeyRefAlt extracts the REF+ALT code from VariantKey.\nfunc ExtractVariantKeyRefAlt(v uint64) uint32 {\n\treturn uint32(C.extract_variantkey_refalt(C.uint64_t(v)))\n}", "id": 4690, "concepts": ["bitwise operation", "bitwise shifting", "bitwise AND", "bitwise OR", "bitwise XOR", "bitwise NOT", "bitwise complement", "bitwise left shift", "bitwise right shift", "bitwise AND with complement", "bitwise OR with complement", "bitwise XOR with complement", "bitwise NOT with complement", "bitwise complement with complement", "bitwise left shift with complement", "bitwise right shift with complement", "bitwise AND with complement with complement", "bitwise OR with complement with complement", "bitwise XOR with complement with complement", "bitwise NOT with complement with complement", "bitwise complement with complement with complement", "bitwise left shift with complement with complement", "bitwise right shift with complement with complement", "bitwise AND with complement with complement with complement", "bitwise OR with complement with complement with complement", "bitwise XOR with complement with complement with complement", "bitwise NOT with complement with complement with complement", "bitwise complement with complement with complement with complement", "bitwise left shift with complement with complement with complement", "bitwise right shift with complement with complement with complement", "bitwise AND with complement with complement with complement with complement", "bitwise OR with complement with complement with complement with complement", "bitwise XOR with complement with complement with complement with complement", "bitwise NOT with complement with"], "_raw_llm_output": "bitwise operation, bitwise shifting, bitwise AND, bitwise OR, bitwise XOR, bitwise NOT, bitwise complement, bitwise left shift, bitwise right shift, bitwise AND with complement, bitwise OR with complement, bitwise XOR with complement, bitwise NOT with complement, bitwise complement with complement, bitwise left shift with complement, bitwise right shift with complement, bitwise AND with complement with complement, bitwise OR with complement with complement, bitwise XOR with complement with complement, bitwise NOT with complement with complement, bitwise complement with complement with complement, bitwise left shift with complement with complement, bitwise right shift with complement with complement, bitwise AND with complement with complement with complement, bitwise OR with complement with complement with complement, bitwise XOR with complement with complement with complement, bitwise NOT with complement with complement with complement, bitwise complement with complement with complement with complement, bitwise left shift with complement with complement with complement, bitwise right shift with complement with complement with complement, bitwise AND with complement with complement with complement with complement, bitwise OR with complement with complement with complement with complement, bitwise XOR with complement with complement with complement with complement, bitwise NOT with complement with"}
{"seed": "// PossibleTypeValues returns an array of possible values for the Type const type.\nfunc PossibleTypeValues() []Type {\n\treturn []Type{MicrosoftKustoclustersattachedDatabaseConfigurations, MicrosoftKustoclustersdatabases}\n}", "id": 4692, "concepts": ["const declaration", "array declaration", "array iteration"], "_raw_llm_output": "const declaration, array declaration, array iteration"}
{"seed": "// PartnerInfo_STATUSGenerator returns a generator of PartnerInfo_STATUS instances for property testing.\nfunc PartnerInfo_STATUSGenerator() gopter.Gen {\n\tif partnerInfo_STATUSGenerator != nil {\n\t\treturn partnerInfo_STATUSGenerator\n\t}\n\n\tgenerators := make(map[string]gopter.Gen)\n\tAddIndependentPropertyGeneratorsForPartnerInfo_STATUS(generators)\n\tpartnerInfo_STATUSGenerator = gen.Struct(reflect.TypeOf(PartnerInfo_STATUS{}), generators)\n\n\treturn partnerInfo_STATUSGenerator\n}", "id": 4712, "concepts": ["struct definition", "map definition", "reflect package usage", "property-based testing"], "_raw_llm_output": "struct definition, map definition, reflect package usage, property-based testing"}
{"seed": "// ContValue returns a Value holding the given arg.\nfunc ContValue(c Cont) Value {\n\treturn Value{iface: c}\n}", "id": 4736, "concepts": ["struct definition", "interface definition", "anonymous struct definition", "method definition"], "_raw_llm_output": "struct definition, interface definition, anonymous struct definition, method definition"}
{"seed": "// ProjectNotBelongToGroupsError indicates project not belong to gropus.\nfunc ProjectNotBelongToGroupsError(name, groups string) error {\n\treturn fmt.Errorf(\"project '%s' not belong to groups '%s'\", name, groups)\n}", "id": 4737, "concepts": ["error handling (fmt.Errorf)", "error wrapping"], "_raw_llm_output": "error handling (fmt.Errorf), error wrapping"}
{"seed": "// DefaultQueueSettings returns the default settings for QueueSettings.\nfunc DefaultQueueSettings() QueueSettings {\n\treturn QueueSettings{\n\t\tEnabled:      true,\n\t\tNumConsumers: 10,\n\t\t// For 5000 queue elements at 100 requests/sec gives about 50 sec of survival of destination outage.\n\t\t// This is a pretty decent value for production.\n\t\t// User should calculate this from the perspective of how many seconds to buffer in case of a backend outage,\n\t\t// multiply that by the number of requests per seconds.\n\t\tQueueSize:                5000,\n\t\tPersistentStorageEnabled: false,\n\t}\n}", "id": 4772, "concepts": ["struct definition", "struct field definition", "struct field initialization", "struct field access", "struct field type inference", "struct field type assertion", "struct field type switch", "struct field type switch case", "struct field type switch default", "struct field type switch case fallthrough", "struct field type switch case fallthrough", "struct field type switch default fallthrough", "struct field type switch case fallthrough", "struct field type switch default fallthrough", "struct field type switch case fallthrough", "struct field type switch default fallthrough", "struct field type switch case fallthrough", "struct field type switch default fallthrough", "struct field type switch case fallthrough", "struct field type switch default fallthrough", "struct field type switch case fallthrough", "struct field type switch default fallthrough", "struct field type switch case fallthrough", "struct field type switch default fallthrough", "struct field type switch case fallthrough", "struct field type switch default fallthrough", "struct field type switch case fallthrough", "struct field type switch default fallthrough", "struct field type switch case fallthrough", "struct field type switch default fallthrough", "struct field type switch case fallthrough", "struct field type switch default fallthrough", "struct field type switch case fallthrough", "struct field type switch default fallthrough", "struct field type switch case fallthrough", "struct field type switch default"], "_raw_llm_output": "struct definition, struct field definition, struct field initialization, struct field access, struct field type inference, struct field type assertion, struct field type switch, struct field type switch case, struct field type switch default, struct field type switch case fallthrough, struct field type switch case fallthrough, struct field type switch default fallthrough, struct field type switch case fallthrough, struct field type switch default fallthrough, struct field type switch case fallthrough, struct field type switch default fallthrough, struct field type switch case fallthrough, struct field type switch default fallthrough, struct field type switch case fallthrough, struct field type switch default fallthrough, struct field type switch case fallthrough, struct field type switch default fallthrough, struct field type switch case fallthrough, struct field type switch default fallthrough, struct field type switch case fallthrough, struct field type switch default fallthrough, struct field type switch case fallthrough, struct field type switch default fallthrough, struct field type switch case fallthrough, struct field type switch default fallthrough, struct field type switch case fallthrough, struct field type switch default fallthrough, struct field type switch case fallthrough, struct field type switch default fallthrough, struct field type switch case fallthrough, struct field type switch default"}
{"seed": "// LoadSigningPubKey loads a public signing key at the given path\n// specified in the given config file.\n// If there is any parsing error or the key is malformed,\n// LoadSigningPubKey() returns an error with a nil key.\nfunc LoadSigningPubKey(path, file string) (sign.PublicKey, error) {\n\tsignPath := utils.ResolvePath(path, file)\n\tsignPubKey, err := ioutil.ReadFile(signPath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Cannot read signing key: %v\", err)\n\t}\n\tif len(signPubKey) != sign.PublicKeySize {\n\t\treturn nil, fmt.Errorf(\"Signing public-key must be 32 bytes (got %d)\", len(signPubKey))\n\t}\n\treturn signPubKey, nil\n}", "id": 4779, "concepts": ["ioutil.ReadFile", "ioutil.WriteFile", "ioutil.TempFile", "ioutil.NopCloser", "ioutil.ReadAll", "ioutil.ReadDir", "ioutil.WriteFile", "ioutil.TempDir", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", "ioutil.TempFile", ""], "_raw_llm_output": "ioutil.ReadFile, ioutil.WriteFile, ioutil.TempFile, ioutil.NopCloser, ioutil.ReadAll, ioutil.ReadDir, ioutil.WriteFile, ioutil.TempDir, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile, ioutil.TempFile,"}
{"seed": "// ConvertTimestamp converts the sync decimal time in seconds to\n// a time in milliseconds\nfunc ConvertTimestamp(ts string) (int, error) {\n\n\tf, err := strconv.ParseFloat(ts, 64)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn int(f * 1000), nil\n\n}", "id": 4786, "concepts": ["string to float conversion", "float to int conversion", "string to int conversion", "strconv package usage"], "_raw_llm_output": "string to float conversion, float to int conversion, string to int conversion, strconv package usage"}
{"seed": "// IDIn applies the In predicate on the ID field.\nfunc IDIn(ids ...int) predicate.Bulk {\n\treturn predicate.Bulk(func(s *sql.Selector) {\n\t\t// if not arguments were provided, append the FALSE constants,\n\t\t// since we can't apply \"IN ()\". This will make this predicate falsy.\n\t\tif len(ids) == 0 {\n\t\t\ts.Where(sql.False())\n\t\t\treturn\n\t\t}\n\t\tv := make([]interface{}, len(ids))\n\t\tfor i := range v {\n\t\t\tv[i] = ids[i]\n\t\t}\n\t\ts.Where(sql.In(s.C(FieldID), v...))\n\t})\n}", "id": 4800, "concepts": ["sql package usage", "sql.In", "sql.False", "sql.Bulk", "predicate.Bulk", "basic function definition"], "_raw_llm_output": "sql package usage, sql.In, sql.False, sql.Bulk, predicate.Bulk, basic function definition"}
{"seed": "// AllowNonEmptyMount allows the mounting over a non-empty directory.\n//\n// The files in it will be shadowed by the freshly created mount. By\n// default these mounts are rejected to prevent accidental covering up\n// of data, which could for example prevent automatic backup.\nfunc AllowNonEmptyMount() MountOption {\n\treturn func(conf *mountConfig) error {\n\t\tconf.options[\"nonempty\"] = \"\"\n\t\treturn nil\n\t}\n}", "id": 4814, "concepts": ["function composition", "function options", "function option composition", "function option usage"], "_raw_llm_output": "function composition, function options, function option composition, function option usage"}
{"seed": "/*\n * param regionId: \u5730\u57df\u4ee3\u7801 (Required)\n * param instanceGid: \u5b9e\u4f8bID (Required)\n * param startTime: \u67e5\u8be2\u5f00\u59cb\u65f6\u95f4\uff0c\u683c\u5f0f\u4e3a\uff1a2006-01-02T15:04:05Z (Required)\n * param endTime: \u67e5\u8be2\u622a\u6b62\u65f6\u95f4\uff0c\u683c\u5f0f\u4e3a\uff1a2006-01-02T15:04:05Z (Required)\n * param dbName: \u8fc7\u6ee4\u6761\u4ef6\uff1a\u6570\u636e\u5e93\u540d (Optional)\n * param userName: \u8fc7\u6ee4\u6761\u4ef6\uff1aclient \u7528\u6237\u540d (Optional)\n * param clientIP: \u8fc7\u6ee4\u6761\u4ef6\uff1aclient IP (Optional)\n * param keyword4Search: \u6a21\u7cca\u67e5\u8be2\u5173\u952e\u5b57\uff0c\u53ea\u652f\u6301\u5355\u4e2a\u5355\u8bcd (Optional)\n * param field: \u6392\u5e8f\u7684\u5b57\u6bb5\uff0c\u652f\u6301 execTime,lockTime,rowsExamined,rowsSent,startTime \u9ed8\u8ba4\u662f startTime (Optional)\n * param sort: \u6392\u5e8f\u65b9\u5f0f\uff0c\u9ed8\u8ba4desc (Optional)\n * param pageIndex: \u663e\u793a\u6570\u636e\u7684\u9875\u7801\uff0c\u9ed8\u8ba4\u4e3a1\uff0c\u53d6\u503c\u8303\u56f4\uff1a[-1,\u221e)\u3002pageIndex \u4e3a-1\u65f6\uff0c\u8fd4\u56de\u6240\u6709\u6570\u636e\u9875\u7801\uff1b (Optional)\n * param pageSize: \u6bcf\u9875\u663e\u793a\u7684\u6570\u636e\u6761\u6570\uff0c\u9ed8\u8ba4\u4e3a10\uff0c\u53d6\u503c\u8303\u56f4\uff1a[1,100]\uff0c\u7528\u4e8e\u67e5\u8be2\u5217\u8868\u7684\u63a5\u53e3 (Optional)\n */\nfunc NewDescribeSlowLogRequestWithAllParams(\n    regionId string,\n    instanceGid string,\n    startTime string,\n    endTime string,\n    dbName *string,\n    userName *string,\n    clientIP *string,\n    keyword4Search *string,\n    field *string,\n    sort *string,\n    pageIndex *int,\n    pageSize *int,\n) *DescribeSlowLogRequest {\n\n    return &DescribeSlowLogRequest{\n        JDCloudRequest: core.JDCloudRequest{\n            URL:     \"/regions/{regionId}/instance/{instanceGid}/slowLog\",\n            Method:  \"GET\",\n            Header:  nil,\n            Version: \"v2\",\n        },\n        RegionId: regionId,\n        InstanceGid: instanceGid,\n        StartTime: startTime,\n        EndTime: endTime,\n        DbName: dbName,\n        UserName: userName,\n        ClientIP: clientIP,\n        Keyword4Search: keyword4Search,\n        Field: field,\n        Sort: sort,\n        PageIndex: pageIndex,\n        PageSize: pageSize,\n    }\n}", "id": 4816, "concepts": ["function definition", "function parameter", "function return value", "function parameter default value", "function parameter type", "function parameter validation", "function parameter validation error handling", "function parameter validation error handling", "function parameter validation error handling", "function parameter validation error handling", "function parameter validation error handling", "function parameter validation error handling", "function parameter validation error handling", "function parameter validation error handling", "function parameter validation error handling", "function parameter validation error handling", "function parameter validation error handling", "function parameter validation error handling", "function parameter validation error handling", "function parameter validation error handling", "function parameter validation error handling", "function parameter validation error handling", "function parameter validation error handling", "function parameter validation error handling", "function parameter validation error handling", "function parameter validation error handling", "function parameter validation error handling", "function parameter validation error handling", "function parameter validation error handling", "function parameter validation error handling", "function parameter validation error handling", "function parameter validation error handling", "function parameter validation error handling", "function parameter validation error handling", "function parameter validation error handling", "function parameter validation error handling", "function parameter validation error handling", "function parameter validation error handling", "function parameter validation error handling", "function parameter validation error handling", "function parameter validation error handling", "function parameter validation error handling", "function parameter validation error handling", "function parameter validation error handling", "function parameter validation error"], "_raw_llm_output": "function definition, function parameter, function return value, function parameter default value, function parameter type, function parameter validation, function parameter validation error handling, function parameter validation error handling, function parameter validation error handling, function parameter validation error handling, function parameter validation error handling, function parameter validation error handling, function parameter validation error handling, function parameter validation error handling, function parameter validation error handling, function parameter validation error handling, function parameter validation error handling, function parameter validation error handling, function parameter validation error handling, function parameter validation error handling, function parameter validation error handling, function parameter validation error handling, function parameter validation error handling, function parameter validation error handling, function parameter validation error handling, function parameter validation error handling, function parameter validation error handling, function parameter validation error handling, function parameter validation error handling, function parameter validation error handling, function parameter validation error handling, function parameter validation error handling, function parameter validation error handling, function parameter validation error handling, function parameter validation error handling, function parameter validation error handling, function parameter validation error handling, function parameter validation error handling, function parameter validation error handling, function parameter validation error handling, function parameter validation error handling, function parameter validation error handling, function parameter validation error handling, function parameter validation error handling, function parameter validation error"}
{"seed": "// RiskDetailPNone returns a pointer to RiskDetailVNone\nfunc RiskDetailPNone() *RiskDetail {\n\tv := RiskDetailVNone\n\treturn &v\n}", "id": 4817, "concepts": ["pointer handling"], "_raw_llm_output": "pointer handling"}
{"seed": "// NewNameContainsFold applies the ContainsFold predicate on the \"new_name\" field.\nfunc NewNameContainsFold(v string) predicate.User {\n\treturn predicate.User(sql.FieldContainsFold(FieldNewName, v))\n}", "id": 4818, "concepts": ["sql.FieldContainsFold", "predicate.User", "sql package usage"], "_raw_llm_output": "sql.FieldContainsFold, predicate.User, sql package usage"}
{"seed": "// Unmarshal a CBE document from a byte slice, creating an object of the same type as the template.\n// If template is nil, an interface type will be returned.\n// If opts is nil, default options will be used.\nfunc UnmarshalCBEFromDocument(document []byte, template interface{}, opts *options.CBEUnmarshalerOptions) (decoded interface{}, err error) {\n\treturn NewCBEUnmarshaler(opts).UnmarshalFromDocument(document, template)\n}", "id": 4819, "concepts": ["interface", "struct", "pointer", "function definition", "standard library usage"], "_raw_llm_output": "interface, struct, pointer, function definition, standard library usage"}
{"seed": "// Exists returns true if the path exists, false otherwise.\n//\n// Returns error on system error.\nfunc Exists(ctx context.Context, readBucket ReadBucket, path string) (bool, error) {\n\t_, err := readBucket.Stat(ctx, path)\n\tif err != nil {\n\t\tif IsNotExist(err) {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, err\n\t}\n\treturn true, nil\n}", "id": 4827, "concepts": ["context package usage", "error handling (IsNotExist)", "standard library usage"], "_raw_llm_output": "context package usage, error handling (IsNotExist), standard library usage"}
{"seed": "// Status_Values returns all elements of the Status enum\nfunc Status_Values() []string {\n\treturn []string{\n\t\tStatusPending,\n\t\tStatusDeployed,\n\t\tStatusPendingDeletion,\n\t}\n}", "id": 4835, "concepts": ["enum", "array", "slice"], "_raw_llm_output": "enum, array, slice"}
{"seed": "// nonemptyString returns nil if s is empty, or else the pointer to s.\nfunc nonemptyString(s string) *string {\n\tif s == \"\" {\n\t\treturn nil\n\t}\n\treturn &s\n}", "id": 4842, "concepts": ["pointer", "nil handling", "pointer dereference"], "_raw_llm_output": "pointer, nil handling, pointer dereference"}
{"seed": "// AddElementosMovimiento insert a new ElementosMovimiento into database and returns\n// last inserted Id on success.\nfunc AddElementosMovimiento(m *ElementosMovimiento) (id int64, err error) {\n\to := orm.NewOrm()\n\tid, err = o.Insert(m)\n\treturn\n}", "id": 4861, "concepts": ["database insertion", "orm usage"], "_raw_llm_output": "database insertion, orm usage"}
{"seed": "// Tr_ is a convenience wrapper for Tr without the attrs argument.\nfunc Tr_(children ...HTML) HTML {\n  return Tr(nil, children...)\n}", "id": 4869, "concepts": ["HTML", "HTML element definition", "HTML attribute definition"], "_raw_llm_output": "HTML, HTML element definition, HTML attribute definition"}
{"seed": "// NewInteraction constructs an interaction with the given prompt, limited to\n// the given choices, if any.\n//\n// Defaults Input and Output to os.Stdin and os.Stderr, respectively.\nfunc NewInteraction(prompt string, choices ...Choice) Interaction {\n\treturn Interaction{\n\t\tInput:   os.Stdin,\n\t\tOutput:  os.Stdout,\n\t\tPrompt:  prompt,\n\t\tChoices: choices,\n\t}\n}", "id": 4874, "concepts": ["struct definition", "function definition", "function return value", "function parameter", "function call", "function call with parameters", "function call with named parameters", "function call with variadic parameters", "function call with variadic parameters and named parameters", "function call with variadic parameters and named parameters", "function call with variadic parameters and named parameters and return value", "function call with variadic parameters and named parameters and return value and error", "function call with variadic parameters and named parameters and return value and error and error handling", "function call with variadic parameters and named parameters and return value and error and error handling and anonymous function", "function call with variadic parameters and named parameters and return value and error and error handling and anonymous function and anonymous function call", "function call with variadic parameters and named parameters and return value and error and error handling and anonymous function and anonymous function call and anonymous function call with parameters", "function call with variadic parameters and named parameters and return value and error and error handling and anonymous function and anonymous function call and anonymous function call with parameters and function definition", "function call with variadic parameters and named parameters and return value and error and error handling and anonymous function and anonymous function call and anonymous function call with parameters and function definition and function call with variadic parameters and named parameters and"], "_raw_llm_output": "struct definition, function definition, function return value, function parameter, function call, function call with parameters, function call with named parameters, function call with variadic parameters, function call with variadic parameters and named parameters, function call with variadic parameters and named parameters, function call with variadic parameters and named parameters and return value, function call with variadic parameters and named parameters and return value and error, function call with variadic parameters and named parameters and return value and error and error handling, function call with variadic parameters and named parameters and return value and error and error handling and anonymous function, function call with variadic parameters and named parameters and return value and error and error handling and anonymous function and anonymous function call, function call with variadic parameters and named parameters and return value and error and error handling and anonymous function and anonymous function call and anonymous function call with parameters, function call with variadic parameters and named parameters and return value and error and error handling and anonymous function and anonymous function call and anonymous function call with parameters and function definition, function call with variadic parameters and named parameters and return value and error and error handling and anonymous function and anonymous function call and anonymous function call with parameters and function definition and function call with variadic parameters and named parameters and"}
{"seed": "// JSONHandler will parse the provided JSON and then return\n// an http.HandlerFunc (which also implements http.Handler)\n// that will attempt to map any paths to their corresponding\n// URL. If the path is not provided in the JSON, then the\n// fallback http.Handler will be called instead.\n//\n// JSON is expected to be in the format:\n//\n//\t[\n//\t\t{\n//\t\t\t\"path\": \"/some-path\",\n//\t\t\t\"url\": \"https://www.some-url.com/demo\"\n//\t\t}\n//\t]\n//\n// The only errors that can be returned all relate to having\n// invalid JSON data.\nfunc JSONHandler(jsonData []byte, fallback http.Handler) (http.HandlerFunc, error) {\n\tmappings := make([]pathURL, 0, 10)\n\tjsonReader := bytes.NewReader(jsonData)\n\tdecoder := json.NewDecoder(jsonReader)\n\terr := decoder.Decode(&mappings)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tmapping := make(map[string]string)\n\t// combine all mappings extracted from json into single mapping\n\tfor _, routingPair := range mappings {\n\t\tmapping[routingPair.Path] = routingPair.URL\n\t}\n\treturn MapHandler(mapping, fallback), nil\n}", "id": 4883, "concepts": ["JSON parsing", "JSON decoding", "map usage", "struct usage", "anonymous function", "interface usage", "error handling"], "_raw_llm_output": "JSON parsing, JSON decoding, map usage, struct usage, anonymous function, interface usage, error handling"}
{"seed": "// PhoneEqualFold applies the EqualFold predicate on the \"phone\" field.\nfunc PhoneEqualFold(v string) predicate.User {\n\treturn predicate.User(sql.FieldEqualFold(FieldPhone, v))\n}", "id": 4903, "concepts": ["predicate.User", "sql.FieldEqualFold", "sql.FieldEqualFold usage"], "_raw_llm_output": "predicate.User, sql.FieldEqualFold, sql.FieldEqualFold usage"}
{"seed": "// NewCountSessionUnauthorized creates a CountSessionUnauthorized with default headers values\nfunc NewCountSessionUnauthorized() *CountSessionUnauthorized {\n\treturn &CountSessionUnauthorized{}\n}", "id": 4921, "concepts": ["struct definition", "struct field initialization", "struct field access", "struct method definition", "method call", "method receiver definition", "method receiver access"], "_raw_llm_output": "struct definition, struct field initialization, struct field access, struct method definition, method call, method receiver definition, method receiver access"}
{"seed": "// Video represents the HTML element 'video'.\n// For more information visit https://www.w3schools.com/tags/tag_video.asp.\nfunc Video(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"video\", Attributes: attrs, Children: children}\n}", "id": 4924, "concepts": ["HTML generation", "HTML tree generation", "HTML element definition", "HTML attribute definition"], "_raw_llm_output": "HTML generation, HTML tree generation, HTML element definition, HTML attribute definition"}
{"seed": "// SignupAuthenticationPath computes a request path to the signup action of authentication.\nfunc SignupAuthenticationPath() string {\n\n\treturn fmt.Sprintf(\"/v1/signup\")\n}", "id": 4925, "concepts": ["string formatting", "fmt package usage"], "_raw_llm_output": "string formatting, fmt package usage"}
{"seed": "// Tfoot represents the HTML element 'tfoot'.\n// For more information visit https://www.w3schools.com/tags/tag_tfoot.asp.\nfunc Tfoot(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"tfoot\", Attributes: attrs, Children: children}\n}", "id": 4927, "concepts": ["HTML generation", "HTML generation (HTML tree)", "HTML generation (HTML element)", "HTML generation (HTML attribute)", "HTML generation (HTML child)", "HTML generation (HTML child)", "HTML generation (HTML child)", "HTML generation (HTML child)", "HTML generation (HTML child)", "HTML generation (HTML child)", "HTML generation (HTML child)", "HTML generation (HTML child)", "HTML generation (HTML child)", "HTML generation (HTML child)", "HTML generation (HTML child)", "HTML generation (HTML child)", "HTML generation (HTML child)", "HTML generation (HTML child)", "HTML generation (HTML child)", "HTML generation (HTML child)", "HTML generation (HTML child)", "HTML generation (HTML child)", "HTML generation (HTML child)", "HTML generation (HTML child)", "HTML generation (HTML child)", "HTML generation (HTML child)", "HTML generation (HTML child)", "HTML generation (HTML child)", "HTML generation (HTML child)", "HTML generation (HTML child)", "HTML generation (HTML child)", "HTML generation (HTML child)", "HTML generation (HTML child)", "HTML generation (HTML child)", "HTML generation (HTML child)", "HTML generation (HTML child)", "HTML generation (HTML child)", "HTML generation (HTML child)", "HTML generation (HTML child)", "HTML generation (HTML child)", "HTML generation (HTML child)", "HTML generation (HTML child)", "HTML generation (HTML child)", ""], "_raw_llm_output": "HTML generation, HTML generation (HTML tree), HTML generation (HTML element), HTML generation (HTML attribute), HTML generation (HTML child), HTML generation (HTML child), HTML generation (HTML child), HTML generation (HTML child), HTML generation (HTML child), HTML generation (HTML child), HTML generation (HTML child), HTML generation (HTML child), HTML generation (HTML child), HTML generation (HTML child), HTML generation (HTML child), HTML generation (HTML child), HTML generation (HTML child), HTML generation (HTML child), HTML generation (HTML child), HTML generation (HTML child), HTML generation (HTML child), HTML generation (HTML child), HTML generation (HTML child), HTML generation (HTML child), HTML generation (HTML child), HTML generation (HTML child), HTML generation (HTML child), HTML generation (HTML child), HTML generation (HTML child), HTML generation (HTML child), HTML generation (HTML child), HTML generation (HTML child), HTML generation (HTML child), HTML generation (HTML child), HTML generation (HTML child), HTML generation (HTML child), HTML generation (HTML child), HTML generation (HTML child), HTML generation (HTML child), HTML generation (HTML child), HTML generation (HTML child), HTML generation (HTML child), HTML generation (HTML child),"}
{"seed": "// DecodeRetrieveResponse returns a decoder for responses returned by the user\n// retrieve endpoint. restoreBody controls whether the response body should be\n// restored after having been read.\n// DecodeRetrieveResponse may return the following errors:\n//\t- \"invalide_token\" (type *goa.ServiceError): http.StatusBadRequest\n//\t- \"not_found\" (type *goa.ServiceError): http.StatusNotFound\n//\t- error: internal error\nfunc DecodeRetrieveResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {\n\treturn func(resp *http.Response) (interface{}, error) {\n\t\tif restoreBody {\n\t\t\tb, err := ioutil.ReadAll(resp.Body)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tresp.Body = ioutil.NopCloser(bytes.NewBuffer(b))\n\t\t\tdefer func() {\n\t\t\t\tresp.Body = ioutil.NopCloser(bytes.NewBuffer(b))\n\t\t\t}()\n\t\t} else {\n\t\t\tdefer resp.Body.Close()\n\t\t}\n\t\tswitch resp.StatusCode {\n\t\tcase http.StatusOK:\n\t\t\tvar (\n\t\t\t\tbody RetrieveResponseBody\n\t\t\t\terr  error\n\t\t\t)\n\t\t\terr = decoder(resp).Decode(&body)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, goahttp.ErrDecodingError(\"user\", \"retrieve\", err)\n\t\t\t}\n\t\t\tp := NewRetrieveResponseDataOK(&body)\n\t\t\tview := \"default\"\n\t\t\tvres := &userviews.ResponseData{p, view}\n\t\t\tif err = userviews.ValidateResponseData(vres); err != nil {\n\t\t\t\treturn nil, goahttp.ErrValidationError(\"user\", \"retrieve\", err)\n\t\t\t}\n\t\t\tres := user.NewResponseData(vres)\n\t\t\treturn res, nil\n\t\tcase http.StatusBadRequest:\n\t\t\tvar (\n\t\t\t\tbody RetrieveInvalideTokenResponseBody\n\t\t\t\terr  error\n\t\t\t)\n\t\t\terr = decoder(resp).Decode(&body)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, goahttp.ErrDecodingError(\"user\", \"retrieve\", err)\n\t\t\t}\n\t\t\terr = ValidateRetrieveInvalideTokenResponseBody(&body)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, goahttp.ErrValidationError(\"user\", \"retrieve\", err)\n\t\t\t}\n\t\t\treturn nil, NewRetrieveInvalideToken(&body)\n\t\tcase http.StatusNotFound:\n\t\t\tvar (\n\t\t\t\tbody RetrieveNotFoundResponseBody\n\t\t\t\terr  error\n\t\t\t)\n\t\t\terr = decoder(resp).Decode(&body)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, goahttp.ErrDecodingError(\"user\", \"retrieve\", err)\n\t\t\t}\n\t\t\terr = ValidateRetrieveNotFoundResponseBody(&body)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, goahttp.ErrValidationError(\"user\", \"retrieve\", err)\n\t\t\t}\n\t\t\treturn nil, NewRetrieveNotFound(&body)\n\t\tdefault:\n\t\t\tbody, _ := ioutil.ReadAll(resp.Body)\n\t\t\treturn nil, goahttp.ErrInvalidResponse(\"user\", \"retrieve\", resp.StatusCode, string(body))\n\t\t}\n\t}\n}", "id": 4962, "concepts": ["function definition", "function return", "function call", "function parameter", "function scope", "function closure", "function composition", "function composition with anonymous function", "function composition with named function", "function composition with named function with parameter", "function composition with named function with return", "function composition with named function with return with parameter", "function composition with named function with return with parameter with return", "function composition with named function with return with parameter with return with parameter", "function composition with named function with return with parameter with return with parameter with return", "function composition with named function with return with parameter with return with parameter with return with parameter", "function composition with named function with return with parameter with return with parameter with return with parameter with return", "function composition with named function with return with parameter with return with parameter with return with parameter with return with parameter", "function composition with named function with return with parameter with return with parameter with return with parameter with return with parameter with return", "function composition with named function with return with parameter with return with parameter with return with parameter with return with parameter with return with return", "function composition with named function with return with parameter with return with parameter with return with parameter with return with parameter with return with return with parameter", "function composition with named function with return with parameter with return with parameter with return with"], "_raw_llm_output": "function definition, function return, function call, function parameter, function scope, function closure, function composition, function composition with anonymous function, function composition with named function, function composition with named function with parameter, function composition with named function with return, function composition with named function with return with parameter, function composition with named function with return with parameter with return, function composition with named function with return with parameter with return with parameter, function composition with named function with return with parameter with return with parameter with return, function composition with named function with return with parameter with return with parameter with return with parameter, function composition with named function with return with parameter with return with parameter with return with parameter with return, function composition with named function with return with parameter with return with parameter with return with parameter with return with parameter, function composition with named function with return with parameter with return with parameter with return with parameter with return with parameter with return, function composition with named function with return with parameter with return with parameter with return with parameter with return with parameter with return with return, function composition with named function with return with parameter with return with parameter with return with parameter with return with parameter with return with return with parameter, function composition with named function with return with parameter with return with parameter with return with"}
{"seed": "// noteTextFromString returns the text of the release note given a string which\n// may contain the commit message, the PR description, etc.\n// This is generally the content inside the ```release-note ``` stanza.\nfunc noteTextFromString(s string) (string, error) {\n\texps := []*regexp.Regexp{\n\t\t// (?s) is needed for '.' to be matching on newlines, by default that's disabled\n\t\t// we need to match ungreedy 'U', because after the notes a `docs` block can occur\n\t\tregexp.MustCompile(\"(?sU)```release-notes?\\\\r\\\\n(?P<note>.+)\\\\r\\\\n```\"),\n\t\tregexp.MustCompile(\"(?sU)```dev-release-notes?\\\\r\\\\n(?P<note>.+)\"),\n\t\tregexp.MustCompile(\"(?sU)```\\\\r\\\\n(?P<note>.+)\\\\r\\\\n```\"),\n\t\tregexp.MustCompile(\"(?sU)```release-notes?\\n(?P<note>.+)\\n```\"),\n\t}\n\n\tfor _, exp := range exps {\n\t\tmatch := exp.FindStringSubmatch(s)\n\t\tif len(match) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tresult := map[string]string{}\n\t\tfor i, name := range exp.SubexpNames() {\n\t\t\tif i != 0 && name != \"\" {\n\t\t\t\tresult[name] = match[i]\n\t\t\t}\n\t\t}\n\n\t\tnote := strings.ReplaceAll(result[\"note\"], \"\\r\", \"\")\n\t\tnote = stripActionRequired(note)\n\t\tnote = dashify(note)\n\t\tnote = unlist(note)\n\t\tnote = strings.TrimSpace(note)\n\t\treturn note, nil\n\t}\n\n\treturn \"\", errors.New(\"no matches found when parsing note text from commit string\")\n}", "id": 4963, "concepts": ["regexp", "string manipulation", "string formatting", "string trimming", "string splitting", "string joining", "string matching", "string replacement", "string trimming", "string splitting", "string joining", "string matching", "string replacement", "string trimming", "string splitting", "string joining", "string matching", "string replacement", "string trimming", "string splitting", "string joining", "string matching", "string replacement", "string trimming", "string splitting", "string joining", "string matching", "string replacement", "string trimming", "string splitting", "string joining", "string matching", "string replacement", "string trimming", "string splitting", "string joining", "string matching", "string replacement", "string trimming", "string splitting", "string joining", "string matching", "string replacement", "string trimming", "string splitting", "string joining", "string matching", "string replacement", "string trimming", "string splitting", "string joining", "string matching", "string replacement", "string trimming", "string splitting", "string joining", "string matching", "string replacement", "string trimming", "string splitting", "string joining", "string matching", "string replacement", "string trimming", "string splitting", "string joining", "string matching", "string replacement", "string trimming", "string splitting", "string joining", "string matching", "string replacement", "string trimming", "string splitting", "string"], "_raw_llm_output": "regexp, string manipulation, string formatting, string trimming, string splitting, string joining, string matching, string replacement, string trimming, string splitting, string joining, string matching, string replacement, string trimming, string splitting, string joining, string matching, string replacement, string trimming, string splitting, string joining, string matching, string replacement, string trimming, string splitting, string joining, string matching, string replacement, string trimming, string splitting, string joining, string matching, string replacement, string trimming, string splitting, string joining, string matching, string replacement, string trimming, string splitting, string joining, string matching, string replacement, string trimming, string splitting, string joining, string matching, string replacement, string trimming, string splitting, string joining, string matching, string replacement, string trimming, string splitting, string joining, string matching, string replacement, string trimming, string splitting, string joining, string matching, string replacement, string trimming, string splitting, string joining, string matching, string replacement, string trimming, string splitting, string joining, string matching, string replacement, string trimming, string splitting, string"}
{"seed": "// NewBoltDBStore creates a BoltDBStore persisting its state in the given directory\nfunc NewBoltDBStore(logger *zap.SugaredLogger, dataDir string) (*BoltDBStore, error) {\n\tdb, err := bolt.Open(filepath.Join(dataDir, \"dd-dns.db\"), 0600, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\t_, err := tx.CreateBucketIfNotExists([]byte(bucketName))\n\t\treturn err\n\t}); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &BoltDBStore{db: db, logger: logger.Named(\"boltdb-store\")}, nil\n}", "id": 4964, "concepts": ["BoltDB", "BoltDB bucket", "BoltDB transaction", "BoltDB update", "BoltDB create bucket if not exists"], "_raw_llm_output": "BoltDB, BoltDB bucket, BoltDB transaction, BoltDB update, BoltDB create bucket if not exists"}
{"seed": "// Create a new root object iterator that will send data events to eventReceiver.\n// If opts is nil, default options will be used.\nfunc NewRootObjectIterator(context *Context,\n\teventReceiver events.DataEventReceiver,\n\topts *options.IteratorOptions) *RootObjectIterator {\n\n\t_this := &RootObjectIterator{}\n\t_this.Init(context, eventReceiver, opts)\n\treturn _this\n}", "id": 4988, "concepts": ["function definition", "function return value", "function pointer", "struct definition", "struct initialization", "method definition", "method call", "method return value", "method pointer"], "_raw_llm_output": "function definition, function return value, function pointer, struct definition, struct initialization, method definition, method call, method return value, method pointer"}
{"seed": "// readln returns a single line (without the ending \\n)\n// from the input buffered reader.\n// An error is returned if there is an error with the\n// buffered reader.\nfunc readln(r *bufio.Reader) (string, error) {\n\tvar (\n\t\tisPrefix bool  = true\n\t\terr      error = nil\n\t\tline, ln []byte\n\t)\n\tfor isPrefix && err == nil {\n\t\tline, isPrefix, err = r.ReadLine()\n\t\tln = append(ln, line...)\n\t}\n\treturn string(ln), err\n}", "id": 4995, "concepts": ["bufio.Reader usage", "buffered reader", "string manipulation"], "_raw_llm_output": "bufio.Reader usage, buffered reader, string manipulation"}
{"seed": "// DefaultExprsEQ applies the EQ predicate on the \"default_exprs\" field.\nfunc DefaultExprsEQ(v string) predicate.User {\n\treturn predicate.User(sql.FieldEQ(FieldDefaultExprs, v))\n}", "id": 5002, "concepts": ["sql.FieldEQ", "sql.Field", "sql.Predicate", "sql.FieldEQ"], "_raw_llm_output": "sql.FieldEQ, sql.Field, sql.Predicate, sql.FieldEQ"}
{"seed": "// NetworkInterfacePropertiesFormat_ARMGenerator returns a generator of NetworkInterfacePropertiesFormat_ARM instances for property testing.\n// We first initialize networkInterfacePropertiesFormat_ARMGenerator with a simplified generator based on the\n// fields with primitive types then replacing it with a more complex one that also handles complex fields\n// to ensure any cycles in the object graph properly terminate.\nfunc NetworkInterfacePropertiesFormat_ARMGenerator() gopter.Gen {\n\tif networkInterfacePropertiesFormat_ARMGenerator != nil {\n\t\treturn networkInterfacePropertiesFormat_ARMGenerator\n\t}\n\n\tgenerators := make(map[string]gopter.Gen)\n\tAddIndependentPropertyGeneratorsForNetworkInterfacePropertiesFormat_ARM(generators)\n\tnetworkInterfacePropertiesFormat_ARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfacePropertiesFormat_ARM{}), generators)\n\n\t// The above call to gen.Struct() captures the map, so create a new one\n\tgenerators = make(map[string]gopter.Gen)\n\tAddIndependentPropertyGeneratorsForNetworkInterfacePropertiesFormat_ARM(generators)\n\tAddRelatedPropertyGeneratorsForNetworkInterfacePropertiesFormat_ARM(generators)\n\tnetworkInterfacePropertiesFormat_ARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfacePropertiesFormat_ARM{}), generators)\n\n\treturn networkInterfacePropertiesFormat_ARMGenerator\n}", "id": 5006, "concepts": ["struct", "map", "reflection", "generator", "property testing"], "_raw_llm_output": "struct, map, reflection, generator, property testing"}
{"seed": "/*union - \u043e\u0431\u044a\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0435 \u0434\u0432\u0443\u0445 \u0441\u0440\u0435\u0437\u043e\u0432 \u0441 \u0443\u043d\u0438\u043a\u0430\u043b\u044c\u043d\u043e\u0441\u0442\u044c\u044e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432*/\nfunc union(arr1 []uint32, arr2 []uint32) []uint32 {\n\tm := make(map[uint32]bool) // \u043a\u0430\u0440\u0442\u0430 \u0443\u043d\u0438\u043a\u0430\u043b\u044c\u043d\u044b\u0445 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432\n\tfor _, item := range arr1 {\n\t\t_, ok := m[item] // \u0435\u0441\u043b\u0438 \u043d\u0435\u0442 \u0442\u0430\u043a\u043e\u0433\u043e id \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c\n\t\tif !ok {\n\t\t\tm[item] = false\n\t\t}\n\t}\n\tfor _, item := range arr2 {\n\t\t_, ok := m[item] // \u0435\u0441\u043b\u0438 \u043d\u0435\u0442 \u0442\u0430\u043a\u043e\u0433\u043e id \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c\n\t\tif !ok {\n\t\t\tm[item] = false\n\t\t}\n\t}\n\tout := make([]uint32, len(m))\n\tfor k := range m {\n\t\tout = append(out, k)\n\t}\n\treturn out\n}", "id": 5007, "concepts": ["map", "slice", "map iteration", "slice iteration", "map key existence check", "slice append"], "_raw_llm_output": "map, slice, map iteration, slice iteration, map key existence check, slice append"}
{"seed": "// Calculate the Sun Declination in degrees based on the formula: rad2deg(asin(sin(deg2rad(obliqCorr))*sin(deg2rad(sunAppLong))))\n// obliqCorr - Obliq Corr calculated by the calcObliqCorr function\n// sunAppLong - Sun App Long calculated by the calcSunAppLong function\n// Return the sun declination slice\nfunc calcSunDeclination(obliqCorr []float64, sunAppLong []float64) (sunDeclination []float64) {\n\tif len(obliqCorr) != len(sunAppLong) {\n\t\treturn\n\t}\n\n\tfor index := 0; index < len(obliqCorr); index++ {\n\t\ttemp := rad2deg(math.Asin(math.Sin(deg2rad(obliqCorr[index])) * math.Sin(deg2rad(sunAppLong[index]))))\n\t\tsunDeclination = append(sunDeclination, temp)\n\t}\n\treturn\n}", "id": 5033, "concepts": ["math package usage", "math functions", "slice iteration", "slice manipulation", "basic function definition"], "_raw_llm_output": "math package usage, math functions, slice iteration, slice manipulation, basic function definition"}
{"seed": "// HasConditionReason returns true if the first Condition with given conditionType from the given slice has the specified reason\nfunc HasConditionReason(conditions []toolchainv1alpha1.Condition, conditionType toolchainv1alpha1.ConditionType, reason string) bool {\n\tcon, found := FindConditionByType(conditions, conditionType)\n\treturn found && con.Reason == reason\n}", "id": 5050, "concepts": ["slice iteration (range loop)", "struct definition", "struct field access", "interface definition", "interface implementation", "standard library usage"], "_raw_llm_output": "slice iteration (range loop), struct definition, struct field access, interface definition, interface implementation, standard library usage"}
{"seed": "// Calculate the Obliq Corr in degrees based on the formula: meanObliqEcliptic+0.00256*cos(deg2rad(125.04-1934.136*julianCentury))\n// meanObliqEcliptic - Mean Obliq Ecliptic calculated by the calcMeanObliqEcliptic function\n// julianCentury - Julian century calculated by the calcJulianCentury function\n// Return the Obliq Corr slice\nfunc calcObliqCorr(meanObliqEcliptic []float64, julianCentury []float64) (obliqCorr []float64) {\n\tif len(meanObliqEcliptic) != len(julianCentury) {\n\t\treturn\n\t}\n\n\tfor index := 0; index < len(julianCentury); index++ {\n\t\ttemp := meanObliqEcliptic[index] + 0.00256*math.Cos(deg2rad(125.04-1934.136*julianCentury[index]))\n\t\tobliqCorr = append(obliqCorr, temp)\n\t}\n\treturn\n}", "id": 5051, "concepts": ["slice", "math.Cos", "math.Sin", "math.Tan", "math.Acos", "math.Asin", "math.Atan", "math.Atan2", "math.Cos", "math.Sin", "math.Tan", "math.Acos", "math.Asin", "math.Atan", "math.Atan2", "math.Cos", "math.Sin", "math.Tan", "math.Acos", "math.Asin", "math.Atan", "math.Atan2", "math.Cos", "math.Sin", "math.Tan", "math.Acos", "math.Asin", "math.Atan", "math.Atan2", "math.Cos", "math.Sin", "math.Tan", "math.Acos", "math.Asin", "math.Atan", "math.Atan2", "math.Cos", "math.Sin", "math.Tan", "math.Acos", "math.Asin", "math.Atan", "math.Atan2", "math.Cos", "math.Sin", "math.Tan", "math.Acos", "math.Asin", "math.Atan", "math.Atan2", "math.Cos", "math.Sin", "math.Tan", "math.Acos", "math.Asin", ""], "_raw_llm_output": "slice, math.Cos, math.Sin, math.Tan, math.Acos, math.Asin, math.Atan, math.Atan2, math.Cos, math.Sin, math.Tan, math.Acos, math.Asin, math.Atan, math.Atan2, math.Cos, math.Sin, math.Tan, math.Acos, math.Asin, math.Atan, math.Atan2, math.Cos, math.Sin, math.Tan, math.Acos, math.Asin, math.Atan, math.Atan2, math.Cos, math.Sin, math.Tan, math.Acos, math.Asin, math.Atan, math.Atan2, math.Cos, math.Sin, math.Tan, math.Acos, math.Asin, math.Atan, math.Atan2, math.Cos, math.Sin, math.Tan, math.Acos, math.Asin, math.Atan, math.Atan2, math.Cos, math.Sin, math.Tan, math.Acos, math.Asin,"}
{"seed": "// Calculate the Sun True Long in degrees based on the formula: sunEqCtr + geomMeanLongSun\n// sunEqCtr - Sun Eq Ctr calculated by the calcSunEqCtr function\n// geomMeanLongSun - Geom Mean Long Sun calculated by the calcGeomMeanLongSun function\n// Return The Sun True Long slice\nfunc calcSunTrueLong(sunEqCtr []float64, geomMeanLongSun []float64) (sunTrueLong []float64) {\n\tif len(sunEqCtr) != len(geomMeanLongSun) {\n\t\treturn\n\t}\n\n\tfor index := 0; index < len(sunEqCtr); index++ {\n\t\ttemp := sunEqCtr[index] + geomMeanLongSun[index]\n\t\tsunTrueLong = append(sunTrueLong, temp)\n\t}\n\treturn\n}", "id": 5064, "concepts": ["slice iteration (range loop)", "slice definition", "slice append", "basic function definition"], "_raw_llm_output": "slice iteration (range loop), slice definition, slice append, basic function definition"}
{"seed": "// TitleNotIn applies the NotIn predicate on the \"title\" field.\nfunc TitleNotIn(vs ...string) predicate.User {\n\treturn predicate.User(sql.FieldNotIn(FieldTitle, vs...))\n}", "id": 5073, "concepts": ["sql.FieldNotIn", "predicate.User", "basic function definition"], "_raw_llm_output": "sql.FieldNotIn, predicate.User, basic function definition"}
{"seed": "// NewStorageNetAppSnapshotPolicySchedule instantiates a new StorageNetAppSnapshotPolicySchedule object\n// This constructor will assign default values to properties that have it defined,\n// and makes sure properties required by API are set, but the set of arguments\n// will change when the set of required properties is changed\nfunc NewStorageNetAppSnapshotPolicySchedule(classId string, objectType string) *StorageNetAppSnapshotPolicySchedule {\n\tthis := StorageNetAppSnapshotPolicySchedule{}\n\tthis.ClassId = classId\n\tthis.ObjectType = objectType\n\treturn &this\n}", "id": 5085, "concepts": ["struct definition", "struct initialization", "struct field access"], "_raw_llm_output": "struct definition, struct initialization, struct field access"}
{"seed": "// NewLocal will return a Local cache pointing to the OS specific directory where files are cached.\n// label is the name of the subdirectory, it should not be empty.\n//\n// Example:\n//   l := NewLocal(\"gnome\")\n//\n// Will return /home/username/.cache/gnome as the location for the cache.\nfunc NewLocal(label string) *Local {\n\treturn &Local{Root: configdir.LocalCache(label)}\n}", "id": 5093, "concepts": ["configdir package usage", "directory creation", "file creation", "file deletion", "file reading", "file writing"], "_raw_llm_output": "configdir package usage, directory creation, file creation, file deletion, file reading, file writing"}
{"seed": "// Every returns true if all elements of a subset are contained into a collection.\nfunc Every[T comparable](collection []T, subset []T) bool {\n\tfor _, elem := range subset {\n\t\tif !Contains(collection, elem) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}", "id": 5106, "concepts": ["slice iteration (range loop)", "type parameter", "generic function definition"], "_raw_llm_output": "slice iteration (range loop), type parameter, generic function definition"}
{"seed": "// FindKeyStoneCACert takes a list of keystone URLs and tries to find the first entry\n// whose region matches with the given region and returns the CA cert for this region. If no such entry is found then it\n// tries to use the non-regional value.\nfunc FindKeyStoneCACert(keyStoneURLs []api.KeyStoneURL, keystoneCABundle *string, region string) *string {\n\tfor _, keyStoneURL := range keyStoneURLs {\n\t\tif keyStoneURL.Region == region && keyStoneURL.CACert != nil && len(*keyStoneURL.CACert) > 0 {\n\t\t\treturn keyStoneURL.CACert\n\t\t}\n\t}\n\n\treturn keystoneCABundle\n}", "id": 5116, "concepts": ["slice iteration (range loop)", "conditional statement (if)", "string comparison", "string length check", "pointer handling"], "_raw_llm_output": "slice iteration (range loop), conditional statement (if), string comparison, string length check, pointer handling"}
{"seed": "// PhoneHasSuffix applies the HasSuffix predicate on the \"phone\" field.\nfunc PhoneHasSuffix(v string) predicate.User {\n\treturn predicate.User(sql.FieldHasSuffix(FieldPhone, v))\n}", "id": 5117, "concepts": ["sql.FieldHasSuffix", "predicate.User", "sql.Field", "sql.FieldHasSuffix"], "_raw_llm_output": "sql.FieldHasSuffix, predicate.User, sql.Field, sql.FieldHasSuffix"}
{"seed": "// NewLabelProperties instantiates a new LabelProperties object\n// This constructor will assign default values to properties that have it defined,\n// and makes sure properties required by API are set, but the set of arguments\n// will change when the set of required properties is changed\nfunc NewLabelProperties() *LabelProperties {\n\tthis := LabelProperties{}\n\n\treturn &this\n}", "id": 5124, "concepts": ["struct definition", "struct initialization", "struct field assignment", "struct field initialization"], "_raw_llm_output": "struct definition, struct initialization, struct field assignment, struct field initialization"}
{"seed": "// BetterHeroScoreNotIn applies the NotIn predicate on the \"better_hero_score\" field.\nfunc BetterHeroScoreNotIn(vs ...int) predicate.User {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.User(func(s *sql.Selector) {\n\t\t// if not arguments were provided, append the FALSE constants,\n\t\t// since we can't apply \"IN ()\". This will make this predicate falsy.\n\t\tif len(vs) == 0 {\n\t\t\ts.Where(sql.False())\n\t\t\treturn\n\t\t}\n\t\ts.Where(sql.NotIn(s.C(FieldBetterHeroScore), v...))\n\t})\n}", "id": 5131, "concepts": ["sql.Selector", "sql.NotIn", "sql.False", "sql.C", "sql.Where", "sql.And", "sql.Or", "sql.Not", "sql.True", "sql.False", "sql.IsNull", "sql.IsNotNull", "sql.IsNullOr", "sql.IsNotNullOr", "sql.NotEq", "sql.Eq", "sql.Gt", "sql.Gte", "sql.Lt", "sql.Lte", "sql.Like", "sql.NotLike", "sql.In", "sql.NotIn", "sql.And", "sql.Or", "sql.Not", "sql.True", "sql.False", "sql.IsNull", "sql.IsNotNull", "sql.IsNullOr", "sql.IsNotNullOr", "sql.NotEq", "sql.Eq", "sql.Gt", "sql.Gte", "sql.Lt", "sql.Lte", "sql.Like", "sql.NotLike", "sql.In", "sql.NotIn", "sql.And", "sql.Or", "sql.Not", "sql.True", "sql.False", "sql.IsNull", "sql.IsNotNull", "sql.IsNullOr", "sql.IsNotNullOr", "sql.NotEq", "sql.Eq", "sql.Gt", "sql.Gte", "sql.Lt", "sql.Lte", "sql.Like", "sql."], "_raw_llm_output": "sql.Selector, sql.NotIn, sql.False, sql.C, sql.Where, sql.And, sql.Or, sql.Not, sql.True, sql.False, sql.IsNull, sql.IsNotNull, sql.IsNullOr, sql.IsNotNullOr, sql.NotEq, sql.Eq, sql.Gt, sql.Gte, sql.Lt, sql.Lte, sql.Like, sql.NotLike, sql.In, sql.NotIn, sql.And, sql.Or, sql.Not, sql.True, sql.False, sql.IsNull, sql.IsNotNull, sql.IsNullOr, sql.IsNotNullOr, sql.NotEq, sql.Eq, sql.Gt, sql.Gte, sql.Lt, sql.Lte, sql.Like, sql.NotLike, sql.In, sql.NotIn, sql.And, sql.Or, sql.Not, sql.True, sql.False, sql.IsNull, sql.IsNotNull, sql.IsNullOr, sql.IsNotNullOr, sql.NotEq, sql.Eq, sql.Gt, sql.Gte, sql.Lt, sql.Lte, sql.Like, sql."}
{"seed": "// NewNetworkPruneParamsWithHTTPClient creates a new NetworkPruneParams object\n// with the default values initialized, and the ability to set a custom HTTPClient for a request\nfunc NewNetworkPruneParamsWithHTTPClient(client *http.Client) *NetworkPruneParams {\n\tvar ()\n\treturn &NetworkPruneParams{\n\t\tHTTPClient: client,\n\t}\n}", "id": 5135, "concepts": ["struct initialization", "pointer usage"], "_raw_llm_output": "struct initialization, pointer usage"}
{"seed": "// FirewallDomainUpdateOperation_Values returns all elements of the FirewallDomainUpdateOperation enum\nfunc FirewallDomainUpdateOperation_Values() []string {\n\treturn []string{\n\t\tFirewallDomainUpdateOperationAdd,\n\t\tFirewallDomainUpdateOperationRemove,\n\t\tFirewallDomainUpdateOperationReplace,\n\t}\n}", "id": 5139, "concepts": ["enum", "string manipulation"], "_raw_llm_output": "enum, string manipulation"}
{"seed": "// HashBytes takes a byte array and uses blake2b\n// to hash the contents. It then returns a hex encoded\n// string of the results\nfunc HashBytes(bytes []byte) string {\n\thash := blake2b.Sum256(bytes)\n\treturn hex.EncodeToString(hash[:])\n}", "id": 5155, "concepts": ["blake2b", "byte array handling", "hex encoding"], "_raw_llm_output": "blake2b, byte array handling, hex encoding"}
{"seed": "// SaturnApparentPolar returns apparent polar semidiameter of Saturn\n// \u571f\u661f\u6781\u89c6\u534a\u5f84\n// at specified distance.\n//\n// Argument \u0394 must be observer-Saturn distance in AU.  Argument B is\n// Saturnicentric latitude of the observer as given by function saturnring.UB()\n// for example.\nfunc SaturnApparentPolar(\u0394 float64, B unit.Angle) unit.Angle {\n\tk := (SaturnPolar.Rad() / SaturnEquatorial.Rad())\n\tk = 1 - k*k\n\tcB := B.Cos()\n\treturn SaturnEquatorial.Mul(math.Sqrt(1-k*cB*cB) / \u0394)\n}", "id": 5158, "concepts": ["struct definition", "struct field access", "struct method definition", "struct method call", "struct method return", "struct method argument", "struct method argument access", "struct method argument access", "struct method argument access", "struct method argument access", "struct method argument access", "struct method argument access", "struct method argument access", "struct method argument access", "struct method argument access", "struct method argument access", "struct method argument access", "struct method argument access", "struct method argument access", "struct method argument access", "struct method argument access", "struct method argument access", "struct method argument access", "struct method argument access", "struct method argument access", "struct method argument access", "struct method argument access", "struct method argument access", "struct method argument access", "struct method argument access", "struct method argument access", "struct method argument access", "struct method argument access", "struct method argument access", "struct method argument access", "struct method argument access", "struct method argument access", "struct method argument access", "struct method argument access", "struct method argument access", "struct method argument access", "struct method argument access", "struct method argument access", "struct method argument access", "struct method argument access", "struct method argument access", "struct method argument access", "struct method argument access", "struct method argument access", "struct method argument access", "struct method argument access", "struct method argument access", "struct method"], "_raw_llm_output": "struct definition, struct field access, struct method definition, struct method call, struct method return, struct method argument, struct method argument access, struct method argument access, struct method argument access, struct method argument access, struct method argument access, struct method argument access, struct method argument access, struct method argument access, struct method argument access, struct method argument access, struct method argument access, struct method argument access, struct method argument access, struct method argument access, struct method argument access, struct method argument access, struct method argument access, struct method argument access, struct method argument access, struct method argument access, struct method argument access, struct method argument access, struct method argument access, struct method argument access, struct method argument access, struct method argument access, struct method argument access, struct method argument access, struct method argument access, struct method argument access, struct method argument access, struct method argument access, struct method argument access, struct method argument access, struct method argument access, struct method argument access, struct method argument access, struct method argument access, struct method argument access, struct method argument access, struct method argument access, struct method argument access, struct method argument access, struct method argument access, struct method argument access, struct method argument access, struct method"}
{"seed": "// FocusIn returns an event that responds to the javascript \"focusin\" event. This is fired when a control, or\n// any of its nested controls, gains focus. In other words, the event bubbles.\nfunc FocusIn() *Event {\n\treturn NewEvent(\"focusin\")\n}", "id": 5165, "concepts": ["event handling", "event bubbling", "event delegation"], "_raw_llm_output": "event handling, event bubbling, event delegation"}
{"seed": "// IsReceiveError returns whether the error is a ReceiveError.\nfunc IsReceiveError(err error) bool {\n\t_, ok := err.(*ReceiveError)\n\treturn ok\n}", "id": 5168, "concepts": ["error handling (type assertion)", "error handling (idiomatic if err != nil)", "error handling (errors.Is)"], "_raw_llm_output": "error handling (type assertion), error handling (idiomatic if err != nil), error handling (errors.Is)"}
{"seed": "// CreatedAtLT applies the LT predicate on the \"created_at\" field.\nfunc CreatedAtLT(v time.Time) predicate.User {\n\treturn predicate.User(sql.FieldLT(FieldCreatedAt, v))\n}", "id": 5183, "concepts": ["predicate.User", "sql.FieldLT", "time.Time"], "_raw_llm_output": "predicate.User, sql.FieldLT, time.Time"}
{"seed": "// CreateDescribeHistogramResponse creates a response to parse from DescribeHistogram response\nfunc CreateDescribeHistogramResponse() (response *DescribeHistogramResponse) {\n\tresponse = &DescribeHistogramResponse{\n\t\tBaseResponse: &responses.BaseResponse{},\n\t}\n\treturn\n}", "id": 5190, "concepts": ["struct definition", "pointer usage", "struct field access"], "_raw_llm_output": "struct definition, pointer usage, struct field access"}
{"seed": "// join concatenates the elements of a to create a single string. The separator\n// string sep is placed between elements in the resulting string.\nfunc join(sep string, a ...string) string {\n\tswitch len(a) {\n\tcase 0:\n\t\treturn \"\"\n\tcase 1:\n\t\treturn a[0]\n\t}\n\n\tres := bytes.NewBufferString(a[0])\n\tfor _, s := range a[1:] {\n\t\tres.WriteString(sep + s)\n\t}\n\n\treturn res.String()\n}", "id": 5191, "concepts": ["string concatenation", "bytes.Buffer usage", "variadic function definition"], "_raw_llm_output": "string concatenation, bytes.Buffer usage, variadic function definition"}
{"seed": "// NewUpdateDriverEndpointParams creates a new UpdateDriverEndpointParams object\n// with the default values initialized.\nfunc NewUpdateDriverEndpointParams() UpdateDriverEndpointParams {\n\tvar ()\n\treturn UpdateDriverEndpointParams{}\n}", "id": 5202, "concepts": ["struct definition", "struct initialization", "struct field initialization"], "_raw_llm_output": "struct definition, struct initialization, struct field initialization"}
{"seed": "// SocialTypeGT applies the GT predicate on the \"social_type\" field.\nfunc SocialTypeGT(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.GT(s.C(FieldSocialType), v))\n\t})\n}", "id": 5224, "concepts": ["sql package usage", "predicate definition", "predicate usage"], "_raw_llm_output": "sql package usage, predicate definition, predicate usage"}
{"seed": "// DropOptionalGT applies the GT predicate on the \"drop_optional\" field.\nfunc DropOptionalGT(v string) predicate.User {\n\treturn predicate.User(sql.FieldGT(FieldDropOptional, v))\n}", "id": 5235, "concepts": ["interface conversion", "sql package usage", "predicate package usage"], "_raw_llm_output": "interface conversion, sql package usage, predicate package usage"}
{"seed": "// Frameset_ is a convenience wrapper for Frameset without the attrs argument.\nfunc Frameset_(children ...HTML) HTML {\n  return Frameset(nil, children...)\n}", "id": 5244, "concepts": ["HTML tag definition", "HTML tag attribute definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", ""], "_raw_llm_output": "HTML tag definition, HTML tag attribute definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition,"}
{"seed": "// GetSparseFileCount returns the number of sparse files to be\n//  created by NDM. Returns 0, if invalid count is specified.\nfunc GetSparseFileCount() int {\n\n\tsparseFileCountStr := os.Getenv(EnvSparseFileCount)\n\n\tif len(sparseFileCountStr) < 1 {\n\t\tsparseFileCountStr = SparseFileDefaultCount\n\t}\n\n\tsparseFileCount, econv := strconv.Atoi(sparseFileCountStr)\n\tif econv != nil {\n\t\tklog.Info(\"Error converting sparse file count:  \", sparseFileCountStr)\n\t\treturn 0\n\t}\n\n\treturn sparseFileCount\n}", "id": 5246, "concepts": ["string parsing", "strconv package usage", "environment variable handling"], "_raw_llm_output": "string parsing, strconv package usage, environment variable handling"}
{"seed": "// WorkplaceContains applies the Contains predicate on the \"workplace\" field.\nfunc WorkplaceContains(v string) predicate.User {\n\treturn predicate.User(sql.FieldContains(FieldWorkplace, v))\n}", "id": 5270, "concepts": ["predicate", "sql.FieldContains"], "_raw_llm_output": "predicate, sql.FieldContains"}
{"seed": "// StdLog creates a Logger that uses the stdlib's log.Logger type.\n//\n// All levels are reported by default. If you pass levels to this function,\n// it will act as a level whitelist.\nfunc StdLog(log *log.Logger, levels ...LogLevel) Logger {\n\treturn newStdLog(log.Println, levels...)\n}", "id": 5271, "concepts": ["stdlib usage", "function composition", "function composition with multiple arguments", "function composition with variadic arguments", "function composition with return value", "function composition with return value and multiple arguments", "function composition with return value and multiple arguments and variadic arguments", "function composition with return value and multiple arguments and variadic arguments and multiple arguments", "function composition with return value and multiple arguments and variadic arguments and multiple arguments and variadic arguments", "function composition with return value and multiple arguments and variadic arguments and multiple arguments and variadic arguments and multiple arguments"], "_raw_llm_output": "stdlib usage, function composition, function composition with multiple arguments, function composition with variadic arguments, function composition with return value, function composition with return value and multiple arguments, function composition with return value and multiple arguments and variadic arguments, function composition with return value and multiple arguments and variadic arguments and multiple arguments, function composition with return value and multiple arguments and variadic arguments and multiple arguments and variadic arguments, function composition with return value and multiple arguments and variadic arguments and multiple arguments and variadic arguments and multiple arguments"}
{"seed": "// FromContext returns the Transaction from the context if present, and nil\n// otherwise.\nfunc FromContext(ctx context.Context) Transaction {\n\th, _ := ctx.Value(contextKey).(Transaction)\n\treturn h\n}", "id": 5272, "concepts": ["context", "context.Context", "context.Value", "context.WithValue"], "_raw_llm_output": "context, context.Context, context.Value, context.WithValue"}
{"seed": "// isUnionType returns true if the reflected type is a FIDL union type.\nfunc isUnionType(t reflect.Type) bool {\n\t// This is a safe way to check if it's a union type because the generated\n\t// code inserts a \"dummy\" field (of type struct{}) at the beginning as a\n\t// marker that the struct should be treated as a FIDL union. Because all FIDL\n\t// fields are exported, there's no potential for name collision either, and a\n\t// struct accidentally being treated as a union.\n\treturn t.Kind() == reflect.Struct && t.NumField() > 1 && t.Field(0).Tag.Get(\"fidl\") == \"tag\"\n}", "id": 5273, "concepts": ["reflection", "struct field access", "type checking"], "_raw_llm_output": "reflection, struct field access, type checking"}
{"seed": "// IsValueMap reports whether v is a map type.\nfunc IsValueMap(v reflect.Value) bool {\n\treturn v.Kind() == reflect.Map\n}", "id": 5274, "concepts": ["reflection", "map type check"], "_raw_llm_output": "reflection, map type check"}
{"seed": "// PossibleAzureSkuNameValues returns an array of possible values for the AzureSkuName const type.\nfunc PossibleAzureSkuNameValues() []AzureSkuName {\n\treturn []AzureSkuName{DevNoSLAStandardD11V2, DevNoSLAStandardE2aV4, StandardD11V2, StandardD12V2, StandardD13V2, StandardD14V2, StandardDS13V21TBPS, StandardDS13V22TBPS, StandardDS14V23TBPS, StandardDS14V24TBPS, StandardE16asV43TBPS, StandardE16asV44TBPS, StandardE16aV4, StandardE2aV4, StandardE4aV4, StandardE64iV3, StandardE8asV41TBPS, StandardE8asV42TBPS, StandardE8aV4, StandardL16s, StandardL4s, StandardL8s}\n}", "id": 5279, "concepts": ["array", "const", "type definition"], "_raw_llm_output": "array, const, type definition"}
{"seed": "// WithHttpRouter is a signalr.MappableRouter factory for signalr.Server.MapHTTP\n// which converts a httprouter.Router to a signalr.MappableRouter.\nfunc WithHttpRouter(r *httprouter.Router) func() signalr.MappableRouter {\n\treturn func() signalr.MappableRouter {\n\t\treturn &julienRouter{r: r}\n\t}\n}", "id": 5281, "concepts": ["httprouter.Router", "signalr.MappableRouter", "signalr.Server.MapHTTP", "anonymous function"], "_raw_llm_output": "httprouter.Router, signalr.MappableRouter, signalr.Server.MapHTTP, anonymous function"}
{"seed": "// Caption_ is a convenience wrapper for Caption without the attrs argument.\nfunc Caption_(children ...HTML) HTML {\n  return Caption(nil, children...)\n}", "id": 5283, "concepts": ["function definition", "variadic function definition", "function argument handling", "function return value handling"], "_raw_llm_output": "function definition, variadic function definition, function argument handling, function return value handling"}
{"seed": "// unmarshalAvatarResponseBodyToFollowingviewsAvatarView builds a value of type\n// *followingviews.AvatarView from a value of type *AvatarResponseBody.\nfunc unmarshalAvatarResponseBodyToFollowingviewsAvatarView(v *AvatarResponseBody) *followingviews.AvatarView {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tres := &followingviews.AvatarView{\n\t\tURL: v.URL,\n\t}\n\n\treturn res\n}", "id": 5321, "concepts": ["pointer dereference", "struct field access", "pointer assignment"], "_raw_llm_output": "pointer dereference, struct field access, pointer assignment"}
{"seed": "// Select represents the HTML element 'select'.\n// For more information visit https://www.w3schools.com/tags/tag_select.asp.\nfunc Select(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"select\", Attributes: attrs, Children: children}\n}", "id": 5329, "concepts": ["HTML generation", "HTML generation with attributes", "HTML generation with children"], "_raw_llm_output": "HTML generation, HTML generation with attributes, HTML generation with children"}
{"seed": "// GetRand returns a new *amcl.RAND with a fresh seed\nfunc GetRand() (*amcl.RAND) {\n\tseedLength := 32\n\tb := make([]byte, seedLength)\n\t_, err := rand.Read(b)\n\tif err != nil {\n\t\t fmt.Print(err ,\"error getting randomness for seed\")\n\t\t return nil\n\t}\n\trng := amcl.NewRAND()\n\trng.Clean()\n\trng.Seed(seedLength, b)\n\treturn rng\n}", "id": 5332, "concepts": ["cryptography", "random number generation", "crypto/rand package usage", "amcl package usage"], "_raw_llm_output": "cryptography, random number generation, crypto/rand package usage, amcl package usage"}
{"seed": "// WithInstallAnnotations is an Option that configures Install annotations\n// to enable custom action.Install fields to be set based on the value of\n// annotations found in the custom resource watched by this reconciler.\n// Duplicate annotation names will result in an error.\nfunc WithInstallAnnotations(as ...annotation.Install) Option {\n\treturn func(r *Reconciler) error {\n\t\tr.annotSetupOnce.Do(r.setupAnnotationMaps)\n\n\t\tfor _, a := range as {\n\t\t\tname := a.Name()\n\t\t\tif _, ok := r.annotations[name]; ok {\n\t\t\t\treturn fmt.Errorf(\"annotation %q already exists\", name)\n\t\t\t}\n\n\t\t\tr.annotations[name] = struct{}{}\n\t\t\tr.installAnnotations[name] = a\n\t\t}\n\t\treturn nil\n\t}\n}", "id": 5333, "concepts": ["map iteration", "map lookup", "map insertion", "map deletion", "map key lookup", "map value lookup", "map key deletion", "map value deletion"], "_raw_llm_output": "map iteration, map lookup, map insertion, map deletion, map key lookup, map value lookup, map key deletion, map value deletion"}
{"seed": "// IsSupported returns true if child process reaping is supported on this\n// platform. This version always returns false.\nfunc IsSupported() bool {\n\treturn false\n}", "id": 5337, "concepts": ["boolean logic", "basic function definition"], "_raw_llm_output": "boolean logic, basic function definition"}
{"seed": "// GenerateBarChart generates a bar chart with the given percent and size.\n// Percent is a float64 from 0-100 representing the progress bar percentage\n// Size is an int representing the length of the progress bar in characters\n// BarType is a BarType representing the type of barchart: It can be one of the following:\n//    SOLIDLT SOLIDMD SOLIDDK: Block characters with a dotted background\n//    UNDERSCORE: Block characters with an line accross the boottom\n//    EMPTY: Block characters with an empty background\nfunc GenerateBarChart(ctx context.Context, percent float64, size int, barType string) string {\n\t// using rune as for utf-8 encoding\n\tsyms := BarStyle[barType]\n\tif len(syms) > 9 {\n\t\tpanic(\"No Syms\")\n\t}\n\n\tfrac := int(math.Floor((float64(size) * 8 * percent) / 100))\n\tbarsFull := int(math.Floor(float64(frac) / 8))\n\n\tif barsFull >= size {\n\t\treturn strings.Repeat(string(syms[8:9]), size)\n\t}\n\n\tvar semi = frac % 8\n\n\tbar := strings.Repeat(string(syms[8:9]), barsFull) + string(syms[semi:semi+1])\n\n\treturn pad(bar, string(syms[0:1]), size)\n}", "id": 5338, "concepts": ["string formatting", "string padding", "string repeat", "string manipulation", "rune handling", "character comparison", "map", "struct", "concurrency", "context", "standard library usage"], "_raw_llm_output": "string formatting, string padding, string repeat, string manipulation, rune handling, character comparison, map, struct, concurrency, context, standard library usage"}
{"seed": "// BlockResponse_Values returns all elements of the BlockResponse enum\nfunc BlockResponse_Values() []string {\n\treturn []string{\n\t\tBlockResponseNodata,\n\t\tBlockResponseNxdomain,\n\t\tBlockResponseOverride,\n\t}\n}", "id": 5340, "concepts": ["enum usage", "string concatenation"], "_raw_llm_output": "enum usage, string concatenation"}
{"seed": "// padBytesNeeded determines how many bytes are needed to fill up to the next 4\n// byte length.\nfunc padBytesNeeded(elementLen int) int {\n\treturn 4*(elementLen/4+1) - elementLen\n}", "id": 5343, "concepts": ["integer division", "integer remainder", "integer multiplication", "integer summation"], "_raw_llm_output": "integer division, integer remainder, integer multiplication, integer summation"}
{"seed": "// SocialAvatarURL applies equality check predicate on the \"social_avatar_url\" field. It's identical to SocialAvatarURLEQ.\nfunc SocialAvatarURL(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldSocialAvatarURL), v))\n\t})\n}", "id": 5346, "concepts": ["sql.Selector", "sql.EQ", "sql.C", "predicate.User", "anonymous function", "function definition"], "_raw_llm_output": "sql.Selector, sql.EQ, sql.C, predicate.User, anonymous function, function definition"}
{"seed": "// WithName sets the name of the container\nfunc WithName(name string) OptionFunc {\n\treturn func(c *container) {\n\t\tc.Name = name\n\t}\n}", "id": 5354, "concepts": ["struct definition", "struct field access", "function definition", "function as value"], "_raw_llm_output": "struct definition, struct field access, function definition, function as value"}
{"seed": "// SetBaseURL is a client option for setting the base URL.\nfunc SetBaseURL(bu string) ClientOpt {\n\treturn func(c *Client) error {\n\t\tu, err := url.Parse(bu)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tc.BaseURL = u\n\t\treturn nil\n\t}\n}", "id": 5360, "concepts": ["function definition", "function composition", "function options"], "_raw_llm_output": "function definition, function composition, function options"}
{"seed": "// NewPcloudSapGetParamsWithContext creates a new PcloudSapGetParams object\n// with the ability to set a context for a request.\nfunc NewPcloudSapGetParamsWithContext(ctx context.Context) *PcloudSapGetParams {\n\treturn &PcloudSapGetParams{\n\t\tContext: ctx,\n\t}\n}", "id": 5364, "concepts": ["context package usage", "function definition"], "_raw_llm_output": "context package usage, function definition"}
{"seed": "// ParseUpdateLoadBalancerResponse parses an HTTP response from a UpdateLoadBalancerWithResponse call\nfunc ParseUpdateLoadBalancerResponse(rsp *http.Response) (*UpdateLoadBalancerResponse, error) {\n\tbodyBytes, err := ioutil.ReadAll(rsp.Body)\n\tdefer rsp.Body.Close()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse := &UpdateLoadBalancerResponse{\n\t\tBody:         bodyBytes,\n\t\tHTTPResponse: rsp,\n\t}\n\n\tswitch {\n\tcase strings.Contains(rsp.Header.Get(\"Content-Type\"), \"json\") && rsp.StatusCode == 200:\n\t\tvar dest Operation\n\t\tif err := json.Unmarshal(bodyBytes, &dest); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresponse.JSON200 = &dest\n\n\t}\n\n\treturn response, nil\n}", "id": 5376, "concepts": ["HTTP response parsing", "JSON decoding", "HTTP status code handling"], "_raw_llm_output": "HTTP response parsing, JSON decoding, HTTP status code handling"}
{"seed": "// GenerateStackID : Generates ID that is used as unique ID for different services\n// Prefixed 'MaxEdge-' so there will always be a letter as the first character,\n// due to CloudFormation StackName constraint\nfunc GenerateStackID() string {\n\treturn `MaxEdge-` + uuid.Must(uuid.NewV4()).String()\n}", "id": 5377, "concepts": ["uuid generation", "string manipulation"], "_raw_llm_output": "uuid generation, string manipulation"}
{"seed": "// NewIPAllocator is the constructor to initialize the IPAllocator object\n// Argument pendingIPRanges map[string]bool is a set of  IP ranges currently reserved by service instances but pending reservation in the cloud instances\nfunc NewIPAllocator(pendingIPRanges map[string]bool) *IPAllocator {\n\t// Make a copy of the pending IP ranges and set it in the IPAllocator so that the caller cannot mutate this map outside the library\n\tpendingIPRangesCopy := make(map[string]bool)\n\tfor pendingIPRange := range pendingIPRanges {\n\t\tpendingIPRangesCopy[pendingIPRange] = true\n\t}\n\treturn &IPAllocator{\n\t\tpendingIPRanges: pendingIPRangesCopy,\n\t}\n}", "id": 5379, "concepts": ["map", "map iteration", "map key iteration", "map value iteration", "map key/value iteration", "map copy", "map key/value copy", "map key/value iteration", "map key/value copy", "map key/value iteration", "map key/value copy", "map key/value iteration", "map key/value copy", "map key/value iteration", "map key/value copy", "map key/value iteration", "map key/value copy", "map key/value iteration", "map key/value copy", "map key/value iteration", "map key/value copy", "map key/value iteration", "map key/value copy", "map key/value iteration", "map key/value copy", "map key/value iteration", "map key/value copy", "map key/value iteration", "map key/value copy", "map key/value iteration", "map key/value copy", "map key/value iteration", "map key/value copy", "map key/value iteration", "map key/value copy", "map key/value iteration", "map key/value copy", "map key/value iteration", "map key/value copy", "map key/value iteration", "map key/value copy", "map key/value iteration", "map key/value copy", "map key/value iteration", "map key/value copy"], "_raw_llm_output": "map, map iteration, map key iteration, map value iteration, map key/value iteration, map copy, map key/value copy, map key/value iteration, map key/value copy, map key/value iteration, map key/value copy, map key/value iteration, map key/value copy, map key/value iteration, map key/value copy, map key/value iteration, map key/value copy, map key/value iteration, map key/value copy, map key/value iteration, map key/value copy, map key/value iteration, map key/value copy, map key/value iteration, map key/value copy, map key/value iteration, map key/value copy, map key/value iteration, map key/value copy, map key/value iteration, map key/value copy, map key/value iteration, map key/value copy, map key/value iteration, map key/value copy, map key/value iteration, map key/value copy, map key/value iteration, map key/value copy, map key/value iteration, map key/value copy, map key/value iteration, map key/value copy, map key/value iteration, map key/value copy"}
{"seed": "// GetPolicyBasePath returns policy base path as set in global config\nfunc GetPolicyBasePath() string {\n\treturn Global.Policy.BasePath\n}", "id": 5384, "concepts": ["struct field access", "global variable access"], "_raw_llm_output": "struct field access, global variable access"}
{"seed": "// Return true iff moving from a to b to c turns counterclockwise.\n//\nfunc CCW(a, b, c Point) bool {\n\t// a->b->c is ccw iff sin(\u0398) < 0\n\t//      c\n\t//     /\n\t//    /\u0398\n\t// b +---- a\n\tv1 := a.Sub(b)\n\tv2 := c.Sub(b)\n\tx := v1.X*v2.Y - v1.Y*v2.X // x = |v1 x v2| = sin(\u0398)|v1||v2|\n\treturn x < 0\n}", "id": 5391, "concepts": ["struct", "struct field access", "struct method definition", "struct method call", "struct method receiver", "struct method receiver type", "struct method receiver type definition", "struct method receiver type definition", "struct method receiver type definition", "struct method receiver type definition", "struct method receiver type definition", "struct method receiver type definition", "struct method receiver type definition", "struct method receiver type definition", "struct method receiver type definition", "struct method receiver type definition", "struct method receiver type definition", "struct method receiver type definition", "struct method receiver type definition", "struct method receiver type definition", "struct method receiver type definition", "struct method receiver type definition", "struct method receiver type definition", "struct method receiver type definition", "struct method receiver type definition", "struct method receiver type definition", "struct method receiver type definition", "struct method receiver type definition", "struct method receiver type definition", "struct method receiver type definition", "struct method receiver type definition", "struct method receiver type definition", "struct method receiver type definition", "struct method receiver type definition", "struct method receiver type definition", "struct method receiver type definition", "struct method receiver type definition", "struct method receiver type definition", "struct method receiver type definition", "struct method receiver type definition", "struct method receiver type definition", "struct method receiver type definition", "struct method receiver type definition", "struct method receiver type definition", "struct method receiver type"], "_raw_llm_output": "struct, struct field access, struct method definition, struct method call, struct method receiver, struct method receiver type, struct method receiver type definition, struct method receiver type definition, struct method receiver type definition, struct method receiver type definition, struct method receiver type definition, struct method receiver type definition, struct method receiver type definition, struct method receiver type definition, struct method receiver type definition, struct method receiver type definition, struct method receiver type definition, struct method receiver type definition, struct method receiver type definition, struct method receiver type definition, struct method receiver type definition, struct method receiver type definition, struct method receiver type definition, struct method receiver type definition, struct method receiver type definition, struct method receiver type definition, struct method receiver type definition, struct method receiver type definition, struct method receiver type definition, struct method receiver type definition, struct method receiver type definition, struct method receiver type definition, struct method receiver type definition, struct method receiver type definition, struct method receiver type definition, struct method receiver type definition, struct method receiver type definition, struct method receiver type definition, struct method receiver type definition, struct method receiver type definition, struct method receiver type definition, struct method receiver type definition, struct method receiver type definition, struct method receiver type definition, struct method receiver type"}
{"seed": "// AnnotationKey returns a unique annotation key for an device allocation\n// by a K8s device plugin. pluginName should be in the format of\n// \"vendor.device-type\". deviceID is the ID of the device the plugin is\n// allocating. It is used to make sure that the generated key is unique\n// even if multiple allocations by a single plugin needs to be annotated.\nfunc AnnotationKey(pluginName, deviceID string) (string, error) {\n\tconst maxNameLen = 63\n\n\tif pluginName == \"\" {\n\t\treturn \"\", errors.New(\"invalid plugin name, empty\")\n\t}\n\tif deviceID == \"\" {\n\t\treturn \"\", errors.New(\"invalid deviceID, empty\")\n\t}\n\n\tname := pluginName + \"_\" + strings.ReplaceAll(deviceID, \"/\", \"_\")\n\n\tif len(name) > maxNameLen {\n\t\treturn \"\", fmt.Errorf(\"invalid plugin+deviceID %q, too long\", name)\n\t}\n\n\tif c := rune(name[0]); !parser.IsAlphaNumeric(c) {\n\t\treturn \"\", fmt.Errorf(\"invalid name %q, first '%c' should be alphanumeric\",\n\t\t\tname, c)\n\t}\n\tif len(name) > 2 {\n\t\tfor _, c := range name[1 : len(name)-1] {\n\t\t\tswitch {\n\t\t\tcase parser.IsAlphaNumeric(c):\n\t\t\tcase c == '_' || c == '-' || c == '.':\n\t\t\tdefault:\n\t\t\t\treturn \"\", fmt.Errorf(\"invalid name %q, invalid character '%c'\",\n\t\t\t\t\tname, c)\n\t\t\t}\n\t\t}\n\t}\n\tif c := rune(name[len(name)-1]); !parser.IsAlphaNumeric(c) {\n\t\treturn \"\", fmt.Errorf(\"invalid name %q, last '%c' should be alphanumeric\",\n\t\t\tname, c)\n\t}\n\n\treturn AnnotationPrefix + name, nil\n}", "id": 5399, "concepts": ["string manipulation", "string formatting", "rune handling", "character comparison", "string validation", "error handling (errors.New)", "string concatenation", "string length", "string iteration (range loop)", "string indexing", "string slicing", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation", "string validation"], "_raw_llm_output": "string manipulation, string formatting, rune handling, character comparison, string validation, error handling (errors.New), string concatenation, string length, string iteration (range loop), string indexing, string slicing, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation, string validation"}
{"seed": "// IsValueInterface reports whether v is an interface type.\nfunc IsValueInterface(v reflect.Value) bool {\n\treturn v.Kind() == reflect.Interface\n}", "id": 5404, "concepts": ["reflection", "interface type", "reflect.Value"], "_raw_llm_output": "reflection, interface type, reflect.Value"}
{"seed": "// Tbody_ is a convenience wrapper for Tbody without the attrs argument.\nfunc Tbody_(children ...HTML) HTML {\n  return Tbody(nil, children...)\n}", "id": 5420, "concepts": ["HTML", "HTML tag definition", "HTML tag attribute definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value"], "_raw_llm_output": "HTML, HTML tag definition, HTML tag attribute definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value"}
{"seed": "// readFromFS parses the given path list and inits FS for each item.\n// Once initialed, readFromFS will try to read and return files from each FS.\n// readFromFS returns an error if at least one FS failed to init.\n// The function can be called multiple times but each unique path\n// will be initialed only once.\n//\n// It is allowed to mix different FS types in path list.\nfunc readFromFS(paths []string) (map[string][]byte, error) {\n\tvar err error\n\tresult := make(map[string][]byte)\n\tfor _, path := range paths {\n\t\tfsRegistryMu.Lock()\n\t\tfs, ok := fsRegistry[path]\n\t\tif !ok {\n\t\t\tfs, err = newFS(path)\n\t\t\tif err != nil {\n\t\t\t\tfsRegistryMu.Unlock()\n\t\t\t\treturn nil, fmt.Errorf(\"error while parsing path %q: %w\", path, err)\n\t\t\t}\n\t\t\tif err := fs.Init(); err != nil {\n\t\t\t\tfsRegistryMu.Unlock()\n\t\t\t\treturn nil, fmt.Errorf(\"error while initializing path %q: %w\", path, err)\n\t\t\t}\n\t\t\tfsRegistry[path] = fs\n\t\t}\n\t\tfsRegistryMu.Unlock()\n\n\t\tlist, err := fs.List()\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to list files from %q\", fs)\n\t\t}\n\n\t\tcLogger.Infof(\"found %d files to read from %q\", len(list), fs)\n\n\t\tif len(list) < 1 {\n\t\t\tcontinue\n\t\t}\n\n\t\tts := time.Now()\n\t\tfiles, err := fs.Read(list)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"error while reading files from %q: %w\", fs, err)\n\t\t}\n\t\tcLogger.Infof(\"finished reading %d files in %v from %q\", len(list), time.Since(ts), fs)\n\n\t\tfor k, v := range files {\n\t\t\tif _, ok := result[k]; ok {\n\t\t\t\treturn nil, fmt.Errorf(\"duplicate found for file name %q: file names must be unique\", k)\n\t\t\t}\n\t\t\tresult[k] = v\n\t\t}\n\t}\n\treturn result, nil\n}", "id": 5421, "concepts": ["map iteration (range loop)", "map lookup", "map insertion", "map deletion", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", ""], "_raw_llm_output": "map iteration (range loop), map lookup, map insertion, map deletion, map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop),"}
{"seed": "// NewLivenessResultOK builds a \"healthcheck\" service \"liveness\" endpoint\n// result from a HTTP \"OK\" response.\nfunc NewLivenessResultOK(body *LivenessResponseBody) *healthcheck.LivenessResult {\n\tv := &healthcheck.LivenessResult{\n\t\tStatus: *body.Status,\n\t}\n\n\treturn v\n}", "id": 5425, "concepts": ["struct", "pointer", "interface", "method definition"], "_raw_llm_output": "struct, pointer, interface, method definition"}
{"seed": "// NewSignupAuthenticationContext parses the incoming request URL and body, performs validations and creates the\n// context used by the authentication controller signup action.\nfunc NewSignupAuthenticationContext(ctx context.Context, r *http.Request, service *goa.Service) (*SignupAuthenticationContext, error) {\n\tvar err error\n\tresp := goa.ContextResponse(ctx)\n\tresp.Service = service\n\treq := goa.ContextRequest(ctx)\n\treq.Request = r\n\trctx := SignupAuthenticationContext{Context: ctx, ResponseData: resp, RequestData: req}\n\treturn &rctx, err\n}", "id": 5429, "concepts": ["context", "http.Request", "http.Response", "goa.Service", "goa.ContextResponse", "goa.ContextRequest", "function definition", "basic function definition"], "_raw_llm_output": "context, http.Request, http.Response, goa.Service, goa.ContextResponse, goa.ContextRequest, function definition, basic function definition"}
{"seed": "/*\n\u529f\u80fd:\u6bd4\u8f83\u7248\u672c\u9ad8\u4f4e\n\u53c2\u6570\uff1a\n- v1, v2:\u4e24\u4e2a\u8981\u6bd4\u8f83\u7684\u7248\u672c\u53f7\n\u8fd4\u56de\u503c:\n- =0: v1 = v2\n- >0: v1 > v2\n- <0: v1 < v2\n*/\nfunc compareVersion(v1, v2 string) int {\n\treturn 0\n}", "id": 5436, "concepts": ["string manipulation", "string parsing", "string comparison"], "_raw_llm_output": "string manipulation, string parsing, string comparison"}
{"seed": "// NewListInstancePoolsRequest generates requests for ListInstancePools\nfunc NewListInstancePoolsRequest(server string) (*http.Request, error) {\n\tvar err error\n\n\tqueryUrl, err := url.Parse(server)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbasePath := fmt.Sprintf(\"/instance-pool\")\n\tif basePath[0] == '/' {\n\t\tbasePath = basePath[1:]\n\t}\n\n\tqueryUrl, err = queryUrl.Parse(basePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq, err := http.NewRequest(\"GET\", queryUrl.String(), nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn req, nil\n}", "id": 5446, "concepts": ["url parsing", "http request generation", "string manipulation", "error handling"], "_raw_llm_output": "url parsing, http request generation, string manipulation, error handling"}
{"seed": "// FromTransmissionRecordModelToDTO transforms a TransmissionRecord Model to a TransmissionRecord DTO\nfunc FromTransmissionRecordModelToDTO(tr models.TransmissionRecord) TransmissionRecord {\n\treturn TransmissionRecord{\n\t\tStatus:   string(tr.Status),\n\t\tResponse: tr.Response,\n\t\tSent:     tr.Sent,\n\t}\n}", "id": 5447, "concepts": ["struct", "struct field access", "anonymous struct", "function definition", "function return value"], "_raw_llm_output": "struct, struct field access, anonymous struct, function definition, function return value"}
{"seed": "// DefaultDevelopmentConfig returns the default development config which is used to create a default sugared logger.\nfunc DefaultDevelopmentConfig(minLevel zapcore.Level) zap.Config {\n\tloggerConf := zap.NewDevelopmentConfig()\n\tloggerConf.Level.SetLevel(minLevel)\n\tloggerConf.EncoderConfig.EncodeLevel = zapcore.CapitalColorLevelEncoder\n\n\treturn loggerConf\n}", "id": 5455, "concepts": ["zap.Config", "zap.NewDevelopmentConfig", "zapcore.Level", "zapcore.CapitalColorLevelEncoder"], "_raw_llm_output": "zap.Config, zap.NewDevelopmentConfig, zapcore.Level, zapcore.CapitalColorLevelEncoder"}
{"seed": "/*\nNewNullLogger returns a null logger instance.\n*/\nfunc NewNullLogger() *NullLogger {\n\treturn &NullLogger{}\n}", "id": 5456, "concepts": ["struct definition", "basic function definition"], "_raw_llm_output": "struct definition, basic function definition"}
{"seed": "// lookupCommit looks up an object at hash `id` in `repo`, and returns\n// it as a git commit. If the object is not a commit, an error is returned.\nfunc lookupCommit(r *git.Repository, id *git.Oid) (*git.Commit, error) {\n\tobj, err := r.Lookup(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif commit, ok := obj.(*git.Commit); ok {\n\t\treturn commit, nil\n\t}\n\treturn nil, fmt.Errorf(\"hash %v exist but is not a commit\", id)\n}", "id": 5461, "concepts": ["git.Repository", "git.Oid", "git.Commit", "git.Object", "git.Object.Lookup", "git.Object.IsType"], "_raw_llm_output": "git.Repository, git.Oid, git.Commit, git.Object, git.Object.Lookup, git.Object.IsType"}
{"seed": "// Decrypt decrypts ciphertext and returns plaintext.\n// ciphertext's length must be a multiple of 8. key is a 24 byte des key.\n// iv is an 8 byte initialization vector. If iv is nil, zeros\n// will be used as the initialization vector.\nfunc Decrypt(ciphertext, key, iv []byte) ([]byte, error) {\n\n\tswitch {\n\tcase len(ciphertext)%8 != 0:\n\t\treturn nil, errors.New(\"invalid ciphertext length\")\n\tcase iv == nil:\n\t\tiv = defaultIV\n\tcase len(iv) != 8:\n\t\treturn nil, errors.New(\"invalid iv length\")\n\t}\n\n\t// create the cipher\n\tdcipher, err := blowfish.NewCipher(key)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// make initialization vector to be the first 8 bytes of ciphertext\n\tiv = ciphertext[:blowfish.BlockSize]\n\n\t// check last slice of encrypted text, if it's not a modulus of cipher block size, we're in trouble\n\tdecrypted := ciphertext[blowfish.BlockSize:]\n\tif len(decrypted)%blowfish.BlockSize != 0 {\n\t\tpanic(\"decrypted is not a multiple of blowfish.BlockSize\")\n\t}\n\n\t// create the decrypter\n\tdcbc := cipher.NewCBCDecrypter(dcipher, iv)\n\n\t// decrypt!\n\tdcbc.CryptBlocks(decrypted, decrypted)\n\n\treturn decrypted, nil\n}", "id": 5470, "concepts": ["cryptography", "blowfish cipher", "CBC mode", "crypto/cipher package", "crypto/blowfish package"], "_raw_llm_output": "cryptography, blowfish cipher, CBC mode, crypto/cipher package, crypto/blowfish package"}
{"seed": "// ReadRatePlanRefSPRate reads a full RatePlanRefSPRate structure from the database based on the supplied row object\nfunc ReadRatePlanRefSPRate(row *sql.Row, a *RatePlanRefSPRate) error {\n\terr := row.Scan(&a.RPRID, &a.BID, &a.RTID, &a.RSPID, &a.FLAGS, &a.Val, &a.CreateTS, &a.CreateBy, &a.LastModTime, &a.LastModBy)\n\tSkipSQLNoRowsError(&err)\n\treturn err\n}", "id": 5495, "concepts": ["sql package usage", "sql.Row.Scan", "error handling"], "_raw_llm_output": "sql package usage, sql.Row.Scan, error handling"}
{"seed": "// getFieldTags returns the tags or names that a struct field is identified by. It prioritizes the mpe tag over the\n// json tag. It defaults to the field name if neither tag is available.\nfunc getFieldTags(t reflect.StructField) (res []string) {\n\tif tags := t.Tag.Get(mapEnvTagName); len(tags) > 0 {\n\t\tfor _, s := range strings.Split(tags, \",\") {\n\t\t\tif len(s) > 0 {\n\t\t\t\tres = append(res, s)\n\t\t\t}\n\t\t}\n\t}\n\n\t// ignore json tags and field name if mpe tag is present\n\tif len(res) > 0 {\n\t\treturn\n\t}\n\n\tif tags := t.Tag.Get(\"json\"); len(tags) > 0 {\n\t\tjsonTags := strings.Split(tags, \",\")\n\t\tif len(jsonTags) > 0 && len(jsonTags[0]) > 0 {\n\t\t\tres = append(res, jsonTags[0])\n\t\t}\n\t}\n\n\t// ignore field name if json tag is present\n\tif len(res) > 0 {\n\t\treturn\n\t}\n\n\tres = append(res, t.Name)\n\n\treturn\n}", "id": 5498, "concepts": ["reflection", "struct field iteration", "string manipulation", "string splitting", "string length check", "string comparison", "string concatenation", "string iteration (range loop)", "string slice", "string slice iteration (range loop)", "string slice length check", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append", "string slice append"], "_raw_llm_output": "reflection, struct field iteration, string manipulation, string splitting, string length check, string comparison, string concatenation, string iteration (range loop), string slice, string slice iteration (range loop), string slice length check, string slice append, string slice append, string slice append, string slice append, string slice append, string slice append, string slice append, string slice append, string slice append, string slice append, string slice append, string slice append, string slice append, string slice append, string slice append, string slice append, string slice append, string slice append, string slice append, string slice append, string slice append, string slice append, string slice append, string slice append, string slice append, string slice append, string slice append, string slice append, string slice append, string slice append, string slice append, string slice append, string slice append, string slice append, string slice append, string slice append, string slice append, string slice append, string slice append, string slice append, string slice append, string slice append, string slice append, string slice append, string slice append, string slice append, string slice append, string slice append, string slice append, string slice append, string slice append, string slice append, string slice append"}
{"seed": "// getValueUnit returns the value and optional unit from the provided value string\nfunc getValueUnit(s string) (string, string) {\n\tval := strings.Split(strings.SplitAfter(s, \"(\")[1], \")\")[0]\n\tparts := strings.Split(val, \"*\")\n\n\t// Check if the value has the optional unit\n\tif len(parts) == 2 {\n\t\treturn parts[0], parts[1]\n\t}\n\n\treturn val, \"\"\n}", "id": 5503, "concepts": ["string manipulation", "string splitting", "string indexing"], "_raw_llm_output": "string manipulation, string splitting, string indexing"}
{"seed": "// NewPutMeAccessRestrictionSmsIDParamsWithTimeout creates a new PutMeAccessRestrictionSmsIDParams object\n// with the default values initialized, and the ability to set a timeout on a request\nfunc NewPutMeAccessRestrictionSmsIDParamsWithTimeout(timeout time.Duration) *PutMeAccessRestrictionSmsIDParams {\n\tvar ()\n\treturn &PutMeAccessRestrictionSmsIDParams{\n\n\t\ttimeout: timeout,\n\t}\n}", "id": 5518, "concepts": ["method definition", "method receiver", "method return value", "method parameter", "method parameter default value", "method parameter type", "method parameter type conversion", "method parameter type assertion", "method parameter type assertion", "method parameter type assertion", "method parameter type assertion", "method parameter type assertion", "method parameter type assertion", "method parameter type assertion", "method parameter type assertion", "method parameter type assertion", "method parameter type assertion", "method parameter type assertion", "method parameter type assertion", "method parameter type assertion", "method parameter type assertion", "method parameter type assertion", "method parameter type assertion", "method parameter type assertion", "method parameter type assertion", "method parameter type assertion", "method parameter type assertion", "method parameter type assertion", "method parameter type assertion", "method parameter type assertion", "method parameter type assertion", "method parameter type assertion", "method parameter type assertion", "method parameter type assertion", "method parameter type assertion", "method parameter type assertion", "method parameter type assertion", "method parameter type assertion", "method parameter type assertion", "method parameter type assertion", "method parameter type assertion", "method parameter type assertion", "method parameter type assertion", "method parameter type assertion", "method parameter type assertion", "method parameter type assertion", "method parameter type assertion", "method parameter type assertion", "method parameter type assertion", "method parameter type assertion", "method parameter type assertion", "method parameter type assertion", "method parameter type"], "_raw_llm_output": "method definition, method receiver, method return value, method parameter, method parameter default value, method parameter type, method parameter type conversion, method parameter type assertion, method parameter type assertion, method parameter type assertion, method parameter type assertion, method parameter type assertion, method parameter type assertion, method parameter type assertion, method parameter type assertion, method parameter type assertion, method parameter type assertion, method parameter type assertion, method parameter type assertion, method parameter type assertion, method parameter type assertion, method parameter type assertion, method parameter type assertion, method parameter type assertion, method parameter type assertion, method parameter type assertion, method parameter type assertion, method parameter type assertion, method parameter type assertion, method parameter type assertion, method parameter type assertion, method parameter type assertion, method parameter type assertion, method parameter type assertion, method parameter type assertion, method parameter type assertion, method parameter type assertion, method parameter type assertion, method parameter type assertion, method parameter type assertion, method parameter type assertion, method parameter type assertion, method parameter type assertion, method parameter type assertion, method parameter type assertion, method parameter type assertion, method parameter type assertion, method parameter type assertion, method parameter type assertion, method parameter type assertion, method parameter type assertion, method parameter type assertion, method parameter type"}
{"seed": "// NewCatalogProductRepositoryV1SavePutParamsWithHTTPClient creates a new CatalogProductRepositoryV1SavePutParams object\n// with the default values initialized, and the ability to set a custom HTTPClient for a request\nfunc NewCatalogProductRepositoryV1SavePutParamsWithHTTPClient(client *http.Client) *CatalogProductRepositoryV1SavePutParams {\n\tvar ()\n\treturn &CatalogProductRepositoryV1SavePutParams{\n\t\tHTTPClient: client,\n\t}\n}", "id": 5538, "concepts": ["http.Client", "function definition", "function parameter", "function return value"], "_raw_llm_output": "http.Client, function definition, function parameter, function return value"}
{"seed": "// LatestHeroScoreLT applies the LT predicate on the \"latest_hero_score\" field.\nfunc LatestHeroScoreLT(v int) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.LT(s.C(FieldLatestHeroScore), v))\n\t})\n}", "id": 5551, "concepts": ["sql.Selector", "sql.LT", "predicate.User", "sql.C"], "_raw_llm_output": "sql.Selector, sql.LT, predicate.User, sql.C"}
{"seed": "// Illuminated returns the illuminated fraction of a body's disk.\n//\n// The illuminated body can be the Moon or a planet.\n//\n// Argument i is the phase angle.\nfunc Illuminated(i unit.Angle) float64 {\n\t// (41.1) p. 283, also (48.1) p. 345.\n\treturn (1 + i.Cos()) * .5\n}", "id": 5552, "concepts": ["math package usage", "unit.Angle type", "basic function definition"], "_raw_llm_output": "math package usage, unit.Angle type, basic function definition"}
{"seed": "// NewHttpSyntheticMonitorUpdateWithDefaults instantiates a new HttpSyntheticMonitorUpdate object\n// This constructor will only assign default values to properties that have it defined,\n// but it doesn't guarantee that properties required by API are set\nfunc NewHttpSyntheticMonitorUpdateWithDefaults() *HttpSyntheticMonitorUpdate {\n\tthis := HttpSyntheticMonitorUpdate{}\n\treturn &this\n}", "id": 5555, "concepts": ["constructor", "default value assignment"], "_raw_llm_output": "constructor, default value assignment"}
{"seed": "// Dd represents the HTML element 'dd'.\n// For more information visit https://www.w3schools.com/tags/tag_dd.asp.\nfunc Dd(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"dd\", Attributes: attrs, Children: children}\n}", "id": 5565, "concepts": ["HTML generation", "HTML element definition", "HTML attribute definition", "HTML element children definition"], "_raw_llm_output": "HTML generation, HTML element definition, HTML attribute definition, HTML element children definition"}
{"seed": "// Kbd represents the HTML element 'kbd'.\n// For more information visit https://www.w3schools.com/tags/tag_kbd.asp.\nfunc Kbd(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"kbd\", Attributes: attrs, Children: children}\n}", "id": 5594, "concepts": ["HTML generation", "HTML element definition", "HTML attribute definition", "HTML tree generation"], "_raw_llm_output": "HTML generation, HTML element definition, HTML attribute definition, HTML tree generation"}
{"seed": "// S_ is a convenience wrapper for S without the attrs argument.\nfunc S_(children ...HTML) HTML {\n  return S(nil, children...)\n}", "id": 5595, "concepts": ["function definition", "variadic function", "function argument", "function return value"], "_raw_llm_output": "function definition, variadic function, function argument, function return value"}
{"seed": "// NewMockRecurringTaskRequirements creates a new instance of MockRecurringTaskRequirements. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.\n// The first argument is typically a *testing.T value.\nfunc NewMockRecurringTaskRequirements(t interface {\n\tmock.TestingT\n\tCleanup(func())\n}) *MockRecurringTaskRequirements {\n\tmock := &MockRecurringTaskRequirements{}\n\tmock.Mock.Test(t)\n\n\tt.Cleanup(func() { mock.AssertExpectations(t) })\n\n\treturn mock\n}", "id": 5611, "concepts": ["mocking", "testing interface", "cleanup function", "testing.T", "mock.TestingT"], "_raw_llm_output": "mocking, testing interface, cleanup function, testing.T, mock.TestingT"}
{"seed": "// PossibleRulesEngineMatchVariableValues returns an array of possible values for the RulesEngineMatchVariable const type.\nfunc PossibleRulesEngineMatchVariableValues() []RulesEngineMatchVariable {\n\treturn []RulesEngineMatchVariable{RulesEngineMatchVariableIsMobile, RulesEngineMatchVariablePostArgs, RulesEngineMatchVariableQueryString, RulesEngineMatchVariableRemoteAddr, RulesEngineMatchVariableRequestBody, RulesEngineMatchVariableRequestFilename, RulesEngineMatchVariableRequestFilenameExtension, RulesEngineMatchVariableRequestHeader, RulesEngineMatchVariableRequestMethod, RulesEngineMatchVariableRequestPath, RulesEngineMatchVariableRequestScheme, RulesEngineMatchVariableRequestURI}\n}", "id": 5614, "concepts": ["const declaration", "array declaration", "array iteration"], "_raw_llm_output": "const declaration, array declaration, array iteration"}
{"seed": "// WithoutBlocking prepares context for transaction that should be scheduled\n// for execution without blocking the caller of the Commit() method.\n// By default, commit is blocking.\nfunc WithoutBlocking(ctx context.Context) context.Context {\n\treturn context.WithValue(ctx, nonBlockingTxnCtxKey, &nonBlockingTxnOpt{})\n}", "id": 5621, "concepts": ["context", "context.WithValue", "context.Context", "context.ContextKey"], "_raw_llm_output": "context, context.WithValue, context.Context, context.ContextKey"}
{"seed": "// NewError creates new HTTP XErr with following structure:\n// message: msg, extra: {\"http_code\": code}, internal_extra: {\"error\": err}.\nfunc NewError(err error, msg string, code int, opts ...xerrors.XErrOpt) *xerrors.XErr {\n\tif err == nil {\n\t\treturn nil\n\t}\n\n\topts = append([]xerrors.XErrOpt{\n\t\txerrors.WithExtra(map[string]interface{}{\"http_code\": code}),\n\t\txerrors.WithInternalExtra(map[string]interface{}{\"error\": err}),\n\t}, opts...)\n\n\treturn xerrors.New(msg, opts...)\n}", "id": 5623, "concepts": ["error handling (xerrors.New)", "error wrapping (xerrors.New)", "error handling (xerrors.XErrOpt)", "error handling (xerrors.WithExtra)", "error handling (xerrors.WithInternalExtra)"], "_raw_llm_output": "error handling (xerrors.New), error wrapping (xerrors.New), error handling (xerrors.XErrOpt), error handling (xerrors.WithExtra), error handling (xerrors.WithInternalExtra)"}
{"seed": "// Dfn_ is a convenience wrapper for Dfn without the attrs argument.\nfunc Dfn_(children ...HTML) HTML {\n  return Dfn(nil, children...)\n}", "id": 5624, "concepts": ["HTML", "function definition", "basic function definition", "basic function call"], "_raw_llm_output": "HTML, function definition, basic function definition, basic function call"}
{"seed": "// NewReplaceSubscriptionParamsWithTimeout creates a new ReplaceSubscriptionParams object\n// with the default values initialized, and the ability to set a timeout on a request\nfunc NewReplaceSubscriptionParamsWithTimeout(timeout time.Duration) *ReplaceSubscriptionParams {\n\tvar ()\n\treturn &ReplaceSubscriptionParams{\n\n\t\ttimeout: timeout,\n\t}\n}", "id": 5626, "concepts": ["struct definition", "struct initialization", "struct field initialization", "struct field assignment", "timeout handling"], "_raw_llm_output": "struct definition, struct initialization, struct field initialization, struct field assignment, timeout handling"}
{"seed": "// getRFC4251String returns a stream of bytes representing a string prepended with a big-endian unit32\n// expressing the length of the data following.\n// This is the 'string' format in RFC4251 Section 5 (https://datatracker.ietf.org/doc/html/rfc4251#section-5)\nfunc getRFC4251String(data []byte) []byte {\n\tbuf := new(bytes.Buffer)\n\t// write a uint32 with the length of the byte stream to the buffer\n\tbinary.Write(buf, binary.BigEndian, uint32(len(data)))\n\t// write the byte stream representing of the rest of the data to the buffer\n\tfor _, v := range data {\n\t\tbinary.Write(buf, binary.BigEndian, v)\n\t}\n\treturn buf.Bytes()\n}", "id": 5637, "concepts": ["byte manipulation", "binary.Write", "big endian encoding", "byte stream manipulation"], "_raw_llm_output": "byte manipulation, binary.Write, big endian encoding, byte stream manipulation"}
{"seed": "// MixedStringNotIn applies the NotIn predicate on the \"mixed_string\" field.\nfunc MixedStringNotIn(vs ...string) predicate.User {\n\treturn predicate.User(sql.FieldNotIn(FieldMixedString, vs...))\n}", "id": 5638, "concepts": ["predicate.User", "sql.FieldNotIn", "..."], "_raw_llm_output": "predicate.User, sql.FieldNotIn, ..."}
{"seed": "// CredentialAssertionResponseToProto converts a CredentialAssertionResponse to\n// its proto counterpart.\nfunc CredentialAssertionResponseToProto(car *CredentialAssertionResponse) *wantypes.CredentialAssertionResponse {\n\tif car == nil {\n\t\treturn nil\n\t}\n\treturn &wantypes.CredentialAssertionResponse{\n\t\tType:  car.Type,\n\t\tRawId: car.RawID,\n\t\tResponse: &wantypes.AuthenticatorAssertionResponse{\n\t\t\tClientDataJson:    car.AssertionResponse.ClientDataJSON,\n\t\t\tAuthenticatorData: car.AssertionResponse.AuthenticatorData,\n\t\t\tSignature:         car.AssertionResponse.Signature,\n\t\t\tUserHandle:        car.AssertionResponse.UserHandle,\n\t\t},\n\t\tExtensions: outputExtensionsToProto(car.Extensions),\n\t}\n}", "id": 5639, "concepts": ["error handling (errors.As)", "pointer handling", "interface conversion", "anonymous function", "standard library usage"], "_raw_llm_output": "error handling (errors.As), pointer handling, interface conversion, anonymous function, standard library usage"}
{"seed": "// NewModels creates a set of ngram models up to size `ngram_size`\nfunc NewModels(ngram_size int) (models CharacterNGramModels) {\n\tmodels = make(map[int]*CharacterNGramModel)\n\tfor key := 1; key <= ngram_size; key++ {\n\t\tmodels[key] = new(CharacterNGramModel)\n\t\tmodels[key].Size = key\n\t\tmodels[key].Counts = make(map[string]float64)\n\t}\n\treturn\n}", "id": 5642, "concepts": ["map iteration", "map creation", "map usage", "map deletion"], "_raw_llm_output": "map iteration, map creation, map usage, map deletion"}
{"seed": "// joinPath returns a path string. The given parts are joined by a slash.\nfunc joinPath(parts ...string) string {\n\treturn strings.Join(parts, \"/\")\n}", "id": 5643, "concepts": ["string manipulation", "string concatenation", "string joining"], "_raw_llm_output": "string manipulation, string concatenation, string joining"}
{"seed": "// AppendRootPath is an util function to append a root path to all existed routes.\n// For example,, if root is '/new', a route with path '/old/foo' is replaced with '/new/old/foo'.\nfunc AppendRootPath(ws *restful.WebService, root string) *restful.WebService {\n\n\t// Set new root\n\tws.Path(root)\n\n\t// Copy all existed routes\n\toldRoutes := ws.Routes()\n\n\t// Reset all existed routes\n\tfor _, oldRoute := range oldRoutes {\n\n\t\tif err := ws.RemoveRoute(oldRoute.Path, oldRoute.Method); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tnewRoute := ws.Method(oldRoute.Method).\n\t\t\tConsumes(oldRoute.Consumes...).\n\t\t\tProduces(oldRoute.Produces...).\n\t\t\tPath(oldRoute.Path).\n\t\t\tTo(oldRoute.Function).\n\t\t\tDoc(oldRoute.Doc).\n\t\t\tNotes(oldRoute.Notes).\n\t\t\tOperation(oldRoute.Operation)\n\n\t\tfor _, f := range oldRoute.Filters {\n\t\t\tnewRoute.Filter(f)\n\t\t}\n\n\t\tfor _, f := range oldRoute.If {\n\t\t\tnewRoute.If(f)\n\t\t}\n\n\t\tfor _, p := range oldRoute.ParameterDocs {\n\t\t\tnewRoute.Param(p)\n\t\t}\n\n\t\tfor _, r := range oldRoute.ResponseErrors {\n\t\t\tnewRoute.Returns(r.Code, r.Message, r.Model)\n\t\t}\n\n\t\tfor k, v := range oldRoute.Metadata {\n\t\t\tnewRoute.Metadata(k, v)\n\t\t}\n\n\t\tws.Route(newRoute)\n\t}\n\n\treturn ws\n}", "id": 5644, "concepts": ["restful.WebService", "restful.WebService.Routes", "restful.WebService.RemoveRoute", "restful.WebService.Method", "restful.WebService.Path", "restful.WebService.To", "restful.WebService.Doc", "restful.WebService.Notes", "restful.WebService.Operation", "restful.WebService.Filter", "restful.WebService.If", "restful.WebService.Param", "restful.WebService.Returns", "restful.WebService.Metadata", "restful.WebService.Route"], "_raw_llm_output": "restful.WebService, restful.WebService.Routes, restful.WebService.RemoveRoute, restful.WebService.Method, restful.WebService.Path, restful.WebService.To, restful.WebService.Doc, restful.WebService.Notes, restful.WebService.Operation, restful.WebService.Filter, restful.WebService.If, restful.WebService.Param, restful.WebService.Returns, restful.WebService.Metadata, restful.WebService.Route"}
{"seed": "// FindAvailableNetwork returns a network from the passed list which does not\n// overlap with existing interfaces in the system\nfunc FindAvailableNetwork(list []*net.IPNet) (*net.IPNet, error) {\n\t// We don't check for an error here, because we don't really care if we\n\t// can't read /etc/resolv.conf. So instead we skip the append if resolvConf\n\t// is nil. It either doesn't exist, or we can't read it for some reason.\n\tvar nameservers []string\n\tif rc, err := os.ReadFile(resolvconf.Path()); err == nil {\n\t\tnameservers = resolvconf.GetNameserversAsCIDR(rc)\n\t}\n\tfor _, nw := range list {\n\t\tif err := CheckNameserverOverlaps(nameservers, nw); err == nil {\n\t\t\tif err := CheckRouteOverlaps(nw); err == nil {\n\t\t\t\treturn nw, nil\n\t\t\t}\n\t\t}\n\t}\n\treturn nil, errors.New(\"no available network\")\n}", "id": 5650, "concepts": ["os package usage", "os.ReadFile", "os.File.Read", "os.File.Close", "os.File.Stat", "os.File.Name", "os.File.Size", "os.File.Seek", "os.File.ReadAt", "os.File.WriteAt", "os.File.Sync", "os.File.Truncate", "os.File.Close", "os.File.Stat", "os.File.Name", "os.File.Size", "os.File.Seek", "os.File.ReadAt", "os.File.WriteAt", "os.File.Sync", "os.File.Truncate", "os.File.Close", "os.File.Stat", "os.File.Name", "os.File.Size", "os.File.Seek", "os.File.ReadAt", "os.File.WriteAt", "os.File.Sync", "os.File.Truncate", "os.File.Close", "os.File.Stat", "os.File.Name", "os.File.Size", "os.File.Seek", "os.File.ReadAt", "os.File.WriteAt", "os.File.Sync", "os.File.Truncate", "os.File.Close", "os.File.Stat", "os.File.Name"], "_raw_llm_output": "os package usage, os.ReadFile, os.File.Read, os.File.Close, os.File.Stat, os.File.Name, os.File.Size, os.File.Seek, os.File.ReadAt, os.File.WriteAt, os.File.Sync, os.File.Truncate, os.File.Close, os.File.Stat, os.File.Name, os.File.Size, os.File.Seek, os.File.ReadAt, os.File.WriteAt, os.File.Sync, os.File.Truncate, os.File.Close, os.File.Stat, os.File.Name, os.File.Size, os.File.Seek, os.File.ReadAt, os.File.WriteAt, os.File.Sync, os.File.Truncate, os.File.Close, os.File.Stat, os.File.Name, os.File.Size, os.File.Seek, os.File.ReadAt, os.File.WriteAt, os.File.Sync, os.File.Truncate, os.File.Close, os.File.Stat, os.File.Name"}
{"seed": "// Footer represents the HTML element 'footer'.\n// For more information visit https://www.w3schools.com/tags/tag_footer.asp.\nfunc Footer(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"footer\", Attributes: attrs, Children: children}\n}", "id": 5651, "concepts": ["HTML generation", "HTML element definition", "HTML attribute definition", "HTML element children definition"], "_raw_llm_output": "HTML generation, HTML element definition, HTML attribute definition, HTML element children definition"}
{"seed": "// deleteTreeNodeBalance balance the tree after deleting.\n// code comment use the following terms:\n// - N as the balance node\n// - P as the father of N\n// - PP as the grand father of N\n// - S as the sibling of N\n// - SL as the left child of S\n// - SR as the right child of S\nfunc deleteTreeNodeBalance(stack *stack) {\n\tvar (\n\t\tp, pp, s  *Node\n\t\tpos, ppos Position\n\t)\n\n\t// case 1: reach the root.\n\t// execute: nothing.\n\t// result: balance finish.\n\tfor stack.index > 0 {\n\t\tp, pp, s = stack.node(), stack.parent(), stack.childSibling()\n\t\tpos, ppos = stack.position(), stack.parentPosition()\n\n\t\t// case 2: S is red.\n\t\t// execute: rotate S up as the PP of N, and exchange the color of P and S.\n\t\t// result: the black number not change, but N has a black sibling now.\n\t\tif s.Color == Red {\n\t\t\tp.Color, s.Color = s.Color, p.Color\n\n\t\t\t// np is original S\n\t\t\tvar np *Node\n\n\t\t\tif pos == Left {\n\t\t\t\tnp = LeftRotate(p)\n\t\t\t\ts = p.Right\n\t\t\t} else {\n\t\t\t\tnp = RightRotate(p)\n\t\t\t\ts = p.Left\n\t\t\t}\n\n\t\t\t// insert np in stack\n\t\t\tstack.insertBefore(np, pos)\n\n\t\t\tif ppos == Left {\n\t\t\t\tpp.Left = np\n\t\t\t} else {\n\t\t\t\tpp.Right = np\n\t\t\t}\n\n\t\t\t// reset PP (original S)\n\t\t\tpp = np\n\t\t}\n\n\t\t// now S is black.\n\n\t\tif s.LeftBlack() && s.RightBlack() {\n\t\t\t// case 3: color of P, S, SL, SR are all Black.\n\t\t\t// execute: set S to red.\n\t\t\t// result: the path through S will reduce one black, and the left and right of P now balance,\n\t\t\t//         set N to p, and continue execute balance.\n\t\t\tif p.Black() {\n\t\t\t\ts.Color = Red\n\t\t\t\tstack.pop()\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// case4: S, SL, SR are black, P is red.\n\t\t\t// execute: exchange the color of S and P.\n\t\t\t// result: add one black on the path through N, while that is not change for path through S, balance finish.\n\t\t\tp.Color, s.Color = s.Color, p.Color\n\t\t\treturn\n\t\t}\n\n\t\t//  now SL and SR has diff color\n\n\t\tif pos == Left {\n\t\t\t// case 5: N is left child of P, S is black, SL is red, SR is black.\n\t\t\t// execute: right rotate on S, then exchange color of SL(parent of S now) and S.\n\t\t\t// result: N has a new black sibling S(original SL), and S has a red right child SR(original S),\n\t\t\t//         while the black count through S will not change.\n\t\t\tif s.LeftRed() {\n\t\t\t\ts = RightRotate(s)\n\t\t\t\ts.Color, s.Right.Color = s.Right.Color, s.Color\n\t\t\t\tp.Right = s\n\t\t\t}\n\n\t\t\t// case6: N is left child of P, S is black, SL is black, SR is red.\n\t\t\t// execute: set SR to black, left rotate P, the exchange the color of P and S.\n\t\t\t// result: S is now the parent of P, the black count through N increase 1,\n\t\t\t//         the black count through S keep the same,\n\t\t\t//         balance finish.\n\t\t\ts.Right.Color = Black\n\t\t\tp.Color, s.Color = s.Color, p.Color\n\t\t\tp = LeftRotate(p)\n\n\t\t\tif ppos == Left {\n\t\t\t\tpp.Left = p\n\t\t\t} else {\n\t\t\t\tpp.Right = p\n\t\t\t}\n\n\t\t\treturn\n\t\t}\n\n\t\t// case 5: N is right child of P, S is black, SL is black, SR is red.\n\t\t// execute: left rotate on S, then exchange color of SR(parent of S now) and S.\n\t\t// result: N has a new black sibling S(original SR), and S has a red left child SL(original S),\n\t\t//         while the black count through S will not change.\n\t\tif s.RightRed() {\n\t\t\ts = LeftRotate(s)\n\t\t\ts.Color, s.Left.Color = s.Left.Color, s.Color\n\t\t\tp.Left = s\n\t\t}\n\n\t\t// case6: N is right child of P, S is black, SL is red, SR is black.\n\t\t// execute: set SL to black, right rotate P, the exchange the color of P and S.\n\t\t// result: S is now the parent of P, the black count through N increase 1,\n\t\t//         the black count through S keep the same,\n\t\t//         balance finish.\n\t\ts.Left.Color = Black\n\t\tp = RightRotate(p)\n\n\t\tif ppos == Left {\n\t\t\tpp.Left = p\n\t\t} else {\n\t\t\tpp.Right = p\n\t\t}\n\n\t\tp.Color, s.Color = s.Color, p.Color\n\t\treturn\n\t}\n}", "id": 5652, "concepts": ["red-black tree", "tree traversal", "tree rotation", "tree balance"], "_raw_llm_output": "red-black tree, tree traversal, tree rotation, tree balance"}
{"seed": "// NewInterpreter returns an initialized Interpreter instance\nfunc NewInterpreter() Interpreter {\n\treturn _interpreter{\n\t\tcoerce:           coerce.New(),\n\t\tvalueInterpreter: value.NewInterpreter(),\n\t}\n}", "id": 5654, "concepts": ["struct definition", "basic function definition"], "_raw_llm_output": "struct definition, basic function definition"}
{"seed": "// WithCommanders middleware finds commanders according to the optional :factionID URL parameter and\n// the optional \"page\" query parameter (falling back to 1), and sets them into ctx.Locals under the\n// key \"commanders\". When present, it will also use the \"name\" and \"summary\" query parameters to\n// refine this search\nfunc WithCommanders(r commanders.Reader) func(*fiber.Ctx) error {\n\treturn func(ctx *fiber.Ctx) error {\n\t\tquery := commanders.FindManyQuery{\n\t\t\tName:      ctx.Query(\"name\"),\n\t\t\tSummary:   ctx.Query(\"summary\"),\n\t\t\tFactionID: factionIDFromLocals(ctx),\n\t\t}\n\t\tcommanders, pages, err := r.FindMany(query, pageFromLocals(ctx))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Set(\"x-pages\", fmt.Sprint(pages))\n\t\tctx.Locals(\"commanders\", commanders)\n\t\treturn ctx.Next()\n\t}\n}", "id": 5660, "concepts": ["function composition", "middleware", "fiber package usage", "URL parameter handling", "query parameter handling", "local variable handling", "error handling", "function definition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", ""], "_raw_llm_output": "function composition, middleware, fiber package usage, URL parameter handling, query parameter handling, local variable handling, error handling, function definition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition,"}
{"seed": "// CoerceString coerces the given value into a string. An empty string is returned\n// if the value cannot be coerced.\nfunc CoerceString(v Value) string {\n\tswitch vc := v.(type) {\n\tcase SafeValue:\n\t\treturn CoerceString(vc.Value())\n\tcase string:\n\t\treturn vc\n\tcase Stringer:\n\t\treturn vc.String()\n\tcase float32, float64, int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64:\n\t\treturn fmt.Sprintf(\"%v\", vc)\n\tcase Number:\n\t\treturn fmt.Sprintf(\"%v\", vc.Number())\n\tcase Boolean:\n\t\tif vc.Boolean() == true {\n\t\t\treturn \"1\" // Twig compatibility (aka PHP compatibility)\n\t\t}\n\tcase bool:\n\t\tif vc == true {\n\t\t\treturn \"1\" // Twig compatibility (aka PHP compatibility)\n\t\t}\n\n\t}\n\treturn \"\"\n}", "id": 5696, "concepts": ["type conversion", "type assertion", "string formatting", "fmt package usage"], "_raw_llm_output": "type conversion, type assertion, string formatting, fmt package usage"}
{"seed": "// appendToFlag appends val to -arg or -arg=... format. If the flag is missing a\n// value, it adds a \"=\" to the flag before appending the value. If a value\n// already exists, inserts a space character before appending the value.\nfunc appendToFlag(arg, val string) string {\n\tif !strings.ContainsRune(arg, '=') {\n\t\targ = arg + \"=\"\n\t}\n\tif arg[len(arg)-1] != '=' && arg[len(arg)-1] != ' ' {\n\t\targ += \" \"\n\t}\n\targ += val\n\treturn arg\n}", "id": 5699, "concepts": ["string manipulation", "string comparison", "string concatenation", "string indexing", "string length", "string manipulation"], "_raw_llm_output": "string manipulation, string comparison, string concatenation, string indexing, string length, string manipulation"}
{"seed": "// TransfertobankaccountLTE applies the LTE predicate on the \"transfertobankaccount\" field.\nfunc TransfertobankaccountLTE(v float64) predicate.Bulk {\n\treturn predicate.Bulk(func(s *sql.Selector) {\n\t\ts.Where(sql.LTE(s.C(FieldTransfertobankaccount), v))\n\t})\n}", "id": 5711, "concepts": ["sql package usage", "sql.Selector", "sql.C", "sql.LTE"], "_raw_llm_output": "sql package usage, sql.Selector, sql.C, sql.LTE"}
{"seed": "// Converts a slice of floats to a Coefs slice as found in a one-value matrix.\nfunc floatsToCoefs(floats []float64) []Coef {\n\tcoefs := make([]Coef, len(floats))\n\tfor index := range floats {\n\t\tcoefs[index] = Coef{floats[index]}\n\t}\n\treturn coefs\n}", "id": 5713, "concepts": ["slice iteration (range loop)", "slice creation", "slice assignment"], "_raw_llm_output": "slice iteration (range loop), slice creation, slice assignment"}
{"seed": "// [LeetCode 3] Longest Substring Without Repeating Characters\n// Given a string, find the length of the longest substring without\n// repeating characters. For example, the longest substring without\n// repeating letters for \u201cabcabcbb\u201d is \u201cabc\u201d, which the length is 3.\n// For \u201cbbbbb\u201d the longest substring is \u201cb\u201d, with the length of 1.\n// Input : \u201cbbbbb\u201d => length = 1\n// Input : \u201cabcabcbb\u201d => length = 3\n// Input : \u201caabcabcbb\u201d => length = 3\n// Solution : Sliding window\nfunc LongestSubstring(input string) int {\n\t// String length >= 2\n\tleft, right := 0, 1\n\tlongest := 0\n\tsize := len(input)\n\tfor ; right < size; right++ {\n\t\t// left != right\n\t\tif input[left] != input[right] {\n\t\t\tlongest = right - left\n\t\t\tif left == 0 {\n\t\t\t\tlongest++\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\t// left == right\n\t\tleft++\n\t}\n\tif longest == 0 {\n\t\treturn 1\n\t}\n\treturn longest\n}", "id": 5714, "concepts": ["string manipulation", "sliding window", "basic function definition"], "_raw_llm_output": "string manipulation, sliding window, basic function definition"}
{"seed": "// ============================================================================================================================\n// Init Product - create a new product, store into chaincode state\n//\n// Shows off building a key's JSON value manually\n//\n// Inputs - Array of strings\n// 0-1      0     ,       1 ,        2,\t\t3\t\t4\t5\t\t6\t\t7\t\t8\t\t9\t\t10\n// productid,   groupid, groupname, registeruserid, registerusername,registerdate,productname, productweight ,productvolume \n//\n//\n//\t\t9\t\t10\n//   mainingredientname, forcoin\n// \n\n// ============================================================================================================================\nfunc init_product(stub shim.ChaincodeStubInterface, args []string) (pb.Response) {\n\tvar err error\n\tfmt.Println(\"starting init_product\")\n\n\n\tif len(args) != 11 {\n\t\treturn shim.Error(\"Incorrect number of arguments. Expecting 11\")\n\t}\n\n\n\t//input sanitation\n\terr = sanitize_arguments(args)\n\tif err != nil {\n\t\treturn shim.Error(err.Error())\n\t}\n\tvar product Product\n\n\tproduct.ObjectType = \"product\"\n\n\tproduct.GroupId = args[0]\n\tproduct.GroupName = strings.ToLower(args[1])\n\tproduct.RegisterUserId = args[2]\n\tproduct.RegisterUserName = strings.ToLower(args[3])\n\tproduct.ProductId = args[4]\n\tproduct.RegisterDate = strings.ToLower(args[5])\n\tproduct.ProductName =strings.ToLower(args[6])\n\tproduct.ProductWeight = strings.ToLower(args[7])\n\tproduct.ProductVolume = strings.ToLower(args[8])\n\tproduct.MainIngredientName = strings.ToLower(args[9])\n\tproduct.FORCoin,err = strconv.Atoi(args[10])\n\n\n\tproductAsBytes, _ :=json.Marshal(product)\n\n\tfmt.Println(\"writing product to state\")\n\n\tfmt.Println(string(productAsBytes))\n\tfmt.Println(\"productid\",product.ProductId)\n\terr = stub.PutState(product.ProductId, productAsBytes)                    //store owner by its Id\n\tif err != nil {\n\t\tfmt.Println(\"Could not store product\")\n\t\treturn shim.Error(err.Error())\n\t}\n\n//\tif err != nil {\n//\t\treturn shim.Error(\"3rd argument must be a numeric string\")\n//\t}\n\n\n\t//build the product json string manually\n//\tstr := `{\n//\t\t\"docType\":\"product\",\n//\t\t\"groupid\": \"` + groupid + `\",\n//\t\t\"groupname\": \"sarang\",\n//\t\t\"registeruserid\": \"sarng2\",\n//\t\t\"registerusername\": \"sarararng\",\n//\t\t\"productid\": \"` + productid + `\",\n//\t\t\"registerdate\": \"` + registerdate + `\",\n//\t\t\"productname\": \"` + productname + `\",\n//\t\t\"productweight\": \"` + productweight + `\",\n//\t\t\"productvolume\": \"` + productvolume + `\",\n//\t\t\"mainingredientname\": \"` + mainingredientname + `\", \n//\t\t\"forcoin\": ` + strconv.Itoa(forcoin) + `, \n//\t}`\n//\terr = stub.PutState(productid, []byte(str))                         //store product with id as key\n//\n//\tAvals ,err :=stub.GetState(productid)\n//\tAvalsString :=string(Avals)\n//\n//\tfmt.Println(\"product?\",AvalsString)\n//\n//\n//\tif err != nil {\n//\t\treturn shim.Error(err.Error())\n//\t}\n//\n\tfmt.Println(\"- end init_product\")\n\n\treturn shim.Success(nil)\n}", "id": 5717, "concepts": ["string manipulation", "string formatting", "JSON encoding/decoding", "basic function definition"], "_raw_llm_output": "string manipulation, string formatting, JSON encoding/decoding, basic function definition"}
{"seed": "// KLDivergence computes the Kullback-Leibler divergence between two probability\n// distributions p and q. p and q are expected to have the same length and\n// contain numbers that sum up to 1.0; The KL divergence is close to 0 if the\n// two distributions are deemed \"similar\" and gets larger the more different\n// they are.\n// See https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence\nfunc KLDivergence(p, q []float64) float64 {\n\tif len(p) != len(q) {\n\t\tlog.Fatalf(\"len(p) == %v, len(q) == %v\", len(p), len(q))\n\t}\n\tvar total float64\n\tfor i := 0; i < len(p); i++ {\n\t\tif p[i] > 0 {\n\t\t\ttotal += p[i] * math.Log(q[i]/p[i])\n\t\t}\n\t}\n\treturn -total\n}", "id": 5718, "concepts": ["slice iteration (range loop)", "floating-point number handling", "mathematical series"], "_raw_llm_output": "slice iteration (range loop), floating-point number handling, mathematical series"}
{"seed": "// Noframes represents the HTML element 'noframes'.\n// For more information visit https://www.w3schools.com/tags/tag_noframes.asp.\nfunc Noframes(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"noframes\", Attributes: attrs, Children: children}\n}", "id": 5729, "concepts": ["HTML generation", "HTML element definition", "HTML attribute definition", "HTML element children definition"], "_raw_llm_output": "HTML generation, HTML element definition, HTML attribute definition, HTML element children definition"}
{"seed": "// sortDescription sorts a slice of structs with Name, Kind, and Version fields\n// by comparing those field's strings in natural order.\nfunc sortDescription(v interface{}) {\n\tslice := reflect.ValueOf(v)\n\tvalues := toValueSlice(slice)\n\tsort.Slice(values, func(i, j int) bool {\n\t\tnameI := values[i].FieldByName(\"Name\").String()\n\t\tnameJ := values[j].FieldByName(\"Name\").String()\n\t\tif nameI == nameJ {\n\t\t\tkindI := values[i].FieldByName(\"Kind\").String()\n\t\t\tkindJ := values[j].FieldByName(\"Kind\").String()\n\t\t\tif kindI == kindJ {\n\t\t\t\tversionI := values[i].FieldByName(\"Version\").String()\n\t\t\t\tversionJ := values[j].FieldByName(\"Version\").String()\n\t\t\t\treturn version.CompareKubeAwareVersionStrings(versionI, versionJ) > 0\n\t\t\t}\n\t\t\treturn kindI < kindJ\n\t\t}\n\t\treturn nameI < nameJ\n\t})\n\tfor i := 0; i < slice.Len(); i++ {\n\t\tslice.Index(i).Set(values[i])\n\t}\n}", "id": 5741, "concepts": ["reflection", "sort.Slice", "interface{}"], "_raw_llm_output": "reflection, sort.Slice, interface{}"}
{"seed": "// NewMockTransportInstanceExposer creates a new instance of MockTransportInstanceExposer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.\n// The first argument is typically a *testing.T value.\nfunc NewMockTransportInstanceExposer(t interface {\n\tmock.TestingT\n\tCleanup(func())\n}) *MockTransportInstanceExposer {\n\tmock := &MockTransportInstanceExposer{}\n\tmock.Mock.Test(t)\n\n\tt.Cleanup(func() { mock.AssertExpectations(t) })\n\n\treturn mock\n}", "id": 5759, "concepts": ["testing interface", "testing cleanup", "mocking"], "_raw_llm_output": "testing interface, testing cleanup, mocking"}
{"seed": "// Sup represents the HTML element 'sup'.\n// For more information visit https://www.w3schools.com/tags/tag_sup.asp.\nfunc Sup(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"sup\", Attributes: attrs, Children: children}\n}", "id": 5760, "concepts": ["HTML generation", "HTML tree traversal"], "_raw_llm_output": "HTML generation, HTML tree traversal"}
{"seed": "// ComparatorInt16 provides a basic comparison on int16.\nfunc ComparatorInt16(a, b interface{}) int {\n\treturn int(qn_conv.Int16(a) - qn_conv.Int16(b))\n}", "id": 5780, "concepts": ["interface", "type conversion", "basic function definition"], "_raw_llm_output": "interface, type conversion, basic function definition"}
{"seed": "// LookPath searches for an executable named file in the directories\n// named by the PATH environment variable. If file contains a slash,\n// it is tried directly and the PATH is not consulted. The result will be\n// an absolute path.\n//\n// LookPath differs from exec.LookPath in its handling of PATH lookups,\n// which are used for file names without slashes. If exec.LookPath's\n// PATH lookup would have returned an executable from the current directory,\n// LookPath instead returns an error.\nfunc LookPath(file string) (string, error) {\n\tpath, err := exec.LookPath(file)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif filepath.Base(file) == file && !filepath.IsAbs(path) {\n\t\treturn \"\", relError(file, path)\n\t}\n\treturn path, nil\n}", "id": 5794, "concepts": ["exec.LookPath", "filepath.Base", "filepath.IsAbs", "error handling"], "_raw_llm_output": "exec.LookPath, filepath.Base, filepath.IsAbs, error handling"}
{"seed": "// Tfoot_ is a convenience wrapper for Tfoot without the attrs argument.\nfunc Tfoot_(children ...HTML) HTML {\n  return Tfoot(nil, children...)\n}", "id": 5821, "concepts": ["function definition", "function argument handling", "variadic function argument handling"], "_raw_llm_output": "function definition, function argument handling, variadic function argument handling"}
{"seed": "////////////////////////////////////////////////////////////////////////////////\n// Public\n////////////////////////////////////////////////////////////////////////////////\n\n// S3AllKeysArnForBucket returns a CloudFormation-compatible Arn expression\n// (string or Ref) for all bucket keys (`/*`).  The bucket\n// parameter may be either a string or an interface{} (\"Ref: \"myResource\")\n// value\nfunc S3AllKeysArnForBucket(bucket interface{}) *gocf.StringExpr {\n\tarnParts := []gocf.Stringable{gocf.String(\"arn:aws:s3:::\")}\n\n\tswitch bucket.(type) {\n\tcase string:\n\t\t// Don't be smart if the Arn value is a user supplied literal\n\t\tarnParts = append(arnParts, gocf.String(bucket.(string)))\n\tcase *gocf.StringExpr:\n\t\tarnParts = append(arnParts, bucket.(*gocf.StringExpr))\n\tcase gocf.RefFunc:\n\t\tarnParts = append(arnParts, bucket.(gocf.RefFunc).String())\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"Unsupported SourceArn value type: %+v\", bucket))\n\t}\n\tarnParts = append(arnParts, gocf.String(\"/*\"))\n\treturn gocf.Join(\"\", arnParts...).String()\n}", "id": 5823, "concepts": ["string concatenation", "string formatting", "string manipulation", "string iteration", "string comparison", "string iteration", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation"], "_raw_llm_output": "string concatenation, string formatting, string manipulation, string iteration, string comparison, string iteration, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation"}
{"seed": "// PossibleTransformTypeValues returns an array of possible values for the TransformType const type.\nfunc PossibleTransformTypeValues() []TransformType {\n\treturn []TransformType{TransformTypeLowercase, TransformTypeRemoveNulls, TransformTypeTrim, TransformTypeUppercase, TransformTypeURLDecode, TransformTypeURLEncode}\n}", "id": 5836, "concepts": ["const type", "array definition", "array iteration"], "_raw_llm_output": "const type, array definition, array iteration"}
{"seed": "// AzureADLicenseTypePPremiumP2 returns a pointer to AzureADLicenseTypeVPremiumP2\nfunc AzureADLicenseTypePPremiumP2() *AzureADLicenseType {\n\tv := AzureADLicenseTypeVPremiumP2\n\treturn &v\n}", "id": 5844, "concepts": ["pointer usage", "struct definition", "struct pointer definition"], "_raw_llm_output": "pointer usage, struct definition, struct pointer definition"}
{"seed": "// IsIntKind reports whether k is an integer kind of any size.\nfunc IsIntKind(k reflect.Kind) bool {\n\tswitch k {\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\treturn true\n\t}\n\treturn false\n}", "id": 5846, "concepts": ["reflect package usage", "integer types", "type switch"], "_raw_llm_output": "reflect package usage, integer types, type switch"}
{"seed": "// UserAgentHandler adds the request's user-agent as a field to the context's logger\n// using fieldKey as field key.\nfunc UserAgentHandler(fieldKey string) func(next httpserver.Handler) httpserver.Handler {\n\treturn func(next httpserver.Handler) httpserver.Handler {\n\t\treturn httpserver.HandlerFunc(func(w http.ResponseWriter, r *http.Request) (int, error) {\n\t\t\tif ua := r.Header.Get(\"User-Agent\"); ua != \"\" {\n\t\t\t\tlog := zerolog.Ctx(r.Context())\n\t\t\t\tlog.UpdateContext(func(c zerolog.Context) zerolog.Context {\n\t\t\t\t\treturn c.Str(fieldKey, ua)\n\t\t\t\t})\n\t\t\t}\n\t\t\treturn next.ServeHTTP(w, r)\n\t\t})\n\t}\n}", "id": 5854, "concepts": ["http.ResponseWriter", "http.Request", "http.Handler", "http.HandlerFunc", "zerolog.Context", "zerolog.Context.Str", "httpserver.Handler", "httpserver.HandlerFunc", "httpserver.HandlerFunc.ServeHTTP", "middleware"], "_raw_llm_output": "http.ResponseWriter, http.Request, http.Handler, http.HandlerFunc, zerolog.Context, zerolog.Context.Str, httpserver.Handler, httpserver.HandlerFunc, httpserver.HandlerFunc.ServeHTTP, middleware"}
{"seed": "// WithMinConnections configures the minimum number of connections to allow for\n// a given server. If min is 0, then there is no lower limit to the number of\n// connections.\nfunc WithMinConnections(fn func(uint64) uint64) ServerOption {\n\treturn func(cfg *serverConfig) error {\n\t\tcfg.minConns = fn(cfg.minConns)\n\t\treturn nil\n\t}\n}", "id": 5873, "concepts": ["function composition", "function definition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", ""], "_raw_llm_output": "function composition, function definition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition,"}
{"seed": "// ResolverQueryLogConfigAssociationStatus_Values returns all elements of the ResolverQueryLogConfigAssociationStatus enum\nfunc ResolverQueryLogConfigAssociationStatus_Values() []string {\n\treturn []string{\n\t\tResolverQueryLogConfigAssociationStatusCreating,\n\t\tResolverQueryLogConfigAssociationStatusActive,\n\t\tResolverQueryLogConfigAssociationStatusActionNeeded,\n\t\tResolverQueryLogConfigAssociationStatusDeleting,\n\t\tResolverQueryLogConfigAssociationStatusFailed,\n\t}\n}", "id": 5883, "concepts": ["enum", "string manipulation", "standard library usage"], "_raw_llm_output": "enum, string manipulation, standard library usage"}
{"seed": "// NewEquipmentFanModuleWithDefaults instantiates a new EquipmentFanModule object\n// This constructor will only assign default values to properties that have it defined,\n// but it doesn't guarantee that properties required by API are set\nfunc NewEquipmentFanModuleWithDefaults() *EquipmentFanModule {\n\tthis := EquipmentFanModule{}\n\tvar classId string = \"equipment.FanModule\"\n\tthis.ClassId = classId\n\tvar objectType string = \"equipment.FanModule\"\n\tthis.ObjectType = objectType\n\treturn &this\n}", "id": 5898, "concepts": ["object instantiation", "struct definition", "struct field assignment", "string formatting"], "_raw_llm_output": "object instantiation, struct definition, struct field assignment, string formatting"}
{"seed": "// SocialAvatarURLLTE applies the LTE predicate on the \"social_avatar_url\" field.\nfunc SocialAvatarURLLTE(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.LTE(s.C(FieldSocialAvatarURL), v))\n\t})\n}", "id": 5901, "concepts": ["sql.Selector", "sql.C", "sql.LTE", "sql.Where", "sql.Predicate", "sql.Field", "sql.Query", "sql.Queryer", "sql.SelectorBuilder", "sql.SelectorBuilderFunc", "sql.SelectorBuilderFunc", "sql.SelectorBuilderFunc", "sql.SelectorBuilderFunc", "sql.SelectorBuilderFunc", "sql.SelectorBuilderFunc", "sql.SelectorBuilderFunc", "sql.SelectorBuilderFunc", "sql.SelectorBuilderFunc", "sql.SelectorBuilderFunc", "sql.SelectorBuilderFunc", "sql.SelectorBuilderFunc", "sql.SelectorBuilderFunc", "sql.SelectorBuilderFunc", "sql.SelectorBuilderFunc", "sql.SelectorBuilderFunc", "sql.SelectorBuilderFunc", "sql.SelectorBuilderFunc", "sql.SelectorBuilderFunc", "sql.SelectorBuilderFunc", "sql.SelectorBuilderFunc", "sql.SelectorBuilderFunc", "sql.SelectorBuilderFunc", "sql.SelectorBuilderFunc", "sql.SelectorBuilderFunc", "sql.SelectorBuilderFunc", "sql.SelectorBuilderFunc", "sql.SelectorBuilderFunc", "sql.SelectorBuilderFunc", "sql.SelectorBuilderFunc", "sql.SelectorBuilderFunc", "sql.SelectorBuilderFunc", "sql.SelectorBuilderFunc", "sql.SelectorBuilderFunc", "sql.SelectorBuilderFunc", "sql.SelectorBuilderFunc", "sql"], "_raw_llm_output": "sql.Selector, sql.C, sql.LTE, sql.Where, sql.Predicate, sql.Field, sql.Query, sql.Queryer, sql.SelectorBuilder, sql.SelectorBuilderFunc, sql.SelectorBuilderFunc, sql.SelectorBuilderFunc, sql.SelectorBuilderFunc, sql.SelectorBuilderFunc, sql.SelectorBuilderFunc, sql.SelectorBuilderFunc, sql.SelectorBuilderFunc, sql.SelectorBuilderFunc, sql.SelectorBuilderFunc, sql.SelectorBuilderFunc, sql.SelectorBuilderFunc, sql.SelectorBuilderFunc, sql.SelectorBuilderFunc, sql.SelectorBuilderFunc, sql.SelectorBuilderFunc, sql.SelectorBuilderFunc, sql.SelectorBuilderFunc, sql.SelectorBuilderFunc, sql.SelectorBuilderFunc, sql.SelectorBuilderFunc, sql.SelectorBuilderFunc, sql.SelectorBuilderFunc, sql.SelectorBuilderFunc, sql.SelectorBuilderFunc, sql.SelectorBuilderFunc, sql.SelectorBuilderFunc, sql.SelectorBuilderFunc, sql.SelectorBuilderFunc, sql.SelectorBuilderFunc, sql.SelectorBuilderFunc, sql.SelectorBuilderFunc, sql.SelectorBuilderFunc, sql.SelectorBuilderFunc, sql.SelectorBuilderFunc, sql.SelectorBuilderFunc, sql"}
{"seed": "// AddMonitoringDashboards adds additional dashboards to the original list.\n// If a name of a new dashboard already exists in orig, it replaces the original.\n// Note that the returns list is also stripped of dashboards that should be disabled.\n// A dashboard is disabled if \"DiscoverOn\" is an empty string and \"Items\" is an empty list.\nfunc AddMonitoringDashboards(orig MonitoringDashboardsList, additional MonitoringDashboardsList) MonitoringDashboardsList {\n\tif additional == nil || orig == nil {\n\t\treturn nil\n\t}\n\tallDashboardsMap := orig.OrganizeByName()\n\tfor _, a := range additional {\n\t\tallDashboardsMap[a.Name] = *((&a).deepCopy())\n\t}\n\n\tnewList := make([]MonitoringDashboard, 0, len(allDashboardsMap))\n\tfor _, val := range allDashboardsMap {\n\t\tif strings.TrimSpace(val.DiscoverOn) != \"\" || len(val.Items) > 0 {\n\t\t\tnewList = append(newList, val)\n\t\t}\n\t}\n\treturn MonitoringDashboardsList(newList)\n}", "id": 5908, "concepts": ["struct", "map", "slice", "pointer", "deep copy", "string manipulation", "map iteration"], "_raw_llm_output": "struct, map, slice, pointer, deep copy, string manipulation, map iteration"}
{"seed": "// ReadRentableLeaseStatuses reads a full RentableLeaseStatus structure of data from the database based on the supplied Rows pointer.\nfunc ReadRentableLeaseStatuses(rows *sql.Rows, a *RentableLeaseStatus) error {\n\treturn rows.Scan(\n\t\t&a.RLID,\n\t\t&a.RID,\n\t\t&a.BID,\n\t\t&a.DtStart,\n\t\t&a.DtStop,\n\t\t&a.LeaseStatus,\n\t\t&a.Comment,\n\t\t&a.FirstName,\n\t\t&a.LastName,\n\t\t&a.Email,\n\t\t&a.Phone,\n\t\t&a.Address,\n\t\t&a.Address2,\n\t\t&a.City,\n\t\t&a.State,\n\t\t&a.PostalCode,\n\t\t&a.Country,\n\t\t&a.CCName,\n\t\t&a.CCType,\n\t\t&a.CCNumber,\n\t\t&a.CCExpMonth,\n\t\t&a.ConfirmationCode,\n\t\t&a.CreateTS,\n\t\t&a.CreateBy,\n\t\t&a.LastModTime,\n\t\t&a.LastModBy)\n}", "id": 5910, "concepts": ["sql package usage", "sql.Rows", "sql.Scan", "pointer usage", "basic function definition"], "_raw_llm_output": "sql package usage, sql.Rows, sql.Scan, pointer usage, basic function definition"}
{"seed": "// PossibleClusterPrincipalRoleValues returns an array of possible values for the ClusterPrincipalRole const type.\nfunc PossibleClusterPrincipalRoleValues() []ClusterPrincipalRole {\n\treturn []ClusterPrincipalRole{AllDatabasesAdmin, AllDatabasesViewer}\n}", "id": 5911, "concepts": ["enumerated type", "const declaration", "array declaration"], "_raw_llm_output": "enumerated type, const declaration, array declaration"}
{"seed": "// EncodeUserDetailsResponse encode the internal response into the expected grpc response type\nfunc EncodeUserDetailsResponse(_ context.Context, r interface{}) (interface{}, error) {\n\tresp := r.(UserDetailsResponse)\n\treturn &pb.UserDetailsResponse{\n\t\tId:          int32(resp.ID),\n\t\tUsername:    resp.Username,\n\t\tEmail:       resp.Email,\n\t\tPhoneNumber: resp.PhoneNumber,\n\t\tConfirmed:   resp.Confirmed,\n\t}, nil\n}", "id": 5920, "concepts": ["grpc", "protobuf", "interface", "anonymous function"], "_raw_llm_output": "grpc, protobuf, interface, anonymous function"}
{"seed": "// ParseFile parses a file described (path + encoding) in a provided configuration file\n// passing the data to LineProcessor.\nfunc ParseFile(conf *vertigo.ParserConf, lproc vertigo.LineProcessor) error {\n\tst, stErr := newSimpleTokenizer(conf.Encoding)\n\tif stErr != nil {\n\t\treturn stErr\n\t}\n\trd, err := files.NewReader(conf.InputFilePath)\n\tif err == nil {\n\t\treturn st.parseSource(rd, lproc)\n\t}\n\treturn err\n}", "id": 5923, "concepts": ["file reading", "file parsing", "file encoding", "file handling", "file path handling", "file line handling"], "_raw_llm_output": "file reading, file parsing, file encoding, file handling, file path handling, file line handling"}
{"seed": "// UpdatedAtEQ applies the EQ predicate on the \"updated_at\" field.\nfunc UpdatedAtEQ(v time.Time) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldUpdatedAt), v))\n\t})\n}", "id": 5944, "concepts": ["sql.Selector", "sql.EQ", "predicate.User", "anonymous function"], "_raw_llm_output": "sql.Selector, sql.EQ, predicate.User, anonymous function"}
{"seed": "// extractAddress extracts the IP address part of the IP:port string\n// set as net/http.Request.RemoteAddr. It handles IPv4 cases like\n// 192.0.2.1:48467 and IPv6 cases like [2001:db8::1%lo0]:48467\nfunc extractAddress(str string) string {\n\tvar addr string\n\n\tswitch {\n\tcase strings.Contains(str, `]`):\n\t\t// IPv6 address [2001:db8::1%lo0]:48467\n\t\taddr = strings.Split(str, `]`)[0]\n\t\taddr = strings.Split(addr, `%`)[0]\n\t\taddr = strings.TrimLeft(addr, `[`)\n\tdefault:\n\t\t// IPv4 address 192.0.2.1:48467\n\t\taddr = strings.Split(str, `:`)[0]\n\t}\n\treturn addr\n}", "id": 5947, "concepts": ["string manipulation", "string splitting", "string trimming", "string comparison", "string concatenation", "string formatting", "string length", "string contains", "string index", "string slice", "string substring", "string replace", "string trim", "string split", "string join", "string contains", "string index", "string slice", "string substring", "string replace", "string trim", "string split", "string join", "string contains", "string index", "string slice", "string substring", "string replace", "string trim", "string split", "string join", "string contains", "string index", "string slice", "string substring", "string replace", "string trim", "string split", "string join", "string contains", "string index", "string slice", "string substring", "string replace", "string trim", "string split", "string join", "string contains", "string index", "string slice", "string substring", "string replace", "string trim", "string split", "string join", "string contains", "string index", "string slice", "string substring", "string replace", "string trim", "string split", "string join", "string contains", "string index", "string slice", "string substring", "string replace", "string trim", "string split", "string join", "string contains", "string index", "string slice", "string substring", "string replace", "string trim", "string split", "string join", "string contains", "string index", "string slice", "string substring", "string replace", ""], "_raw_llm_output": "string manipulation, string splitting, string trimming, string comparison, string concatenation, string formatting, string length, string contains, string index, string slice, string substring, string replace, string trim, string split, string join, string contains, string index, string slice, string substring, string replace, string trim, string split, string join, string contains, string index, string slice, string substring, string replace, string trim, string split, string join, string contains, string index, string slice, string substring, string replace, string trim, string split, string join, string contains, string index, string slice, string substring, string replace, string trim, string split, string join, string contains, string index, string slice, string substring, string replace, string trim, string split, string join, string contains, string index, string slice, string substring, string replace, string trim, string split, string join, string contains, string index, string slice, string substring, string replace, string trim, string split, string join, string contains, string index, string slice, string substring, string replace, string trim, string split, string join, string contains, string index, string slice, string substring, string replace,"}
{"seed": "// PhoneNEQ applies the NEQ predicate on the \"phone\" field.\nfunc PhoneNEQ(v string) predicate.User {\n\treturn predicate.User(sql.FieldNEQ(FieldPhone, v))\n}", "id": 5951, "concepts": ["SQL query building", "predicate definition", "SQL query execution"], "_raw_llm_output": "SQL query building, predicate definition, SQL query execution"}
{"seed": "// CheckGameLocation converts a path into a GameLocation, making sure to set Valid & Version correctly in the process.\nfunc CheckGameLocation(dir string) GameLocation {\n\tgameInstance := game.At(dir)\n\tpath, err := gameInstance.BasePath()\n\tif err != nil {\n\t\treturn GameLocation{\n\t\t\tLocation: dir,\n\t\t}\n\t}\n\tcc, _ := gameInstance.Get(\"crosscode\")\n\tinfo, _ := cc.Info()\n\n\treturn GameLocation{\n\t\tValid:    true,\n\t\tLocation: path,\n\t\tVersion:  info.CurrentVersion,\n\t}\n}", "id": 5956, "concepts": ["game.At", "game.BasePath", "game.Get", "game.Info", "game.CurrentVersion", "game.Version", "game.Location", "game.Valid", "game.Info", "game.CurrentVersion", "game.Version", "game.Location", "game.Valid", "game.Info", "game.CurrentVersion", "game.Version", "game.Location", "game.Valid", "game.Info", "game.CurrentVersion", "game.Version", "game.Location", "game.Valid", "game.Info", "game.CurrentVersion", "game.Version", "game.Location", "game.Valid", "game.Info", "game.CurrentVersion", "game.Version", "game.Location", "game.Valid", "game.Info", "game.CurrentVersion", "game.Version", "game.Location", "game.Valid", "game.Info", "game.CurrentVersion", "game.Version", "game.Location", "game.Valid", "game.Info", "game.CurrentVersion", "game.Version", "game.Location", "game.Valid", "game.Info", "game.CurrentVersion", "game.Version", "game.Location", "game.Valid", "game.Info", "game.CurrentVersion", "game.Version", "game.Location", "game.Valid", "game.Info", "game.CurrentVersion", "game.Version"], "_raw_llm_output": "game.At, game.BasePath, game.Get, game.Info, game.CurrentVersion, game.Version, game.Location, game.Valid, game.Info, game.CurrentVersion, game.Version, game.Location, game.Valid, game.Info, game.CurrentVersion, game.Version, game.Location, game.Valid, game.Info, game.CurrentVersion, game.Version, game.Location, game.Valid, game.Info, game.CurrentVersion, game.Version, game.Location, game.Valid, game.Info, game.CurrentVersion, game.Version, game.Location, game.Valid, game.Info, game.CurrentVersion, game.Version, game.Location, game.Valid, game.Info, game.CurrentVersion, game.Version, game.Location, game.Valid, game.Info, game.CurrentVersion, game.Version, game.Location, game.Valid, game.Info, game.CurrentVersion, game.Version, game.Location, game.Valid, game.Info, game.CurrentVersion, game.Version, game.Location, game.Valid, game.Info, game.CurrentVersion, game.Version"}
{"seed": "// GetDisplayRules returns the view.DisplayRules for knative serving.\nfunc GetDisplayRules() view.DisplayRules {\n\treturn view.DisplayRules{\n\t\tPackageNameRule: PackageDisplayRule,\n\t}\n}", "id": 5957, "concepts": ["struct definition", "interface implementation", "function definition", "function return value", "standard library usage"], "_raw_llm_output": "struct definition, interface implementation, function definition, function return value, standard library usage"}
{"seed": "// ValidateSecret checks if the secret is still valid and has not expired.\n// Returns an error if the Secret is not valid and has expired.\nfunc ValidateSecret(secret *pbauth.Secret) error {\n\tif secret == nil {\n\t\treturn consts.ErrNilSecret\n\t}\n\tif strings.TrimSpace(secret.Key) == \"\" {\n\t\treturn consts.ErrEmptySecret\n\t}\n\tcreateTime := secret.CreatedTimestamp\n\tif createTime == 0 || createTime > time.Now().UTC().Unix() {\n\t\treturn consts.ErrInvalidSecretCreateTimestamp\n\t}\n\tif isExpired(secret.ExpirationTimestamp) {\n\t\treturn consts.ErrExpiredSecret\n\t}\n\treturn nil\n}", "id": 5959, "concepts": ["time handling", "time.Now()", "time.Unix()", "time.Time.Unix()", "time.Time.UTC()", "time.Time.UnixNano()", "time.Time.Unix()", "time.Time.Format()", "time.Time.In()", "time.Time.After()", "time.Time.Before()", "time.Time.Equal()", "time.Time.Add()", "time.Time.Sub()", "time.Time.Location()", "time.Time.Format()", "time.Time.Format()", "time.Time.Format()", "time.Time.Format()", "time.Time.Format()", "time.Time.Format()", "time.Time.Format()", "time.Time.Format()", "time.Time.Format()", "time.Time.Format()", "time.Time.Format()", "time.Time.Format()", "time.Time.Format()", "time.Time.Format()", "time.Time.Format()", "time.Time.Format()", "time.Time.Format()", "time.Time.Format()", "time.Time.Format()", "time.Time.Format()", "time.Time.Format()", "time.Time.Format()", "time.Time.Format()", "time.Time.Format()", "time.Time.Format()", "time.Time.Format()", "time.Time.Format()", "time.Time.Format()", "time.Time"], "_raw_llm_output": "time handling, time.Now(), time.Unix(), time.Time.Unix(), time.Time.UTC(), time.Time.UnixNano(), time.Time.Unix(), time.Time.Format(), time.Time.In(), time.Time.After(), time.Time.Before(), time.Time.Equal(), time.Time.Add(), time.Time.Sub(), time.Time.Location(), time.Time.Format(), time.Time.Format(), time.Time.Format(), time.Time.Format(), time.Time.Format(), time.Time.Format(), time.Time.Format(), time.Time.Format(), time.Time.Format(), time.Time.Format(), time.Time.Format(), time.Time.Format(), time.Time.Format(), time.Time.Format(), time.Time.Format(), time.Time.Format(), time.Time.Format(), time.Time.Format(), time.Time.Format(), time.Time.Format(), time.Time.Format(), time.Time.Format(), time.Time.Format(), time.Time.Format(), time.Time.Format(), time.Time.Format(), time.Time.Format(), time.Time.Format(), time.Time"}
{"seed": "// FailoverGroupReadWriteEndpointGenerator returns a generator of FailoverGroupReadWriteEndpoint instances for property testing.\nfunc FailoverGroupReadWriteEndpointGenerator() gopter.Gen {\n\tif failoverGroupReadWriteEndpointGenerator != nil {\n\t\treturn failoverGroupReadWriteEndpointGenerator\n\t}\n\n\tgenerators := make(map[string]gopter.Gen)\n\tAddIndependentPropertyGeneratorsForFailoverGroupReadWriteEndpoint(generators)\n\tfailoverGroupReadWriteEndpointGenerator = gen.Struct(reflect.TypeOf(FailoverGroupReadWriteEndpoint{}), generators)\n\n\treturn failoverGroupReadWriteEndpointGenerator\n}", "id": 5973, "concepts": ["map", "struct", "reflection", "property testing", "property-based testing"], "_raw_llm_output": "map, struct, reflection, property testing, property-based testing"}
{"seed": "// SocialPayload applies equality check predicate on the \"social_payload\" field. It's identical to SocialPayloadEQ.\nfunc SocialPayload(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldSocialPayload), v))\n\t})\n}", "id": 5982, "concepts": ["sql package usage", "sql.Selector", "sql.C", "sql.EQ", "predicate.User"], "_raw_llm_output": "sql package usage, sql.Selector, sql.C, sql.EQ, predicate.User"}
{"seed": "// DropOptionalNotIn applies the NotIn predicate on the \"drop_optional\" field.\nfunc DropOptionalNotIn(vs ...string) predicate.User {\n\treturn predicate.User(sql.FieldNotIn(FieldDropOptional, vs...))\n}", "id": 5992, "concepts": ["predicate composition", "predicate.User", "sql.FieldNotIn"], "_raw_llm_output": "predicate composition, predicate.User, sql.FieldNotIn"}
{"seed": "// NewNegotiableQuoteCouponManagementV1RemoveDeleteParamsWithContext creates a new NegotiableQuoteCouponManagementV1RemoveDeleteParams object\n// with the default values initialized, and the ability to set a context for a request\nfunc NewNegotiableQuoteCouponManagementV1RemoveDeleteParamsWithContext(ctx context.Context) *NegotiableQuoteCouponManagementV1RemoveDeleteParams {\n\tvar ()\n\treturn &NegotiableQuoteCouponManagementV1RemoveDeleteParams{\n\n\t\tContext: ctx,\n\t}\n}", "id": 6012, "concepts": ["context package usage", "function definition", "function parameters", "function return values"], "_raw_llm_output": "context package usage, function definition, function parameters, function return values"}
{"seed": "// NewTokenLT applies the LT predicate on the \"new_token\" field.\nfunc NewTokenLT(v string) predicate.User {\n\treturn predicate.User(sql.FieldLT(FieldNewToken, v))\n}", "id": 6014, "concepts": ["struct field access", "predicate.User", "sql.FieldLT"], "_raw_llm_output": "struct field access, predicate.User, sql.FieldLT"}
{"seed": "// NewContext creates a new context for eager execution.\n// options may be nil to use the default options.\nfunc NewContext(options *ContextOptions) (*Context, error) {\n\tstatus := newStatus()\n\tcOpt, err := options.c()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer C.TFE_DeleteContextOptions(cOpt)\n\tcContext := C.TFE_NewContext(cOpt, status.c)\n\tif err := status.Err(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tc := &Context{c: cContext}\n\truntime.SetFinalizer(c, (*Context).finalizer)\n\treturn c, nil\n}", "id": 6054, "concepts": ["error handling (runtime.SetFinalizer)", "error handling (runtime.SetFinalizer)", "error handling (runtime.SetFinalizer)", "error handling (runtime.SetFinalizer)", "error handling (runtime.SetFinalizer)", "error handling (runtime.SetFinalizer)", "error handling (runtime.SetFinalizer)", "error handling (runtime.SetFinalizer)", "error handling (runtime.SetFinalizer)", "error handling (runtime.SetFinalizer)", "error handling (runtime.SetFinalizer)", "error handling (runtime.SetFinalizer)", "error handling (runtime.SetFinalizer)", "error handling (runtime.SetFinalizer)", "error handling (runtime.SetFinalizer)", "error handling (runtime.SetFinalizer)", "error handling (runtime.SetFinalizer)", "error handling (runtime.SetFinalizer)", "error handling (runtime.SetFinalizer)", "error handling (runtime.SetFinalizer)", "error handling (runtime.SetFinalizer)", "error handling (runtime.SetFinalizer)", "error handling (runtime.SetFinalizer)", "error handling (runtime.SetFinalizer)", "error handling (runtime.SetFinalizer)", "error handling (runtime.SetFinalizer)", "error handling (runtime.SetFinalizer)", "error handling (runtime.SetFinalizer)", "error handling ("], "_raw_llm_output": "error handling (runtime.SetFinalizer), error handling (runtime.SetFinalizer), error handling (runtime.SetFinalizer), error handling (runtime.SetFinalizer), error handling (runtime.SetFinalizer), error handling (runtime.SetFinalizer), error handling (runtime.SetFinalizer), error handling (runtime.SetFinalizer), error handling (runtime.SetFinalizer), error handling (runtime.SetFinalizer), error handling (runtime.SetFinalizer), error handling (runtime.SetFinalizer), error handling (runtime.SetFinalizer), error handling (runtime.SetFinalizer), error handling (runtime.SetFinalizer), error handling (runtime.SetFinalizer), error handling (runtime.SetFinalizer), error handling (runtime.SetFinalizer), error handling (runtime.SetFinalizer), error handling (runtime.SetFinalizer), error handling (runtime.SetFinalizer), error handling (runtime.SetFinalizer), error handling (runtime.SetFinalizer), error handling (runtime.SetFinalizer), error handling (runtime.SetFinalizer), error handling (runtime.SetFinalizer), error handling (runtime.SetFinalizer), error handling (runtime.SetFinalizer), error handling ("}
{"seed": "// NewActivity returns a new Activity instance.\n// The caller is responsible for closing a.\n// Returned Activity instance must be closed when the test is finished.\nfunc NewActivity(a *ARC, pkgName, activityName string) (*Activity, error) {\n\tdisp, err := NewDisplay(a, DefaultDisplayID)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"could not create a new Display\")\n\t}\n\treturn &Activity{\n\t\ta:            a,\n\t\tpkgName:      pkgName,\n\t\tactivityName: activityName,\n\t\tdisp:         disp,\n\t}, nil\n}", "id": 6067, "concepts": ["error handling (errors.Wrap)", "error wrapping", "error handling (errors.Is)", "error handling (errors.As)", "error handling (errors.Unwrap)", "error handling (errors.Cause)", "error handling (errors.Errorf)", "error handling (errors.New)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling"], "_raw_llm_output": "error handling (errors.Wrap), error wrapping, error handling (errors.Is), error handling (errors.As), error handling (errors.Unwrap), error handling (errors.Cause), error handling (errors.Errorf), error handling (errors.New), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling"}
{"seed": "// matchesGloblist is a simple function which tries an item against a\n// slice of globs. It returns true if any of them match.\nfunc matchesGloblist(item string, list []glob.Glob) bool {\n\tfor _, glob := range list {\n\t\tif glob.Match(item) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}", "id": 6075, "concepts": ["glob matching", "glob package usage"], "_raw_llm_output": "glob matching, glob package usage"}
{"seed": "// SocialUserIDGTE applies the GTE predicate on the \"social_user_id\" field.\nfunc SocialUserIDGTE(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.GTE(s.C(FieldSocialUserID), v))\n\t})\n}", "id": 6077, "concepts": ["sql package usage", "predicate definition", "predicate usage"], "_raw_llm_output": "sql package usage, predicate definition, predicate usage"}
{"seed": "// NewPostSecdefSearchParamsWithContext creates a new PostSecdefSearchParams object\n// with the default values initialized, and the ability to set a context for a request\nfunc NewPostSecdefSearchParamsWithContext(ctx context.Context) *PostSecdefSearchParams {\n\tvar ()\n\treturn &PostSecdefSearchParams{\n\n\t\tContext: ctx,\n\t}\n}", "id": 6094, "concepts": ["context package usage", "struct definition", "method definition", "method invocation"], "_raw_llm_output": "context package usage, struct definition, method definition, method invocation"}
{"seed": "// NewExtrasGraphsReadParamsWithHTTPClient creates a new ExtrasGraphsReadParams object\n// with the default values initialized, and the ability to set a custom HTTPClient for a request\nfunc NewExtrasGraphsReadParamsWithHTTPClient(client *http.Client) *ExtrasGraphsReadParams {\n\tvar ()\n\treturn &ExtrasGraphsReadParams{\n\t\tHTTPClient: client,\n\t}\n}", "id": 6098, "concepts": ["pointer", "struct", "method definition", "method invocation", "HTTPClient usage"], "_raw_llm_output": "pointer, struct, method definition, method invocation, HTTPClient usage"}
{"seed": "// NewQueryFirewallFieldsParams creates a new QueryFirewallFieldsParams object,\n// with the default timeout for this client.\n//\n// Default values are not hydrated, since defaults are normally applied by the API server side.\n//\n// To enforce default values in parameter, use SetDefaults or WithDefaults.\nfunc NewQueryFirewallFieldsParams() *QueryFirewallFieldsParams {\n\treturn &QueryFirewallFieldsParams{\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 6105, "concepts": ["default values", "timeout", "function definition"], "_raw_llm_output": "default values, timeout, function definition"}
{"seed": "// StringToInt creates a binding that connects a String data item to a Int.\n// Changes to the String will be parsed and pushed to the Int if the parse was successful, and setting\n// the Int update the String binding.\n//\n// Since: 2.0\nfunc StringToInt(str String) Int {\n\tv := &stringToInt{from: str}\n\tstr.AddListener(v)\n\treturn v\n}", "id": 6106, "concepts": ["binding", "listener", "anonymous function", "closure", "basic function definition"], "_raw_llm_output": "binding, listener, anonymous function, closure, basic function definition"}
{"seed": "// NewService creates a new subscriber list for ServiceHandlers.\nfunc NewService() *ServiceList {\n\treturn &ServiceList{}\n}", "id": 6111, "concepts": ["struct definition", "struct field definition", "struct initialization", "struct method definition"], "_raw_llm_output": "struct definition, struct field definition, struct initialization, struct method definition"}
{"seed": "// Cite represents the HTML element 'cite'.\n// For more information visit https://www.w3schools.com/tags/tag_cite.asp.\nfunc Cite(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"cite\", Attributes: attrs, Children: children}\n}", "id": 6115, "concepts": ["HTML generation", "HTML element definition", "HTML attribute definition", "HTML element children definition"], "_raw_llm_output": "HTML generation, HTML element definition, HTML attribute definition, HTML element children definition"}
{"seed": "// NewNameLT applies the LT predicate on the \"new_name\" field.\nfunc NewNameLT(v string) predicate.User {\n\treturn predicate.User(sql.FieldLT(FieldNewName, v))\n}", "id": 6118, "concepts": ["predicate.User", "sql.FieldLT"], "_raw_llm_output": "predicate.User, sql.FieldLT"}
{"seed": "// BulkCreditSamedayIn applies the In predicate on the \"bulkCreditSameday\" field.\nfunc BulkCreditSamedayIn(vs ...float64) predicate.Bulk {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.Bulk(func(s *sql.Selector) {\n\t\t// if not arguments were provided, append the FALSE constants,\n\t\t// since we can't apply \"IN ()\". This will make this predicate falsy.\n\t\tif len(v) == 0 {\n\t\t\ts.Where(sql.False())\n\t\t\treturn\n\t\t}\n\t\ts.Where(sql.In(s.C(FieldBulkCreditSameday), v...))\n\t})\n}", "id": 6126, "concepts": ["sql.Selector", "sql.In", "sql.False", "sql.C", "sql.Where", "sql.Bulk", "sql.Predicate", "sql.Selector.C", "sql.Selector.Where", "sql.Selector.Where.sql.In", "sql.Selector.Where.sql.False", "sql.Selector.Where.sql.Bulk", "sql.Selector.Where.sql.Predicate", "sql.Selector.Where.sql.Predicate.sql.In", "sql.Selector.Where.sql.Predicate.sql.Bulk", "sql.Selector.Where.sql.Predicate.sql.Bulk.sql.Selector.C", "sql.Selector.Where.sql.Predicate.sql.Bulk.sql.Selector.Where", "sql.Selector.Where.sql.Predicate.sql.Bulk.sql.Selector.Where.sql.In", "sql.Selector.Where.sql.Predicate.sql.Bulk.sql.Selector.Where.sql.False", "sql.Selector.Where.sql.Predicate.sql.Bulk.sql.Selector.Where.sql.False.sql.Selector.C", "sql.Selector.Where.sql.Predicate.sql.Bulk.sql.Selector.Where.sql.False.sql.Selector.Where"], "_raw_llm_output": "sql.Selector, sql.In, sql.False, sql.C, sql.Where, sql.Bulk, sql.Predicate, sql.Selector.C, sql.Selector.Where, sql.Selector.Where.sql.In, sql.Selector.Where.sql.False, sql.Selector.Where.sql.Bulk, sql.Selector.Where.sql.Predicate, sql.Selector.Where.sql.Predicate.sql.In, sql.Selector.Where.sql.Predicate.sql.Bulk, sql.Selector.Where.sql.Predicate.sql.Bulk.sql.Selector.C, sql.Selector.Where.sql.Predicate.sql.Bulk.sql.Selector.Where, sql.Selector.Where.sql.Predicate.sql.Bulk.sql.Selector.Where.sql.In, sql.Selector.Where.sql.Predicate.sql.Bulk.sql.Selector.Where.sql.False, sql.Selector.Where.sql.Predicate.sql.Bulk.sql.Selector.Where.sql.False.sql.Selector.C, sql.Selector.Where.sql.Predicate.sql.Bulk.sql.Selector.Where.sql.False.sql.Selector.Where"}
{"seed": "// Ruby_ is a convenience wrapper for Ruby without the attrs argument.\nfunc Ruby_(children ...HTML) HTML {\n  return Ruby(nil, children...)\n}", "id": 6133, "concepts": ["basic function definition", "variadic function definition", "function call", "HTML"], "_raw_llm_output": "basic function definition, variadic function definition, function call, HTML"}
{"seed": "// MaxCallRecvMsgSize is the client-side response receive limit.\n// If 0, it defaults to \"math.MaxInt32\", because range response can\n// easily exceed request send limits.\n// Make sure that \"MaxCallRecvMsgSize\" >= server-side default send/recv limit.\n// (\"--max-request-bytes\" flag to etcd or \"embed.Config.MaxRequestBytes\").\nfunc MaxCallRecvMsgSize(v int) Configer {\n\treturn func(c *clientv3.Config) {\n\t\tc.MaxCallRecvMsgSize = v\n\t}\n}", "id": 6136, "concepts": ["client-side response receive limit", "MaxCallRecvMsgSize", "configuration", "clientv3 package usage"], "_raw_llm_output": "client-side response receive limit, MaxCallRecvMsgSize, configuration, clientv3 package usage"}
{"seed": "// Creates a logger with values from http Request. The intended use is like\n// the following in the case of GIN:\n// ...\n//    r.GET(\"...\", func(c *gin.Context) {\n//        routeHandler(c, NewLogger(c.Request, ctx))\n//    }\n// ...\n//\n// func routeHandler(c *gin.Context, log *log.Logger) {\n//   // no changes to the use of log from before.\n//   ...\n// }\nfunc NewLogger(r *http.Request, ctx *logx.LogHandler) *log.Logger {\n\tvar b []byte\n\tif r.Body != nil && r.GetBody != nil {\n\t\tbody, err := r.GetBody()\n\t\tif err == nil {\n\t\t\t_, _ = body.Read(b)\n\t\t}\n\t}\n\n\tw := &Writer{\n\t\tctx: ctx,\n\t\tContext: Context{\n\t\t\tMethod:  r.Method,\n\t\t\tPath:    r.URL.Path,\n\t\t\tIP:      r.RemoteAddr,\n\t\t\tBody:    b,\n\t\t\tHeaders: r.Header,\n\t\t},\n\t}\n\treturn log.New(w, \"\", 0)\n}", "id": 6137, "concepts": ["http.Request", "http.ResponseWriter", "http.GetBody", "*http.Request", "*http.ResponseWriter", "*http.Request", "*http.ResponseWriter", "*http.Request", "*http.ResponseWriter", "*http.Request", "*http.ResponseWriter", "*http.Request", "*http.ResponseWriter", "*http.Request", "*http.ResponseWriter", "*http.Request", "*http.ResponseWriter", "*http.Request", "*http.ResponseWriter", "*http.Request", "*http.ResponseWriter", "*http.Request", "*http.ResponseWriter", "*http.Request", "*http.ResponseWriter", "*http.Request", "*http.ResponseWriter", "*http.Request", "*http.ResponseWriter", "*http.Request", "*http.ResponseWriter", "*http.Request", "*http.ResponseWriter", "*http.Request", "*http.ResponseWriter", "*http.Request", "*http.ResponseWriter", "*http.Request", "*http.ResponseWriter", "*http.Request", "*http.ResponseWriter", "*http.Request", "*http.ResponseWriter", "*http.Request", "*http.ResponseWriter", "*http.Request", "*http.ResponseWriter", "*http.Request", "*http.ResponseWriter", "*http.Request", "*http.ResponseWriter", "*http"], "_raw_llm_output": "http.Request, http.ResponseWriter, http.GetBody, *http.Request, *http.ResponseWriter, *http.Request, *http.ResponseWriter, *http.Request, *http.ResponseWriter, *http.Request, *http.ResponseWriter, *http.Request, *http.ResponseWriter, *http.Request, *http.ResponseWriter, *http.Request, *http.ResponseWriter, *http.Request, *http.ResponseWriter, *http.Request, *http.ResponseWriter, *http.Request, *http.ResponseWriter, *http.Request, *http.ResponseWriter, *http.Request, *http.ResponseWriter, *http.Request, *http.ResponseWriter, *http.Request, *http.ResponseWriter, *http.Request, *http.ResponseWriter, *http.Request, *http.ResponseWriter, *http.Request, *http.ResponseWriter, *http.Request, *http.ResponseWriter, *http.Request, *http.ResponseWriter, *http.Request, *http.ResponseWriter, *http.Request, *http.ResponseWriter, *http.Request, *http.ResponseWriter, *http.Request, *http.ResponseWriter, *http.Request, *http.ResponseWriter, *http"}
{"seed": "// NewGetSubscriptionsParamsWithTimeout creates a new GetSubscriptionsParams object\n// with the default values initialized, and the ability to set a timeout on a request\nfunc NewGetSubscriptionsParamsWithTimeout(timeout time.Duration) *GetSubscriptionsParams {\n\tvar ()\n\treturn &GetSubscriptionsParams{\n\n\t\ttimeout: timeout,\n\t}\n}", "id": 6146, "concepts": ["struct definition", "timeout handling", "method definition"], "_raw_llm_output": "struct definition, timeout handling, method definition"}
{"seed": "// DeserializeThrift takes a byte slice and attempts to write it into the\n// given thrift struct using the thrift binary protocol. This is a temporary\n// measure before frames can be forwarded directly past the endpoint to the proper\n// destinaiton.\nfunc DeserializeThrift(ctx context.Context, b []byte, s athrift.TStruct) error {\n\treader := bytes.NewReader(b)\n\ttransport := athrift.NewStreamTransportR(reader)\n\treturn s.Read(ctx, athrift.NewTBinaryProtocolTransport(transport))\n}", "id": 6153, "concepts": ["byte slice handling", "binary protocol", "thrift binary protocol", "context", "error handling"], "_raw_llm_output": "byte slice handling, binary protocol, thrift binary protocol, context, error handling"}
{"seed": "// DefaultExprsIsNil applies the IsNil predicate on the \"default_exprs\" field.\nfunc DefaultExprsIsNil() predicate.User {\n\treturn predicate.User(sql.FieldIsNull(FieldDefaultExprs))\n}", "id": 6155, "concepts": ["sql.FieldIsNull", "sql.FieldIsNotNil", "sql.FieldIsZero", "sql.FieldIsNotNil", "sql.FieldIsZero", "sql.FieldIsNotNil", "sql.FieldIsZero", "sql.FieldIsZero", "sql.FieldIsZero", "sql.FieldIsZero", "sql.FieldIsZero", "sql.FieldIsZero", "sql.FieldIsZero", "sql.FieldIsZero", "sql.FieldIsZero", "sql.FieldIsZero", "sql.FieldIsZero", "sql.FieldIsZero", "sql.FieldIsZero", "sql.FieldIsZero", "sql.FieldIsZero", "sql.FieldIsZero", "sql.FieldIsZero", "sql.FieldIsZero", "sql.FieldIsZero", "sql.FieldIsZero", "sql.FieldIsZero", "sql.FieldIsZero", "sql.FieldIsZero", "sql.FieldIsZero", "sql.FieldIsZero", "sql.FieldIsZero", "sql.FieldIsZero", "sql.FieldIsZero", "sql.FieldIsZero", "sql.FieldIsZero", "sql.FieldIsZero", "sql.FieldIsZero", "sql.FieldIsZero", "sql.FieldIsZero", "sql.FieldIsZero", "sql.FieldIsZero", "sql.FieldIs"], "_raw_llm_output": "sql.FieldIsNull, sql.FieldIsNotNil, sql.FieldIsZero, sql.FieldIsNotNil, sql.FieldIsZero, sql.FieldIsNotNil, sql.FieldIsZero, sql.FieldIsZero, sql.FieldIsZero, sql.FieldIsZero, sql.FieldIsZero, sql.FieldIsZero, sql.FieldIsZero, sql.FieldIsZero, sql.FieldIsZero, sql.FieldIsZero, sql.FieldIsZero, sql.FieldIsZero, sql.FieldIsZero, sql.FieldIsZero, sql.FieldIsZero, sql.FieldIsZero, sql.FieldIsZero, sql.FieldIsZero, sql.FieldIsZero, sql.FieldIsZero, sql.FieldIsZero, sql.FieldIsZero, sql.FieldIsZero, sql.FieldIsZero, sql.FieldIsZero, sql.FieldIsZero, sql.FieldIsZero, sql.FieldIsZero, sql.FieldIsZero, sql.FieldIsZero, sql.FieldIsZero, sql.FieldIsZero, sql.FieldIsZero, sql.FieldIsZero, sql.FieldIsZero, sql.FieldIsZero, sql.FieldIs"}
{"seed": "// NewDeleteRolesParamsWithContext creates a new DeleteRolesParams object\n// with the default values initialized, and the ability to set a context for a request\nfunc NewDeleteRolesParamsWithContext(ctx context.Context) *DeleteRolesParams {\n\tvar ()\n\treturn &DeleteRolesParams{\n\n\t\tContext: ctx,\n\t}\n}", "id": 6166, "concepts": ["context package usage", "function definition", "struct definition"], "_raw_llm_output": "context package usage, function definition, struct definition"}
{"seed": "// validateParameters returns an error if not all required parameters are provided in \"parameters\".\n// Unknown parameters (neither required nor optional) result in an error.\nfunc validateParameters(task Task, parameters map[string]string) error {\n\tvalidParams := make(map[string]bool)\n\tvar missingParams []string\n\tfor _, reqParam := range task.RequiredParameters() {\n\t\tif _, ok := parameters[reqParam]; ok {\n\t\t\tvalidParams[reqParam] = true\n\t\t} else {\n\t\t\tmissingParams = append(missingParams, reqParam)\n\t\t}\n\t}\n\tif len(missingParams) > 0 {\n\t\treturn fmt.Errorf(\"required parameters are missing: %v\", missingParams)\n\t}\n\tfor _, optParam := range task.OptionalParameters() {\n\t\tvalidParams[optParam] = true\n\t}\n\tfor param := range parameters {\n\t\tif !validParams[param] {\n\t\t\treturn fmt.Errorf(\"parameter %v is not allowed. Allowed required parameters: %v optional parameters: %v\",\n\t\t\t\tparam, task.RequiredParameters(), task.OptionalParameters())\n\t\t}\n\t}\n\treturn nil\n}", "id": 6188, "concepts": ["map iteration (range loop)", "map keys", "map values", "map key existence check", "error handling (fmt.Errorf)", "basic function definition"], "_raw_llm_output": "map iteration (range loop), map keys, map values, map key existence check, error handling (fmt.Errorf), basic function definition"}
{"seed": "// NewToken applies equality check predicate on the \"new_token\" field. It's identical to NewTokenEQ.\nfunc NewToken(v string) predicate.User {\n\treturn predicate.User(sql.FieldEQ(FieldNewToken, v))\n}", "id": 6209, "concepts": ["sql package usage", "sql.FieldEQ", "predicate.User"], "_raw_llm_output": "sql package usage, sql.FieldEQ, predicate.User"}
{"seed": "// NewFetchIntegrationFormParamsWithTimeout creates a new FetchIntegrationFormParams object\n// with the ability to set a timeout on a request.\nfunc NewFetchIntegrationFormParamsWithTimeout(timeout time.Duration) *FetchIntegrationFormParams {\n\treturn &FetchIntegrationFormParams{\n\t\ttimeout: timeout,\n\t}\n}", "id": 6213, "concepts": ["function definition", "timeout usage"], "_raw_llm_output": "function definition, timeout usage"}
{"seed": "// NewPGClient creates a new PGClient out of a '*sql.DB' or a\n// custom wrapper around a db connection.\n//\n// If you provide your own wrapper around a '*sql.DB' for logging or\n// custom tracing, you MUST forward all calls to an underlying '*sql.DB'\n// member of your wrapper.\n//\n// If the DBConn passed into NewPGClient implements an ErrorConverter\n// method which returns a func(error) error, the result of calling the\n// ErrorConverter method will be called on every error that the generated\n// code returns right before the error is returned. If ErrorConverter\n// returns nil or is not present, it will default to the identity function.\nfunc NewPGClient(conn pggen.DBConn) *PGClient {\n\tclient := PGClient{\n\t\ttopLevelDB: conn,\n\t}\n\tclient.impl = pgClientImpl{\n\t\tdb:     conn,\n\t\tclient: &client,\n\t}\n\n\t// extract the optional error converter routine\n\tec, ok := conn.(interface {\n\t\tErrorConverter() func(error) error\n\t})\n\tif ok {\n\t\tclient.errorConverter = ec.ErrorConverter()\n\t}\n\tif client.errorConverter == nil {\n\t\tclient.errorConverter = func(err error) error { return err }\n\t}\n\n\treturn &client\n}", "id": 6225, "concepts": ["interface", "method overriding", "error handling", "method composition"], "_raw_llm_output": "interface, method overriding, error handling, method composition"}
{"seed": "// isV2OrHigherIncompat reports if version has a v2+ major version and is \"+incompatible\" (e.g., \"2.0.0+incompatible\")\r\nfunc isV2OrHigherIncompat(version string) bool {\r\n\tif !semver.IsValid(version) {\r\n\t\treturn false\r\n\t}\r\n\tmajor := semver.Major(version)\r\n\t// minor nuance: here we are purposefully attempting to treat v2.0.0-alpha as a \"v2\" release\r\n\treturn major != \"v0\" && major != \"v1\" && semver.Build(version) == \"+incompatible\"\r\n}", "id": 6248, "concepts": ["semver package usage", "semver.Build", "semver.Major", "semver.IsValid"], "_raw_llm_output": "semver package usage, semver.Build, semver.Major, semver.IsValid"}
{"seed": "// BulkCreditSamedayFeeGTE applies the GTE predicate on the \"bulkCreditSamedayFee\" field.\nfunc BulkCreditSamedayFeeGTE(v float64) predicate.Bulk {\n\treturn predicate.Bulk(func(s *sql.Selector) {\n\t\ts.Where(sql.GTE(s.C(FieldBulkCreditSamedayFee), v))\n\t})\n}", "id": 6255, "concepts": ["sql package usage", "sql.Selector", "sql.C", "sql.GTE", "predicate.Bulk", "anonymous function", "standard library usage"], "_raw_llm_output": "sql package usage, sql.Selector, sql.C, sql.GTE, predicate.Bulk, anonymous function, standard library usage"}
{"seed": "// stateGNeg is the state after reading `G-` during a number.\nfunc stateGNeg(s *scanner, c byte) int {\n\tif c == '0' {\n\t\ts.step = stateG0\n\t\treturn scanContinue\n\t}\n\tif '1' <= c && c <= '9' {\n\t\ts.step = stateG1\n\t\treturn scanContinue\n\t}\n\treturn s.error(c, \"in numeric literal\")\n}", "id": 6263, "concepts": ["state machine", "state transition", "error handling"], "_raw_llm_output": "state machine, state transition, error handling"}
{"seed": "// NewVIDPIDMatcher returns a SerialPortMatcher that returns true if the usb vendor and product IDs match.\nfunc NewVIDPIDMatcher(vid, pid string) SerialPortMatcher {\n\treturn func(sp SerialPort) bool {\n\t\treturn sp.VID == vid && sp.PID == pid\n\t}\n}", "id": 6282, "concepts": ["function definition", "function composition", "function return", "function parameter", "function call"], "_raw_llm_output": "function definition, function composition, function return, function parameter, function call"}
{"seed": "// newFollower converts projected type Follower to service type Follower.\nfunc newFollower(vres *followingviews.FollowerView) *Follower {\n\tres := &Follower{}\n\tif vres.ID != nil {\n\t\tres.ID = *vres.ID\n\t}\n\tif vres.Name != nil {\n\t\tres.Name = *vres.Name\n\t}\n\tif vres.Avatar != nil {\n\t\tres.Avatar = transformFollowingviewsAvatarViewToAvatar(vres.Avatar)\n\t}\n\treturn res\n}", "id": 6296, "concepts": ["type conversion", "pointer handling"], "_raw_llm_output": "type conversion, pointer handling"}
{"seed": "// IsFalseWithReason returns `true` if the condition with the given condition type is found among the conditions\n// and its status is set to `false` with the given reason.\nfunc IsFalseWithReason(conditions []toolchainv1alpha1.Condition, conditionType toolchainv1alpha1.ConditionType, reason string) bool {\n\tc, found := FindConditionByType(conditions, conditionType)\n\treturn found && c.Status == apiv1.ConditionFalse && c.Reason == reason\n}", "id": 6304, "concepts": ["slice iteration (range loop)", "struct iteration (for range loop)", "struct field access", "function definition", "function parameter"], "_raw_llm_output": "slice iteration (range loop), struct iteration (for range loop), struct field access, function definition, function parameter"}
{"seed": "// Parse returns the hash whose standard format (possibly absent the brackets) is the value of str.\nfunc Parse(str string) (hash Hash, err error) {\n\terr = errHashFormat\n\tif len(str) != 2*Size {\n\t\treturn\n\t}\n\tfor i := range hash {\n\t\ta := unhex(str[2*i])\n\t\tb := unhex(str[2*i+1])\n\t\tif a == 255 || b == 255 {\n\t\t\treturn\n\t\t}\n\t\thash[i] = a<<4 | b\n\t}\n\terr = nil\n\treturn\n}", "id": 6307, "concepts": ["string manipulation", "rune handling", "character comparison", "error handling", "standard library usage"], "_raw_llm_output": "string manipulation, rune handling, character comparison, error handling, standard library usage"}
{"seed": "// MapInt64Uint32Ptr takes two inputs -\n// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list\nfunc MapInt64Uint32Ptr(f func(*int64) *uint32, list []*int64) []*uint32 {\n\tif f == nil {\n\t\treturn []*uint32{}\n\t}\n\tnewList := make([]*uint32, len(list))\n\tfor i, v := range list {\n\t\tnewList[i] = f(v)\n\t}\n\treturn newList\n}", "id": 6310, "concepts": ["function definition", "function pointer", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", ""], "_raw_llm_output": "function definition, function pointer, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition,"}
{"seed": "// EncodeOrgName converts org to the tsdb internal serialization that may be used\n// as a prefix when searching for keys matching a specific organization.\nfunc EncodeOrgName(org platform.ID) [8]byte {\n\tvar orgBytes [8]byte\n\tbinary.BigEndian.PutUint64(orgBytes[0:8], uint64(org))\n\treturn orgBytes\n}", "id": 6315, "concepts": ["byte array manipulation", "binary.BigEndian", "byte array conversion", "byte array manipulation"], "_raw_llm_output": "byte array manipulation, binary.BigEndian, byte array conversion, byte array manipulation"}
{"seed": "// PresenceFunc returns an option that matches on presence stanzas.\n// For more information see Presence.\nfunc PresenceFunc(typ stanza.PresenceType, payload xml.Name, h PresenceHandlerFunc) Option {\n\treturn Presence(typ, payload, h)\n}", "id": 6344, "concepts": ["xml.Name", "stanza.PresenceType", "xml.Unmarshaler", "xml.UnmarshalerFunc", "xml.Unmarshaler interface", "xml.UnmarshalerFunc interface", "xml.UnmarshalerFunc type", "xml.UnmarshalerFunc type", "xml.UnmarshalerFunc type", "xml.UnmarshalerFunc type", "xml.UnmarshalerFunc type", "xml.UnmarshalerFunc type", "xml.UnmarshalerFunc type", "xml.UnmarshalerFunc type", "xml.UnmarshalerFunc type", "xml.UnmarshalerFunc type", "xml.UnmarshalerFunc type", "xml.UnmarshalerFunc type", "xml.UnmarshalerFunc type", "xml.UnmarshalerFunc type", "xml.UnmarshalerFunc type", "xml.UnmarshalerFunc type", "xml.UnmarshalerFunc type", "xml.UnmarshalerFunc type", "xml.UnmarshalerFunc type", "xml.UnmarshalerFunc type", "xml.UnmarshalerFunc type", "xml.UnmarshalerFunc type", "xml.UnmarshalerFunc type", "xml.UnmarshalerFunc type", "xml.UnmarshalerFunc type", "xml.UnmarshalerFunc type", "xml.UnmarshalerFunc type", "xml.UnmarshalerFunc type", "xml.UnmarshalerFunc type", "xml.UnmarshalerFunc type", "xml.UnmarshalerFunc type", "xml.Unmarshaler"], "_raw_llm_output": "xml.Name, stanza.PresenceType, xml.Unmarshaler, xml.UnmarshalerFunc, xml.Unmarshaler interface, xml.UnmarshalerFunc interface, xml.UnmarshalerFunc type, xml.UnmarshalerFunc type, xml.UnmarshalerFunc type, xml.UnmarshalerFunc type, xml.UnmarshalerFunc type, xml.UnmarshalerFunc type, xml.UnmarshalerFunc type, xml.UnmarshalerFunc type, xml.UnmarshalerFunc type, xml.UnmarshalerFunc type, xml.UnmarshalerFunc type, xml.UnmarshalerFunc type, xml.UnmarshalerFunc type, xml.UnmarshalerFunc type, xml.UnmarshalerFunc type, xml.UnmarshalerFunc type, xml.UnmarshalerFunc type, xml.UnmarshalerFunc type, xml.UnmarshalerFunc type, xml.UnmarshalerFunc type, xml.UnmarshalerFunc type, xml.UnmarshalerFunc type, xml.UnmarshalerFunc type, xml.UnmarshalerFunc type, xml.UnmarshalerFunc type, xml.UnmarshalerFunc type, xml.UnmarshalerFunc type, xml.UnmarshalerFunc type, xml.UnmarshalerFunc type, xml.UnmarshalerFunc type, xml.UnmarshalerFunc type, xml.Unmarshaler"}
{"seed": "// NewEntitlementManagementConnectedOrganizationsConnectedOrganizationItemRequestBuilder instantiates a new ConnectedOrganizationItemRequestBuilder and sets the default values.\nfunc NewEntitlementManagementConnectedOrganizationsConnectedOrganizationItemRequestBuilder(rawUrl string, requestAdapter i2ae4187f7daee263371cb1c977df639813ab50ffa529013b7437480d1ec0158f.RequestAdapter)(*EntitlementManagementConnectedOrganizationsConnectedOrganizationItemRequestBuilder) {\n    urlParams := make(map[string]string)\n    urlParams[\"request-raw-url\"] = rawUrl\n    return NewEntitlementManagementConnectedOrganizationsConnectedOrganizationItemRequestBuilderInternal(urlParams, requestAdapter)\n}", "id": 6347, "concepts": ["request builder", "request builder instantiation", "request adapter", "request adapter instantiation"], "_raw_llm_output": "request builder, request builder instantiation, request adapter, request adapter instantiation"}
{"seed": "// BulkCreditSamedayNotNil applies the NotNil predicate on the \"bulkCreditSameday\" field.\nfunc BulkCreditSamedayNotNil() predicate.Bulk {\n\treturn predicate.Bulk(func(s *sql.Selector) {\n\t\ts.Where(sql.NotNull(s.C(FieldBulkCreditSameday)))\n\t})\n}", "id": 6350, "concepts": ["sql.Selector", "sql.NotNull", "sql.C", "sql.Where", "sql.Bulk", "sql.FieldBulkCreditSameday", "predicate.Bulk", "predicate.Bulk(func(s *sql.Selector))", "sql.Selector.Where", "sql.Selector.C", "sql.Selector.NotNull", "sql.Selector.Bulk"], "_raw_llm_output": "sql.Selector, sql.NotNull, sql.C, sql.Where, sql.Bulk, sql.FieldBulkCreditSameday, predicate.Bulk, predicate.Bulk(func(s *sql.Selector)), sql.Selector.Where, sql.Selector.C, sql.Selector.NotNull, sql.Selector.Bulk"}
{"seed": "// Md5 returns the MD5 checksum string of the data.\nfunc Md5(b []byte) string {\n\tchecksum := md5.Sum(b)\n\treturn hex.EncodeToString(checksum[:])\n}", "id": 6353, "concepts": ["md5 checksum", "hex encoding", "byte slice manipulation"], "_raw_llm_output": "md5 checksum, hex encoding, byte slice manipulation"}
{"seed": "// Figure represents the HTML element 'figure'.\n// For more information visit https://www.w3schools.com/tags/tag_figure.asp.\nfunc Figure(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"figure\", Attributes: attrs, Children: children}\n}", "id": 6354, "concepts": ["HTML generation", "HTML tree", "HTML element definition"], "_raw_llm_output": "HTML generation, HTML tree, HTML element definition"}
{"seed": "// confirmed checks whether a transaction at height txHeight has met minconf\n// confirmations for a blockchain at height curHeight.\nfunc confirmed(minconf, txHeight, curHeight int32) bool {\n\treturn confirms(txHeight, curHeight) >= minconf\n}", "id": 6361, "concepts": ["integer comparison", "integer addition", "integer subtraction", "integer multiplication", "integer division"], "_raw_llm_output": "integer comparison, integer addition, integer subtraction, integer multiplication, integer division"}
{"seed": "// WithMaxClockSkew specifies the allowed time discrepancy between the client and the server.\n// Fractions of a second are discarded. Must not be negative.\nfunc WithMaxClockSkew(maxClockSkew time.Duration) JwtHandlerConfigOption {\n\treturn func(cache *JwtAuthenticationHandler) error {\n\t\tif maxClockSkew < 0 {\n\t\t\treturn fmt.Errorf(\"max clock skew must not be a negative duration\")\n\t\t}\n\t\tcache.maxClockSkew = int64(maxClockSkew.Seconds())\n\t\treturn nil\n\t}\n}", "id": 6368, "concepts": ["time package usage", "time.Duration", "time.Duration.Seconds()", "time.Duration.Nanoseconds()", "time.Duration.Milliseconds()", "time.Duration.Microseconds()", "time.Duration.Nanoseconds()", "time.Duration.Nanoseconds()", "time.Duration.Nanoseconds()", "time.Duration.Nanoseconds()", "time.Duration.Nanoseconds()", "time.Duration.Nanoseconds()", "time.Duration.Nanoseconds()", "time.Duration.Nanoseconds()", "time.Duration.Nanoseconds()", "time.Duration.Nanoseconds()", "time.Duration.Nanoseconds()", "time.Duration.Nanoseconds()", "time.Duration.Nanoseconds()", "time.Duration.Nanoseconds()", "time.Duration.Nanoseconds()", "time.Duration.Nanoseconds()", "time.Duration.Nanoseconds()", "time.Duration.Nanoseconds()", "time.Duration.Nanoseconds()", "time.Duration.Nanoseconds()", "time.Duration.Nanoseconds()", "time.Duration.Nanoseconds()", "time.Duration.Nanoseconds()", "time.Duration.Nanoseconds()", "time.Duration.Nanoseconds()", "time.Duration.Nanoseconds()", "time.Duration.Nanoseconds()", "time.Duration.Nanoseconds()", "time.Duration.Nanoseconds()", "time.Duration.Nanoseconds()", "time.Duration.Nanoseconds()", "time.Duration."], "_raw_llm_output": "time package usage, time.Duration, time.Duration.Seconds(), time.Duration.Nanoseconds(), time.Duration.Milliseconds(), time.Duration.Microseconds(), time.Duration.Nanoseconds(), time.Duration.Nanoseconds(), time.Duration.Nanoseconds(), time.Duration.Nanoseconds(), time.Duration.Nanoseconds(), time.Duration.Nanoseconds(), time.Duration.Nanoseconds(), time.Duration.Nanoseconds(), time.Duration.Nanoseconds(), time.Duration.Nanoseconds(), time.Duration.Nanoseconds(), time.Duration.Nanoseconds(), time.Duration.Nanoseconds(), time.Duration.Nanoseconds(), time.Duration.Nanoseconds(), time.Duration.Nanoseconds(), time.Duration.Nanoseconds(), time.Duration.Nanoseconds(), time.Duration.Nanoseconds(), time.Duration.Nanoseconds(), time.Duration.Nanoseconds(), time.Duration.Nanoseconds(), time.Duration.Nanoseconds(), time.Duration.Nanoseconds(), time.Duration.Nanoseconds(), time.Duration.Nanoseconds(), time.Duration.Nanoseconds(), time.Duration.Nanoseconds(), time.Duration.Nanoseconds(), time.Duration.Nanoseconds(), time.Duration.Nanoseconds(), time.Duration."}
{"seed": "// BulkCreditSamedayFeeIn applies the In predicate on the \"bulkCreditSamedayFee\" field.\nfunc BulkCreditSamedayFeeIn(vs ...float64) predicate.Bulk {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.Bulk(func(s *sql.Selector) {\n\t\t// if not arguments were provided, append the FALSE constants,\n\t\t// since we can't apply \"IN ()\". This will make this predicate falsy.\n\t\tif len(v) == 0 {\n\t\t\ts.Where(sql.False())\n\t\t\treturn\n\t\t}\n\t\ts.Where(sql.In(s.C(FieldBulkCreditSamedayFee), v...))\n\t})\n}", "id": 6374, "concepts": ["sql.Selector", "sql.In", "sql.False", "sql.C", "sql.Where", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In"], "_raw_llm_output": "sql.Selector, sql.In, sql.False, sql.C, sql.Where, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In"}
{"seed": "// NewPostback is called when a \"postback:[uuid]\" value is pushed to the\n// \"postbacks\" list on the Redis instance. This function creates a new Postback\n// struct and populates each field, then calls Postback.Listen() to listen for\n// data objects.\nfunc NewPostback(db *redis.Client, key string) {\n\tvar (\n\t\tp *Postback = &Postback{}\n\t\t// this will be the \"postback:[uuid]\" value\n\t\tvalue []byte\n\t\terr   error\n\t)\n\n\t// get the json object from the postback:[uuid] key in redis\n\tif value, err = db.Get(key).Bytes(); err != nil {\n\t\tlog.Print(err)\n\t\treturn\n\t}\n\n\t// delete the postback:[uuid] key from redis\n\tif err = db.Del(key).Err(); err != nil {\n\t\tlog.Print(err)\n\t\treturn\n\t}\n\n\t// unmarshal json object to p\n\tif err = json.Unmarshal(value, p); err != nil {\n\t\tlog.Print(err)\n\t\treturn\n\t}\n\n\t// make sure method field is valid, can add more if needed\n\tif p.Method != \"GET\" && p.Method != \"POST\" && p.Method != \"PUT\" {\n\t\tlog.Print(ErrInvalidMethod)\n\t\treturn\n\t}\n\n\t// parse the postback url for params\n\tif err = p.Parse(nil); err != nil {\n\t\tlog.Print(err)\n\t\treturn\n\t}\n\n\t// start listening for data objects on postback:[uuid]:data\n\tp.Listen(db, key+\":data\")\n}", "id": 6375, "concepts": ["redis", "JSON unmarshaling", "Redis key deletion", "Redis key creation", "Redis key value assignment", "Redis key value retrieval", "Redis key value deletion", "Redis key value comparison", "Redis key value assignment", "Redis key value retrieval", "Redis key value deletion", "Redis key value comparison", "Redis key value assignment", "Redis key value retrieval", "Redis key value deletion", "Redis key value comparison", "Redis key value assignment", "Redis key value retrieval", "Redis key value deletion", "Redis key value comparison", "Redis key value assignment", "Redis key value retrieval", "Redis key value deletion", "Redis key value comparison", "Redis key value assignment", "Redis key value retrieval", "Redis key value deletion", "Redis key value comparison", "Redis key value assignment", "Redis key value retrieval", "Redis key value deletion", "Redis key value comparison", "Redis key value assignment", "Redis key value retrieval", "Redis key value deletion", "Redis key value comparison", "Redis key value assignment", "Redis key value retrieval", "Redis key value deletion", "Redis key value comparison", "Redis key value assignment", "Redis key value retrieval", "Redis key value deletion", "Redis key value comparison", "Redis key value assignment", "Redis key value retrieval", "Redis key value deletion", "Redis key value comparison", "Redis key value assignment", "Redis key value retrieval", "Redis key value deletion", "Redis key value comparison", "Redis"], "_raw_llm_output": "redis, JSON unmarshaling, Redis key deletion, Redis key creation, Redis key value assignment, Redis key value retrieval, Redis key value deletion, Redis key value comparison, Redis key value assignment, Redis key value retrieval, Redis key value deletion, Redis key value comparison, Redis key value assignment, Redis key value retrieval, Redis key value deletion, Redis key value comparison, Redis key value assignment, Redis key value retrieval, Redis key value deletion, Redis key value comparison, Redis key value assignment, Redis key value retrieval, Redis key value deletion, Redis key value comparison, Redis key value assignment, Redis key value retrieval, Redis key value deletion, Redis key value comparison, Redis key value assignment, Redis key value retrieval, Redis key value deletion, Redis key value comparison, Redis key value assignment, Redis key value retrieval, Redis key value deletion, Redis key value comparison, Redis key value assignment, Redis key value retrieval, Redis key value deletion, Redis key value comparison, Redis key value assignment, Redis key value retrieval, Redis key value deletion, Redis key value comparison, Redis key value assignment, Redis key value retrieval, Redis key value deletion, Redis key value comparison, Redis key value assignment, Redis key value retrieval, Redis key value deletion, Redis key value comparison, Redis"}
{"seed": "// Converts a string with structure: %d-%d %s\n// to a Condition struct and returns it\nfunc ReadCondition(text string) Condition {\n    c := Condition{}\n    f := strings.Split(text, \" \")\n    c.letter = f[1]\n    minmax := strings.Split(f[0], \"-\")\n    min, _ := strconv.Atoi(minmax[0])\n    max, _ := strconv.Atoi(minmax[1])\n    c.min = min\n    c.max = max\n    return c\n}", "id": 6392, "concepts": ["string manipulation", "string conversion", "string splitting"], "_raw_llm_output": "string manipulation, string conversion, string splitting"}
{"seed": "// ParseTags converts a serialized tags list to map[string]string\nfunc ParseTags(in string) (map[string]string, error) {\n\tout := map[string]string{}\n\n\tfor _, entry := range strings.Split(in, \",\") {\n\t\tentry = strings.TrimSpace(entry)\n\t\tif entry == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tfields := strings.SplitN(entry, \":\", 2)\n\t\tif len(fields) < 2 {\n\t\t\treturn nil, fmt.Errorf(\"Invalid tag: %s\", entry)\n\t\t}\n\n\t\t_, ok := out[fields[0]]\n\t\tif ok {\n\t\t\treturn nil, fmt.Errorf(\"Duplicate tag: %s\", entry)\n\t\t}\n\n\t\tout[fields[0]] = fields[1]\n\t}\n\n\treturn out, nil\n}", "id": 6406, "concepts": ["string manipulation", "string splitting", "map iteration", "map insertion", "map lookup", "error handling"], "_raw_llm_output": "string manipulation, string splitting, map iteration, map insertion, map lookup, error handling"}
{"seed": "// SocialTypeLTE applies the LTE predicate on the \"social_type\" field.\nfunc SocialTypeLTE(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.LTE(s.C(FieldSocialType), v))\n\t})\n}", "id": 6429, "concepts": ["sql.Selector", "sql.C", "sql.LTE", "sql.Where", "predicate.User", "predicate.FieldSocialType"], "_raw_llm_output": "sql.Selector, sql.C, sql.LTE, sql.Where, predicate.User, predicate.FieldSocialType"}
{"seed": "// Not applies the not operator on the given predicate.\nfunc Not(p predicate.TradeCorrection) predicate.TradeCorrection {\n\treturn predicate.TradeCorrection(func(s *sql.Selector) {\n\t\tp(s.Not())\n\t})\n}", "id": 6430, "concepts": ["function composition", "predicate pattern"], "_raw_llm_output": "function composition, predicate pattern"}
{"seed": "// HeroRepeatGTE applies the GTE predicate on the \"hero_repeat\" field.\nfunc HeroRepeatGTE(v uint) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.GTE(s.C(FieldHeroRepeat), v))\n\t})\n}", "id": 6431, "concepts": ["sql.Selector", "sql.C", "sql.GTE", "sql.Where", "predicate.User"], "_raw_llm_output": "sql.Selector, sql.C, sql.GTE, sql.Where, predicate.User"}
{"seed": "// LatestHeroScoreNotIn applies the NotIn predicate on the \"latest_hero_score\" field.\nfunc LatestHeroScoreNotIn(vs ...int) predicate.User {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.User(func(s *sql.Selector) {\n\t\t// if not arguments were provided, append the FALSE constants,\n\t\t// since we can't apply \"IN ()\". This will make this predicate falsy.\n\t\tif len(vs) == 0 {\n\t\t\ts.Where(sql.False())\n\t\t\treturn\n\t\t}\n\t\ts.Where(sql.NotIn(s.C(FieldLatestHeroScore), v...))\n\t})\n}", "id": 6435, "concepts": ["sql.Selector", "sql.NotIn", "sql.False", "sql.C", "predicate.User", "basic function definition"], "_raw_llm_output": "sql.Selector, sql.NotIn, sql.False, sql.C, predicate.User, basic function definition"}
{"seed": "// NewTable returns a table with sectionctl standard formatting\nfunc NewTable(out io.Writer) (t *tablewriter.Table) {\n\tt = tablewriter.NewWriter(out)\n\tt.SetBorders(tablewriter.Border{Left: true, Top: false, Right: true, Bottom: false})\n\tt.SetCenterSeparator(\"|\")\n\tt.SetAlignment(tablewriter.ALIGN_LEFT)\n\treturn t\n}", "id": 6438, "concepts": ["tablewriter package usage", "table formatting"], "_raw_llm_output": "tablewriter package usage, table formatting"}
{"seed": "// AzureADLicenseTypePBasic returns a pointer to AzureADLicenseTypeVBasic\nfunc AzureADLicenseTypePBasic() *AzureADLicenseType {\n\tv := AzureADLicenseTypeVBasic\n\treturn &v\n}", "id": 6448, "concepts": ["pointer usage", "struct definition", "pointer dereference"], "_raw_llm_output": "pointer usage, struct definition, pointer dereference"}
{"seed": "// lookupTip looks up the object referenced by refname, and returns it\n// as a Commit object. If the reference does not exist, or if object is\n// not a commit, nil is returned. Other errors cannot be detected.\nfunc lookupTip(r *git.Repository, refname string) *git.Commit {\n\tref, err := r.LookupReference(refname)\n\tif err != nil {\n\t\treturn nil\n\t}\n\tcommit, err := lookupCommit(r, ref.Target())\n\tif err != nil {\n\t\treturn nil\n\t}\n\treturn commit\n}", "id": 6470, "concepts": ["git.Repository", "git.Commit", "git.Reference", "git.Object", "git.LookupReference", "git.LookupCommit", "git.Target", "git.Commit", "git.Object", "git.Object.Type", "git.Commit.Type"], "_raw_llm_output": "git.Repository, git.Commit, git.Reference, git.Object, git.LookupReference, git.LookupCommit, git.Target, git.Commit, git.Object, git.Object.Type, git.Commit.Type"}
{"seed": "// WithMarkFailedAfter specifies the duration after which the reconciler will mark a release in a pending (locked)\n// state as false in order to allow rolling forward.\nfunc WithMarkFailedAfter(duration time.Duration) Option {\n\treturn func(r *Reconciler) error {\n\t\tif duration < 0 {\n\t\t\treturn errors.New(\"auto-rollback after duration must not be negative\")\n\t\t}\n\t\tr.markFailedAfter = duration\n\t\treturn nil\n\t}\n}", "id": 6484, "concepts": ["time.Duration", "function composition", "option pattern"], "_raw_llm_output": "time.Duration, function composition, option pattern"}
{"seed": "// AuthzCodeHandler is net/http middleware which expects to receive an authz code\n// from a login server. It uses this to get an OAuth access token and Open ID id_token\n// and populates the session user based on their attributes.\nfunc AuthzCodeHandler(w http.ResponseWriter, r *http.Request) {\n\tlog.Printf(\"AuthzCodeHandler: extracting code and checking state\\n\")\n\tstate, ok := r.Context().Value(session.StateKey).(string)\n  if ok == false {\n\t\thttp.Error(w, \"AuthzCodeHandler: could not find state\\n\",\n\t\t\thttp.StatusInternalServerError)\n\t\treturn\n\t}\n\tif state != r.FormValue(\"state\") {\n\t\tlog.Printf(\"AuthzCodeHandler: state mismatch: have: %s; got: %s\\n\",\n\t\t\tstate, r.FormValue(\"state\"))\n\t\thttp.Error(w, \"AuthzCodeHandler: state doesn't match session's state, rejecting\",\n\t\t\thttp.StatusNotAcceptable)\n\t\treturn\n\t}\n\n\tcode := r.FormValue(\"code\")\n\tlog.Printf(\"AuthzCodeHandler: going to request access token with code: %s\\n\", code)\n\ttoken, err := oauth2Config.Exchange(context.Background(), code)\n\tif err != nil {\n\t\tlog.Printf(\"AuthzCodeHandler: failed to exchange authz code: %v\\n\", err)\n\t\thttp.Error(w, \"failed to get access token with authz code\",\n\t\t\thttp.StatusInternalServerError)\n\t\treturn\n\t}\n\tlog.Printf(\"AuthzCodeHandler: got token: %+v\\n\", token)\n\n\tidToken, ok := token.Extra(\"id_token\").(string)\n\tif ok == false {\n\t\tlog.Printf(\"AuthzCodeHandler: but didn't find id_token\\n\")\n\t\thttp.Error(w, \"didn't receive id_token\", http.StatusInternalServerError)\n\t\treturn\n\t} else {\n\t\tlog.Printf(\"AuthzCodeHandler: and id_token: %+v\\n\\n\", idToken)\n\t}\n\n\tlog.Printf(\"AuthzCodeHandler: building rider via id_token: %+v\\n\", idToken)\n\trider, err := riderFromJwt(idToken)\n\tif err != nil {\n\t\tlog.Printf(\"AuthzCodeHandler: failed to build rider from jwt: %s\\n\", err)\n\t\thttp.Error(w, \"failed to build rider from jwt\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tlog.Printf(\"AuthzCodeHandler: setting state with rider: %v\\n\", rider)\n\tsession.SetSession(rider, w, r)\n\tlog.Printf(\"AuthzCodeHandler: done, redirecting to SPA\\n\")\n\thttp.Redirect(w, r, \"/web/\", http.StatusFound)\n}", "id": 6490, "concepts": ["net/http", "net/http middleware", "oauth2", "OpenID", "JWT", "context", "session", "concurrency", "standard library usage"], "_raw_llm_output": "net/http, net/http middleware, oauth2, OpenID, JWT, context, session, concurrency, standard library usage"}
{"seed": "// defer \u0432\u044b\u0437\u044b\u0432\u0430\u0435\u0442\u0441\u044f \u043f\u043e\u0441\u043b\u0435 return \u043d\u043e \u0434\u043e \u043c\u043e\u043c\u0435\u043d\u0442\u0430 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u0432\u044b\u0437\u044b\u0432\u0430\u044e\u0449\u0435\u0439 \u0441\u0442\u043e\u0440\u043e\u043d\u043e\u0439\n\n// \u041f\u0440\u0438 \u0440\u0430\u0431\u043e\u0442\u0435 \u0441 defer - 3 \u043f\u0440\u0430\u0432\u0438\u043b\u0430\n// 1) \u0410\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u044b \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u044e\u0442\u0441\u044f \u0432 \u043c\u043e\u043c\u0435\u043d\u0442 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0441\u0442\u0440\u043e\u043a\u0438 ex: defer Add(a,b)\n// 2) Defer'\u044b - \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u044e\u0442\u0441\u044f \u043f\u043e \u0441\u0442\u0435\u043a\u0443\n// 3) Defer \u043c\u043e\u0436\u0435\u0442 \u0447\u0438\u0442\u0430\u0442\u044c/\u043f\u0438\u0441\u0430\u0442\u044c \u0432 \u0438\u043c\u0435\u043d\u043e\u0432\u0430\u043d\u043d\u044b\u0439 \u0432\u043e\u0437\u0432\u0440\u0430\u0442\n\nfunc test() (x int) { // \u0437\u0434\u0435\u0441\u044c defer \u043c\u043e\u0436\u0435\u0442 \u0447\u0438\u0442\u0430\u0442\u044c \u0438 \u043f\u0440\u0438\u0441\u0432\u0430\u0438\u0432\u0430\u0442\u044c \u0432 x - \u0442.\u043a. x - \u0438\u043c\u0435\u043d\u043e\u0432\u0430\u043d\u043d\u044b\u0439 \u0432\u043e\u0437\u0432\u0440\u0430\u0442\n\tdefer func() {\n\t\tx++\n\t}()\n\tx = 1\n\treturn\n}", "id": 6497, "concepts": ["defer", "named return value", "return value"], "_raw_llm_output": "defer, named return value, return value"}
{"seed": "// GetTodayTime \u8fd4\u56de\u4eca\u5929\u96f6\u70b9\u7684time\nfunc GetTodayTime() time.Time {\n\tnow := time.Now()\n\t// now.Year(), now.Month(), now.Day() \u662f\u4ee5\u672c\u5730\u65f6\u533a\u4e3a\u53c2\u7167\u7684\u5e74\u3001\u6708\u3001\u65e5\n\ttoday := time.Date(now.Year(), now.Month(), now.Day(), 0, 0, 0, 0, time.Local)\n\treturn today\n}", "id": 6499, "concepts": ["time package usage", "time.Date", "time.Local"], "_raw_llm_output": "time package usage, time.Date, time.Local"}
{"seed": "// Test the functionality of the cache when the onEviction function\n// never returns an error.\n// Note this test assumes the internal cache is a FIFO cache\nfunc TestOnEvictCacheNoOnEvictionError(t *testing.T) {\n\trequire := require.New(t)\n\n\tevicted := []int{}\n\tonEviction := func(n int) error {\n\t\tevicted = append(evicted, n)\n\t\treturn nil\n\t}\n\tmaxSize := 3\n\n\tcache := newOnEvictCache[int](maxSize, onEviction)\n\n\t// Get non-existent key\n\t_, ok := cache.Get(0)\n\trequire.False(ok)\n\n\t// Put key\n\trequire.NoError(cache.Put(0, 0))\n\trequire.Equal(1, cache.fifo.Len())\n\n\t// Get key\n\tval, ok := cache.Get(0)\n\trequire.True(ok)\n\trequire.Zero(val)\n\n\t// Get non-existent key\n\t_, ok = cache.Get(1)\n\trequire.False(ok)\n\n\t// Fill the cache\n\tfor i := 1; i < maxSize; i++ {\n\t\trequire.NoError(cache.Put(i, i))\n\t\trequire.Equal(i+1, cache.fifo.Len())\n\t}\n\trequire.Empty(evicted)\n\n\t// Cache has [0,1,2]\n\n\t// Put another key. This should evict the oldest inserted key (0).\n\trequire.NoError(cache.Put(maxSize, maxSize))\n\trequire.Equal(maxSize, cache.fifo.Len())\n\trequire.Len(evicted, 1)\n\trequire.Zero(evicted[0])\n\n\t// Cache has [1,2,3]\n\titer := cache.fifo.NewIterator()\n\trequire.True(iter.Next())\n\trequire.Equal(1, iter.Key())\n\trequire.Equal(1, iter.Value())\n\trequire.True(iter.Next())\n\trequire.Equal(2, iter.Key())\n\trequire.Equal(2, iter.Value())\n\trequire.True(iter.Next())\n\trequire.Equal(3, iter.Key())\n\trequire.Equal(3, iter.Value())\n\trequire.False(iter.Next())\n\n\t// 0 should no longer be in the cache\n\t_, ok = cache.Get(0)\n\trequire.False(ok)\n\n\t// Other keys should still be in the cache\n\tfor i := maxSize; i >= 1; i-- {\n\t\tval, ok := cache.Get(i)\n\t\trequire.True(ok)\n\t\trequire.Equal(i, val)\n\t}\n\n\t// Cache has [1,2,3]\n\titer = cache.fifo.NewIterator()\n\trequire.True(iter.Next())\n\trequire.Equal(1, iter.Key())\n\trequire.Equal(1, iter.Value())\n\trequire.True(iter.Next())\n\trequire.Equal(2, iter.Key())\n\trequire.Equal(2, iter.Value())\n\trequire.True(iter.Next())\n\trequire.Equal(3, iter.Key())\n\trequire.Equal(3, iter.Value())\n\trequire.False(iter.Next())\n\n\t// Put another key to evict the oldest inserted key (1).\n\trequire.NoError(cache.Put(maxSize+1, maxSize+1))\n\trequire.Equal(maxSize, cache.fifo.Len())\n\trequire.Len(evicted, 2)\n\trequire.Equal(1, evicted[1])\n\n\t// Cache has [2,3,4]\n\titer = cache.fifo.NewIterator()\n\trequire.True(iter.Next())\n\trequire.Equal(2, iter.Key())\n\trequire.Equal(2, iter.Value())\n\trequire.True(iter.Next())\n\trequire.Equal(3, iter.Key())\n\trequire.Equal(3, iter.Value())\n\trequire.True(iter.Next())\n\trequire.Equal(4, iter.Key())\n\trequire.Equal(4, iter.Value())\n\trequire.False(iter.Next())\n\n\t// 1 should no longer be in the cache\n\t_, ok = cache.Get(1)\n\trequire.False(ok)\n\n\trequire.NoError(cache.Flush())\n\n\t// Cache should be empty\n\trequire.Zero(cache.fifo.Len())\n\trequire.Len(evicted, 5)\n\trequire.Equal([]int{0, 1, 2, 3, 4}, evicted)\n\trequire.Zero(cache.fifo.Len())\n\trequire.Equal(maxSize, cache.maxSize) // Should be unchanged\n}", "id": 6500, "concepts": ["FIFO cache", "FIFO cache iterator", "FIFO cache flushing", "FIFO cache eviction"], "_raw_llm_output": "FIFO cache, FIFO cache iterator, FIFO cache flushing, FIFO cache eviction"}
{"seed": "// I_ is a convenience wrapper for I without the attrs argument.\nfunc I_(children ...HTML) HTML {\n  return I(nil, children...)\n}", "id": 6506, "concepts": ["type aliasing", "basic function definition"], "_raw_llm_output": "type aliasing, basic function definition"}
{"seed": "// Mark_ is a convenience wrapper for Mark without the attrs argument.\nfunc Mark_(children ...HTML) HTML {\n  return Mark(nil, children...)\n}", "id": 6516, "concepts": ["type alias", "function definition", "function overloading"], "_raw_llm_output": "type alias, function definition, function overloading"}
{"seed": "// GetLeaderboardForEntities get the leaderboard limited to a set of entities.\n// https://api.playfab.com/Documentation/Leaderboards/method/GetLeaderboardForEntities\nfunc GetLeaderboardForEntities(settings *playfab.Settings, postData *GetLeaderboardForEntitiesRequestModel, entityToken string) (*GetEntityLeaderboardResponseModel, error) {\n    if entityToken == \"\" {\n        return nil, playfab.NewCustomError(\"entityToken should not be an empty string\", playfab.ErrorGeneric)\n    }\n    b, errMarshal := json.Marshal(postData)\n    if errMarshal != nil {\n        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)\n    }\n\n    sourceMap, err := playfab.Request(settings, b, \"/Leaderboard/GetLeaderboardForEntities\", \"X-EntityToken\", entityToken)\n    if err != nil {\n        return nil, err\n    }\n    \n    result := &GetEntityLeaderboardResponseModel{}\n\n    config := mapstructure.DecoderConfig{\n        DecodeHook: playfab.StringToDateTimeHook,\n        Result:     result,\n    }\n    \n    decoder, errDecoding := mapstructure.NewDecoder(&config)\n    if errDecoding != nil {\n        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)\n    }\n   \n    errDecoding = decoder.Decode(sourceMap)\n    if errDecoding != nil {\n        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)\n    }\n\n    return result, nil\n}", "id": 6517, "concepts": ["JSON marshaling", "JSON unmarshaling", "map iteration (range loop)", "map iteration (for loop)", "map iteration (for-range loop)", "map iteration (while loop)", "map iteration (while-loop)", "map iteration (for-each loop)", "map iteration (for-each-loop)", "map iteration (for-each-value loop)", "map iteration (for-each-value-loop)", "map iteration (for-each-key loop)", "map iteration (for-each-key-loop)", "map iteration (for-each-key-value loop)", "map iteration (for-each-key-value-loop)", "map iteration (for-each-key-value-loop)", "map iteration (for-each-key-value-pair loop)", "map iteration (for-each-key-value-pair-loop)", "map iteration (for-each-key-value-pair-loop)", "map iteration (for-each-key-value-pair-loop)", "map iteration (for-each-key-value-pair-loop)", "map iteration (for-each-key-value-pair-loop)", "map iteration (for-each-key-value-pair-loop)", "map iteration (for-each-key-value-pair-"], "_raw_llm_output": "JSON marshaling, JSON unmarshaling, map iteration (range loop), map iteration (for loop), map iteration (for-range loop), map iteration (while loop), map iteration (while-loop), map iteration (for-each loop), map iteration (for-each-loop), map iteration (for-each-value loop), map iteration (for-each-value-loop), map iteration (for-each-key loop), map iteration (for-each-key-loop), map iteration (for-each-key-value loop), map iteration (for-each-key-value-loop), map iteration (for-each-key-value-loop), map iteration (for-each-key-value-pair loop), map iteration (for-each-key-value-pair-loop), map iteration (for-each-key-value-pair-loop), map iteration (for-each-key-value-pair-loop), map iteration (for-each-key-value-pair-loop), map iteration (for-each-key-value-pair-loop), map iteration (for-each-key-value-pair-loop), map iteration (for-each-key-value-pair-"}
{"seed": "// SetOpSourceAccount sets the source account ID on an Operation, allowing M-strkeys (as defined in SEP23).\nfunc SetOpSourceAccount(op *xdr.Operation, sourceAccount string) {\n\tif sourceAccount == \"\" {\n\t\treturn\n\t}\n\tvar opSourceAccountID xdr.MuxedAccount\n\topSourceAccountID.SetAddress(sourceAccount)\n\top.SourceAccount = &opSourceAccountID\n}", "id": 6537, "concepts": ["muxed account", "operation", "standard library usage"], "_raw_llm_output": "muxed account, operation, standard library usage"}
{"seed": "// UnitVector returns a vector in the same direction as v, but with a magnitude\n// of 1.\nfunc UnitVector(v Vector) Vector {\n\tmagnitude := Magnitude(v)\n\treturn Vector{\n\t\tI: v.I * (1 / magnitude),\n\t\tJ: v.J * (1 / magnitude),\n\t\tK: v.K * (1 / magnitude),\n\t}\n}", "id": 6544, "concepts": ["struct definition", "struct field access", "struct field assignment", "struct field initialization", "struct field type conversion", "struct field type assertion", "struct field type switch", "struct field type switch case", "struct field type switch default", "struct field type switch case fallthrough", "struct field type switch case break", "struct field type switch case continue", "struct field type switch case return", "struct field type switch case fallthrough", "struct field type switch case break", "struct field type switch case continue", "struct field type switch case return", "struct field type switch case fallthrough", "struct field type switch case break", "struct field type switch case continue", "struct field type switch case return", "struct field type switch case fallthrough", "struct field type switch case break", "struct field type switch case continue", "struct field type switch case return", "struct field type switch case fallthrough", "struct field type switch case break", "struct field type switch case continue", "struct field type switch case return", "struct field type switch case fallthrough", "struct field type switch case break", "struct field type switch case continue", "struct field type switch case return", "struct field type switch case fallthrough", "struct field type switch case break", "struct field type switch case continue", "struct field type switch case return", "struct field type switch case fallthrough", "struct field"], "_raw_llm_output": "struct definition, struct field access, struct field assignment, struct field initialization, struct field type conversion, struct field type assertion, struct field type switch, struct field type switch case, struct field type switch default, struct field type switch case fallthrough, struct field type switch case break, struct field type switch case continue, struct field type switch case return, struct field type switch case fallthrough, struct field type switch case break, struct field type switch case continue, struct field type switch case return, struct field type switch case fallthrough, struct field type switch case break, struct field type switch case continue, struct field type switch case return, struct field type switch case fallthrough, struct field type switch case break, struct field type switch case continue, struct field type switch case return, struct field type switch case fallthrough, struct field type switch case break, struct field type switch case continue, struct field type switch case return, struct field type switch case fallthrough, struct field type switch case break, struct field type switch case continue, struct field type switch case return, struct field type switch case fallthrough, struct field type switch case break, struct field type switch case continue, struct field type switch case return, struct field type switch case fallthrough, struct field"}
{"seed": "// Plaintext represents the HTML element 'plaintext'.\n// For more information visit https://www.w3schools.com/tags/tag_plaintext.asp.\nfunc Plaintext(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"plaintext\", Attributes: attrs, Children: children}\n}", "id": 6545, "concepts": ["HTML tree construction", "HTML element definition", "HTML attribute definition"], "_raw_llm_output": "HTML tree construction, HTML element definition, HTML attribute definition"}
{"seed": "// addIndent adds indentation to the beginning of each line of the provided\n// string. The indentInSpaces argument is the number of spaces that will be\n// inserted into each line.\n//\n// Example: addIndent(\"hello,\\nworld!\\n\", 2) -> \"  hello,\\n  world!\\n\"\nfunc addIndent(s string, indentInSpaces uint) string {\n\t// Setup indent string\n\tvar b strings.Builder\n\tfor i := 0; i < int(indentInSpaces); i++ {\n\t\tb.WriteString(\" \")\n\t}\n\tindent := b.String()\n\n\t// Add indentation after each new line\n\tr := strings.NewReplacer(\"\\n\", \"\\n\"+indent)\n\tss := r.Replace(s)\n\n\t// Remove trailing spaces\n\tss = strings.TrimSpace(ss)\n\n\t// Add indent to the first line\n\treturn indent + ss\n}", "id": 6553, "concepts": ["string manipulation", "string formatting", "string replacement", "string trimming"], "_raw_llm_output": "string manipulation, string formatting, string replacement, string trimming"}
{"seed": "// MustBool does the same as the Bool function, but generates panic in case of an error.\nfunc MustBool(key string) (value bool) {\n\tvalue, err := Bool(key)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn\n}", "id": 6555, "concepts": ["error handling (idiomatic if err != nil", "errors.Is)", "panic"], "_raw_llm_output": "error handling (idiomatic if err != nil, errors.Is), panic"}
{"seed": "// IsNoChainHeadError returns whether the error is a NoChainHeadError.\nfunc IsNoChainHeadError(err error) bool {\n\t_, ok := err.(*NoChainHeadError)\n\treturn ok\n}", "id": 6568, "concepts": ["error handling", "error type assertion"], "_raw_llm_output": "error handling, error type assertion"}
{"seed": "// GenerateExternalSalt returns some new external salt of the length specified in params.\n// This salt should be passed to NewUser and can be used for passphrase hashing prior to\n// calling NewUser. It is stored in the user database and can be retrieved as ExternalSalt.\nfunc GenerateExternalSalt(params *Params) []byte {\n\tsalt := make([]byte, params.ExternalSaltLength)\n\tn, err := rand.Read(salt)\n\tif err != nil || uint32(n) < params.ExternalSaltLength {\n\t\treturn nil\n\t}\n\treturn salt\n}", "id": 6572, "concepts": ["crypto/rand package usage", "crypto/sha256 package usage", "crypto/hmac package usage", "crypto/aes package usage", "crypto/cipher package usage", "crypto/rand.Read usage", "crypto/sha256.Sum256 usage", "crypto/hmac.New usage", "crypto/aes.NewCipher usage", "crypto/cipher.NewCBCEncrypter usage", "crypto/cipher.NewCBCDecrypter usage", "crypto/cipher.NewCTR usage", "crypto/cipher.NewCTR", "crypto/cipher.NewCTR", "crypto/cipher.NewCTR", "crypto/cipher.NewCTR", "crypto/cipher.NewCTR", "crypto/cipher.NewCTR", "crypto/cipher.NewCTR", "crypto/cipher.NewCTR", "crypto/cipher.NewCTR", "crypto/cipher.NewCTR", "crypto/cipher.NewCTR", "crypto/cipher.NewCTR", "crypto/cipher.NewCTR", "crypto/cipher.NewCTR", "crypto/cipher.NewCTR", "crypto/cipher.NewCTR", "crypto/cipher.NewCTR", "crypto/cipher.NewCTR", "crypto/cipher.NewCTR", "crypto/cipher.NewCTR", "crypto/cipher.NewCTR", "crypto/cipher.NewCTR", "crypto/cipher.New"], "_raw_llm_output": "crypto/rand package usage, crypto/sha256 package usage, crypto/hmac package usage, crypto/aes package usage, crypto/cipher package usage, crypto/rand.Read usage, crypto/sha256.Sum256 usage, crypto/hmac.New usage, crypto/aes.NewCipher usage, crypto/cipher.NewCBCEncrypter usage, crypto/cipher.NewCBCDecrypter usage, crypto/cipher.NewCTR usage, crypto/cipher.NewCTR, crypto/cipher.NewCTR, crypto/cipher.NewCTR, crypto/cipher.NewCTR, crypto/cipher.NewCTR, crypto/cipher.NewCTR, crypto/cipher.NewCTR, crypto/cipher.NewCTR, crypto/cipher.NewCTR, crypto/cipher.NewCTR, crypto/cipher.NewCTR, crypto/cipher.NewCTR, crypto/cipher.NewCTR, crypto/cipher.NewCTR, crypto/cipher.NewCTR, crypto/cipher.NewCTR, crypto/cipher.NewCTR, crypto/cipher.NewCTR, crypto/cipher.NewCTR, crypto/cipher.NewCTR, crypto/cipher.NewCTR, crypto/cipher.NewCTR, crypto/cipher.New"}
{"seed": "// +lifted:source=https://github.com/kubernetes/kubernetes/blob/release-1.26/pkg/controller/deployment/util/deployment_util.go#L597-L609\n\n// EqualIgnoreHash returns true if two given podTemplateSpec are equal, ignoring the diff in value of Labels[pod-template-hash]\n// We ignore pod-template-hash because:\n//  1. The hash result would be different upon podTemplateSpec API changes\n//     (e.g. the addition of a new field will cause the hash code to change)\n//  2. The deployment template won't have hash labels\nfunc EqualIgnoreHash(template1, template2 *corev1.PodTemplateSpec) bool {\n\tt1Copy := template1.DeepCopy()\n\tt2Copy := template2.DeepCopy()\n\t// Remove hash labels from template.Labels before comparing\n\tdelete(t1Copy.Labels, appsv1.DefaultDeploymentUniqueLabelKey)\n\tdelete(t2Copy.Labels, appsv1.DefaultDeploymentUniqueLabelKey)\n\treturn apiequality.Semantic.DeepEqual(t1Copy, t2Copy)\n}", "id": 6588, "concepts": ["equality comparison", "podTemplateSpec", "labels", "equality comparison"], "_raw_llm_output": "equality comparison, podTemplateSpec, labels, equality comparison"}
{"seed": "// namedError returns whether the fail node represents a named error in the grammar,\n// a rule whose name is followed by an error name before the <-.\nfunc namedError(n *peg.Fail) bool {\n\tif n.Want == \"\" {\n\t\treturn false\n\t}\n\t// Peggy error node texts for non-named errors begin with one of: \" . [ ! or &.\n\tr, _ := utf8.DecodeRuneInString(n.Want)\n\treturn !strings.ContainsRune(`\".[!&`, r)\n}", "id": 6592, "concepts": ["string manipulation", "rune handling", "character comparison", "PEG grammar"], "_raw_llm_output": "string manipulation, rune handling, character comparison, PEG grammar"}
{"seed": "// Big represents the HTML element 'big'.\n// For more information visit https://www.w3schools.com/tags/tag_big.asp.\nfunc Big(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"big\", Attributes: attrs, Children: children}\n}", "id": 6596, "concepts": ["HTML generation", "HTML tree manipulation", "HTML element definition", "HTML attribute definition"], "_raw_llm_output": "HTML generation, HTML tree manipulation, HTML element definition, HTML attribute definition"}
{"seed": "// ParseScaleInstancePoolResponse parses an HTTP response from a ScaleInstancePoolWithResponse call\nfunc ParseScaleInstancePoolResponse(rsp *http.Response) (*ScaleInstancePoolResponse, error) {\n\tbodyBytes, err := ioutil.ReadAll(rsp.Body)\n\tdefer rsp.Body.Close()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse := &ScaleInstancePoolResponse{\n\t\tBody:         bodyBytes,\n\t\tHTTPResponse: rsp,\n\t}\n\n\tswitch {\n\tcase strings.Contains(rsp.Header.Get(\"Content-Type\"), \"json\") && rsp.StatusCode == 200:\n\t\tvar dest Operation\n\t\tif err := json.Unmarshal(bodyBytes, &dest); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresponse.JSON200 = &dest\n\n\t}\n\n\treturn response, nil\n}", "id": 6603, "concepts": ["HTTP response parsing", "JSON parsing", "HTTP response status code handling"], "_raw_llm_output": "HTTP response parsing, JSON parsing, HTTP response status code handling"}
{"seed": "// Title_ is a convenience wrapper for Title without the attrs argument.\nfunc Title_(children ...HTML) HTML {\n  return Title(nil, children...)\n}", "id": 6606, "concepts": ["HTML", "function definition", "function call", "function argument", "function return value"], "_raw_llm_output": "HTML, function definition, function call, function argument, function return value"}
{"seed": "// Calculate oxidation of SO2 by hydrogen peroxide in clouds as adopted\n// from the WRF/Chem file module_gocart_chem.F.\n// Reactions are assumed to occur instantaneously.\n// Inputs are fraction of grid cell containing clouds (cloudFrac),\n// temperature (T [K]), and concentrations of SO2 and H2O2. Units of\n// of SO2 and H2O2 are not important as long as both quantities have\n// the same units. Outputs are the fractions of SO2 and H2O2 that have\n// reacted (so2rxFrac, h2o2rxFrac).\nfunc SulfurAqueousOxidationFraction(cloudFrac, T, so2, h2o2 float64) (\n\tso2rxFrac, h2o2rxFrac float64) {\n\n\tif cloudFrac > 0. && so2 > 0. && T > 258.0 { // Only happens above 258 K\n\t\tif so2 > h2o2 {\n\t\t\tso2rxFrac = cloudFrac * h2o2 / so2\n\t\t\th2o2rxFrac = cloudFrac\n\t\t} else {\n\t\t\tso2rxFrac = cloudFrac\n\t\t\th2o2rxFrac = cloudFrac * so2 / h2o2\n\t\t}\n\t}\n\treturn\n}", "id": 6610, "concepts": ["floating point arithmetic", "if statement", "function definition", "function return"], "_raw_llm_output": "floating point arithmetic, if statement, function definition, function return"}
{"seed": "// ShowDraftPath computes a request path to the show action of draft.\nfunc ShowDraftPath() string {\n\n\treturn fmt.Sprintf(\"/sao/v1/drafts/\")\n}", "id": 6611, "concepts": ["string formatting", "fmt package usage"], "_raw_llm_output": "string formatting, fmt package usage"}
{"seed": "// Input prints the prefix to the writer, and then reads a single line from the\n// reader, trimming writespace. The received line is passed to the validators,\n// and if any of them return a non-nil error, the error is printed to the\n// writer, and the input process happens again. Otherwise, the line is returned\n// to the caller.\n//\n// Input is intended to be used to take interactive input from the user.\nfunc Input(w io.Writer, prefix string, r io.Reader, validators ...func(string) error) (string, error) {\n\ts := bufio.NewScanner(r)\n\nouter:\n\tfor {\n\t\tfmt.Fprint(w, Bold(prefix))\n\t\tif ok := s.Scan(); !ok {\n\t\t\treturn \"\", s.Err()\n\t\t}\n\n\t\tline := strings.TrimSpace(s.Text())\n\t\tfor _, validate := range validators {\n\t\t\tif err := validate(line); err != nil {\n\t\t\t\tfmt.Fprintln(w, err.Error())\n\t\t\t\tcontinue outer\n\t\t\t}\n\t\t}\n\n\t\treturn line, nil\n\t}\n}", "id": 6638, "concepts": ["io.Writer", "io.Reader", "bufio.Scanner", "string manipulation", "error handling (idiomatic if err != nil)", "functions (anonymous", "variadic)", "concurrency", "standard library usage"], "_raw_llm_output": "io.Writer, io.Reader, bufio.Scanner, string manipulation, error handling (idiomatic if err != nil), functions (anonymous, variadic), concurrency, standard library usage"}
{"seed": "// NewComponentVersionsMapper substitutes strings of the form 0.0.1-snapshot with releaseName and strings\n// of the form 0.0.1-snapshot-[component] with the version value located in versions, or returns an error.\n// tagsByName allows the caller to return an error if references are ambiguous (two tags declare different\n// version values) - if that replacement is detected and tagsByName[component] has more than one entry,\n// then an error is returned by the ManifestMapper.\n// If the input release name is not a semver, a request for `0.0.1-snapshot` will be left unmodified.\nfunc NewComponentVersionsMapper(releaseName string, versions ComponentVersions, tagsByName map[string][]string) ManifestMapper {\n\tif v, err := semver.Parse(releaseName); err == nil {\n\t\tv.Build = nil\n\t\treleaseName = v.String()\n\t} else {\n\t\treleaseName = \"\"\n\t}\n\tre, err := regexp.Compile(componentVersionFormat)\n\tif err != nil {\n\t\treturn func([]byte) ([]byte, error) {\n\t\t\treturn nil, fmt.Errorf(\"component versions mapper regex: %v\", err)\n\t\t}\n\t}\n\treturn func(data []byte) ([]byte, error) {\n\t\tvar missing []string\n\t\tvar conflicts []string\n\t\tdata = re.ReplaceAllFunc(data, func(part []byte) []byte {\n\t\t\tmatches := re.FindSubmatch(part)\n\t\t\tif matches == nil {\n\t\t\t\treturn part\n\t\t\t}\n\t\t\tkey := string(matches[2])\n\t\t\tif len(key) == 0 && len(releaseName) > 0 {\n\t\t\t\tbuf := &bytes.Buffer{}\n\t\t\t\tbuf.Write(matches[1])\n\t\t\t\tbuf.WriteString(releaseName)\n\t\t\t\treturn buf.Bytes()\n\t\t\t}\n\t\t\tif !strings.HasPrefix(key, \"-\") {\n\t\t\t\treturn part\n\t\t\t}\n\t\t\tkey = key[1:]\n\t\t\tvalue, ok := versions[key]\n\t\t\tif !ok {\n\t\t\t\tmissing = append(missing, key)\n\t\t\t\treturn part\n\t\t\t}\n\t\t\tif len(tagsByName[key]) > 1 {\n\t\t\t\tconflicts = append(conflicts, key)\n\t\t\t\treturn part\n\t\t\t}\n\t\t\tbuf := &bytes.Buffer{}\n\t\t\tbuf.Write(matches[1])\n\t\t\tbuf.WriteString(value.Version)\n\t\t\treturn buf.Bytes()\n\t\t})\n\t\tif len(missing) > 0 {\n\t\t\tswitch len(missing) {\n\t\t\tcase 1:\n\t\t\t\tif len(missing[0]) == 0 {\n\t\t\t\t\treturn nil, fmt.Errorf(\"empty version references are not allowed\")\n\t\t\t\t}\n\t\t\t\treturn nil, fmt.Errorf(\"unknown version reference %q\", missing[0])\n\t\t\tdefault:\n\t\t\t\treturn nil, fmt.Errorf(\"unknown version references: %s\", strings.Join(missing, \", \"))\n\t\t\t}\n\t\t}\n\t\tif len(conflicts) > 0 {\n\t\t\tallImageTags := tagsByName[conflicts[0]]\n\t\t\tsort.Strings(allImageTags)\n\t\t\treturn nil, fmt.Errorf(\"the version for %q is inconsistent across the referenced images: %s\", conflicts[0], strings.Join(allImageTags, \", \"))\n\t\t}\n\t\treturn data, nil\n\t}\n}", "id": 6654, "concepts": ["string manipulation", "regexp", "string formatting", "map iteration", "map lookup", "map value iteration", "string sorting", "string joining", "string comparison", "error handling", "standard library usage"], "_raw_llm_output": "string manipulation, regexp, string formatting, map iteration, map lookup, map value iteration, string sorting, string joining, string comparison, error handling, standard library usage"}
{"seed": "// I represents the HTML element 'i'.\n// For more information visit https://www.w3schools.com/tags/tag_i.asp.\nfunc I(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"i\", Attributes: attrs, Children: children}\n}", "id": 6655, "concepts": ["struct definition", "interface implementation", "HTML generation"], "_raw_llm_output": "struct definition, interface implementation, HTML generation"}
{"seed": "// createDirMarker will create a pseudo-directory in Swift.\n//\n// https://github.com/openstack/python-swiftclient/blob/e65070964c7b1e04119c87e5f344d39358780d18/swiftclient/service.py#L1656\nfunc createDirMarker(\n\tclient *gophercloud.ServiceClient,\n\tcontainerName string,\n\tobjectName string,\n\topts *UploadOpts,\n\torigObject *originalObject,\n\tsourceFileInfo os.FileInfo) (*UploadResult, error) {\n\n\tuploadResult := &UploadResult{\n\t\tAction:    \"create_dir_marker\",\n\t\tContainer: containerName,\n\t\tObject:    objectName,\n\t}\n\n\tif origObject != nil {\n\t\tif opts.Changed {\n\t\t\tcontentLength := origObject.headers.ContentLength\n\t\t\teTag := origObject.headers.ETag\n\n\t\t\tcontentType := GetContentType(origObject.headers.ContentType)\n\n\t\t\tvar mtMatch bool\n\t\t\tif origMTime, ok := origObject.metadata[\"Mtime\"]; ok {\n\t\t\t\tif newMTime, ok := opts.Metadata[\"Mtime\"]; ok {\n\t\t\t\t\tif origMTime == newMTime {\n\t\t\t\t\t\tmtMatch = true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar ctMatch bool\n\t\t\tfor _, kdm := range knownDirMarkers {\n\t\t\t\tif contentType == kdm {\n\t\t\t\t\tctMatch = true\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ctMatch && mtMatch && contentLength == 0 && eTag == emptyETag {\n\t\t\t\tuploadResult.Success = true\n\t\t\t\treturn uploadResult, nil\n\t\t\t}\n\t\t}\n\t}\n\n\tcreateOpts := objects.CreateOpts{\n\t\tContent:       strings.NewReader(\"\"),\n\t\tContentLength: 0,\n\t\tContentType:   \"application/directory\",\n\t\tMetadata:      opts.Metadata,\n\t}\n\n\tres := objects.Create(client, containerName, objectName, createOpts)\n\tif res.Err != nil {\n\t\treturn uploadResult, res.Err\n\t}\n\n\tuploadResult.Success = true\n\treturn uploadResult, nil\n}", "id": 6658, "concepts": ["struct", "interface", "slice", "map", "concurrency", "standard library usage"], "_raw_llm_output": "struct, interface, slice, map, concurrency, standard library usage"}
{"seed": "// Thead represents the HTML element 'thead'.\n// For more information visit https://www.w3schools.com/tags/tag_thead.asp.\nfunc Thead(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"thead\", Attributes: attrs, Children: children}\n}", "id": 6665, "concepts": ["HTML generation", "HTML tree traversal", "HTML element definition"], "_raw_llm_output": "HTML generation, HTML tree traversal, HTML element definition"}
{"seed": "// IsPtr reports whether value is a ptr type.\nfunc IsPtr(value interface{}) bool {\n\treturn kindOf(value) == reflect.Ptr\n}", "id": 6667, "concepts": ["reflect package usage", "interface usage", "type assertion"], "_raw_llm_output": "reflect package usage, interface usage, type assertion"}
{"seed": "// ElasticsearchStatusCode returns the HTTP status code from an Elasticsearch client error as a string.\n// It's used for labels in Prometheus metrics. The err parameter can be of\n// type *http.Response, *elastic.Error, elastic.Error, or int (indicating the HTTP status code).\n// Returns 0 if err is not one of those types.\n// Based on elastic.IsStatusCode (https://github.com/olivere/elastic/blob/release-branch.v7/errors.go#L151)\nfunc ElasticsearchStatusCode(err interface{}) string {\n\tvar code int\n\tswitch e := err.(type) {\n\tcase *http.Response:\n\t\tcode = e.StatusCode\n\tcase *elastic.Error:\n\t\tcode = e.Status\n\tcase elastic.Error:\n\t\tcode = e.Status\n\tcase int:\n\t\tcode = e\n\t}\n\tif code == 0 {\n\t\treturn \"\"\n\t}\n\treturn strconv.Itoa(code)\n}", "id": 6671, "concepts": ["type casting", "type assertion", "type switch", "error handling", "standard library usage"], "_raw_llm_output": "type casting, type assertion, type switch, error handling, standard library usage"}
{"seed": "// PossibleStateValues returns an array of possible values for the State const type.\nfunc PossibleStateValues() []State {\n\treturn []State{StateCreating, StateDeleted, StateDeleting, StateRunning, StateStarting, StateStopped, StateStopping, StateUnavailable, StateUpdating}\n}", "id": 6699, "concepts": ["array definition", "const type", "array iteration (range loop)", "basic function definition"], "_raw_llm_output": "array definition, const type, array iteration (range loop), basic function definition"}
{"seed": "// Open opens a database/sql.DB specified by the driver name and\n// the data source name, and returns a new client attached to it.\n// Optional parameters can be added for configuring the client.\nfunc Open(driverName, dataSourceName string, options ...Option) (*Client, error) {\n\tswitch driverName {\n\tcase dialect.MySQL, dialect.Postgres, dialect.SQLite:\n\t\tdrv, err := sql.Open(driverName, dataSourceName)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn NewClient(append(options, Driver(drv))...), nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unsupported driver: %q\", driverName)\n\t}\n}", "id": 6700, "concepts": ["database/sql package usage", "sql.Open", "sql.DB", "sql.Driver", "sql.Rows", "sql.Result", "sql.Tx", "sql.Conn", "sql.Stmt", "sql.NamedArg", "sql.NamedValue", "sql.NamedValueArg", "sql.NamedValueContext", "sql.NamedValueExpr", "sql.NamedValueExprArg", "sql.NamedValueExprContext", "sql.NamedValueExprValue", "sql.NamedValueExprValueArg", "sql.NamedValueExprValueContext", "sql.NamedValueExprValueContext", "sql.NamedValueExprValueContextArg", "sql.NamedValueExprValueContextContext", "sql.NamedValueExprValueContextContextArg", "sql.NamedValueExprValueContextContextContext", "sql.NamedValueExprValueContextContextContextArg", "sql.NamedValueExprValueContextContextContextContext", "sql.NamedValueExprValueContextContextContextContext", "sql.NamedValueExprValueContextContextContextContext", "sql.NamedValueExprValueContextContextContextContext", "sql.NamedValueExprValueContextContextContextContext", "sql.NamedValueExprValueContextContextContextContext", "sql.NamedValueExprValueContextContextContextContext", "sql.NamedValueExprValueContextContextContextContext", "sql.NamedValueExprValueContext"], "_raw_llm_output": "database/sql package usage, sql.Open, sql.DB, sql.Driver, sql.Rows, sql.Result, sql.Tx, sql.Conn, sql.Stmt, sql.NamedArg, sql.NamedValue, sql.NamedValueArg, sql.NamedValueContext, sql.NamedValueExpr, sql.NamedValueExprArg, sql.NamedValueExprContext, sql.NamedValueExprValue, sql.NamedValueExprValueArg, sql.NamedValueExprValueContext, sql.NamedValueExprValueContext, sql.NamedValueExprValueContextArg, sql.NamedValueExprValueContextContext, sql.NamedValueExprValueContextContextArg, sql.NamedValueExprValueContextContextContext, sql.NamedValueExprValueContextContextContextArg, sql.NamedValueExprValueContextContextContextContext, sql.NamedValueExprValueContextContextContextContext, sql.NamedValueExprValueContextContextContextContext, sql.NamedValueExprValueContextContextContextContext, sql.NamedValueExprValueContextContextContextContext, sql.NamedValueExprValueContextContextContextContext, sql.NamedValueExprValueContextContextContextContext, sql.NamedValueExprValueContextContextContextContext, sql.NamedValueExprValueContext"}
{"seed": "// NotFound is a convenience function for building HTTP 404 Not Found\n// responses. If data is nil, a default serializer will be used.\nfunc NotFound(data Serializer, logging ...interface{}) Response {\n\tif data == nil {\n\t\tdata = String(\"404 Not Found\")\n\t}\n\treturn Response{Status: http.StatusNotFound, Data: data, Logging: logging}\n}", "id": 6706, "concepts": ["http package usage", "basic function definition", "interface usage"], "_raw_llm_output": "http package usage, basic function definition, interface usage"}
{"seed": "// NewRedisClient creates a new go-redis/redis client according to passed options.\n// Address needs to be a valid redis URL, e.g. redis://127.0.0.1:6379/0 or redis://:qwerty@localhost:6379/1\nfunc NewRedisClient(addr string) (*redis.Client, error) {\n\topt, err := redis.ParseURL(addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tc := redis.NewClient(&redis.Options{\n\t\tAddr:     opt.Addr,\n\t\tPassword: opt.Password,\n\t\tDB:       opt.DB,\n\t})\n\n\treturn c, nil\n}", "id": 6718, "concepts": ["redis client creation", "redis URL parsing", "redis client options", "redis client usage"], "_raw_llm_output": "redis client creation, redis URL parsing, redis client options, redis client usage"}
{"seed": "// Var_ is a convenience wrapper for Var without the attrs argument.\nfunc Var_(children ...HTML) HTML {\n  return Var(nil, children...)\n}", "id": 6736, "concepts": ["HTML", "basic function definition", "variadic function definition"], "_raw_llm_output": "HTML, basic function definition, variadic function definition"}
{"seed": "// Decide whether the given rune is in the XML Character Range, per\n// the Char production of http://www.xml.com/axml/testaxml.htm,\n// Section 2.2 Characters.\n// Lifted from https://golang.org/src/encoding/xml/xml.go:1102\nfunc isInCharacterRange(r rune) (inrange bool) {\n\treturn r == 0x09 ||\n\t\tr == 0x0A ||\n\t\tr == 0x0D ||\n\t\tr >= 0x20 && r <= 0xDF77 ||\n\t\tr >= 0xE000 && r <= 0xFFFD ||\n\t\tr >= 0x10000 && r <= 0x10FFFF\n}", "id": 6748, "concepts": ["rune handling", "character comparison", "character range"], "_raw_llm_output": "rune handling, character comparison, character range"}
{"seed": "// NewMemKeyVault returns a crypto.KeyVault that stores keys in memory.\n// Certificates must be PEM encoded.\n// The given map must not be modified after calling this function.\nfunc NewMemKeyVault(m map[string][]byte) crypto.KeyVault {\n\treturn &memKeyVault{\n\t\tm: m,\n\t}\n}", "id": 6749, "concepts": ["map", "crypto.KeyVault", "crypto.KeyVault interface", "crypto.KeyVault implementation"], "_raw_llm_output": "map, crypto.KeyVault, crypto.KeyVault interface, crypto.KeyVault implementation"}
{"seed": "// Date returns the Time corresponding to\n//\tyyyy-mm-dd 00:00:00 + 0 nanoseconds\n// in Universal Coordinated Time (UTC)\nfunc Date(year int, month time.Month, day int) time.Time {\n\treturn time.Date(year, month, day, 0, 0, 0, 0, time.UTC)\n}", "id": 6755, "concepts": ["time package usage", "time.Date", "time.Month"], "_raw_llm_output": "time package usage, time.Date, time.Month"}
{"seed": "// NewNetInfoCellFromConn constructs a NetInfoCell with local and remote\n// addresses from conn.\nfunc NewNetInfoCellFromConn(conn net.Conn) (*NetInfoCell, error) {\n\treturn NewNetInfoCellFromAddresses(conn.RemoteAddr(), conn.LocalAddr())\n}", "id": 6756, "concepts": ["net.Conn", "net.Addr", "net.Addr.String()", "net.Addr.Network()", "net.Addr.String()", "error handling (errors.New)", "error handling (errors.Is)", "error handling (errors.As)", "error handling (errors.Unwrap)", "error handling (errors.Wrap)", "error handling (errors.Wrapf)", "error handling (errors.Errorf)", "error handling (errors.Cause)", "error handling (errors.Unwrap)", "error handling (errors.Is)", "error handling (errors.As)", "error handling (errors.Unwrap)", "error handling (errors.Wrap)", "error handling (errors.Wrapf)", "error handling (errors.Errorf)", "error handling (errors.Cause)", "error handling (errors.Unwrap)", "error handling (errors.Is)", "error handling (errors.As)", "error handling (errors.Unwrap)", "error handling (errors.Wrap)", "error handling (errors.Wrapf)", "error handling (errors.Errorf)", "error handling (errors.Cause)", "error handling (errors.Unwrap)", "error handling (errors.Is)", "error handling (errors.As)", "error handling (errors.Unwrap)", "error handling (errors.Wrap)", "error handling (errors.Wrapf)", "error handling (errors.Errorf)", "error"], "_raw_llm_output": "net.Conn, net.Addr, net.Addr.String(), net.Addr.Network(), net.Addr.String(), error handling (errors.New), error handling (errors.Is), error handling (errors.As), error handling (errors.Unwrap), error handling (errors.Wrap), error handling (errors.Wrapf), error handling (errors.Errorf), error handling (errors.Cause), error handling (errors.Unwrap), error handling (errors.Is), error handling (errors.As), error handling (errors.Unwrap), error handling (errors.Wrap), error handling (errors.Wrapf), error handling (errors.Errorf), error handling (errors.Cause), error handling (errors.Unwrap), error handling (errors.Is), error handling (errors.As), error handling (errors.Unwrap), error handling (errors.Wrap), error handling (errors.Wrapf), error handling (errors.Errorf), error handling (errors.Cause), error handling (errors.Unwrap), error handling (errors.Is), error handling (errors.As), error handling (errors.Unwrap), error handling (errors.Wrap), error handling (errors.Wrapf), error handling (errors.Errorf), error"}
{"seed": "// ToDiscardOutput configures the logger to write to io.Discard. This is for\n// benchmarking purposes only.\nfunc ToDiscardOutput() Option {\n\treturn func(cfg *Config) {\n\t\tcfg.toIODiscard = true\n\t\tcfg.ToStderr = false\n\t}\n}", "id": 6772, "concepts": ["io.Discard", "logger configuration", "function composition"], "_raw_llm_output": "io.Discard, logger configuration, function composition"}
{"seed": "// NewListEngineTypeParams creates a new ListEngineTypeParams object\n// with the default values initialized.\nfunc NewListEngineTypeParams() *ListEngineTypeParams {\n\tvar ()\n\treturn &ListEngineTypeParams{\n\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 6775, "concepts": ["struct initialization", "struct field initialization", "struct field declaration"], "_raw_llm_output": "struct initialization, struct field initialization, struct field declaration"}
{"seed": "// CompareArtistName calculates the similarity score\n// (100 represents a perfect match) between the two submitted\n// artist names. Two scores are returned. The first is the direct\n// comparison score. The second is the score after scrubbing\n// noise words.\n//\nfunc CompareArtistName(a, b string) (score, scrubbedScore float64) {\n\tscrubbedA, scrubbedB := ScrubArtistName(a), ScrubArtistName(b)\n\tscore = levenshtein.RatioForStrings([]rune(a), []rune(b), levenshtein.DefaultOptions)\n\tscrubbedScore = levenshtein.RatioForStrings([]rune(scrubbedA), []rune(scrubbedB), levenshtein.DefaultOptions)\n\treturn score * 100, scrubbedScore * 100\n}", "id": 6788, "concepts": ["string manipulation", "string comparison", "levenshtein distance", "string scrubbing"], "_raw_llm_output": "string manipulation, string comparison, levenshtein distance, string scrubbing"}
{"seed": "// HeroPlayedLTE applies the LTE predicate on the \"hero_played\" field.\nfunc HeroPlayedLTE(v uint) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.LTE(s.C(FieldHeroPlayed), v))\n\t})\n}", "id": 6789, "concepts": ["sql package usage", "sql.Selector", "sql.C", "sql.LTE", "sql.Where", "predicate.User"], "_raw_llm_output": "sql package usage, sql.Selector, sql.C, sql.LTE, sql.Where, predicate.User"}
{"seed": "// New returns a MarketDataSnapshotFullRefresh initialized with the required fields for MarketDataSnapshotFullRefresh\nfunc New(symbol field.SymbolField) (m MarketDataSnapshotFullRefresh) {\n\tm.Message = quickfix.NewMessage()\n\tm.Header = fix42.NewHeader(&m.Message.Header)\n\tm.Body = &m.Message.Body\n\tm.Trailer.Trailer = &m.Message.Trailer\n\n\tm.Header.Set(field.NewMsgType(\"W\"))\n\tm.Set(symbol)\n\n\treturn\n}", "id": 6792, "concepts": ["struct initialization", "struct field access", "struct field assignment", "struct field definition", "struct field type definition", "struct field type definition", "struct field type definition", "struct field type definition", "struct field type definition", "struct field type definition", "struct field type definition", "struct field type definition", "struct field type definition", "struct field type definition", "struct field type definition", "struct field type definition", "struct field type definition", "struct field type definition", "struct field type definition", "struct field type definition", "struct field type definition", "struct field type definition", "struct field type definition", "struct field type definition", "struct field type definition", "struct field type definition", "struct field type definition", "struct field type definition", "struct field type definition", "struct field type definition", "struct field type definition", "struct field type definition", "struct field type definition", "struct field type definition", "struct field type definition", "struct field type definition", "struct field type definition", "struct field type definition", "struct field type definition", "struct field type definition", "struct field type definition", "struct field type definition", "struct field type definition", "struct field type definition", "struct field type definition", "struct field type definition", "struct field type definition", "struct field type definition", "struct field type definition", "struct field type definition", "struct field type definition", "struct field type definition", ""], "_raw_llm_output": "struct initialization, struct field access, struct field assignment, struct field definition, struct field type definition, struct field type definition, struct field type definition, struct field type definition, struct field type definition, struct field type definition, struct field type definition, struct field type definition, struct field type definition, struct field type definition, struct field type definition, struct field type definition, struct field type definition, struct field type definition, struct field type definition, struct field type definition, struct field type definition, struct field type definition, struct field type definition, struct field type definition, struct field type definition, struct field type definition, struct field type definition, struct field type definition, struct field type definition, struct field type definition, struct field type definition, struct field type definition, struct field type definition, struct field type definition, struct field type definition, struct field type definition, struct field type definition, struct field type definition, struct field type definition, struct field type definition, struct field type definition, struct field type definition, struct field type definition, struct field type definition, struct field type definition, struct field type definition, struct field type definition, struct field type definition, struct field type definition, struct field type definition, struct field type definition, struct field type definition,"}
{"seed": "// matOrientation determines the orientation using the mat package.\n//\n// It first computes the conditional number of the matrix. When the condition number\n// is higher than the Condition Tolerance, then we assume the matrix is singular and\n// the determinant is 0. If the determinant is not 0 the sign of the determinant is computed.\n//\n//\t| x1 y1 1 |\n//\t| x2 y2 1 |\n//\t| x  y  1 |\nfunc matOrientation(x1, y1, x2, y2, x, y float64) OrientationKind {\n\tif (x1 == x2 && x2 == x) || (y1 == y2 && y2 == y) {\n\t\t// points are horizontally or vertically aligned\n\t\treturn Colinear\n\t}\n\tm := mat.NewDense(3, 3, []float64{x1, y1, 1, x2, y2, 1, x, y, 1})\n\tvar lu mat.LU\n\tlu.Factorize(m)\n\tcond := lu.Cond()\n\tif cond > mat.ConditionTolerance {\n\t\treturn Colinear\n\t}\n\t// Since only the sign is needed LogDet achieves the result in faster time.\n\t_, sign := lu.LogDet()\n\tswitch sign {\n\tcase 1:\n\t\treturn CCW\n\tcase -1:\n\t\treturn CW\n\t}\n\treturn IndeterminateOrientation\n}", "id": 6798, "concepts": ["mat package usage", "matrix manipulation", "matrix determinant calculation", "matrix inversion", "matrix condition number calculation", "matrix log determinant calculation", "matrix sign calculation"], "_raw_llm_output": "mat package usage, matrix manipulation, matrix determinant calculation, matrix inversion, matrix condition number calculation, matrix log determinant calculation, matrix sign calculation"}
{"seed": "// Basefont_ is a convenience wrapper for Basefont without the attrs argument.\nfunc Basefont_(children ...HTML) HTML {\n  return Basefont(nil, children...)\n}", "id": 6802, "concepts": ["HTML tag definition", "HTML tag attribute definition", "HTML tag attribute value definition"], "_raw_llm_output": "HTML tag definition, HTML tag attribute definition, HTML tag attribute value definition"}
{"seed": "// StrLower returns lowercase s.\nfunc StrLower(s string) string {\n\treturn strings.ToLower(s)\n}", "id": 6810, "concepts": ["string manipulation", "strings.ToLower"], "_raw_llm_output": "string manipulation, strings.ToLower"}
{"seed": "// PossibleOptInHeaderTypeValues returns the possible values for the OptInHeaderType const type.\nfunc PossibleOptInHeaderTypeValues() []OptInHeaderType {\n\treturn []OptInHeaderType{\n\t\tOptInHeaderTypeClientGroupMembership,\n\t\tOptInHeaderTypeNotSpecified,\n\t\tOptInHeaderTypeSignedAuxiliaryTokens,\n\t\tOptInHeaderTypeSignedUserToken,\n\t\tOptInHeaderTypeUnboundedClientGroupMembership,\n\t}\n}", "id": 6817, "concepts": ["constant definition", "type definition", "slice definition", "array definition", "slice iteration", "type conversion"], "_raw_llm_output": "constant definition, type definition, slice definition, array definition, slice iteration, type conversion"}
{"seed": "// Import an Application defined either outside the CDK, or in a different CDK Stack.\n//\n// Returns: a Construct representing a reference to an existing Application\n// Experimental.\nfunc LambdaApplication_FromLambdaApplicationName(scope constructs.Construct, id *string, lambdaApplicationName *string) ILambdaApplication {\n\t_init_.Initialize()\n\n\tvar returns ILambdaApplication\n\n\t_jsii_.StaticInvoke(\n\t\t\"monocdk.aws_codedeploy.LambdaApplication\",\n\t\t\"fromLambdaApplicationName\",\n\t\t[]interface{}{scope, id, lambdaApplicationName},\n\t\t&returns,\n\t)\n\n\treturn returns\n}", "id": 6818, "concepts": ["cdk.Construct", "cdk.Construct.fromLookup", "cdk.Construct.fromCfnElement", "cdk.Construct.fromCfnResource", "cdk.Construct.fromCfnAttributes", "cdk.Construct.fromCfnResponseAttributes", "cdk.Construct.fromCfnResponse", "cdk.Construct.fromCfnJson", "cdk.Construct.fromCfnJsonAttributes", "cdk.Construct.fromCfnJsonString", "cdk.Construct.fromCfnJsonStringAttributes", "cdk.Construct.fromCfnJsonStringResponse", "cdk.Construct.fromCfnJsonStringResponseAttributes", "cdk.Construct.fromCfnJsonStringResponseAttribute", "cdk.Construct.fromCfnJsonStringResponseAttributeAttributes", "cdk.Construct.fromCfnJsonStringResponseAttributeAttribute", "cdk.Construct.fromCfnJsonStringResponseAttributeAttributeAttributes", "cdk.Construct.fromCfnJsonStringResponseAttributeAttributeAttribute", "cdk.Construct.fromCfnJsonStringResponseAttributeAttributeAttributeAttributes", "cdk.Construct.fromCfnJsonStringResponseAttributeAttributeAttributeAttribute", "cdk.Construct.fromCfnJsonStringResponseAttributeAttributeAttributeAttributeAttributes", "cdk."], "_raw_llm_output": "cdk.Construct, cdk.Construct.fromLookup, cdk.Construct.fromCfnElement, cdk.Construct.fromCfnResource, cdk.Construct.fromCfnAttributes, cdk.Construct.fromCfnResponseAttributes, cdk.Construct.fromCfnResponse, cdk.Construct.fromCfnJson, cdk.Construct.fromCfnJsonAttributes, cdk.Construct.fromCfnJsonString, cdk.Construct.fromCfnJsonStringAttributes, cdk.Construct.fromCfnJsonStringResponse, cdk.Construct.fromCfnJsonStringResponseAttributes, cdk.Construct.fromCfnJsonStringResponseAttribute, cdk.Construct.fromCfnJsonStringResponseAttributeAttributes, cdk.Construct.fromCfnJsonStringResponseAttributeAttribute, cdk.Construct.fromCfnJsonStringResponseAttributeAttributeAttributes, cdk.Construct.fromCfnJsonStringResponseAttributeAttributeAttribute, cdk.Construct.fromCfnJsonStringResponseAttributeAttributeAttributeAttributes, cdk.Construct.fromCfnJsonStringResponseAttributeAttributeAttributeAttribute, cdk.Construct.fromCfnJsonStringResponseAttributeAttributeAttributeAttributeAttributes, cdk."}
{"seed": "// NewFileHandler creates a file Handler, which will output the logs to the given file path.\n// path is the path to your file.\n// levels are the levels that you want your Handler to handle.\nfunc NewFileHandler(path string, levels ...LogLevel) Handler {\n\treturn &fileHandler{\n\t\tleveled: leveled{levels},\n\t\tpath: path,\n\t\tfile: nil,\n\t}\n}", "id": 6825, "concepts": ["interface implementation", "struct composition", "method composition", "method overriding", "method chaining", "method composition"], "_raw_llm_output": "interface implementation, struct composition, method composition, method overriding, method chaining, method composition"}
{"seed": "// TypeName \u8fd4\u56de\u539f\u59cb\u7c7b\u578b\u7684\u5168\u9650\u5b9a\u540d\uff0cGo \u8bed\u8a00\u5141\u8bb8\u4e0d\u540c\u7684\u8def\u5f84\u4e0b\u5b58\u5728\u76f8\u540c\u7684\u5305\uff0c\u56e0\u6b64\u6709\u5168\u9650\u5b9a\u540d\n// \u7684\u9700\u6c42\uff0c\u5f62\u5982 \"github.com/go-spring/spring-core/SpringCore.BeanDefinition\"\u3002\nfunc TypeName(i interface{}) string {\n\ttyp := TypeOf(i)\n\n\tfor { // \u53bb\u6389\u6307\u9488\u548c\u6570\u7ec4\u7684\u5305\u88c5\uff0c\u4ee5\u83b7\u5f97\u539f\u59cb\u7c7b\u578b\n\t\tif k := typ.Kind(); k == reflect.Ptr || k == reflect.Slice {\n\t\t\ttyp = typ.Elem()\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif pkgPath := typ.PkgPath(); pkgPath != \"\" {\n\t\treturn pkgPath + \"/\" + typ.String()\n\t}\n\treturn typ.String() // \u5185\u7f6e\u7c7b\u578b\u7684\u8def\u5f84\u4e3a\u7a7a\n}", "id": 6826, "concepts": ["reflection", "interface", "pointer", "array", "string manipulation", "type comparison"], "_raw_llm_output": "reflection, interface, pointer, array, string manipulation, type comparison"}
{"seed": "// GetLinks extracts the URLs from the given body and finds the right URLs\n// using the given host. It returns a slice of URLs and if something goes wrong,\n// slice would be empty and an error would be returend\nfunc GetLinks(body string, host string) ([]string, error) {\n\tvar links []string\n\tresult := linkTagRegex.FindAllStringSubmatch(body, -1)\n\n\tfor _, tag := range result {\n\t\turl, err := ValidateURL(tag[1], host)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif url != nil {\n\t\t\tlinks = append(links, url.String())\n\t\t}\n\t}\n\n\tlinks = Deduplicate(links)\n\n\treturn links, nil\n}", "id": 6865, "concepts": ["regular expression", "URL validation", "string manipulation", "slice manipulation", "error handling", "standard library usage"], "_raw_llm_output": "regular expression, URL validation, string manipulation, slice manipulation, error handling, standard library usage"}
{"seed": "// BulkCreditSamedayLTE applies the LTE predicate on the \"bulkCreditSameday\" field.\nfunc BulkCreditSamedayLTE(v float64) predicate.Bulk {\n\treturn predicate.Bulk(func(s *sql.Selector) {\n\t\ts.Where(sql.LTE(s.C(FieldBulkCreditSameday), v))\n\t})\n}", "id": 6877, "concepts": ["sql package usage", "sql.Selector", "sql.C", "sql.LTE", "sql.Where", "sql.Predicate", "sql.Field", "sql.Bulk", "sql.Predicate.Bulk", "sql.Predicate.Where", "sql.Predicate.C", "sql.Predicate.LTE", "sql.Predicate.SQL", "sql.Predicate.String"], "_raw_llm_output": "sql package usage, sql.Selector, sql.C, sql.LTE, sql.Where, sql.Predicate, sql.Field, sql.Bulk, sql.Predicate.Bulk, sql.Predicate.Where, sql.Predicate.C, sql.Predicate.LTE, sql.Predicate.SQL, sql.Predicate.String"}
{"seed": "// FocusOut returns an event that responds to the javascript \"focusout\" event. This is fired when a control,\n// or any of its nested controls, loses focus. In other words, the event bubbles.\nfunc FocusOut() *Event {\n\treturn NewEvent(\"focusout\")\n}", "id": 6878, "concepts": ["event handling", "event bubbling", "event delegation"], "_raw_llm_output": "event handling, event bubbling, event delegation"}
{"seed": "// Tr represents the HTML element 'tr'.\n// For more information visit https://www.w3schools.com/tags/tag_tr.asp.\nfunc Tr(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"tr\", Attributes: attrs, Children: children}\n}", "id": 6884, "concepts": ["HTML generation", "HTML tree", "HTML element", "HTML attribute", "HTML child"], "_raw_llm_output": "HTML generation, HTML tree, HTML element, HTML attribute, HTML child"}
{"seed": "// Convert commonly understood types to a float64\n// Valid types are int64, float64 or PositionPoint with a Value of int64 or float64\n// The second retuned boolean indicates if the conversion was successful.\nfunc toFloat64(v interface{}) (float64, bool) {\n\tswitch value := v.(type) {\n\tcase int64:\n\t\treturn float64(value), true\n\tcase float64:\n\t\treturn value, true\n\tcase PositionPoint:\n\t\treturn toFloat64(value.Value)\n\t}\n\treturn 0, false\n}", "id": 6892, "concepts": ["type switch", "type assertion", "interface", "basic function definition"], "_raw_llm_output": "type switch, type assertion, interface, basic function definition"}
{"seed": "// SocialNameIn applies the In predicate on the \"social_name\" field.\nfunc SocialNameIn(vs ...string) predicate.User {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.User(func(s *sql.Selector) {\n\t\t// if not arguments were provided, append the FALSE constants,\n\t\t// since we can't apply \"IN ()\". This will make this predicate falsy.\n\t\tif len(vs) == 0 {\n\t\t\ts.Where(sql.False())\n\t\t\treturn\n\t\t}\n\t\ts.Where(sql.In(s.C(FieldSocialName), v...))\n\t})\n}", "id": 6895, "concepts": ["sql package usage", "predicate definition", "predicate usage"], "_raw_llm_output": "sql package usage, predicate definition, predicate usage"}
{"seed": "// NewFulfillment creates an optional unlock fulfillment,\n// using an optionally given MarshalableUnlockFulfillment.\nfunc NewFulfillment(f MarshalableUnlockFulfillment) UnlockFulfillmentProxy {\n\treturn UnlockFulfillmentProxy{Fulfillment: f}\n}", "id": 6906, "concepts": ["struct definition", "interface definition", "pointer usage", "method definition", "method usage"], "_raw_llm_output": "struct definition, interface definition, pointer usage, method definition, method usage"}
{"seed": "// NewWriter returns a new WriteCloser writing to w.  It converts writes\n// of UTF-8 text into writes on w of text in the named character set.\n// The Close is necessary to flush any remaining partially translated\n// characters to the output.\nfunc NewWriter(charset string, w io.Writer) (io.WriteCloser, error) {\n\ttr, err := TranslatorTo(charset)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn NewTranslatingWriter(w, tr), nil\n}", "id": 6915, "concepts": ["io.Writer", "io.WriteCloser", "io.Reader", "io.ReaderFrom", "io.WriterTo", "io.Closer", "io.Flusher", "io.Seeker", "io.ReaderAt", "io.ByteReader", "io.RuneReader", "io.ByteScanner", "io.RuneScanner", "io.ByteWriter", "io.RuneWriter", "io.StringWriter", "io.WriterAt", "io.WriterTo", "io.Seeker", "io.ReaderFrom", "io.ReadWriter", "io.ReadSeeker", "io.ReadCloser", "io.ReadWriteCloser", "io.ReadWriteSeeker", "io.ReadWriterAt", "io.ReadWriterCloser", "io.ReadWriter", "io.ReadWriterAt", "io.ReadWriterSeeker", "io.ReadWriterCloser", "io.ReadWriterAt", "io.ReadWriterSeeker", "io.ReadWriterCloser", "io.ReadWriterAt", "io.ReadWriterSeeker", "io.ReadWriterCloser", "io.ReadWriterAt", "io.ReadWriterSeeker", "io.ReadWriterCloser", "io.ReadWriterAt", "io.ReadWriterSeeker", "io.ReadWriterCloser", "io.ReadWriterAt", "io.ReadWriterSeeker", "io.ReadWriterCloser", ""], "_raw_llm_output": "io.Writer, io.WriteCloser, io.Reader, io.ReaderFrom, io.WriterTo, io.Closer, io.Flusher, io.Seeker, io.ReaderAt, io.ByteReader, io.RuneReader, io.ByteScanner, io.RuneScanner, io.ByteWriter, io.RuneWriter, io.StringWriter, io.WriterAt, io.WriterTo, io.Seeker, io.ReaderFrom, io.ReadWriter, io.ReadSeeker, io.ReadCloser, io.ReadWriteCloser, io.ReadWriteSeeker, io.ReadWriterAt, io.ReadWriterCloser, io.ReadWriter, io.ReadWriterAt, io.ReadWriterSeeker, io.ReadWriterCloser, io.ReadWriterAt, io.ReadWriterSeeker, io.ReadWriterCloser, io.ReadWriterAt, io.ReadWriterSeeker, io.ReadWriterCloser, io.ReadWriterAt, io.ReadWriterSeeker, io.ReadWriterCloser, io.ReadWriterAt, io.ReadWriterSeeker, io.ReadWriterCloser, io.ReadWriterAt, io.ReadWriterSeeker, io.ReadWriterCloser,"}
{"seed": "// Join returns an error that wraps the given errors.  Any nil error values are\n// discarded.  Join returns nil if errs contains no non-nil values.  The error\n// formats as the concatenation of the strings obtained by calling the Error\n// method of each element of errs, with a newline between each string.\n//\n// It calls [errors.Join] from the Go standard library.\nfunc Join(errs ...error) error {\n\treturn stderrors.Join(errs...)\n}", "id": 6924, "concepts": ["error handling (errors.Join)", "standard library usage"], "_raw_llm_output": "error handling (errors.Join), standard library usage"}
{"seed": "// IsUnknownPeerError returns whether the error is a UnknownPeerError.\nfunc IsUnknownPeerError(err error) bool {\n\t_, ok := err.(*UnknownPeerError)\n\treturn ok\n}", "id": 6925, "concepts": ["error handling (type assertion)", "error handling (errors.Is)", "error handling (errors.As)"], "_raw_llm_output": "error handling (type assertion), error handling (errors.Is), error handling (errors.As)"}
{"seed": "// ReadVehicles reads a full Vehicle structure from the database based on the supplied rows object\nfunc ReadVehicles(rows *sql.Rows, a *Vehicle) error {\n\treturn rows.Scan(&a.VID, &a.TCID, &a.BID, &a.VehicleType, &a.VehicleMake, &a.VehicleModel, &a.VehicleColor, &a.VehicleYear,\n\t\t&a.VIN, &a.LicensePlateState, &a.LicensePlateNumber, &a.ParkingPermitNumber, &a.DtStart, &a.DtStop,\n\t\t&a.CreateTS, &a.CreateBy, &a.LastModTime, &a.LastModBy)\n}", "id": 6937, "concepts": ["sql package usage", "struct definition", "pointer usage", "struct field access"], "_raw_llm_output": "sql package usage, struct definition, pointer usage, struct field access"}
{"seed": "// DefaultPort will return the hostname with the default internal Gansoi port.\n// If hostport already contains a port, DefaultPort will simply return that.\nfunc DefaultPort(hostport string) string {\n\tif !strings.ContainsRune(hostport, ':') {\n\t\treturn hostport + \":\" + \"4934\"\n\t}\n\n\treturn hostport\n}", "id": 6946, "concepts": ["string manipulation", "string comparison", "string concatenation", "string conversion", "string handling", "string search", "string splitting", "string substitution"], "_raw_llm_output": "string manipulation, string comparison, string concatenation, string conversion, string handling, string search, string splitting, string substitution"}
{"seed": "// NewPostSecdefSearchParamsWithHTTPClient creates a new PostSecdefSearchParams object\n// with the default values initialized, and the ability to set a custom HTTPClient for a request\nfunc NewPostSecdefSearchParamsWithHTTPClient(client *http.Client) *PostSecdefSearchParams {\n\tvar ()\n\treturn &PostSecdefSearchParams{\n\t\tHTTPClient: client,\n\t}\n}", "id": 6949, "concepts": ["struct initialization", "struct field initialization", "struct field assignment", "struct field access", "struct field pointer access", "struct field pointer assignment", "struct field pointer access", "struct field pointer assignment", "struct field pointer access", "struct field pointer assignment", "struct field pointer access", "struct field pointer assignment", "struct field pointer access", "struct field pointer assignment", "struct field pointer access", "struct field pointer assignment", "struct field pointer access", "struct field pointer assignment", "struct field pointer access", "struct field pointer assignment", "struct field pointer access", "struct field pointer assignment", "struct field pointer access", "struct field pointer assignment", "struct field pointer access", "struct field pointer assignment", "struct field pointer access", "struct field pointer assignment", "struct field pointer access", "struct field pointer assignment", "struct field pointer access", "struct field pointer assignment", "struct field pointer access", "struct field pointer assignment", "struct field pointer access", "struct field pointer assignment", "struct field pointer access", "struct field pointer assignment", "struct field pointer access", "struct field pointer assignment", "struct field pointer access", "struct field pointer assignment", "struct field pointer access", "struct field pointer assignment", "struct field pointer access", "struct field pointer assignment", "struct field pointer access", "struct field pointer assignment", "struct field pointer access", "struct field pointer assignment", "struct field pointer access", "struct field pointer assignment", ""], "_raw_llm_output": "struct initialization, struct field initialization, struct field assignment, struct field access, struct field pointer access, struct field pointer assignment, struct field pointer access, struct field pointer assignment, struct field pointer access, struct field pointer assignment, struct field pointer access, struct field pointer assignment, struct field pointer access, struct field pointer assignment, struct field pointer access, struct field pointer assignment, struct field pointer access, struct field pointer assignment, struct field pointer access, struct field pointer assignment, struct field pointer access, struct field pointer assignment, struct field pointer access, struct field pointer assignment, struct field pointer access, struct field pointer assignment, struct field pointer access, struct field pointer assignment, struct field pointer access, struct field pointer assignment, struct field pointer access, struct field pointer assignment, struct field pointer access, struct field pointer assignment, struct field pointer access, struct field pointer assignment, struct field pointer access, struct field pointer assignment, struct field pointer access, struct field pointer assignment, struct field pointer access, struct field pointer assignment, struct field pointer access, struct field pointer assignment, struct field pointer access, struct field pointer assignment, struct field pointer access, struct field pointer assignment, struct field pointer access, struct field pointer assignment, struct field pointer access, struct field pointer assignment,"}
{"seed": "// AssetDir returns the file names below a certain\n// directory embedded in the file by go-bindata.\n// For example if you run go-bindata on data/... and data contains the\n// following hierarchy:\n//     data/\n//       foo.txt\n//       img/\n//         a.png\n//         b.png\n// then AssetDir(\"data\") would return []string{\"foo.txt\", \"img\"}\n// AssetDir(\"data/img\") would return []string{\"a.png\", \"b.png\"}\n// AssetDir(\"foo.txt\") and AssetDir(\"notexist\") would return an error\n// AssetDir(\"\") will return []string{\"data\"}.\nfunc AssetDir(name string) ([]string, error) {\n\tnode := _bintree\n\tif len(name) != 0 {\n\t\tcannonicalName := strings.Replace(name, \"\\\\\", \"/\", -1)\n\t\tpathList := strings.Split(cannonicalName, \"/\")\n\t\tfor _, p := range pathList {\n\t\t\tnode = node.Children[p]\n\t\t\tif node == nil {\n\t\t\t\treturn nil, fmt.Errorf(\"Asset %s not found\", name)\n\t\t\t}\n\t\t}\n\t}\n\tif node.Func != nil {\n\t\treturn nil, fmt.Errorf(\"Asset %s not found\", name)\n\t}\n\trv := make([]string, 0, len(node.Children))\n\tfor name := range node.Children {\n\t\trv = append(rv, name)\n\t}\n\treturn rv, nil\n}", "id": 6952, "concepts": ["string manipulation", "string splitting", "map iteration", "error handling (errors.New)", "standard library usage"], "_raw_llm_output": "string manipulation, string splitting, map iteration, error handling (errors.New), standard library usage"}
{"seed": "// LoggingMiddlewareWithOptions is a middleware that logs requests to the logger.\n// Requires an Options struct to accept additional information.\nfunc LoggingMiddlewareWithOptions(options Options) func(stdhttp.Handler) stdhttp.Handler {\n\treturn func(next stdhttp.Handler) stdhttp.Handler {\n\t\treturn stdhttp.HandlerFunc(func(w stdhttp.ResponseWriter, r *stdhttp.Request) {\n\t\t\tmw := mutil.WrapWriter(w)\n\t\t\tctx := log.PushContext(r.Context(), func(l *log.Entry) *log.Entry {\n\t\t\t\treturn l.WithFields(log.F{\n\t\t\t\t\t\"req\": middleware.GetReqID(r.Context()),\n\t\t\t\t})\n\t\t\t})\n\t\t\tr = r.WithContext(ctx)\n\n\t\t\tlogStartOfRequest(r, options.ExtraHeaders)\n\n\t\t\tthen := time.Now()\n\t\t\tnext.ServeHTTP(mw, r)\n\t\t\tduration := time.Since(then)\n\n\t\t\tlogEndOfRequest(r, duration, mw)\n\t\t})\n\t}\n}", "id": 6960, "concepts": ["middleware", "context", "time package usage", "logging", "standard library usage"], "_raw_llm_output": "middleware, context, time package usage, logging, standard library usage"}
{"seed": "// sanitizeFunc sanitizes the argument src by replacing newlines with\n// blanks, removing extra blanks, and by removing trailing whitespace\n// and commas before closing parentheses.\nfunc sanitizeFunc(src string) string {\n\tbuf := make([]byte, len(src))\n\tj := 0      // buf index\n\tcomma := -1 // comma index if >= 0\n\tfor i := 0; i < len(src); i++ {\n\t\tch := src[i]\n\t\tswitch ch {\n\t\tcase '\\t', '\\n', ' ':\n\t\t\t// ignore whitespace at the beginning, after a blank, or after opening parentheses\n\t\t\tif j == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif p := buf[j-1]; p == ' ' || p == '(' || p == '{' || p == '[' {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// replace all whitespace with blanks\n\t\t\tch = ' '\n\t\tcase ',':\n\t\t\tcomma = j\n\t\tcase ')', '}', ']':\n\t\t\t// remove any trailing comma\n\t\t\tif comma >= 0 {\n\t\t\t\tj = comma\n\t\t\t}\n\t\t\t// remove any trailing whitespace\n\t\t\tif j > 0 && buf[j-1] == ' ' {\n\t\t\t\tj--\n\t\t\t}\n\t\tdefault:\n\t\t\tcomma = -1\n\t\t}\n\t\tbuf[j] = ch\n\t\tj++\n\t}\n\t// remove trailing blank, if any\n\tif j > 0 && buf[j-1] == ' ' {\n\t\tj--\n\t}\n\treturn string(buf[:j])\n}", "id": 6961, "concepts": ["string manipulation", "rune handling", "character comparison", "string formatting", "standard library usage"], "_raw_llm_output": "string manipulation, rune handling, character comparison, string formatting, standard library usage"}
{"seed": "// CorrectionEQ applies the EQ predicate on the \"correction\" field.\nfunc CorrectionEQ(v string) predicate.TradeCorrection {\n\treturn predicate.TradeCorrection(sql.FieldEQ(FieldCorrection, v))\n}", "id": 6974, "concepts": ["sql.FieldEQ", "sql.FieldLike", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldBetween", "sql.FieldLT", "sql.FieldGT", "sql.FieldLTE", "sql.FieldGTE", "sql.FieldIsNull", "sql.FieldIsNotNull", "sql.FieldRegexp", "sql.FieldNotRegexp", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldBetween", "sql.FieldLT", "sql.FieldGT", "sql.FieldLTE", "sql.FieldGTE", "sql.FieldIsNull", "sql.FieldIsNotNull", "sql.FieldRegexp", "sql.FieldNotRegexp", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldBetween", "sql.FieldLT", "sql.FieldGT", "sql.FieldLTE", "sql.FieldGTE", "sql.FieldIsNull", "sql.FieldIsNotNull", "sql.FieldRegexp", "sql.FieldNotRegexp", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldBetween", "sql.FieldLT", "sql.FieldGT", "sql.FieldLTE", "sql.FieldGTE", "sql.FieldIsNull", "sql.FieldIsNotNull", "sql.FieldRegexp", "sql.FieldNotRegexp", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldBetween", "sql."], "_raw_llm_output": "sql.FieldEQ, sql.FieldLike, sql.FieldIn, sql.FieldNotIn, sql.FieldBetween, sql.FieldLT, sql.FieldGT, sql.FieldLTE, sql.FieldGTE, sql.FieldIsNull, sql.FieldIsNotNull, sql.FieldRegexp, sql.FieldNotRegexp, sql.FieldIn, sql.FieldNotIn, sql.FieldBetween, sql.FieldLT, sql.FieldGT, sql.FieldLTE, sql.FieldGTE, sql.FieldIsNull, sql.FieldIsNotNull, sql.FieldRegexp, sql.FieldNotRegexp, sql.FieldIn, sql.FieldNotIn, sql.FieldBetween, sql.FieldLT, sql.FieldGT, sql.FieldLTE, sql.FieldGTE, sql.FieldIsNull, sql.FieldIsNotNull, sql.FieldRegexp, sql.FieldNotRegexp, sql.FieldIn, sql.FieldNotIn, sql.FieldBetween, sql.FieldLT, sql.FieldGT, sql.FieldLTE, sql.FieldGTE, sql.FieldIsNull, sql.FieldIsNotNull, sql.FieldRegexp, sql.FieldNotRegexp, sql.FieldIn, sql.FieldNotIn, sql.FieldBetween, sql."}
{"seed": "// Audio represents the HTML element 'audio'.\n// For more information visit https://www.w3schools.com/tags/tag_audio.asp.\nfunc Audio(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"audio\", Attributes: attrs, Children: children}\n}", "id": 6986, "concepts": ["HTML generation", "HTML tree representation", "HTML element definition"], "_raw_llm_output": "HTML generation, HTML tree representation, HTML element definition"}
{"seed": "// RegisterOcpTestApiHandler registers the http handlers for service OcpTestApi to \"mux\".\n// The handlers forward requests to the grpc endpoint over \"conn\".\nfunc RegisterOcpTestApiHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {\n\treturn RegisterOcpTestApiHandlerClient(ctx, mux, NewOcpTestApiClient(conn))\n}", "id": 7002, "concepts": ["grpc", "runtime.ServeMux", "grpc.ClientConn", "grpc.NewClientConn", "grpc.NewClientConn", "runtime.RegisterServiceHandler", "runtime.RegisterServiceHandlerClient", "runtime.RegisterServiceHandlerClient", "runtime.RegisterServiceHandlerClient", "runtime.RegisterServiceHandlerClient"], "_raw_llm_output": "grpc, runtime.ServeMux, grpc.ClientConn, grpc.NewClientConn, grpc.NewClientConn, runtime.RegisterServiceHandler, runtime.RegisterServiceHandlerClient, runtime.RegisterServiceHandlerClient, runtime.RegisterServiceHandlerClient, runtime.RegisterServiceHandlerClient"}
{"seed": "// NewKeyFromURL creates a new Key from an TOTP or HOTP url.\n//\n// The URL format is documented here:\n//   https://github.com/google/google-authenticator/wiki/Key-Uri-Format\n//\nfunc NewKeyFromURL(orig string) (*Key, error) {\n\ts := strings.TrimSpace(orig)\n\n\tu, err := url.Parse(s)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &Key{\n\t\torig: s,\n\t\turl:  u,\n\t}, nil\n}", "id": 7004, "concepts": ["url parsing", "url.Parse", "url.URL", "string manipulation", "error handling"], "_raw_llm_output": "url parsing, url.Parse, url.URL, string manipulation, error handling"}
{"seed": "// New returns a map of the helpers within this package.\nfunc New() hctx.Map {\n\treturn hctx.Map{\n\t\tPathForKey: PathFor,\n\t}\n}", "id": 7008, "concepts": ["map creation", "map iteration (range loop)", "map key creation", "map value creation"], "_raw_llm_output": "map creation, map iteration (range loop), map key creation, map value creation"}
{"seed": "// ChoriaPlugin produces the Choria pluggable plugin it uses the metadata\n// to dynamically answer questions of name and version\nfunc ChoriaPlugin() plugin.Pluggable {\n\treturn mcorpc.NewChoriaAgentPlugin(metadata, New)\n}", "id": 7013, "concepts": ["plugin.Pluggable", "mcorpc.NewChoriaAgentPlugin", "metadata", "New"], "_raw_llm_output": "plugin.Pluggable, mcorpc.NewChoriaAgentPlugin, metadata, New"}
{"seed": "// SocialEmailIn applies the In predicate on the \"social_email\" field.\nfunc SocialEmailIn(vs ...string) predicate.User {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.User(func(s *sql.Selector) {\n\t\t// if not arguments were provided, append the FALSE constants,\n\t\t// since we can't apply \"IN ()\". This will make this predicate falsy.\n\t\tif len(vs) == 0 {\n\t\t\ts.Where(sql.False())\n\t\t\treturn\n\t\t}\n\t\ts.Where(sql.In(s.C(FieldSocialEmail), v...))\n\t})\n}", "id": 7019, "concepts": ["sql.Selector", "sql.In", "sql.False", "sql.C", "sql.Where", "predicate.User", "anonymous function", "standard library usage"], "_raw_llm_output": "sql.Selector, sql.In, sql.False, sql.C, sql.Where, predicate.User, anonymous function, standard library usage"}
{"seed": "// PossibleTemplateDeploymentCapabilitiesValues returns the possible values for the TemplateDeploymentCapabilities const type.\nfunc PossibleTemplateDeploymentCapabilitiesValues() []TemplateDeploymentCapabilities {\n\treturn []TemplateDeploymentCapabilities{\n\t\tTemplateDeploymentCapabilitiesDefault,\n\t\tTemplateDeploymentCapabilitiesPreflight,\n\t}\n}", "id": 7020, "concepts": ["const type", "enum", "iota", "iota usage"], "_raw_llm_output": "const type, enum, iota, iota usage"}
{"seed": "// PossibleCertificateSourceValues returns an array of possible values for the CertificateSource const type.\nfunc PossibleCertificateSourceValues() []CertificateSource {\n\treturn []CertificateSource{CertificateSourceAzureKeyVault, CertificateSourceFrontDoor}\n}", "id": 7026, "concepts": ["const type", "array definition"], "_raw_llm_output": "const type, array definition"}
{"seed": "// H5_ is a convenience wrapper for H5 without the attrs argument.\nfunc H5_(children ...HTML) HTML {\n  return H5(nil, children...)\n}", "id": 7028, "concepts": ["HTML tag definition", "HTML tag attribute definition", "HTML tag child definition"], "_raw_llm_output": "HTML tag definition, HTML tag attribute definition, HTML tag child definition"}
{"seed": "// IDNEQ applies the NEQ predicate on the ID field.\nfunc IDNEQ(id string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldID), id))\n\t})\n}", "id": 7032, "concepts": ["SQL query building", "SQL predicate usage", "SQL query execution"], "_raw_llm_output": "SQL query building, SQL predicate usage, SQL query execution"}
{"seed": "// SqliteUniqueViolation returns true when the provided error matches the SQLite error\n// for duplicate entries (violating a unique table constraint).\nfunc SqliteUniqueViolation(err error) bool {\n\tmatch := strings.Contains(err.Error(), \"UNIQUE constraint failed\")\n\tif e, ok := err.(sqlite3.Error); ok {\n\t\treturn match || e.Code == sqlite3.ErrConstraint\n\t}\n\treturn match\n}", "id": 7036, "concepts": ["sqlite3 package usage", "error handling", "error type assertion"], "_raw_llm_output": "sqlite3 package usage, error handling, error type assertion"}
{"seed": "// GetExtendingApps returns the list of apps which are installed in the cluster registered for extending the pipeline.\n// An app registers its interest in extending the pipeline by having the 'pipeline-extension' label set.\nfunc GetExtendingApps(jxClient versioned.Interface, namespace string) ([]jenkinsv1.App, error) {\n\tlistOptions := metav1.ListOptions{}\n\tlistOptions.LabelSelector = fmt.Sprintf(apps.AppTypeLabel+\" in (%s)\", apps.PipelineExtension)\n\tappsList, err := jxClient.JenkinsV1().Apps(namespace).List(listOptions)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"error retrieving pipeline contributor apps\")\n\t}\n\treturn appsList.Items, nil\n}", "id": 7058, "concepts": ["kubernetes API usage", "label selector", "basic function definition"], "_raw_llm_output": "kubernetes API usage, label selector, basic function definition"}
{"seed": "/*\n\tNewServer creates and returns a new server listening on the given port.\n*/\nfunc NewServer(port int) *Server {\n\treturn &Server{port: port}\n}", "id": 7072, "concepts": ["function definition", "struct definition", "return value"], "_raw_llm_output": "function definition, struct definition, return value"}
{"seed": "// HowManyGames returns the number of games possible to buy withing budget.\n// p: current game price\n// d: price decrement at subsequent game\n// m: minimum value game can be bought\n// s: total available budget\nfunc HowManyGames(p int32, d int32, m int32, s int32) int32 {\n\tvar (\n\t\tres int32 = 0\n\t\tsum int32 = 0\n\t\tcurPrice int32 = p\n\t)\n\tfor {\n\t\t// Check current sum with potential game price doesn't exceeds bugdet.\n\t\tif sum + curPrice > s {\n\t\t\tbreak\n\t\t}\n\n\t\t// Update game count and new sum.\n\t\tres++\n\t\tsum += curPrice\n\n\t\t// Update current price according to decrement and minimum game price.\n\t\tif curPrice - d > m {\n\t\t\tcurPrice -= d\n\t\t} else {\n\t\t\tcurPrice = m\n\t\t}\n\t}\n\treturn res\n}", "id": 7079, "concepts": ["integer arithmetic", "integer comparison", "integer decrement", "integer summation"], "_raw_llm_output": "integer arithmetic, integer comparison, integer decrement, integer summation"}
{"seed": "// AutodefinedReverseFlag_Values returns all elements of the AutodefinedReverseFlag enum\nfunc AutodefinedReverseFlag_Values() []string {\n\treturn []string{\n\t\tAutodefinedReverseFlagEnable,\n\t\tAutodefinedReverseFlagDisable,\n\t\tAutodefinedReverseFlagUseLocalResourceSetting,\n\t}\n}", "id": 7098, "concepts": ["enum", "string iteration"], "_raw_llm_output": "enum, string iteration"}
{"seed": "// NewNegotiableQuoteCouponManagementV1RemoveDeleteParams creates a new NegotiableQuoteCouponManagementV1RemoveDeleteParams object\n// with the default values initialized.\nfunc NewNegotiableQuoteCouponManagementV1RemoveDeleteParams() *NegotiableQuoteCouponManagementV1RemoveDeleteParams {\n\tvar ()\n\treturn &NegotiableQuoteCouponManagementV1RemoveDeleteParams{\n\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 7100, "concepts": ["struct initialization", "pointer usage", "method definition"], "_raw_llm_output": "struct initialization, pointer usage, method definition"}
{"seed": "// Begin a span within the current trace. Return a new context that should be\n// used for operations that logically occur within the span, and a report\n// function that must be called with the outcome of the logical operation\n// represented by the span.\n//\n// If no trace is active, no span will be created but ctx and report will still\n// be valid.\nfunc StartSpan(\n\tparent context.Context,\n\tdesc string) (ctx context.Context, report ReportFunc) {\n\t// Look for the trace state.\n\tval := parent.Value(traceStateKey)\n\tif val == nil {\n\t\t// Nothing to do.\n\t\tctx = parent\n\t\treport = func(err error) {}\n\t\treturn\n\t}\n\n\tts := val.(*traceState)\n\n\t// Set up the report function.\n\treport = ts.CreateSpan(desc)\n\n\t// For now we don't do anything interesting with the context. In the future,\n\t// we may use it to record span hierarchy.\n\tctx = parent\n\n\treturn\n}", "id": 7105, "concepts": ["context package usage", "context.Context", "context.Value", "context.WithValue", "context.Background", "context.TODO", "context.Deadline", "context.WithCancel", "context.WithDeadline", "context.WithTimeout", "context.WithValue", "context.WithValue", "context.Context", "context.Context.Value", "context.Context.Deadline", "context.Context.Done", "context.Context.Err", "context.Context.Value", "context.Context.WithValue", "context.Context.Deadline", "context.Context.Done", "context.Context.Err", "context.Context.Value", "context.Context.Deadline", "context.Context.Done", "context.Context.Err", "context.Context.Value", "context.Context.Deadline", "context.Context.Done", "context.Context.Err", "context.Context.Value", "context.Context.Deadline", "context.Context.Done", "context.Context.Err", "context.Context.Value", "context.Context.Deadline", "context.Context.Done", "context.Context.Err", "context.Context.Value", "context.Context.Deadline", "context.Context.Done", "context.Context.Err", "context.Context.Value", "context.Context.Deadline", "context.Context.Done", "context.Context.Err", "context."], "_raw_llm_output": "context package usage, context.Context, context.Value, context.WithValue, context.Background, context.TODO, context.Deadline, context.WithCancel, context.WithDeadline, context.WithTimeout, context.WithValue, context.WithValue, context.Context, context.Context.Value, context.Context.Deadline, context.Context.Done, context.Context.Err, context.Context.Value, context.Context.WithValue, context.Context.Deadline, context.Context.Done, context.Context.Err, context.Context.Value, context.Context.Deadline, context.Context.Done, context.Context.Err, context.Context.Value, context.Context.Deadline, context.Context.Done, context.Context.Err, context.Context.Value, context.Context.Deadline, context.Context.Done, context.Context.Err, context.Context.Value, context.Context.Deadline, context.Context.Done, context.Context.Err, context.Context.Value, context.Context.Deadline, context.Context.Done, context.Context.Err, context.Context.Value, context.Context.Deadline, context.Context.Done, context.Context.Err, context."}
{"seed": "// NatGatewaySku_ARMGenerator returns a generator of NatGatewaySku_ARM instances for property testing.\nfunc NatGatewaySku_ARMGenerator() gopter.Gen {\n\tif natGatewaySku_ARMGenerator != nil {\n\t\treturn natGatewaySku_ARMGenerator\n\t}\n\n\tgenerators := make(map[string]gopter.Gen)\n\tAddIndependentPropertyGeneratorsForNatGatewaySku_ARM(generators)\n\tnatGatewaySku_ARMGenerator = gen.Struct(reflect.TypeOf(NatGatewaySku_ARM{}), generators)\n\n\treturn natGatewaySku_ARMGenerator\n}", "id": 7107, "concepts": ["reflection", "property testing", "struct definition", "generator definition"], "_raw_llm_output": "reflection, property testing, struct definition, generator definition"}
{"seed": "// DropOptional applies equality check predicate on the \"drop_optional\" field. It's identical to DropOptionalEQ.\nfunc DropOptional(v string) predicate.User {\n\treturn predicate.User(sql.FieldEQ(FieldDropOptional, v))\n}", "id": 7108, "concepts": ["interface", "sql package usage", "sql.FieldEQ"], "_raw_llm_output": "interface, sql package usage, sql.FieldEQ"}
{"seed": "// resourceNetboxIpamPrefixDelete deletes an existing Prefix by ID.\nfunc resourceNetboxIpamPrefixDelete(d *schema.ResourceData, meta interface{}) error {\n\tlog.Debugf(\"Deleting Prefix: %v\\n\", d)\n\n\tid := int64(d.Get(\"prefix_id\").(int))\n\n\tvar deleteParameters = ipam.NewIPAMPrefixesDeleteParams().WithID(id)\n\n\tc := meta.(*ProviderNetboxClient).client\n\n\tout, err := c.IPAM.IPAMPrefixesDelete(deleteParameters, nil)\n\n\tif err != nil {\n\t\tlog.Debugf(\"Failed to execute IPAMPrefixesDelete: %v\", err)\n\t}\n\n\tlog.Debugf(\"Done Executing IPAMPrefixesDelete: %v\", out)\n\n\treturn nil\n}", "id": 7132, "concepts": ["schema package usage", "resource deletion", "netbox API usage"], "_raw_llm_output": "schema package usage, resource deletion, netbox API usage"}
{"seed": "// addOneNode recursively down to leaf, and add the new node to the leaf,\n// then rebuild the tree from the leaf to root.\n// the main purpose is reduce two linked red nodes and keep the black count balance.\n//\n// code comment use the following terms:\n// - N as the balance node\n// - L as the left child of N\n// - R as the right child of N\n// - P as the parent of N\n// - LL as the left child of left child of N\n// - RR as the right child of right child of N\nfunc addOneNode(node *Node, pos Position, one *Node) *Node {\n\t// case 1: first node\n\tif node == nil {\n\t\treturn one\n\t}\n\n\tif one.Item.Less(node.Item) {\n\t\tnode.Left = addOneNode(node.Left, Left, one)\n\n\t\t// case 2: L is black means it's already balance.\n\t\tif node.Left.Color == Black {\n\t\t\treturn node\n\t\t}\n\n\t\tif node.Color == Red {\n\t\t\t// case 3: L is red, N is red, N is right child of P\n\t\t\t// execute: right rotate up the L\n\t\t\t// result: the black count through L,N will not change, but let it match the case 4\n\t\t\tif pos == Right {\n\t\t\t\tnode = RightRotate(node)\n\t\t\t}\n\n\t\t\t// case 4: L is red, N is red, N is left child of P\n\t\t\t// execute: nothing\n\t\t\t// result: it's the case 5 of PP\n\t\t\treturn node\n\t\t}\n\n\t\tif node.Left.Left != nil && node.Left.Left.Color == Red {\n\t\t\t// case 5: N is black, L is red, LL is red\n\t\t\t// execute: right rotate N, and make LL to black\n\t\t\t// result: black count through N is not change, while that through LL increase 1, tree is now balance.\n\t\t\tnode = RightRotate(node)\n\t\t\tnode.Left.Color = Black\n\t\t}\n\n\t\treturn node\n\t}\n\n\tif node.Item.Less(one.Item) {\n\t\tnode.Right = addOneNode(node.Right, Right, one)\n\n\t\t// case 2: R is black means it's already balance\n\t\tif node.Right.Color == Black {\n\t\t\treturn node\n\t\t}\n\n\t\tif node.Color == Red {\n\t\t\tif pos == Left {\n\t\t\t\t// case 3: R is red, N is red, N is left child of P\n\t\t\t\t// execute: left rotate up the R\n\t\t\t\t// result: the black count through R,N will not change, but let it match the case 4\n\t\t\t\tnode = LeftRotate(node)\n\t\t\t}\n\n\t\t\t// case 4: R is red, N is red, N is right child of P\n\t\t\t// execute: nothing\n\t\t\t// result: it's the case 5 of PP\n\t\t\treturn node\n\t\t}\n\n\t\t// case 5: N is black, R is red, RR is red\n\t\t// execute: left rotate N, and make RR to black\n\t\t// result: black count through N is not change, while that through RR increase 1, tree is now balance.\n\t\tif node.Right.Right != nil && node.Right.Right.Color == Red {\n\t\t\tnode = LeftRotate(node)\n\t\t\tnode.Right.Color = Black\n\t\t}\n\n\t\treturn node\n\t}\n\n\t// case 6: find the exists node, just replace the old value with the new\n\tnode.Item = one.Item\n\n\treturn node\n}", "id": 7150, "concepts": ["recursion", "tree traversal", "tree rotation", "tree rebalance"], "_raw_llm_output": "recursion, tree traversal, tree rotation, tree rebalance"}
{"seed": "// NewAlertsClient creates a new instance of AlertsClient with the specified values.\n//   - credential - used to authorize requests. Usually a credential from azidentity.\n//   - options - pass nil to accept the default values.\nfunc NewAlertsClient(credential azcore.TokenCredential, options *arm.ClientOptions) (*AlertsClient, error) {\n\tcl, err := arm.NewClient(moduleName+\".AlertsClient\", moduleVersion, credential, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tclient := &AlertsClient{\n\t\tinternal: cl,\n\t}\n\treturn client, nil\n}", "id": 7153, "concepts": ["azcore.TokenCredential", "arm.Client", "anonymous function", "function definition", "standard library usage"], "_raw_llm_output": "azcore.TokenCredential, arm.Client, anonymous function, function definition, standard library usage"}
{"seed": "// IsDirectory returns true if a given path points to a directory.\nfunc IsDirectory(filePath string) bool {\n\tstat, err := os.Stat(filePath)\n\tif err != nil {\n\t\treturn false\n\t}\n\treturn stat.IsDir()\n}", "id": 7167, "concepts": ["os.Stat usage", "os.IsDir usage"], "_raw_llm_output": "os.Stat usage, os.IsDir usage"}
{"seed": "// Frame_ is a convenience wrapper for Frame without the attrs argument.\nfunc Frame_(children ...HTML) HTML {\n  return Frame(nil, children...)\n}", "id": 7169, "concepts": ["function definition", "variadic function argument", "function return value"], "_raw_llm_output": "function definition, variadic function argument, function return value"}
{"seed": "// MustParseVMStorageKey parses VMStorage key and panics on failure.\nfunc MustParseVMStorageKey(key []byte) *dvmTypes.VMAccessPath {\n\t// Key length is expected to be correct: {address_20bytes}:{path_at_least_1byte}\n\texpectedMinLen := VMAddressLength + len(KeyDelimiter) + 1\n\tif len(key) < expectedMinLen {\n\t\tpanic(fmt.Errorf(\"VMKey (%s): invalid key length: expected / actual: %d / %d\", string(key), expectedMinLen, len(key)))\n\t}\n\n\t// Calc indices\n\taddressStartIdx := 0\n\taddressEndIdx := addressStartIdx + VMAddressLength\n\tdelimiterStartIdx := addressEndIdx\n\tdelimiterEndIdx := delimiterStartIdx + len(KeyDelimiter)\n\tpathStartIdx := delimiterEndIdx\n\n\t// Split key\n\taddressValue := key[addressStartIdx:addressEndIdx]\n\tdelimiterValue := key[delimiterStartIdx:delimiterEndIdx]\n\tpathValue := key[pathStartIdx:]\n\n\t// Validate\n\tif !bytes.Equal(delimiterValue, KeyDelimiter) {\n\t\tpanic(fmt.Errorf(\"VMKey (%s): 1st delimiter value is invalid\", string(key)))\n\t}\n\tif len(addressValue) < VMAddressLength {\n\t\tpanic(fmt.Errorf(\"VMKey (%s): address length is invalid: expected / actual: %d / %d\", string(key), VMAddressLength, len(addressValue)))\n\t}\n\tif len(pathValue) == 0 {\n\t\tpanic(fmt.Errorf(\"VMKey (%s): path length is invalid: expected / actual: GT 1 / %d\", string(key), len(pathValue)))\n\t}\n\n\treturn &dvmTypes.VMAccessPath{\n\t\tAddress: addressValue,\n\t\tPath:    pathValue,\n\t}\n}", "id": 7174, "concepts": ["byte slice manipulation", "string comparison", "panic handling"], "_raw_llm_output": "byte slice manipulation, string comparison, panic handling"}
{"seed": "// GetAllSubDirs returns all subdirectories of given root path.\n// Slice does not include given path itself.\nfunc GetAllSubDirs(rootPath string) ([]string, error) {\n\tif !IsDir(rootPath) {\n\t\treturn nil, errors.New(\"not a directory or does not exist: \" + rootPath)\n\t}\n\treturn statDir(rootPath, \"\", true, true)\n}", "id": 7176, "concepts": ["os.Stat", "os.IsDir", "os.ReadDir", "os.File.Readdirnames", "os.File.Readdir", "os.File.Readdirnames", "os.File.Readdir", "os.File.Readdirnames", "os.File.Readdir", "os.File.Readdirnames", "os.File.Readdir", "os.File.Readdirnames", "os.File.Readdir", "os.File.Readdirnames", "os.File.Readdir", "os.File.Readdirnames", "os.File.Readdir", "os.File.Readdirnames", "os.File.Readdir", "os.File.Readdirnames", "os.File.Readdir", "os.File.Readdirnames", "os.File.Readdir", "os.File.Readdirnames", "os.File.Readdir", "os.File.Readdirnames", "os.File.Readdir", "os.File.Readdirnames", "os.File.Readdir", "os.File.Readdirnames", "os.File.Readdir", "os.File.Readdirnames", "os.File.Readdir", "os.File.Readdirnames", "os.File.Readdir", "os"], "_raw_llm_output": "os.Stat, os.IsDir, os.ReadDir, os.File.Readdirnames, os.File.Readdir, os.File.Readdirnames, os.File.Readdir, os.File.Readdirnames, os.File.Readdir, os.File.Readdirnames, os.File.Readdir, os.File.Readdirnames, os.File.Readdir, os.File.Readdirnames, os.File.Readdir, os.File.Readdirnames, os.File.Readdir, os.File.Readdirnames, os.File.Readdir, os.File.Readdirnames, os.File.Readdir, os.File.Readdirnames, os.File.Readdir, os.File.Readdirnames, os.File.Readdir, os.File.Readdirnames, os.File.Readdir, os.File.Readdirnames, os.File.Readdir, os.File.Readdirnames, os.File.Readdir, os.File.Readdirnames, os.File.Readdir, os.File.Readdirnames, os.File.Readdir, os"}
{"seed": "// TransfertobankaccountNEQ applies the NEQ predicate on the \"transfertobankaccount\" field.\nfunc TransfertobankaccountNEQ(v float64) predicate.Bulk {\n\treturn predicate.Bulk(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldTransfertobankaccount), v))\n\t})\n}", "id": 7181, "concepts": ["sql.Selector", "sql.NEQ", "sql.C", "sql.Where", "sql.Bulk"], "_raw_llm_output": "sql.Selector, sql.NEQ, sql.C, sql.Where, sql.Bulk"}
{"seed": "// NewMemory creates new memory based repo with provided options.\n// opts can be nil, it  will be replaced with defaults.\n// Any field in opts can be nil, they will be replaced by defaults.\nfunc NewMemory(opts *MemRepoOptions) *MemRepo {\n\tif opts == nil {\n\t\topts = &MemRepoOptions{}\n\t}\n\tif opts.Ds == nil {\n\t\topts.Ds = dssync.MutexWrap(datastore.NewMapDatastore())\n\t}\n\tif opts.KeyStore == nil {\n\t\topts.KeyStore = make(map[string]types.KeyInfo)\n\t}\n\n\treturn &MemRepo{\n\t\trepoLock:   make(chan struct{}, 1),\n\t\tblockstore: blockstore.WrapIDStore(blockstore.NewMemorySync()),\n\t\tdatastore:  opts.Ds,\n\t\tkeystore:   opts.KeyStore,\n\t}\n}", "id": 7183, "concepts": ["struct definition", "struct field initialization", "map definition", "map element initialization", "function definition", "function parameter", "function return"], "_raw_llm_output": "struct definition, struct field initialization, map definition, map element initialization, function definition, function parameter, function return"}
{"seed": "// NewConfigWithIncludes parses a configuration blob and recursively\n// any specified `include` directive.\n// Any relative include path is considered to be relative to `basedir`.\n// If `basedir` is empty, relative paths will be resolved from the current\n// working directory.\n//\n// Note that the order of the includes is meaningful: the latest includes will\n// override the earliest. The inclusion tree is traversed depth-first\n// pre-order, so the inner includes have always more priority than the outer\n// (top-level) ones. Recursion alert!\n// The recursion depth has a hard limit of 512, which should be enough to avoid\n// loops.\nfunc NewConfigWithIncludes(data []byte, basedir string) (*Config, error) {\n\tmaxDepth, currentDepth := uint(512), uint(0)\n\treturn newConfigWithIncludes(data, basedir, maxDepth, currentDepth)\n}", "id": 7193, "concepts": ["recursion", "depth-first search", "recursion depth limit", "recursion depth calculation"], "_raw_llm_output": "recursion, depth-first search, recursion depth limit, recursion depth calculation"}
{"seed": "// DumpBody returns the contents of m.Body\n// while resetting m.Body\n// allowing it to be read from later.\nfunc DumpBody(m *Message) ([]byte, error) {\n\tb := m.Body\n\t// inspired by https://golang.org/src/net/http/httputil/dump.go#L26\n\tvar buf bytes.Buffer\n\n\tif _, err := buf.ReadFrom(b); err != nil {\n\t\treturn nil, err\n\t}\n\tm.Body = &buf\n\n\treturn buf.Bytes(), nil\n}", "id": 7220, "concepts": ["http.Request", "http.Response", "http.Client", "http.Get", "http.Post", "http.PostForm", "http.NewRequest", "http.Client.Do", "http.Client.Get", "http.Client.Post", "http.Client.PostForm", "http.Client.Transport", "http.Transport.RoundTrip", "http.RoundTripper", "http.RoundTripper.RoundTrip", "http.Request.Header", "http.Request.Body", "http.Request.Close", "http.Request.ContentLength", "http.Request.Method", "http.Request.URL", "http.Response.Body", "http.Response.Close", "http.Response.ContentLength", "http.Response.Header", "http.Response.StatusCode", "http.Response.Status", "http.Response.TLS", "http.Response.Trailer", "http.Response.TransferEncoding", "http.Response.Uncompressed", "http.Response.Write", "http.Response.WriteProxy", "http.Response.WriteProxyBody", "http.Response.WriteProxyTrailer", "http.Response.WriteProxyTrailerBody", "http.Response.WriteProxyTrailerHeader", "http.Response.WriteProxyTrailerHeaderBody", "http.Response.WriteProxyTrailerHeaderBody", ""], "_raw_llm_output": "http.Request, http.Response, http.Client, http.Get, http.Post, http.PostForm, http.NewRequest, http.Client.Do, http.Client.Get, http.Client.Post, http.Client.PostForm, http.Client.Transport, http.Transport.RoundTrip, http.RoundTripper, http.RoundTripper.RoundTrip, http.Request.Header, http.Request.Body, http.Request.Close, http.Request.ContentLength, http.Request.Method, http.Request.URL, http.Response.Body, http.Response.Close, http.Response.ContentLength, http.Response.Header, http.Response.StatusCode, http.Response.Status, http.Response.TLS, http.Response.Trailer, http.Response.TransferEncoding, http.Response.Uncompressed, http.Response.Write, http.Response.WriteProxy, http.Response.WriteProxyBody, http.Response.WriteProxyTrailer, http.Response.WriteProxyTrailerBody, http.Response.WriteProxyTrailerHeader, http.Response.WriteProxyTrailerHeaderBody, http.Response.WriteProxyTrailerHeaderBody,"}
{"seed": "// NewReplicaDesc returns an empty *distributor.ReplicaDesc.\nfunc NewReplicaDesc() *ReplicaDesc {\n\treturn &ReplicaDesc{}\n}", "id": 7229, "concepts": ["struct definition", "struct field definition", "struct field initialization"], "_raw_llm_output": "struct definition, struct field definition, struct field initialization"}
{"seed": "// ColorDistance returns the maximum absolute difference between each component of a and b.\n// Both a and b are assumed to be RGBA colors.\nfunc ColorDistance(a, b color.Color) int {\n\taR, aG, aB, aA := a.RGBA()\n\tbR, bG, bB, bA := b.RGBA()\n\tabs := func(a int) int {\n\t\tif a < 0 {\n\t\t\treturn -a\n\t\t}\n\t\treturn a\n\t}\n\tmax := func(nums ...int) int {\n\t\tm := 0\n\t\tfor _, n := range nums {\n\t\t\tif n > m {\n\t\t\t\tm = n\n\t\t\t}\n\t\t}\n\t\treturn m\n\t}\n\t// Interestingly, the RGBA method returns components in the range [0, 0xFFFF] corresponding\n\t// to the 8-bit values multiplied by 0x101 (see https://blog.golang.org/image). Therefore,\n\t// we must shift them to the right by 8 so that they are in the more typical [0, 255] range.\n\treturn max(abs(int(aR>>8)-int(bR>>8)),\n\t\tabs(int(aG>>8)-int(bG>>8)),\n\t\tabs(int(aB>>8)-int(bB>>8)),\n\t\tabs(int(aA>>8)-int(bA>>8)))\n}", "id": 7240, "concepts": ["color manipulation", "color.RGBA usage", "integer arithmetic", "error handling (errors.New)", "function definition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", ""], "_raw_llm_output": "color manipulation, color.RGBA usage, integer arithmetic, error handling (errors.New), function definition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition,"}
{"seed": "// Gdirname returns the first filename from a buffer of directory entries,\n// and a slice containing the remaining directory entries.\n// If the buffer doesn't start with a valid directory entry, the returned name is nil.\n//go:nosplit\nfunc gdirname(buf []byte) (name []byte, rest []byte) {\n\tif 2+nameOffset+2 > len(buf) {\n\t\treturn\n\t}\n\tentryLen, buf := gbit16(buf)\n\tif entryLen > len(buf) {\n\t\treturn\n\t}\n\tn, b := gbit16(buf[nameOffset:])\n\tif n > len(b) {\n\t\treturn\n\t}\n\tname = b[:n]\n\trest = buf[entryLen:]\n\treturn\n}", "id": 7253, "concepts": ["bit manipulation", "byte manipulation", "slice manipulation", "slice iteration (range loop)", "bitwise operations", "integer manipulation", "string manipulation", "byte comparison", "string comparison", "string formatting", "string concatenation", "string manipulation"], "_raw_llm_output": "bit manipulation, byte manipulation, slice manipulation, slice iteration (range loop), bitwise operations, integer manipulation, string manipulation, byte comparison, string comparison, string formatting, string concatenation, string manipulation"}
{"seed": "// prefixPattern creates a regular expression that matches strings beginning with\n// the given pattern.\nfunc prefixPattern(pattern *regexp.Regexp) *regexp.Regexp {\n\treturn regexp.MustCompile(\"^\" + pattern.String())\n}", "id": 7254, "concepts": ["regexp usage", "regexp.MustCompile", "regexp.Regexp"], "_raw_llm_output": "regexp usage, regexp.MustCompile, regexp.Regexp"}
{"seed": "// NewSpaceError creates a new error given space spc, a value used in an operation and the return state of the implemented operation.\n// NewSpaceError returns a structure which fulfils the error interface and if an operation error has occured.\n// NewSpaceError returns nil if no operation failure has occured.\nfunc NewSpaceError(spc *Space, value interface{}, state interface{}) error {\n\tvar msg, sid, val string\n\tvar err error\n\tvar sop bool\n\tvar libInfo, usrInfo function.CallerInfo\n\tvar status interface{}\n\n\tlibInfo = function.ExtractCallerInfo(libCallDepth)\n\tusrInfo = function.ExtractCallerInfo(usrCallDepth)\n\n\tif spc == nil {\n\t\tsid = \"nil\"\n\t\tmsg = errMsg[SpaceInvalid]\n\t\tstatus = nil\n\t} else if state != nil {\n\t\tsid = (*spc).id\n\n\t\tspct := reflect.ValueOf(spc)\n\n\t\tmethod := spct.MethodByName(\"InterpretError\")\n\t\tif method.IsValid() {\n\t\t\tvals := method.Call([]reflect.Value{reflect.ValueOf(state)})\n\t\t\tif len(vals) == 1 {\n\t\t\t\tmsg = vals[0].String()\n\t\t\t} else {\n\t\t\t\tmsg = errMsg[SpaceNoErrorMethod]\n\t\t\t}\n\t\t} else {\n\t\t\tmsg = errMsg[SpaceNoErrorMethod]\n\t\t}\n\n\t\tmethod = spct.MethodByName(\"InterpretOperation\")\n\t\tif method.IsValid() {\n\t\t\tvals := method.Call([]reflect.Value{reflect.ValueOf(state)})\n\t\t\tif len(vals) == 1 {\n\t\t\t\tsop = vals[0].Interface().(bool)\n\t\t\t} else {\n\t\t\t\tsop = false\n\t\t\t}\n\t\t} else {\n\t\t\tsop = false\n\t\t}\n\n\t\tmethod = spct.MethodByName(\"InterpretValue\")\n\t\tif method.IsValid() {\n\t\t\tvals := method.Call([]reflect.Value{reflect.ValueOf(value)})\n\t\t\tif len(vals) == 1 {\n\t\t\t\tval = vals[0].Interface().(string)\n\t\t\t} else {\n\t\t\t\tval = \"\"\n\t\t\t}\n\t\t} else {\n\t\t\tval = \"\"\n\t\t}\n\n\t\tstatus = state\n\t}\n\n\tif sop == true {\n\t\terr = nil\n\t} else {\n\t\tif state != nil {\n\t\t\terr = SpaceError{Msg: msg, LibInfo: libInfo, UsrInfo: usrInfo, Sid: sid, Val: val, Sop: sop, Status: status}\n\t\t}\n\t}\n\n\treturn err\n}", "id": 7264, "concepts": ["error handling (error interface)", "error handling (error struct)", "error handling (error type)", "error handling (error type)", "error handling (error type)", "error handling (error type)", "error handling (error type)", "error handling (error type)", "error handling (error type)", "error handling (error type)", "error handling (error type)", "error handling (error type)", "error handling (error type)", "error handling (error type)", "error handling (error type)", "error handling (error type)", "error handling (error type)", "error handling (error type)", "error handling (error type)", "error handling (error type)", "error handling (error type)", "error handling (error type)", "error handling (error type)", "error handling (error type)", "error handling (error type)", "error handling (error type)", "error handling (error type)", "error handling (error type)", "error handling (error type)", "error handling (error type)", "error handling (error type)", "error handling (error type)", "error handling (error type)", "error handling (error type)", "error handling (error type)", "error handling (error type)", "error handling (error type)", "error handling (error type)", "error handling (error type)", "error handling (error type)", "error handling (error type)", "error handling (error type)", "error handling ("], "_raw_llm_output": "error handling (error interface), error handling (error struct), error handling (error type), error handling (error type), error handling (error type), error handling (error type), error handling (error type), error handling (error type), error handling (error type), error handling (error type), error handling (error type), error handling (error type), error handling (error type), error handling (error type), error handling (error type), error handling (error type), error handling (error type), error handling (error type), error handling (error type), error handling (error type), error handling (error type), error handling (error type), error handling (error type), error handling (error type), error handling (error type), error handling (error type), error handling (error type), error handling (error type), error handling (error type), error handling (error type), error handling (error type), error handling (error type), error handling (error type), error handling (error type), error handling (error type), error handling (error type), error handling (error type), error handling (error type), error handling (error type), error handling (error type), error handling (error type), error handling (error type), error handling ("}
{"seed": "// NewASLParser produces a new parser instance for the optional input antlr.TokenStream.\n//\n// The *ASLParser instance produced may be reused by calling the SetInputStream method.\n// The initial parser configuration is expensive to construct, and the object is not thread-safe;\n// however, if used within a Golang sync.Pool, the construction cost amortizes well and the\n// objects can be used in a thread-safe manner.\nfunc NewASLParser(input antlr.TokenStream) *ASLParser {\n\tthis := new(ASLParser)\n\tdeserializer := antlr.NewATNDeserializer(nil)\n\tdeserializedATN := deserializer.DeserializeFromUInt16(parserATN)\n\tdecisionToDFA := make([]*antlr.DFA, len(deserializedATN.DecisionToState))\n\tfor index, ds := range deserializedATN.DecisionToState {\n\t\tdecisionToDFA[index] = antlr.NewDFA(ds, index)\n\t}\n\tthis.BaseParser = antlr.NewBaseParser(input)\n\n\tthis.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())\n\tthis.RuleNames = ruleNames\n\tthis.LiteralNames = literalNames\n\tthis.SymbolicNames = symbolicNames\n\tthis.GrammarFileName = \"ASL.g4\"\n\n\treturn this\n}", "id": 7266, "concepts": ["ANTLR parser", "ANTLR grammar", "ANTLR parser generator", "ANTLR parser generator usage"], "_raw_llm_output": "ANTLR parser, ANTLR grammar, ANTLR parser generator, ANTLR parser generator usage"}
{"seed": "// IsError returns an ErrorIdentifier for the specified target error,\n// matched using `errors.Is()`. Use like\n//\n//     p.Add(pipe.IgnoreError(someStage, IsError(io.EOF)))\nfunc IsError(target error) ErrorMatcher {\n\treturn func(err error) bool {\n\t\treturn errors.Is(err, target)\n\t}\n}", "id": 7268, "concepts": ["error handling (errors.Is)", "error matching"], "_raw_llm_output": "error handling (errors.Is), error matching"}
{"seed": "// Facade around jwt.Parser.ParseUnverified used to create a jwt.Token\n// object with parsed headers, JwtVapiClaims, signature and underlined jwt.SigningMethod\n// via which the signature is to be verified. The jwt.SigningMethod is derived from\n// the 'alg' header.\n// Along with the parsed token object an array of strings representing the '.'\n// separated token is returned.\n// returns\n//  (*jwt.Token, []string, nil) for successful parsing\n//  (nil, nil, error) otherwise\nfunc parseUnverified(tokenString string) (*jwt.Token, []string, error) {\n\tparser := jwt.NewParser(jwt.WithoutClaimsValidation())\n\tclaims := &JwtVapiClaims{}\n\ttoken, parts, err := parser.ParseUnverified(tokenString, claims)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\t// populate the token signature as in jwt.Parser.ParseWithClaims; parts length is validated in ParseUnverified\n\ttoken.Signature = parts[2]\n\treturn token, parts, nil\n}", "id": 7277, "concepts": ["jwt.Parser", "jwt.Token", "jwt.SigningMethod", "jwt.WithoutClaimsValidation", "jwt.NewParser", "jwt.NewParser", "jwt.NewParser", "jwt.NewParser", "jwt.NewParser", "jwt.NewParser", "jwt.NewParser", "jwt.NewParser", "jwt.NewParser", "jwt.NewParser", "jwt.NewParser", "jwt.NewParser", "jwt.NewParser", "jwt.NewParser", "jwt.NewParser", "jwt.NewParser", "jwt.NewParser", "jwt.NewParser", "jwt.NewParser", "jwt.NewParser", "jwt.NewParser", "jwt.NewParser", "jwt.NewParser", "jwt.NewParser", "jwt.NewParser", "jwt.NewParser", "jwt.NewParser", "jwt.NewParser", "jwt.NewParser", "jwt.NewParser", "jwt.NewParser", "jwt.NewParser", "jwt.NewParser", "jwt.NewParser", "jwt.NewParser", "jwt.NewParser", "jwt.NewParser", "jwt.NewParser", "jwt.NewParser", "jwt.NewParser", "jwt.NewParser", "jwt.NewParser", "jwt.NewParser", "jwt.NewParser", "jwt.NewParser", "jwt.NewParser", "jwt.NewParser", "jwt"], "_raw_llm_output": "jwt.Parser, jwt.Token, jwt.SigningMethod, jwt.WithoutClaimsValidation, jwt.NewParser, jwt.NewParser, jwt.NewParser, jwt.NewParser, jwt.NewParser, jwt.NewParser, jwt.NewParser, jwt.NewParser, jwt.NewParser, jwt.NewParser, jwt.NewParser, jwt.NewParser, jwt.NewParser, jwt.NewParser, jwt.NewParser, jwt.NewParser, jwt.NewParser, jwt.NewParser, jwt.NewParser, jwt.NewParser, jwt.NewParser, jwt.NewParser, jwt.NewParser, jwt.NewParser, jwt.NewParser, jwt.NewParser, jwt.NewParser, jwt.NewParser, jwt.NewParser, jwt.NewParser, jwt.NewParser, jwt.NewParser, jwt.NewParser, jwt.NewParser, jwt.NewParser, jwt.NewParser, jwt.NewParser, jwt.NewParser, jwt.NewParser, jwt.NewParser, jwt.NewParser, jwt.NewParser, jwt.NewParser, jwt.NewParser, jwt.NewParser, jwt.NewParser, jwt.NewParser, jwt"}
{"seed": "// Determine whether a parameter name ends at the current position,\n// that is, whether the given character qualifies as a separator.\nfunc isParameterSeparator(c rune) bool {\n\tif unicode.IsSpace(c) {\n\t\treturn true\n\t}\n\tfor _, ps := range PARAMETER_SEPARATORS {\n\t\tif c == ps {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}", "id": 7280, "concepts": ["rune handling", "unicode handling", "string manipulation"], "_raw_llm_output": "rune handling, unicode handling, string manipulation"}
{"seed": "// GetMutableBag returns an initialized bag.\n//\n// Bags can be chained in a parent/child relationship. You can pass nil if the\n// bag has no parent.\n//\n// When you are done using the mutable bag, call the Done method to recycle it.\nfunc GetMutableBag(parent Bag) *MutableBag {\n\tmb := mutableBags.Get().(*MutableBag)\n\n\tmb.parent = parent\n\tif parent == nil {\n\t\tmb.parent = empty\n\t}\n\n\treturn mb\n}", "id": 7284, "concepts": ["bag pattern", "pointer usage", "standard library usage"], "_raw_llm_output": "bag pattern, pointer usage, standard library usage"}
{"seed": "// CallAndRecover calls the function f and returns the result of recover().\n// This minimizes the scope of the deferred recover, to ensure f is actually the\n// function that paniced.\n//\n//nolint:unused\nfunc CallAndRecover(f func()) (result interface{}) {\n\tdefer func() {\n\t\tresult = recover()\n\t}()\n\tf()\n\treturn\n}", "id": 7287, "concepts": ["defer", "recover", "panic", "function definition"], "_raw_llm_output": "defer, recover, panic, function definition"}
{"seed": "// U_ is a convenience wrapper for U without the attrs argument.\nfunc U_(children ...HTML) HTML {\n  return U(nil, children...)\n}", "id": 7288, "concepts": ["function definition", "function argument handling", "variadic function"], "_raw_llm_output": "function definition, function argument handling, variadic function"}
{"seed": "// FromRequest gets the logger in the request's context.\n// This is a shortcut for log.Ctx(r.Context())\nfunc FromRequest(r *http.Request) *zerolog.Logger {\n\treturn log.Ctx(r.Context())\n}", "id": 7293, "concepts": ["http.Request", "zerolog.Logger", "context package usage"], "_raw_llm_output": "http.Request, zerolog.Logger, context package usage"}
{"seed": "// FullGameLeaderboard retrieves a the leaderboard for a specific game and one of\n// its full-game categories. An error is returned if no category is given or if\n// a per-level category is given. If no game is given, it is fetched automatically,\n// but if you have it already at hand, you can save one request by specifying it.\nfunc FullGameLeaderboard(game *Game, cat *Category, options *LeaderboardOptions, embeds string) (*Leaderboard, *Error) {\n\tif cat == nil {\n\t\treturn nil, &Error{\"\", \"\", ErrorBadLogic, \"No category given.\"}\n\t}\n\n\tif cat.Type != \"per-game\" {\n\t\treturn nil, &Error{\"\", \"\", ErrorBadLogic, \"The given category is not a full-game category.\"}\n\t}\n\n\tif game == nil {\n\t\tvar err *Error\n\n\t\tgame, err = cat.Game(\"\")\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn fetchLeaderboard(request{\"GET\", \"/leaderboards/\" + game.ID + \"/category/\" + cat.ID, options, nil, nil, embeds})\n}", "id": 7302, "concepts": ["error handling (idiomatic)", "string manipulation", "string comparison", "string concatenation", "string formatting", "string conversion", "string length", "string indexing", "string slicing", "string substring", "string comparison", "string concatenation", "string formatting", "string conversion", "string length", "string indexing", "string slicing", "string substring", "string comparison", "string concatenation", "string formatting", "string conversion", "string length", "string indexing", "string slicing", "string substring", "string comparison", "string concatenation", "string formatting", "string conversion", "string length", "string indexing", "string slicing", "string substring", "string comparison", "string concatenation", "string formatting", "string conversion", "string length", "string indexing", "string slicing", "string substring", "string comparison", "string concatenation", "string formatting", "string conversion", "string length", "string indexing", "string slicing", "string substring", "string comparison", "string concatenation", "string formatting", "string conversion", "string length", "string indexing", "string slicing", "string substring", "string comparison", "string concatenation", "string formatting", "string conversion", "string length", "string indexing", "string slicing", "string substring", "string comparison", "string concatenation", "string formatting", "string conversion", "string length", "string indexing", "string slicing", "string substring", "string comparison", "string concatenation", "string formatting", "string"], "_raw_llm_output": "error handling (idiomatic), string manipulation, string comparison, string concatenation, string formatting, string conversion, string length, string indexing, string slicing, string substring, string comparison, string concatenation, string formatting, string conversion, string length, string indexing, string slicing, string substring, string comparison, string concatenation, string formatting, string conversion, string length, string indexing, string slicing, string substring, string comparison, string concatenation, string formatting, string conversion, string length, string indexing, string slicing, string substring, string comparison, string concatenation, string formatting, string conversion, string length, string indexing, string slicing, string substring, string comparison, string concatenation, string formatting, string conversion, string length, string indexing, string slicing, string substring, string comparison, string concatenation, string formatting, string conversion, string length, string indexing, string slicing, string substring, string comparison, string concatenation, string formatting, string conversion, string length, string indexing, string slicing, string substring, string comparison, string concatenation, string formatting, string conversion, string length, string indexing, string slicing, string substring, string comparison, string concatenation, string formatting, string"}
{"seed": "// rawError returns an Error from a failed parse tree with the raw, morphological errors.\n// The FilePath on the returned Error is the empty string,\n// but can be set by the caller.\nfunc rawError(text string, n *peg.Fail) *Error {\n\tfails := getLeaves(n)\n\tsort.Slice(fails, func(i, j int) bool {\n\t\tswitch a, b := fails[i], fails[j]; {\n\t\tcase namedError(a) && !namedError(b):\n\t\t\treturn false\n\t\tcase !namedError(a) && namedError(b):\n\t\t\treturn true\n\t\tdefault:\n\t\t\treturn wantString(a) < wantString(b)\n\t\t}\n\t})\n\tmax := -1\n\tvar wants []string\n\tfor _, f := range fails {\n\t\tswitch {\n\t\tcase f.Pos > max:\n\t\t\tmax = f.Pos\n\t\t\twants = []string{wantString(f)}\n\t\tcase f.Pos == max:\n\t\t\twants = append(wants, wantString(f))\n\t\t}\n\t}\n\treturn &Error{Loc: Location(text, max), Want: wants}\n}", "id": 7325, "concepts": ["error handling", "error handling (idiomatic if err != nil)", "error handling (errors.Is)", "error handling (errors.As)", "error handling (errors.New)", "error handling (errors.Wrap)", "error handling (errors.Unwrap)", "error handling (errors.Cause)", "error handling (errors.Errorf)", "error handling (errors.Wrapf)", "error handling (errors.WrapWith)", "error handling (errors.WithMessage)", "error handling (errors.WithMessagef)", "error handling (errors.WithStack)", "error handling (errors.WithStack)", "error handling (errors.Is)", "error handling (errors.As)", "error handling (errors.New)", "error handling (errors.Wrap)", "error handling (errors.Unwrap)", "error handling (errors.Cause)", "error handling (errors.Errorf)", "error handling (errors.Wrapf)", "error handling (errors.WrapWith)", "error handling (errors.WithMessage)", "error handling (errors.WithMessagef)", "error handling (errors.WithStack)", "error handling (errors.WithStack)", "error handling (errors.Is)", "error handling (errors.As)", "error handling (errors.New)", "error handling (errors.Wrap)", "error handling (errors.Unwrap)", "error handling (errors.Cause)", ""], "_raw_llm_output": "error handling, error handling (idiomatic if err != nil), error handling (errors.Is), error handling (errors.As), error handling (errors.New), error handling (errors.Wrap), error handling (errors.Unwrap), error handling (errors.Cause), error handling (errors.Errorf), error handling (errors.Wrapf), error handling (errors.WrapWith), error handling (errors.WithMessage), error handling (errors.WithMessagef), error handling (errors.WithStack), error handling (errors.WithStack), error handling (errors.Is), error handling (errors.As), error handling (errors.New), error handling (errors.Wrap), error handling (errors.Unwrap), error handling (errors.Cause), error handling (errors.Errorf), error handling (errors.Wrapf), error handling (errors.WrapWith), error handling (errors.WithMessage), error handling (errors.WithMessagef), error handling (errors.WithStack), error handling (errors.WithStack), error handling (errors.Is), error handling (errors.As), error handling (errors.New), error handling (errors.Wrap), error handling (errors.Unwrap), error handling (errors.Cause),"}
{"seed": "// Kbd_ is a convenience wrapper for Kbd without the attrs argument.\nfunc Kbd_(children ...HTML) HTML {\n  return Kbd(nil, children...)\n}", "id": 7329, "concepts": ["HTML", "HTML tag", "HTML attribute", "HTML attribute value", "HTML child", "HTML child element", "HTML child element attribute", "HTML child element attribute value", "HTML child element attribute value", "HTML child element attribute value", "HTML child element attribute value", "HTML child element attribute value", "HTML child element attribute value", "HTML child element attribute value", "HTML child element attribute value", "HTML child element attribute value", "HTML child element attribute value", "HTML child element attribute value", "HTML child element attribute value", "HTML child element attribute value", "HTML child element attribute value", "HTML child element attribute value", "HTML child element attribute value", "HTML child element attribute value", "HTML child element attribute value", "HTML child element attribute value", "HTML child element attribute value", "HTML child element attribute value", "HTML child element attribute value", "HTML child element attribute value", "HTML child element attribute value", "HTML child element attribute value", "HTML child element attribute value", "HTML child element attribute value", "HTML child element attribute value", "HTML child element attribute value", "HTML child element attribute value", "HTML child element attribute value", "HTML child element attribute value", "HTML child element attribute value", "HTML child element attribute value", "HTML child element attribute value", "HTML child element attribute value", "HTML child element attribute value", "HTML child element attribute value", "HTML child element"], "_raw_llm_output": "HTML, HTML tag, HTML attribute, HTML attribute value, HTML child, HTML child element, HTML child element attribute, HTML child element attribute value, HTML child element attribute value, HTML child element attribute value, HTML child element attribute value, HTML child element attribute value, HTML child element attribute value, HTML child element attribute value, HTML child element attribute value, HTML child element attribute value, HTML child element attribute value, HTML child element attribute value, HTML child element attribute value, HTML child element attribute value, HTML child element attribute value, HTML child element attribute value, HTML child element attribute value, HTML child element attribute value, HTML child element attribute value, HTML child element attribute value, HTML child element attribute value, HTML child element attribute value, HTML child element attribute value, HTML child element attribute value, HTML child element attribute value, HTML child element attribute value, HTML child element attribute value, HTML child element attribute value, HTML child element attribute value, HTML child element attribute value, HTML child element attribute value, HTML child element attribute value, HTML child element attribute value, HTML child element attribute value, HTML child element attribute value, HTML child element attribute value, HTML child element attribute value, HTML child element attribute value, HTML child element attribute value, HTML child element"}
{"seed": "// BulkCreditSamedayNotIn applies the NotIn predicate on the \"bulkCreditSameday\" field.\nfunc BulkCreditSamedayNotIn(vs ...float64) predicate.Bulk {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.Bulk(func(s *sql.Selector) {\n\t\t// if not arguments were provided, append the FALSE constants,\n\t\t// since we can't apply \"IN ()\". This will make this predicate falsy.\n\t\tif len(v) == 0 {\n\t\t\ts.Where(sql.False())\n\t\t\treturn\n\t\t}\n\t\ts.Where(sql.NotIn(s.C(FieldBulkCreditSameday), v...))\n\t})\n}", "id": 7338, "concepts": ["sql package usage", "sql.Selector", "sql.NotIn", "sql.False", "sql.C", "sql.Where", "sql.Bulk", "sql.Predicate", "sql.Selector.C", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql"], "_raw_llm_output": "sql package usage, sql.Selector, sql.NotIn, sql.False, sql.C, sql.Where, sql.Bulk, sql.Predicate, sql.Selector.C, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql"}
{"seed": "// arnStrToARN returns the given ARN string as a structured ARN.\nfunc arnStrToARN(arnStr string) (*apis.ARN, error) {\n\tarn, err := arn.Parse(arnStr)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"parsing ARN string: %w\", err)\n\t}\n\n\tapiARN := apis.ARN(arn)\n\treturn &apiARN, nil\n}", "id": 7352, "concepts": ["parsing", "string manipulation", "error handling", "standard library usage"], "_raw_llm_output": "parsing, string manipulation, error handling, standard library usage"}
{"seed": "// getDeviceID extract the device ID from Mqtt topic.\nfunc getDeviceID(topic string) (id string) {\n\tre := regexp.MustCompile(`hw/events/device/(.+)/twin/update/delta`)\n\treturn re.FindStringSubmatch(topic)[1]\n}", "id": 7353, "concepts": ["regular expression usage (regexp.MustCompile)", "string matching (regexp.FindStringSubmatch)", "basic function definition"], "_raw_llm_output": "regular expression usage (regexp.MustCompile), string matching (regexp.FindStringSubmatch), basic function definition"}
{"seed": "// Output represents the HTML element 'output'.\n// For more information visit https://www.w3schools.com/tags/tag_output.asp.\nfunc Output(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"output\", Attributes: attrs, Children: children}\n}", "id": 7371, "concepts": ["HTML generation", "HTML tree representation", "basic function definition"], "_raw_llm_output": "HTML generation, HTML tree representation, basic function definition"}
{"seed": "// EncodeAddress encodes the given IP address into the byte format appropriate\n// for NETINFO cells and other purposes.\nfunc EncodeAddress(ip net.IP) []byte {\n\t// Referenced in tor spec but in relation to something else.\n\t//\n\t// Reference: https://github.com/torproject/torspec/blob/8aaa36d1a062b20ca263b6ac613b77a3ba1eb113/tor-spec.txt#L1659-L1669\n\t//\n\t//\t       Type   (1 octet)\n\t//\t       Length (1 octet)\n\t//\t       Value  (variable-width)\n\t//\t       TTL    (4 octets)\n\t//\t   \"Length\" is the length of the Value field.\n\t//\t   \"Type\" is one of:\n\t//\t      0x00 -- Hostname\n\t//\t      0x04 -- IPv4 address\n\t//\t      0x06 -- IPv6 address\n\t//\t      0xF0 -- Error, transient\n\t//\t      0xF1 -- Error, nontransient\n\t//\n\t// Reference: https://github.com/torproject/tor/blob/51e47481fc6f131d4e421de061029459ccbb033e/src/or/relay.c#L3015-L3042\n\t//\n\t//\t/** Append an encoded value of <b>addr</b> to <b>payload_out</b>, which must\n\t//\t * have at least 18 bytes of free space.  The encoding is, as specified in\n\t//\t * tor-spec.txt:\n\t//\t *   RESOLVED_TYPE_IPV4 or RESOLVED_TYPE_IPV6  [1 byte]\n\t//\t *   LENGTH                                    [1 byte]\n\t//\t *   ADDRESS                                   [length bytes]\n\t//\t * Return the number of bytes added, or -1 on error */\n\t//\tint\n\t//\tappend_address_to_payload(uint8_t *payload_out, const tor_addr_t *addr)\n\t//\t{\n\t//\t  uint32_t a;\n\t//\t  switch (tor_addr_family(addr)) {\n\t//\t  case AF_INET:\n\t//\t    payload_out[0] = RESOLVED_TYPE_IPV4;\n\t//\t    payload_out[1] = 4;\n\t//\t    a = tor_addr_to_ipv4n(addr);\n\t//\t    memcpy(payload_out+2, &a, 4);\n\t//\t    return 6;\n\t//\t  case AF_INET6:\n\t//\t    payload_out[0] = RESOLVED_TYPE_IPV6;\n\t//\t    payload_out[1] = 16;\n\t//\t    memcpy(payload_out+2, tor_addr_to_in6_addr8(addr), 16);\n\t//\t    return 18;\n\t//\t  case AF_UNSPEC:\n\t//\t  default:\n\t//\t    return -1;\n\t//\t  }\n\t//\t}\n\t//\n\t// Reference: https://github.com/torproject/tor/blob/506b4bfabaf823225c34172fae6dd405cfe1b58e/src/or/or.h#L665-L669\n\t//\n\t//\t#define RESOLVED_TYPE_HOSTNAME 0\n\t//\t#define RESOLVED_TYPE_IPV4 4\n\t//\t#define RESOLVED_TYPE_IPV6 6\n\t//\t#define RESOLVED_TYPE_ERROR_TRANSIENT 0xF0\n\t//\t#define RESOLVED_TYPE_ERROR 0xF1\n\t//\n\n\tip4 := ip.To4()\n\tif ip4 != nil {\n\t\treturn append([]byte{4, 4}, ip4...)\n\t}\n\n\tip16 := ip.To16()\n\tif ip16 != nil {\n\t\treturn append([]byte{6, 16}, ip16...)\n\t}\n\n\treturn nil\n}", "id": 7373, "concepts": ["net.IP", "net.IP.To4", "net.IP.To16", "byte slice concatenation", "byte slice iteration (range loop)", "byte slice length", "byte slice indexing", "byte slice assignment", "basic function definition"], "_raw_llm_output": "net.IP, net.IP.To4, net.IP.To16, byte slice concatenation, byte slice iteration (range loop), byte slice length, byte slice indexing, byte slice assignment, basic function definition"}
{"seed": "// NewRemoveDOMStorageItemArgs initializes RemoveDOMStorageItemArgs with the required arguments.\nfunc NewRemoveDOMStorageItemArgs(storageID StorageID, key string) *RemoveDOMStorageItemArgs {\n\targs := new(RemoveDOMStorageItemArgs)\n\targs.StorageID = storageID\n\targs.Key = key\n\treturn args\n}", "id": 7390, "concepts": ["struct initialization", "basic function definition"], "_raw_llm_output": "struct initialization, basic function definition"}
{"seed": "// newKnativeServiceCreated makes a new reconciler event with event type Normal, and\n// reason ServiceCreated.\nfunc newKnativeServiceCreated(namespace, name string) pkgreconciler.Event {\n\treturn pkgreconciler.NewEvent(corev1.EventTypeNormal, \"KnativeServiceCreated\", \"created service: \\\"%s/%s\\\"\", namespace, name)\n}", "id": 7419, "concepts": ["event creation", "event type", "event reason", "event message"], "_raw_llm_output": "event creation, event type, event reason, event message"}
{"seed": "// LightUserDataValue returns a Value holding the given arg.\nfunc LightUserDataValue(d LightUserData) Value {\n\treturn Value{iface: d}\n}", "id": 7425, "concepts": ["struct definition", "interface definition", "basic function definition"], "_raw_llm_output": "struct definition, interface definition, basic function definition"}
{"seed": "// playMSEVideo plays an MSE video stream via Shaka player, and checks its play progress.\n// mpdFile is the name of MPD file for the video stream.\n// url is the URL of the shaka player webpage.\nfunc playMSEVideo(ctx context.Context, cs ash.ConnSource, mpdFile, url string) (bool, error) {\n\tctx, st := timing.Start(ctx, \"play_mse_video\")\n\tdefer st.End()\n\n\tconn, err := loadPage(ctx, cs, url)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tdefer conn.Close()\n\tdefer conn.CloseTarget(ctx)\n\n\tobserver, err := conn.GetMediaPropertiesChangedObserver(ctx)\n\tif err != nil {\n\t\treturn false, errors.Wrap(err, \"failed to retrieve a media DevTools observer\")\n\t}\n\n\tif err := conn.Call(ctx, nil, \"play_shaka\", mpdFile); err != nil {\n\t\treturn false, err\n\t}\n\n\tisPlatform, _, err := devtools.GetVideoDecoder(ctx, observer, url)\n\treturn isPlatform, err\n}", "id": 7442, "concepts": ["context", "error handling", "error wrapping", "string manipulation", "map iteration", "function definition", "function call", "standard library usage", "concurrency", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard library usage", "standard"], "_raw_llm_output": "context, error handling, error wrapping, string manipulation, map iteration, function definition, function call, standard library usage, concurrency, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard library usage, standard"}
{"seed": "// GetLogReader returns a reader for the specified filename. In\n// restricted mode, the filename must be the base name of a file in\n// this process's log directory (this is safe for cases when the\n// filename comes from external sources, such as the admin UI via\n// HTTP). In unrestricted mode any path is allowed, relative to the\n// current directory, with the added feature that simple (base name)\n// file names will be searched in this process's log directory if not\n// found in the current directory.\nfunc GetLogReader(filename string, restricted bool) (io.ReadCloser, error) {\n\tdir, err := logging.logDir.get()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tswitch restricted {\n\tcase true:\n\t\t// Verify there are no path separators in a restricted-mode pathname.\n\t\tif filepath.Base(filename) != filename {\n\t\t\treturn nil, errors.Errorf(\"pathnames must be basenames only: %s\", filename)\n\t\t}\n\t\tfilename = filepath.Join(dir, filename)\n\t\t// Symlinks are not followed in restricted mode.\n\t\tinfo, err := os.Lstat(filename)\n\t\tif err != nil {\n\t\t\tif os.IsNotExist(err) {\n\t\t\t\treturn nil, errors.Errorf(\"no such file %s in the log directory\", filename)\n\t\t\t}\n\t\t\treturn nil, errors.Wrapf(err, \"Lstat: %s\", filename)\n\t\t}\n\t\tmode := info.Mode()\n\t\tif mode&os.ModeSymlink != 0 {\n\t\t\treturn nil, errors.Errorf(\"symlinks are not allowed\")\n\t\t}\n\t\tif !mode.IsRegular() {\n\t\t\treturn nil, errors.Errorf(\"not a regular file\")\n\t\t}\n\tcase false:\n\t\tinfo, err := osStat(filename)\n\t\tif err != nil {\n\t\t\tif !os.IsNotExist(err) {\n\t\t\t\treturn nil, errors.Wrapf(err, \"Stat: %s\", filename)\n\t\t\t}\n\t\t\t// The absolute filename didn't work, so try within the log\n\t\t\t// directory if the filename isn't a path.\n\t\t\tif filepath.IsAbs(filename) {\n\t\t\t\treturn nil, errors.Errorf(\"no such file %s\", filename)\n\t\t\t}\n\t\t\tfilenameAttempt := filepath.Join(dir, filename)\n\t\t\tinfo, err = osStat(filenameAttempt)\n\t\t\tif err != nil {\n\t\t\t\tif os.IsNotExist(err) {\n\t\t\t\t\treturn nil, errors.Errorf(\"no such file %s either in current directory or in %s\", filename, dir)\n\t\t\t\t}\n\t\t\t\treturn nil, errors.Wrapf(err, \"Stat: %s\", filename)\n\t\t\t}\n\t\t\tfilename = filenameAttempt\n\t\t}\n\t\tfilename, err = filepath.EvalSymlinks(filename)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif !info.Mode().IsRegular() {\n\t\t\treturn nil, errors.Errorf(\"not a regular file\")\n\t\t}\n\t}\n\n\t// Check that the file name is valid.\n\tif _, err := parseLogFilename(filepath.Base(filename)); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn os.Open(filename)\n}", "id": 7452, "concepts": ["file system access", "file name validation", "file name parsing", "file name evaluation", "file name resolution", "file name evaluation", "file name validation", "file name parsing", "file name validation", "file name parsing", "file name validation", "file name parsing", "file name validation", "file name parsing", "file name validation", "file name parsing", "file name validation", "file name parsing", "file name validation", "file name parsing", "file name validation", "file name parsing", "file name validation", "file name parsing", "file name validation", "file name parsing", "file name validation", "file name parsing", "file name validation", "file name parsing", "file name validation", "file name parsing", "file name validation", "file name parsing", "file name validation", "file name parsing", "file name validation", "file name parsing", "file name validation", "file name parsing", "file name validation", "file name parsing", "file name validation", "file name parsing", "file name validation", "file name parsing", "file name validation", "file name parsing", "file name validation", "file name parsing", "file name validation", "file name parsing", "file name validation", "file name parsing", "file name validation", "file name parsing", "file name validation", "file name parsing", "file name validation", "file name parsing", "file name validation", "file name parsing", "file name validation", "file name parsing"], "_raw_llm_output": "file system access, file name validation, file name parsing, file name evaluation, file name resolution, file name evaluation, file name validation, file name parsing, file name validation, file name parsing, file name validation, file name parsing, file name validation, file name parsing, file name validation, file name parsing, file name validation, file name parsing, file name validation, file name parsing, file name validation, file name parsing, file name validation, file name parsing, file name validation, file name parsing, file name validation, file name parsing, file name validation, file name parsing, file name validation, file name parsing, file name validation, file name parsing, file name validation, file name parsing, file name validation, file name parsing, file name validation, file name parsing, file name validation, file name parsing, file name validation, file name parsing, file name validation, file name parsing, file name validation, file name parsing, file name validation, file name parsing, file name validation, file name parsing, file name validation, file name parsing, file name validation, file name parsing, file name validation, file name parsing, file name validation, file name parsing, file name validation, file name parsing, file name validation, file name parsing"}
{"seed": "// NewGetMarketsRegionIDHistoryParamsWithHTTPClient creates a new GetMarketsRegionIDHistoryParams object\n// with the default values initialized, and the ability to set a custom HTTPClient for a request\nfunc NewGetMarketsRegionIDHistoryParamsWithHTTPClient(client *http.Client) *GetMarketsRegionIDHistoryParams {\n\tvar (\n\t\tdatasourceDefault = string(\"tranquility\")\n\t)\n\treturn &GetMarketsRegionIDHistoryParams{\n\t\tDatasource: &datasourceDefault,\n\t\tHTTPClient: client,\n\t}\n}", "id": 7467, "concepts": ["http.Client usage", "default values", "function definition"], "_raw_llm_output": "http.Client usage, default values, function definition"}
{"seed": "// volumeAction creates a CheckRunAction which matches the one\n// kube-ci sets up for volume deletion.\nfunc volumeAction(scope string) *github.CheckRunAction {\n\tif scope == \"\" {\n\t\treturn nil\n\t}\n\ttask := \"clearCache\"\n\tif scope == \"branch\" {\n\t\ttask = \"clearCacheBranch\"\n\t}\n\n\treturn &github.CheckRunAction{\n\t\tLabel:       \"Clear Cache\",\n\t\tDescription: \"delete the cache volume for this build\",\n\t\tIdentifier:  task,\n\t}\n}", "id": 7469, "concepts": ["string comparison", "nil pointer handling", "pointer dereference", "struct definition"], "_raw_llm_output": "string comparison, nil pointer handling, pointer dereference, struct definition"}
{"seed": "// SocialAvatarURLHasPrefix applies the HasPrefix predicate on the \"social_avatar_url\" field.\nfunc SocialAvatarURLHasPrefix(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.HasPrefix(s.C(FieldSocialAvatarURL), v))\n\t})\n}", "id": 7473, "concepts": ["sql.Selector", "sql.C", "sql.HasPrefix", "predicate.User", "function definition"], "_raw_llm_output": "sql.Selector, sql.C, sql.HasPrefix, predicate.User, function definition"}
{"seed": "// NewGetContactsParamsWithTimeout creates a new GetContactsParams object\n// with the default values initialized, and the ability to set a timeout on a request\nfunc NewGetContactsParamsWithTimeout(timeout time.Duration) *GetContactsParams {\n\tvar (\n\t\tlimitDefault  = int32(5000)\n\t\toffsetDefault = int32(0)\n\t)\n\treturn &GetContactsParams{\n\t\tLimit:  &limitDefault,\n\t\tOffset: &offsetDefault,\n\n\t\ttimeout: timeout,\n\t}\n}", "id": 7479, "concepts": ["struct initialization", "pointer receivers", "method receivers", "method definition", "method call", "method chaining", "method composition", "method composition with anonymous function", "method composition with anonymous function with method call", "method composition with anonymous function with method call with method call", "method composition with anonymous function with method call with method call with method call", "method composition with anonymous function with method call with method call with method call with method call", "method composition with anonymous function with method call with method call with method call with method call with method call", "method composition with anonymous function with method call with method call with method call with method call with method call with method call", "method composition with anonymous function with method call with method call with method call with method call with method call with method call with method call", "method composition with anonymous function with method call with method call with method call with method call with method call with method call with method call with method call", "method composition with anonymous function with method call with method call with method call with method call with method call with method call with method call with method call with method call", "method composition with anonymous function with method call with method call with method call with method call with method call with method call with method call with method call with method call with method call", "method"], "_raw_llm_output": "struct initialization, pointer receivers, method receivers, method definition, method call, method chaining, method composition, method composition with anonymous function, method composition with anonymous function with method call, method composition with anonymous function with method call with method call, method composition with anonymous function with method call with method call with method call, method composition with anonymous function with method call with method call with method call with method call, method composition with anonymous function with method call with method call with method call with method call with method call, method composition with anonymous function with method call with method call with method call with method call with method call with method call, method composition with anonymous function with method call with method call with method call with method call with method call with method call with method call, method composition with anonymous function with method call with method call with method call with method call with method call with method call with method call with method call, method composition with anonymous function with method call with method call with method call with method call with method call with method call with method call with method call with method call, method composition with anonymous function with method call with method call with method call with method call with method call with method call with method call with method call with method call with method call, method"}
{"seed": "// intersectingComponentRoutes takes a slice of componentRouteSpec and a slice\n// of componentRouteStatus, identifies which (namespace,name) tuples appear in\n// both slices, and returns a slice of aggregatedComponentRoute corresponding to\n// those tuples if they require Roles and RoleBindings.\nfunc intersectingComponentRoutes(componentRouteSpecs []configv1.ComponentRouteSpec, componentRouteStatuses []configv1.ComponentRouteStatus) []aggregatedComponentRoute {\n\tcomponentRouteHashToComponentRouteStatus := map[string]configv1.ComponentRouteStatus{}\n\tfor _, componentRouteStatus := range componentRouteStatuses {\n\t\tcomponentRouteHash := util.Hash(namespacedName(componentRouteStatus.Namespace, componentRouteStatus.Name))\n\t\tcomponentRouteHashToComponentRouteStatus[componentRouteHash] = componentRouteStatus\n\t}\n\n\tcomponentRoutes := []aggregatedComponentRoute{}\n\tfor _, componentRouteSpec := range componentRouteSpecs {\n\t\thash := util.Hash(namespacedName(componentRouteSpec.Namespace, componentRouteSpec.Name))\n\t\tif componentRouteStatus, ok := componentRouteHashToComponentRouteStatus[hash]; ok {\n\t\t\tcomponentRoute := newAggregatedComponentRoute(componentRouteSpec, componentRouteStatus)\n\t\t\tif componentRoute.requiresRBAC() {\n\t\t\t\tcomponentRoutes = append(componentRoutes, componentRoute)\n\t\t\t}\n\t\t}\n\t}\n\treturn componentRoutes\n}", "id": 7481, "concepts": ["map iteration (range loop)", "map lookup", "map creation", "map deletion", "map iteration (range loop)", "slice iteration (range loop)", "string hashing", "string formatting", "string manipulation", "string comparison", "string concatenation", "string conversion", "string length", "string slice", "string slicing", "string substring", "string trimming", "string formatting", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation"], "_raw_llm_output": "map iteration (range loop), map lookup, map creation, map deletion, map iteration (range loop), slice iteration (range loop), string hashing, string formatting, string manipulation, string comparison, string concatenation, string conversion, string length, string slice, string slicing, string substring, string trimming, string formatting, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation"}
{"seed": "// CreateAllocateImageBlueprint creates empty ImageBlueprint\nfunc CreateAllocateImageBlueprint() *ImageBlueprint {\n\treturn &ImageBlueprint{Blueprint: *CreateBlueprint(\"IMAGE\")}\n}", "id": 7488, "concepts": ["struct definition", "struct field assignment", "pointer usage"], "_raw_llm_output": "struct definition, struct field assignment, pointer usage"}
{"seed": "// Small represents the HTML element 'small'.\n// For more information visit https://www.w3schools.com/tags/tag_small.asp.\nfunc Small(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"small\", Attributes: attrs, Children: children}\n}", "id": 7495, "concepts": ["HTML generation", "HTML tree generation", "HTML element definition", "HTML attribute definition"], "_raw_llm_output": "HTML generation, HTML tree generation, HTML element definition, HTML attribute definition"}
{"seed": "// FileDescriptorSet returns a descriptor set for this proto package, which\n// includes all defined services, and all transitive dependencies.\n//\n// Will not return nil.\n//\n// Do NOT modify the returned descriptor.\nfunc FileDescriptorSet() *descriptor.FileDescriptorSet {\n\t// We just need ONE of the service names to look up the FileDescriptorSet.\n\tret, err := discovery.GetDescriptorSet(\"logdog.Logs\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn ret\n}", "id": 7501, "concepts": ["descriptor.FileDescriptorSet", "descriptor.FileDescriptor", "descriptor.ServiceDescriptor", "descriptor.ServiceDescriptorProto", "descriptor.MethodDescriptor", "descriptor.MethodDescriptorProto", "descriptor.FileOptions", "descriptor.FileOptions_OptimizeMode", "descriptor.SourceCodeInfo", "descriptor.SourceCodeInfo_Location", "descriptor.SourceCodeInfo_Location_Span", "descriptor.SourceCodeInfo_Location_Span_Location", "descriptor.SourceCodeInfo_Location_Span_Location_Path", "descriptor.SourceCodeInfo_Location_Span_Location_Fragment", "descriptor.SourceCodeInfo_Location_Span_Location_Fragment_Fragment", "descriptor.SourceCodeInfo_Location_Span_Location_Fragment_Fragment_Start", "descriptor.SourceCodeInfo_Location_Span_Location_Fragment_Fragment_Start_Line", "descriptor.SourceCodeInfo_Location_Span_Location_Fragment_Fragment_Start_Column", "descriptor.SourceCodeInfo_Location_Span_Location_Fragment_Fragment_End", "descriptor.SourceCodeInfo_Location_Span_Location_Fragment_Fragment_End_Line", "descriptor.SourceCodeInfo_Location_Span_Location_Fragment_Fragment_End_Column", "descriptor.SourceCodeInfo_Location_Span_Location_Fragment_Fragment_Start"], "_raw_llm_output": "descriptor.FileDescriptorSet, descriptor.FileDescriptor, descriptor.ServiceDescriptor, descriptor.ServiceDescriptorProto, descriptor.MethodDescriptor, descriptor.MethodDescriptorProto, descriptor.FileOptions, descriptor.FileOptions_OptimizeMode, descriptor.SourceCodeInfo, descriptor.SourceCodeInfo_Location, descriptor.SourceCodeInfo_Location_Span, descriptor.SourceCodeInfo_Location_Span_Location, descriptor.SourceCodeInfo_Location_Span_Location_Path, descriptor.SourceCodeInfo_Location_Span_Location_Fragment, descriptor.SourceCodeInfo_Location_Span_Location_Fragment_Fragment, descriptor.SourceCodeInfo_Location_Span_Location_Fragment_Fragment_Start, descriptor.SourceCodeInfo_Location_Span_Location_Fragment_Fragment_Start_Line, descriptor.SourceCodeInfo_Location_Span_Location_Fragment_Fragment_Start_Column, descriptor.SourceCodeInfo_Location_Span_Location_Fragment_Fragment_End, descriptor.SourceCodeInfo_Location_Span_Location_Fragment_Fragment_End_Line, descriptor.SourceCodeInfo_Location_Span_Location_Fragment_Fragment_End_Column, descriptor.SourceCodeInfo_Location_Span_Location_Fragment_Fragment_Start"}
{"seed": "// StatusEQ applies the EQ predicate on the \"status\" field.\nfunc StatusEQ(v Status) predicate.User {\n\treturn predicate.User(sql.FieldEQ(FieldStatus, v))\n}", "id": 7504, "concepts": ["interface", "struct", "field equality check", "sql package usage"], "_raw_llm_output": "interface, struct, field equality check, sql package usage"}
{"seed": "// DMessageEmbedExistsP checks if the DMessageEmbed row exists. Panics on error.\nfunc DMessageEmbedExistsP(exec boil.Executor, id int64) bool {\n\te, err := DMessageEmbedExists(exec, id)\n\tif err != nil {\n\t\tpanic(boil.WrapErr(err))\n\t}\n\n\treturn e\n}", "id": 7505, "concepts": ["database query", "panic handling", "boil package usage"], "_raw_llm_output": "database query, panic handling, boil package usage"}
{"seed": "// RiskDetailPAiConfirmedSigninSafe returns a pointer to RiskDetailVAiConfirmedSigninSafe\nfunc RiskDetailPAiConfirmedSigninSafe() *RiskDetail {\n\tv := RiskDetailVAiConfirmedSigninSafe\n\treturn &v\n}", "id": 7515, "concepts": ["pointer", "struct", "pointer dereference"], "_raw_llm_output": "pointer, struct, pointer dereference"}
{"seed": "// Next returns a zero status code and empty response. Will make the\n// `Handlers` function move on to the next handler.\nfunc Next() (int, Response) {\n\treturn 0, Response{}\n}", "id": 7518, "concepts": ["zero status code", "empty response"], "_raw_llm_output": "zero status code, empty response"}
{"seed": "// readLabels takes a path to a labels file, parses out, and returns all labels\n// as a slice of strings\nfunc readLabels(labelsPath string) ([]string, error) {\n\t// Open the passed labels file and defer close it\n\tf, err := os.Open(labelsPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer f.Close()\n\n\t// Scan all lines and populate a slice of labels\n\tvar labels []string\n\ts := bufio.NewScanner(f)\n\tfor s.Scan() {\n\t\tlabels = append(labels, s.Text())\n\t}\n\tif err := s.Err(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn labels, nil\n}", "id": 7519, "concepts": ["file handling (os.Open", "bufio.NewScanner)", "error handling (os.Open", "bufio.NewScanner)", "slice population"], "_raw_llm_output": "file handling (os.Open, bufio.NewScanner), error handling (os.Open, bufio.NewScanner), slice population"}
{"seed": "// GetStringVal retrieves a string value from given environment envVar\n// Returns default value if envVar is not set.\nfunc GetStringVal(envVar string, defaultValue string) string {\n\tif val := os.Getenv(envVar); val != \"\" {\n\t\treturn val\n\t} else {\n\t\treturn defaultValue\n\t}\n}", "id": 7532, "concepts": ["os.Getenv", "string concatenation", "string comparison", "basic function definition"], "_raw_llm_output": "os.Getenv, string concatenation, string comparison, basic function definition"}
{"seed": "// SeeOther is a convenience function for building HTTP 303 Temporary\n// Redirect responses. It takes no data argument because there isn't much point\n// in custom status text for a redirect response. Instead, it takes a URL that\n// will be used as the Location header, which should be used by clients as the\n// redirect location. When deciding between HTTP 302, 303, and 307, consult\n// https://developer.mozilla.org/en-US/docs/Web/HTTP/Redirections#temporary_redirections.\nfunc SeeOther(location string, logging ...interface{}) Response {\n\treturn Response{\n\t\tStatus:  http.StatusSeeOther,\n\t\tData:    String(\"303 See Other\"),\n\t\tLogging: logging,\n\t\tHeaders: http.Header{\"Location\": []string{location}},\n\t}\n}", "id": 7554, "concepts": ["HTTP status codes", "HTTP 303 status code", "HTTP 302 status code", "HTTP 307 status code", "HTTP 301 status code", "HTTP 302 status code", "HTTP 303 status code", "HTTP 307 status code", "HTTP 301 status code", "HTTP 302 status code", "HTTP 303 status code", "HTTP 307 status code", "HTTP 301 status code", "HTTP 302 status code", "HTTP 303 status code", "HTTP 307 status code", "HTTP 301 status code", "HTTP 302 status code", "HTTP 303 status code", "HTTP 307 status code", "HTTP 301 status code", "HTTP 302 status code", "HTTP 303 status code", "HTTP 307 status code", "HTTP 301 status code", "HTTP 302 status code", "HTTP 303 status code", "HTTP 307 status code", "HTTP 301 status code", "HTTP 302 status code", "HTTP 303 status code", "HTTP 307 status code", "HTTP 3"], "_raw_llm_output": "HTTP status codes, HTTP 303 status code, HTTP 302 status code, HTTP 307 status code, HTTP 301 status code, HTTP 302 status code, HTTP 303 status code, HTTP 307 status code, HTTP 301 status code, HTTP 302 status code, HTTP 303 status code, HTTP 307 status code, HTTP 301 status code, HTTP 302 status code, HTTP 303 status code, HTTP 307 status code, HTTP 301 status code, HTTP 302 status code, HTTP 303 status code, HTTP 307 status code, HTTP 301 status code, HTTP 302 status code, HTTP 303 status code, HTTP 307 status code, HTTP 301 status code, HTTP 302 status code, HTTP 303 status code, HTTP 307 status code, HTTP 301 status code, HTTP 302 status code, HTTP 303 status code, HTTP 307 status code, HTTP 3"}
{"seed": "// NameContains applies the Contains predicate on the \"name\" field.\nfunc NameContains(v string) predicate.User {\n\treturn predicate.User(sql.FieldContains(FieldName, v))\n}", "id": 7561, "concepts": ["SQL query building", "SQL query execution", "SQL query execution with error handling", "SQL query execution with error handling", "SQL query execution with error handling", "SQL query execution with error handling", "SQL query execution with error handling", "SQL query execution with error handling", "SQL query execution with error handling", "SQL query execution with error handling", "SQL query execution with error handling", "SQL query execution with error handling", "SQL query execution with error handling", "SQL query execution with error handling", "SQL query execution with error handling", "SQL query execution with error handling", "SQL query execution with error handling", "SQL query execution with error handling", "SQL query execution with error handling", "SQL query execution with error handling", "SQL query execution with error handling", "SQL query execution with error handling", "SQL query execution with error handling", "SQL query execution with error handling", "SQL query execution with error handling", "SQL query execution with error handling", "SQL query execution with error handling", "SQL query execution with error handling", "SQL query execution with error handling", "SQL query execution with error handling", "SQL query execution with error handling", "SQL query execution with error handling", "SQL query execution with error handling", "SQL query execution with error handling", "SQL query execution with error handling", "SQL query execution with error handling", "SQL query execution with error handling", "SQL query"], "_raw_llm_output": "SQL query building, SQL query execution, SQL query execution with error handling, SQL query execution with error handling, SQL query execution with error handling, SQL query execution with error handling, SQL query execution with error handling, SQL query execution with error handling, SQL query execution with error handling, SQL query execution with error handling, SQL query execution with error handling, SQL query execution with error handling, SQL query execution with error handling, SQL query execution with error handling, SQL query execution with error handling, SQL query execution with error handling, SQL query execution with error handling, SQL query execution with error handling, SQL query execution with error handling, SQL query execution with error handling, SQL query execution with error handling, SQL query execution with error handling, SQL query execution with error handling, SQL query execution with error handling, SQL query execution with error handling, SQL query execution with error handling, SQL query execution with error handling, SQL query execution with error handling, SQL query execution with error handling, SQL query execution with error handling, SQL query execution with error handling, SQL query execution with error handling, SQL query execution with error handling, SQL query execution with error handling, SQL query execution with error handling, SQL query execution with error handling, SQL query execution with error handling, SQL query"}
{"seed": "// NewRenewOrganizationLicensesSeatsParams creates a new RenewOrganizationLicensesSeatsParams object\n// with the default values initialized.\nfunc NewRenewOrganizationLicensesSeatsParams() *RenewOrganizationLicensesSeatsParams {\n\tvar ()\n\treturn &RenewOrganizationLicensesSeatsParams{\n\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 7569, "concepts": ["struct initialization", "basic function definition"], "_raw_llm_output": "struct initialization, basic function definition"}
{"seed": "// InstantiatedPrepareAppUnitName returns the systemd service unit name for prepare-app\n// instantiated for the given root.\nfunc InstantiatedPrepareAppUnitName(appName types.ACName) string {\n\t// Naming respecting escaping rules, see systemd.unit(5) and systemd-escape(1)\n\tescapedRoot := unit.UnitNamePathEscape(common.RelAppRootfsPath(appName))\n\treturn \"prepare-app@-\" + escapedRoot + \".service\"\n}", "id": 7575, "concepts": ["string manipulation", "escaping", "systemd unit naming"], "_raw_llm_output": "string manipulation, escaping, systemd unit naming"}
{"seed": "// HeroRepeatNEQ applies the NEQ predicate on the \"hero_repeat\" field.\nfunc HeroRepeatNEQ(v uint) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldHeroRepeat), v))\n\t})\n}", "id": 7585, "concepts": ["sql.Selector", "sql.NEQ", "sql.C", "sql.Where", "sql.Predicate"], "_raw_llm_output": "sql.Selector, sql.NEQ, sql.C, sql.Where, sql.Predicate"}
{"seed": "// NewLinkFilter creates a new LinkFilter with the specified values.\n// Any preexisting link filter with the same name will be updated with the new code and value.\nfunc NewLinkFilter(name string, code uint64, value any) LinkFilter {\n\treturn func(f encoding.Filter) {\n\t\tvar descriptor any\n\t\tif code != 0 {\n\t\t\tdescriptor = code\n\t\t} else {\n\t\t\tdescriptor = encoding.Symbol(name)\n\t\t}\n\t\tf[encoding.Symbol(name)] = &encoding.DescribedType{\n\t\t\tDescriptor: descriptor,\n\t\t\tValue:      value,\n\t\t}\n\t}\n}", "id": 7604, "concepts": ["function composition", "function definition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", ""], "_raw_llm_output": "function composition, function definition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition,"}
{"seed": "// NewProjectRepository returns a new instance of a in-memory project repository.\nfunc NewProjectRepository() project.Repository {\n\treturn &projectRepository{\n\t\tprojects: make(map[string]*project.Project),\n\t}\n}", "id": 7605, "concepts": ["struct definition", "map usage", "pointer usage"], "_raw_llm_output": "struct definition, map usage, pointer usage"}
{"seed": "// NewStepList provides a StepList instance containing the given step.\nfunc NewStepList(step steps.Step) StepList {\n\treturn StepList{\n\t\tList: []steps.Step{step},\n\t}\n}", "id": 7617, "concepts": ["struct definition", "struct field initialization"], "_raw_llm_output": "struct definition, struct field initialization"}
{"seed": "// NewGetDevicesApsProfilesParamsWithHTTPClient creates a new GetDevicesApsProfilesParams object\n// with the ability to set a custom HTTPClient for a request.\nfunc NewGetDevicesApsProfilesParamsWithHTTPClient(client *http.Client) *GetDevicesApsProfilesParams {\n\treturn &GetDevicesApsProfilesParams{\n\t\tHTTPClient: client,\n\t}\n}", "id": 7621, "concepts": ["http.Client", "function definition", "custom HTTPClient"], "_raw_llm_output": "http.Client, function definition, custom HTTPClient"}
{"seed": "// ExtractExceptionFromResult extracts exceptions defined in thrift IDL from\n// result TStruct used in TClient.Call.\n//\n// For a endpoint defined in thrift IDL like this:\n//\n//     service MyService {\n//       FooResponse foo(1: FooRequest request) throws (\n//         1: Exception1 error1,\n//         2: Exception2 error2,\n//       )\n//     }\n//\n// The thrift compiler generated go code for the result TStruct would be like:\n//\n//     type MyServiceFooResult struct {\n//       Success *FooResponse `thrift:\"success,0\" db:\"success\" json:\"success,omitempty\"`\n//       Error1 *Exception1 `thrift:\"error1,1\" db:\"error1\" json:\"error1,omitempty\"`\n//       Error2 *Exception2 `thrift:\"error2,2\" db:\"error2\" json:\"error2,omitempty\"`\n//     }\n//\n// And this function extracts the first non-nil exception out of\n// *MyServiceFooResult.\nfunc ExtractExceptionFromResult(result TStruct) error {\n\tv := reflect.Indirect(reflect.ValueOf(result))\n\tif v.Kind() != reflect.Struct {\n\t\treturn nil\n\t}\n\ttyp := v.Type()\n\tfor i := 0; i < v.NumField(); i++ {\n\t\tif typ.Field(i).Name == \"Success\" {\n\t\t\tcontinue\n\t\t}\n\t\tfield := v.Field(i)\n\t\tif field.IsZero() {\n\t\t\tcontinue\n\t\t}\n\t\ttExc, ok := field.Interface().(TException)\n\t\tif ok && tExc != nil && tExc.TExceptionType() == TExceptionTypeCompiled {\n\t\t\treturn tExc\n\t\t}\n\t}\n\treturn nil\n}", "id": 7623, "concepts": ["reflection", "TException", "TExceptionType", "TStruct", "TExceptionTypeCompiled"], "_raw_llm_output": "reflection, TException, TExceptionType, TStruct, TExceptionTypeCompiled"}
{"seed": "// IsIterable returns true if the given Value is a slice, array, or map.\nfunc IsIterable(val Value) bool {\n\tif val == nil {\n\t\treturn true\n\t}\n\tr := reflect.Indirect(reflect.ValueOf(val))\n\tswitch r.Kind() {\n\tcase reflect.Slice, reflect.Array, reflect.Map:\n\t\treturn true\n\t}\n\treturn false\n}", "id": 7637, "concepts": ["reflect package usage", "type checking", "reflect.Kind"], "_raw_llm_output": "reflect package usage, type checking, reflect.Kind"}
{"seed": "// New returns a CloudWatch struct configured against the input session.\nfunc New(s *session.Session) *CloudWatch {\n\treturn &CloudWatch{\n\t\tcwClient: cloudwatch.New(s),\n\t\trgClient: resourcegroups.New(s),\n\t}\n}", "id": 7642, "concepts": ["struct definition", "method definition", "pointer receiver", "resource group API usage"], "_raw_llm_output": "struct definition, method definition, pointer receiver, resource group API usage"}
{"seed": "// TNewPEM generates a certificate and private key in PEM format. To override default values, pass\n// a Config value. If an error occurs, t.Error is called.\nfunc TNewPEM(t *testing.T, cfg ...Config) (certificate []byte, key []byte) {\n\tc, k, err := NewPEM(cfg...)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\treturn c, k\n}", "id": 7655, "concepts": ["testing package usage", "testing.T", "testing.B", "testing.Error", "testing.Skip", "testing.Skipf", "testing.Fail", "testing.FailNow", "testing.Fatal", "testing.Fatalf", "testing.Helper", "testing.Run", "testing.RunParallel", "testing.Benchmark", "testing.BenchmarkParallel", "testing.Main", "testing.MainParallel", "testing.Parallel", "testing.Short", "testing.Verbose", "testing.TB", "testing.T.Error", "testing.T.Errorf", "testing.T.Fatal", "testing.T.Fatalf", "testing.T.Helper", "testing.T.Log", "testing.T.Name", "testing.T.Skip", "testing.T.SkipNow", "testing.T.Skipf", "testing.T.Failed", "testing.T.Failedf", "testing.T.FatalAfterFailure", "testing.T.FatalIfFailed", "testing.T.FatalIf", "testing.T.Log", "testing.T.Logf", "testing.T.Run", "testing.T.RunParallel", "testing.T.RunParallel", "testing.T.Parallel", "testing.T.TempDir", "testing.T.TempDir", "testing.T.TempDir", "testing.T.TempDir", "testing.T.TempDir", ""], "_raw_llm_output": "testing package usage, testing.T, testing.B, testing.Error, testing.Skip, testing.Skipf, testing.Fail, testing.FailNow, testing.Fatal, testing.Fatalf, testing.Helper, testing.Run, testing.RunParallel, testing.Benchmark, testing.BenchmarkParallel, testing.Main, testing.MainParallel, testing.Parallel, testing.Short, testing.Verbose, testing.TB, testing.T.Error, testing.T.Errorf, testing.T.Fatal, testing.T.Fatalf, testing.T.Helper, testing.T.Log, testing.T.Name, testing.T.Skip, testing.T.SkipNow, testing.T.Skipf, testing.T.Failed, testing.T.Failedf, testing.T.FatalAfterFailure, testing.T.FatalIfFailed, testing.T.FatalIf, testing.T.Log, testing.T.Logf, testing.T.Run, testing.T.RunParallel, testing.T.RunParallel, testing.T.Parallel, testing.T.TempDir, testing.T.TempDir, testing.T.TempDir, testing.T.TempDir, testing.T.TempDir,"}
{"seed": "// NewExtensionManifest creates a new resolver for the GraphQL type ExtensionManifest with the given\n// raw contents of an extension manifest.\nfunc NewExtensionManifest(raw *string) graphqlbackend.ExtensionManifest {\n\tif raw == nil {\n\t\treturn nil\n\t}\n\treturn &extensionManifest{raw: *raw}\n}", "id": 7667, "concepts": ["interface implementation", "pointer dereferencing", "string handling"], "_raw_llm_output": "interface implementation, pointer dereferencing, string handling"}
{"seed": "// SetupDiClassGuidsFromNameEx retrieves the GUIDs associated with the specified class name. This resulting list contains the classes currently installed on a local or remote computer.\nfunc SetupDiClassGuidsFromNameEx(className string, machineName string) ([]w32.GUID, error) {\n\trequiredSize := uint32(0)\n\terr := setupDiClassGuidsFromNameEx(className, nil, 0, &requiredSize, machineName, 0)\n\n\trets := make([]w32.GUID, requiredSize, requiredSize)\n\terr = setupDiClassGuidsFromNameEx(className, &rets[0], 1, &requiredSize, machineName, 0)\n\treturn rets, err\n}", "id": 7674, "concepts": ["windows API usage", "GUID handling", "string manipulation", "error handling", "standard library usage"], "_raw_llm_output": "windows API usage, GUID handling, string manipulation, error handling, standard library usage"}
{"seed": "// ParseListSksClustersResponse parses an HTTP response from a ListSksClustersWithResponse call\nfunc ParseListSksClustersResponse(rsp *http.Response) (*ListSksClustersResponse, error) {\n\tbodyBytes, err := ioutil.ReadAll(rsp.Body)\n\tdefer rsp.Body.Close()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse := &ListSksClustersResponse{\n\t\tBody:         bodyBytes,\n\t\tHTTPResponse: rsp,\n\t}\n\n\tswitch {\n\tcase strings.Contains(rsp.Header.Get(\"Content-Type\"), \"json\") && rsp.StatusCode == 200:\n\t\tvar dest struct {\n\t\t\tSksClusters *[]SksCluster `json:\"sks-clusters,omitempty\"`\n\t\t}\n\t\tif err := json.Unmarshal(bodyBytes, &dest); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresponse.JSON200 = &dest\n\n\t}\n\n\treturn response, nil\n}", "id": 7676, "concepts": ["HTTP response parsing", "JSON parsing", "JSON unmarshaling", "HTTP response handling"], "_raw_llm_output": "HTTP response parsing, JSON parsing, JSON unmarshaling, HTTP response handling"}
{"seed": "// setSourceIamPolicy grants user roles/securitycenter.findingsEditor permision\n// for a source. sourceName is the full resource name of the source to be\n// updated. user is an email address that IAM can grant permissions to.\nfunc setSourceIamPolicy(w io.Writer, sourceName string, user string) error {\n\t// sourceName := \"organizations/111122222444/sources/1234\"\n\t// user := \"someuser@some_domain.com\n\t// Instantiate a context and a security service client to make API calls.\n\tctx := context.Background()\n\tclient, err := securitycenter.NewClient(ctx)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"securitycenter.NewClient: %w\", err)\n\t}\n\tdefer client.Close() // Closing the client safely cleans up background resources.\n\n\t// Retrieve the existing policy so we can update only a specific\n\t// field.\n\texisting, err := client.GetIamPolicy(ctx, &iam.GetIamPolicyRequest{\n\t\tResource: sourceName,\n\t})\n\tif err != nil {\n\t\treturn fmt.Errorf(\"GetIamPolicy(%s): %w\", sourceName, err)\n\t}\n\n\treq := &iam.SetIamPolicyRequest{\n\t\tResource: sourceName,\n\t\tPolicy: &iam.Policy{\n\t\t\t// Enables partial update of existing policy\n\t\t\tEtag: existing.Etag,\n\t\t\tBindings: []*iam.Binding{{\n\t\t\t\tRole: \"roles/securitycenter.findingsEditor\",\n\t\t\t\t// New IAM Binding for the user.\n\t\t\t\tMembers: []string{fmt.Sprintf(\"user:%s\", user)},\n\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tpolicy, err := client.SetIamPolicy(ctx, req)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"SetIamPolicy(%s, %v): %w\", sourceName, req.Policy, err)\n\t}\n\n\tfmt.Fprint(w, \"Bindings:\\n\")\n\tfor _, binding := range policy.Bindings {\n\t\tfor _, member := range binding.Members {\n\t\t\tfmt.Fprintf(w, \"Principal: %s Role: %s\\n\", member, binding.Role)\n\t\t}\n\t}\n\treturn nil\n}", "id": 7682, "concepts": ["string formatting", "fmt package usage", "iam.Policy", "iam.Binding", "iam.GetIamPolicyRequest", "iam.SetIamPolicyRequest", "iam.Policy", "iam.Binding", "iam.GetIamPolicyRequest", "iam.SetIamPolicyRequest", "iam.Policy", "iam.Binding", "iam.GetIamPolicyRequest", "iam.SetIamPolicyRequest", "iam.Policy", "iam.Binding", "iam.GetIamPolicyRequest", "iam.SetIamPolicyRequest", "iam.Policy", "iam.Binding", "iam.GetIamPolicyRequest", "iam.SetIamPolicyRequest", "iam.Policy", "iam.Binding", "iam.GetIamPolicyRequest", "iam.SetIamPolicyRequest", "iam.Policy", "iam.Binding", "iam.GetIamPolicyRequest", "iam.SetIamPolicyRequest", "iam.Policy", "iam.Binding", "iam.GetIamPolicyRequest", "iam.SetIamPolicyRequest", "iam.Policy", "iam.Binding", "iam.GetIamPolicyRequest", "iam.SetIamPolicyRequest", "iam.Policy", "iam.Binding", "iam.GetIamPolicyRequest", "iam.SetIamPolicyRequest", "iam.Policy", "iam.Binding", "iam.GetIamPolicyRequest", "iam.SetIamPolicyRequest", "iam.Policy", "iam."], "_raw_llm_output": "string formatting, fmt package usage, iam.Policy, iam.Binding, iam.GetIamPolicyRequest, iam.SetIamPolicyRequest, iam.Policy, iam.Binding, iam.GetIamPolicyRequest, iam.SetIamPolicyRequest, iam.Policy, iam.Binding, iam.GetIamPolicyRequest, iam.SetIamPolicyRequest, iam.Policy, iam.Binding, iam.GetIamPolicyRequest, iam.SetIamPolicyRequest, iam.Policy, iam.Binding, iam.GetIamPolicyRequest, iam.SetIamPolicyRequest, iam.Policy, iam.Binding, iam.GetIamPolicyRequest, iam.SetIamPolicyRequest, iam.Policy, iam.Binding, iam.GetIamPolicyRequest, iam.SetIamPolicyRequest, iam.Policy, iam.Binding, iam.GetIamPolicyRequest, iam.SetIamPolicyRequest, iam.Policy, iam.Binding, iam.GetIamPolicyRequest, iam.SetIamPolicyRequest, iam.Policy, iam.Binding, iam.GetIamPolicyRequest, iam.SetIamPolicyRequest, iam.Policy, iam.Binding, iam.GetIamPolicyRequest, iam.SetIamPolicyRequest, iam.Policy, iam."}
{"seed": "// ListLogFiles returns a slice of FileInfo structs for each log file\n// on the local node, in any of the configured log directories.\nfunc ListLogFiles() ([]FileInfo, error) {\n\treturn logging.listLogFiles()\n}", "id": 7689, "concepts": ["os package usage", "logging package usage"], "_raw_llm_output": "os package usage, logging package usage"}
{"seed": "// NewAPIServiceMissedBlocksParamsWithHTTPClient creates a new APIServiceMissedBlocksParams object\n// with the default values initialized, and the ability to set a custom HTTPClient for a request\nfunc NewAPIServiceMissedBlocksParamsWithHTTPClient(client *http.Client) *APIServiceMissedBlocksParams {\n\tvar ()\n\treturn &APIServiceMissedBlocksParams{\n\t\tHTTPClient: client,\n\t}\n}", "id": 7691, "concepts": ["APIServiceMissedBlocksParams", "APIServiceMissedBlocksParamsWithHTTPClient", "http.Client", "function definition"], "_raw_llm_output": "APIServiceMissedBlocksParams, APIServiceMissedBlocksParamsWithHTTPClient, http.Client, function definition"}
{"seed": "// withSingleProxyPort sets up a single proxy port listener config and\n// sets `auth.proxy_listener_mode` to \"multiplex\".\nfunc withSingleProxyPort(t *testing.T) testOptionsFunc {\n\tt.Helper()\n\t// enable proxy single port mode\n\treturn func(options *testOptions) {\n\t\toptions.instanceConfigFuncs = append(options.instanceConfigFuncs, func(cfg *helpers.InstanceConfig) {\n\t\t\tcfg.Listeners = helpers.SingleProxyPortSetup(t, &cfg.Fds)\n\t\t})\n\t\toptions.serviceConfigFuncs = append(options.serviceConfigFuncs, func(cfg *servicecfg.Config) {\n\t\t\tcfg.Auth.NetworkingConfig.SetProxyListenerMode(types.ProxyListenerMode_Multiplex)\n\t\t})\n\t}\n}", "id": 7713, "concepts": ["testing", "testing.T", "testOptionsFunc", "testOptions", "testOptions.instanceConfigFuncs", "testOptions.serviceConfigFuncs", "helpers.InstanceConfig", "helpers.SingleProxyPortSetup", "helpers.SingleProxyPortSetup.t", "helpers.SingleProxyPortSetup.fds", "helpers.SingleProxyPortSetup.t.Helper", "helpers.SingleProxyPortSetup.t.Helper", "helpers.SingleProxyPortSetup.t.Helper", "helpers.SingleProxyPortSetup.t.Helper", "helpers.SingleProxyPortSetup.t.Helper", "helpers.SingleProxyPortSetup.t.Helper", "helpers.SingleProxyPortSetup.t.Helper", "helpers.SingleProxyPortSetup.t.Helper", "helpers.SingleProxyPortSetup.t.Helper", "helpers.SingleProxyPortSetup.t.Helper", "helpers.SingleProxyPortSetup.t.Helper", "helpers.SingleProxyPortSetup.t.Helper", "helpers.SingleProxyPortSetup.t.Helper", "helpers.SingleProxyPortSetup.t.Helper", "helpers.SingleProxyPortSetup.t.Helper", "helpers.SingleProxyPortSetup.t.Helper", "helpers.SingleProxyPortSetup.t.Helper", "helpers.SingleProxyPortSetup.t.Helper", ""], "_raw_llm_output": "testing, testing.T, testOptionsFunc, testOptions, testOptions.instanceConfigFuncs, testOptions.serviceConfigFuncs, helpers.InstanceConfig, helpers.SingleProxyPortSetup, helpers.SingleProxyPortSetup.t, helpers.SingleProxyPortSetup.fds, helpers.SingleProxyPortSetup.t.Helper, helpers.SingleProxyPortSetup.t.Helper, helpers.SingleProxyPortSetup.t.Helper, helpers.SingleProxyPortSetup.t.Helper, helpers.SingleProxyPortSetup.t.Helper, helpers.SingleProxyPortSetup.t.Helper, helpers.SingleProxyPortSetup.t.Helper, helpers.SingleProxyPortSetup.t.Helper, helpers.SingleProxyPortSetup.t.Helper, helpers.SingleProxyPortSetup.t.Helper, helpers.SingleProxyPortSetup.t.Helper, helpers.SingleProxyPortSetup.t.Helper, helpers.SingleProxyPortSetup.t.Helper, helpers.SingleProxyPortSetup.t.Helper, helpers.SingleProxyPortSetup.t.Helper, helpers.SingleProxyPortSetup.t.Helper, helpers.SingleProxyPortSetup.t.Helper, helpers.SingleProxyPortSetup.t.Helper,"}
{"seed": "// PossibleResourceTypeMarketplaceTypeValues returns the possible values for the ResourceTypeMarketplaceType const type.\nfunc PossibleResourceTypeMarketplaceTypeValues() []ResourceTypeMarketplaceType {\n\treturn []ResourceTypeMarketplaceType{\n\t\tResourceTypeMarketplaceTypeAddOn,\n\t\tResourceTypeMarketplaceTypeBypass,\n\t\tResourceTypeMarketplaceTypeNotSpecified,\n\t\tResourceTypeMarketplaceTypeStore,\n\t}\n}", "id": 7718, "concepts": ["constant definition", "type definition", "type conversion", "basic function definition"], "_raw_llm_output": "constant definition, type definition, type conversion, basic function definition"}
{"seed": "// GetCapacityCommitment gets an existing CapacityCommitment resource's state with the given name, ID, and optional\n// state properties that are used to uniquely qualify the lookup (nil if not required).\nfunc GetCapacityCommitment(ctx *pulumi.Context,\n\tname string, id pulumi.IDInput, state *CapacityCommitmentState, opts ...pulumi.ResourceOption) (*CapacityCommitment, error) {\n\tvar resource CapacityCommitment\n\terr := ctx.ReadResource(\"google-native:bigqueryreservation/v1:CapacityCommitment\", name, id, state, &resource, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &resource, nil\n}", "id": 7720, "concepts": ["resource definition", "resource usage", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource property access", "resource"], "_raw_llm_output": "resource definition, resource usage, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource property access, resource"}
{"seed": "// NewHasher is a factory to create an instance of Hasher.\nfunc NewHasher() *Hasher {\n\treturn &Hasher{}\n}", "id": 7722, "concepts": ["factory function", "basic function definition"], "_raw_llm_output": "factory function, basic function definition"}
{"seed": "// GetStartLocation returns the location of the gateway closest to the device\n// in terms of SNR.\nfunc GetStartLocation(rxInfo []*gw.UplinkRXInfo) *common.Location {\n\tvar snr *float64\n\tvar loc *common.Location\n\n\tfor i := range rxInfo {\n\t\tif rxInfo[i].Location == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tif snr == nil || *snr < rxInfo[i].LoraSnr {\n\t\t\tsnr = &rxInfo[i].LoraSnr\n\t\t\tloc = rxInfo[i].Location\n\t\t}\n\t}\n\n\treturn loc\n}", "id": 7733, "concepts": ["pointer handling", "nil pointer handling", "pointer dereference", "struct field access"], "_raw_llm_output": "pointer handling, nil pointer handling, pointer dereference, struct field access"}
{"seed": "// NewViewedFollowersPage initializes viewed result type FollowersPage from\n// result type FollowersPage using the given view.\nfunc NewViewedFollowersPage(res *FollowersPage, view string) *followingviews.FollowersPage {\n\tp := newFollowersPageView(res)\n\treturn &followingviews.FollowersPage{Projected: p, View: \"default\"}\n}", "id": 7740, "concepts": ["type conversion", "type aliasing", "type embedding"], "_raw_llm_output": "type conversion, type aliasing, type embedding"}
{"seed": "// boolPyToGo converts a python-compatible C.Char to Go bool\nfunc boolPyToGo(b C.char) bool {\n\tif b != 0 {\n\t\treturn true\n\t}\n\treturn false\n}", "id": 7743, "concepts": ["C.char", "boolean conversion"], "_raw_llm_output": "C.char, boolean conversion"}
{"seed": "// OffsetToPage returns the pagination page value\n// corresponding to the given offset and size.\nfunc OffsetToPage(offset, size int) int {\n\treturn (offset / size) + 1\n}", "id": 7745, "concepts": ["integer division", "integer addition", "basic function definition"], "_raw_llm_output": "integer division, integer addition, basic function definition"}
{"seed": "// WithPostExtension is an Option that configures the reconciler to run the given\n// extension after performing any reconciliation steps (including uninstall of the release,\n// but not removal of the finalizer).\n// An error returned from the extension will cause the reconciliation to fail, which might\n// prevent the finalizer from getting removed.\n// This should be preferred to WithPostHook in most cases, except for when the logic\n// depends on the translated Helm values.\n// The extension will be invoked with the raw object state; meaning it needs to be careful\n// to check for existence of the deletionTimestamp field.\nfunc WithPostExtension(e extensions.ReconcileExtension) Option {\n\treturn func(r *Reconciler) error {\n\t\tr.postExtensions = append(r.postExtensions, e)\n\t\treturn nil\n\t}\n}", "id": 7751, "concepts": ["struct definition", "interface definition", "method definition", "function definition", "function call", "function return", "function argument", "function return value", "function return value type", "function return value type definition", "function return value type definition", "function return value definition", "function return value definition", "function return value definition type", "function return value definition type", "function return value definition type definition", "function return value definition type definition", "function return value definition type definition type", "function return value definition type definition type definition", "function return value definition type definition type definition type", "function return value definition type definition type definition type definition", "function return value definition type definition type definition type definition type", "function return value definition type definition type definition type definition type definition", "function return value definition type definition type definition type definition type definition type", "function return value definition type definition type definition type definition type definition type definition", "function return value definition type definition type definition type definition type definition type definition type", "function return value definition type definition type definition type definition type definition type definition type definition", "function return value definition type definition type definition type definition type definition type definition type definition type", "function return value definition type definition type definition type definition type definition type definition type definition type definition", "function return value definition type definition type definition type definition type definition type definition type"], "_raw_llm_output": "struct definition, interface definition, method definition, function definition, function call, function return, function argument, function return value, function return value type, function return value type definition, function return value type definition, function return value definition, function return value definition, function return value definition type, function return value definition type, function return value definition type definition, function return value definition type definition, function return value definition type definition type, function return value definition type definition type definition, function return value definition type definition type definition type, function return value definition type definition type definition type definition, function return value definition type definition type definition type definition type, function return value definition type definition type definition type definition type definition, function return value definition type definition type definition type definition type definition type, function return value definition type definition type definition type definition type definition type definition, function return value definition type definition type definition type definition type definition type definition type, function return value definition type definition type definition type definition type definition type definition type definition, function return value definition type definition type definition type definition type definition type definition type definition type, function return value definition type definition type definition type definition type definition type definition type definition type definition, function return value definition type definition type definition type definition type definition type definition type"}
{"seed": "// isAlphaNumeric reports whether r is an alphabetic, digit, or underscore.\nfunc isAlphaNumeric(r rune) bool {\n\treturn r == '_' || unicode.IsLetter(r) || unicode.IsDigit(r)\n}", "id": 7756, "concepts": ["rune handling", "unicode package usage"], "_raw_llm_output": "rune handling, unicode package usage"}
{"seed": "// SameEndingSubSlice returns true if the slices end the same way, e.g.\n// {\"a\", \"b\", \"c\"}, {\"b\", \"c\"} => true\n// {\"a\", \"b\", \"c\"}, {\"a\", \"b\"} => false\n// If one slice is empty and the other is not, return false.\nfunc SameEndingSubSlice(shortest, longest []string) bool {\n\tif len(shortest) > len(longest) {\n\t\tlongest, shortest = shortest, longest\n\t}\n\tdiff := len(longest) - len(shortest)\n\tif len(shortest) == 0 {\n\t\treturn diff == 0\n\t}\n\tfor i := len(shortest) - 1; i >= 0; i-- {\n\t\tif longest[i+diff] != shortest[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}", "id": 7775, "concepts": ["slice iteration (range loop)", "slice comparison", "slice manipulation"], "_raw_llm_output": "slice iteration (range loop), slice comparison, slice manipulation"}
{"seed": "// ParseResetSksNodepoolFieldResponse parses an HTTP response from a ResetSksNodepoolFieldWithResponse call\nfunc ParseResetSksNodepoolFieldResponse(rsp *http.Response) (*ResetSksNodepoolFieldResponse, error) {\n\tbodyBytes, err := ioutil.ReadAll(rsp.Body)\n\tdefer rsp.Body.Close()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse := &ResetSksNodepoolFieldResponse{\n\t\tBody:         bodyBytes,\n\t\tHTTPResponse: rsp,\n\t}\n\n\tswitch {\n\tcase strings.Contains(rsp.Header.Get(\"Content-Type\"), \"json\") && rsp.StatusCode == 200:\n\t\tvar dest Operation\n\t\tif err := json.Unmarshal(bodyBytes, &dest); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresponse.JSON200 = &dest\n\n\t}\n\n\treturn response, nil\n}", "id": 7776, "concepts": ["HTTP response parsing", "JSON parsing", "error handling"], "_raw_llm_output": "HTTP response parsing, JSON parsing, error handling"}
{"seed": "// gcmDouble returns the result of doubling an element of GF(2\u00b9\u00b2\u2078).\nfunc gcmDouble(x *gcmFieldElement) (double gcmFieldElement) {\n\tmsbSet := x.high&1 == 1\n\n\t// Because of the bit-ordering, doubling is actually a right shift.\n\tdouble.high = x.high >> 1\n\tdouble.high |= x.low << 63\n\tdouble.low = x.low >> 1\n\n\t// If the most-significant bit was set before shifting then it,\n\t// conceptually, becomes a term of x^128. This is greater than the\n\t// irreducible polynomial so the result has to be reduced. The\n\t// irreducible polynomial is 1+x+x^2+x^7+x^128. We can subtract that to\n\t// eliminate the term at x^128 which also means subtracting the other\n\t// four terms. In characteristic 2 fields, subtraction == addition ==\n\t// XOR.\n\tif msbSet {\n\t\tdouble.low ^= 0xe100000000000000\n\t}\n\n\treturn\n}", "id": 7792, "concepts": ["bit manipulation", "bit-ordering", "irreducible polynomial", "characteristic 2 field", "XOR"], "_raw_llm_output": "bit manipulation, bit-ordering, irreducible polynomial, characteristic 2 field, XOR"}
{"seed": "// DefaultExprsLTE applies the LTE predicate on the \"default_exprs\" field.\nfunc DefaultExprsLTE(v string) predicate.User {\n\treturn predicate.User(sql.FieldLTE(FieldDefaultExprs, v))\n}", "id": 7794, "concepts": ["sql package usage", "field comparison", "predicate definition"], "_raw_llm_output": "sql package usage, field comparison, predicate definition"}
{"seed": "// NewGetBacsUnauthorized creates a GetBacsUnauthorized with default headers values\nfunc NewGetBacsUnauthorized() *GetBacsUnauthorized {\n\treturn &GetBacsUnauthorized{}\n}", "id": 7798, "concepts": ["struct definition", "struct field initialization", "anonymous struct", "struct field access"], "_raw_llm_output": "struct definition, struct field initialization, anonymous struct, struct field access"}
{"seed": "// CreatedAt applies equality check predicate on the \"created_at\" field. It's identical to CreatedAtEQ.\nfunc CreatedAt(v time.Time) predicate.User {\n\treturn predicate.User(sql.FieldEQ(FieldCreatedAt, v))\n}", "id": 7810, "concepts": ["struct field access", "predicate.User", "sql.FieldEQ"], "_raw_llm_output": "struct field access, predicate.User, sql.FieldEQ"}
{"seed": "// MapInt64Uint8Ptr takes two inputs -\n// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list\nfunc MapInt64Uint8Ptr(f func(*int64) *uint8, list []*int64) []*uint8 {\n\tif f == nil {\n\t\treturn []*uint8{}\n\t}\n\tnewList := make([]*uint8, len(list))\n\tfor i, v := range list {\n\t\tnewList[i] = f(v)\n\t}\n\treturn newList\n}", "id": 7811, "concepts": ["function", "pointer", "map", "slice", "anonymous function", "type conversion"], "_raw_llm_output": "function, pointer, map, slice, anonymous function, type conversion"}
{"seed": "// Th represents the HTML element 'th'.\n// For more information visit https://www.w3schools.com/tags/tag_th.asp.\nfunc Th(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"th\", Attributes: attrs, Children: children}\n}", "id": 7837, "concepts": ["HTML generation", "HTML generation using HTML package"], "_raw_llm_output": "HTML generation, HTML generation using HTML package"}
{"seed": "//BodyBytesToString converts http body bytes to string\nfunc BodyBytesToString(body io.Reader) string {\n\n\tbodyBytes, err := ioutil.ReadAll(body)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\treturn string(bodyBytes)\n}", "id": 7841, "concepts": ["ioutil package usage", "io.Reader", "string conversion"], "_raw_llm_output": "ioutil package usage, io.Reader, string conversion"}
{"seed": "// MakeDriverDMA returns initialized driver that uses provided SDMMC peripheral\n// and DMA channel. If d0 is valid it also configures EXTI to detect rising edge\n// on d0 pin.\nfunc MakeDriverDMA(p *Periph, dma *dma.Channel, d0 gpio.Pin) DriverDMA {\n\tif d0.IsValid() {\n\t\tsetupEXTI(d0)\n\t}\n\treturn DriverDMA{p: p, dma: dma, d0: d0}\n}", "id": 7847, "concepts": ["struct definition", "function definition", "function return value", "function parameter", "function call", "function scope", "function closure", "function pointer", "function type", "function value", "function signature", "function body", "function declaration", "function definition", "function call", "function return value", "function parameter", "function parameter type", "function parameter name", "function parameter value", "function parameter list", "function parameter declaration", "function parameter definition", "function parameter scope", "function parameter type", "function parameter name", "function parameter value", "function parameter list", "function parameter declaration", "function parameter definition", "function parameter scope", "function parameter type", "function parameter name", "function parameter value", "function parameter list", "function parameter declaration", "function parameter definition", "function parameter scope", "function parameter type", "function parameter name", "function parameter value", "function parameter list", "function parameter declaration", "function parameter definition", "function parameter scope", "function parameter type", "function parameter name", "function parameter value", "function parameter list", "function parameter declaration", "function parameter definition", "function parameter scope", "function parameter type", "function parameter name", "function parameter value", "function parameter list", "function parameter declaration", "function parameter definition", "function parameter scope", "function parameter type", "function parameter name", "function parameter value", "function parameter list", "function parameter declaration", "function parameter definition", "function parameter scope", "function parameter type", "function parameter"], "_raw_llm_output": "struct definition, function definition, function return value, function parameter, function call, function scope, function closure, function pointer, function type, function value, function signature, function body, function declaration, function definition, function call, function return value, function parameter, function parameter type, function parameter name, function parameter value, function parameter list, function parameter declaration, function parameter definition, function parameter scope, function parameter type, function parameter name, function parameter value, function parameter list, function parameter declaration, function parameter definition, function parameter scope, function parameter type, function parameter name, function parameter value, function parameter list, function parameter declaration, function parameter definition, function parameter scope, function parameter type, function parameter name, function parameter value, function parameter list, function parameter declaration, function parameter definition, function parameter scope, function parameter type, function parameter name, function parameter value, function parameter list, function parameter declaration, function parameter definition, function parameter scope, function parameter type, function parameter name, function parameter value, function parameter list, function parameter declaration, function parameter definition, function parameter scope, function parameter type, function parameter name, function parameter value, function parameter list, function parameter declaration, function parameter definition, function parameter scope, function parameter type, function parameter"}
{"seed": "// BindingQueryGet Test ShouldBindQuery\n// \u6d4b\u8bd5 GET query \u8bf7\u6c42\u7684\u7ed1\u5b9a\n// GET http://localhost:18080/bind/query?user=abc&password=123\n// Content-Type: text/plain\n// ###\nfunc BindingQueryGet(ctx *gin.Context) {\n\ttype login struct {\n\t\tUser     string `form:\"user\" json:\"usr\" xml:\"user\"  binding:\"required\"`\n\t\tPassword string `form:\"password\" json:\"pwd\" xml:\"password\" binding:\"required\"`\n\t}\n\n\tvar usr login\n\tif err := ctx.ShouldBindQuery(&usr); err != nil {\n\t\tctx.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()})\n\t\treturn\n\t}\n\n\tlog.Println(usr)\n\n\tctx.Status(http.StatusNoContent)\n}", "id": 7862, "concepts": ["gin.Context", "ShouldBindQuery", "binding.Struct", "binding.Form", "binding.FormPost", "binding.FormMultipart", "binding.FormFile", "binding.FormArray", "binding.FormMap", "binding.FormMapPost", "binding.FormMapMultipart", "binding.FormMapFile", "binding.FormMapArray", "binding.FormMapSlice", "binding.FormMapSlicePost", "binding.FormMapSliceMultipart", "binding.FormMapSliceFile", "binding.FormMapSliceArray", "binding.FormMapSliceMap", "binding.FormMapSliceMapPost", "binding.FormMapSliceMapMultipart", "binding.FormMapSliceMapFile", "binding.FormMapSliceMapArray", "binding.FormMapSliceMapSlice", "binding.FormMapSliceMapSlicePost", "binding.FormMapSliceMapSliceMultipart", "binding.FormMapSliceMapSliceFile", "binding.FormMapSliceMapSliceArray", "binding.FormMapSliceMapSliceMap", "binding.FormMapSliceMapSliceMapPost", "binding.FormMapSliceMapSliceMapMultipart", "binding.FormMapSliceMapSliceMapFile", "binding.FormMapSliceMapSliceMapArray", "binding.FormMapSliceMapSliceMapSlice", "binding.FormMapSliceMapSliceMapSlicePost", "binding.Form"], "_raw_llm_output": "gin.Context, ShouldBindQuery, binding.Struct, binding.Form, binding.FormPost, binding.FormMultipart, binding.FormFile, binding.FormArray, binding.FormMap, binding.FormMapPost, binding.FormMapMultipart, binding.FormMapFile, binding.FormMapArray, binding.FormMapSlice, binding.FormMapSlicePost, binding.FormMapSliceMultipart, binding.FormMapSliceFile, binding.FormMapSliceArray, binding.FormMapSliceMap, binding.FormMapSliceMapPost, binding.FormMapSliceMapMultipart, binding.FormMapSliceMapFile, binding.FormMapSliceMapArray, binding.FormMapSliceMapSlice, binding.FormMapSliceMapSlicePost, binding.FormMapSliceMapSliceMultipart, binding.FormMapSliceMapSliceFile, binding.FormMapSliceMapSliceArray, binding.FormMapSliceMapSliceMap, binding.FormMapSliceMapSliceMapPost, binding.FormMapSliceMapSliceMapMultipart, binding.FormMapSliceMapSliceMapFile, binding.FormMapSliceMapSliceMapArray, binding.FormMapSliceMapSliceMapSlice, binding.FormMapSliceMapSliceMapSlicePost, binding.Form"}
{"seed": "// SocialAvatarURLEQ applies the EQ predicate on the \"social_avatar_url\" field.\nfunc SocialAvatarURLEQ(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldSocialAvatarURL), v))\n\t})\n}", "id": 7867, "concepts": ["sql.Selector", "sql.EQ", "sql.C", "predicate.User", "function definition"], "_raw_llm_output": "sql.Selector, sql.EQ, sql.C, predicate.User, function definition"}
{"seed": "// NewPutParamsWithHTTPClient creates a new PutParams object\n// with the default values initialized, and the ability to set a custom HTTPClient for a request\nfunc NewPutParamsWithHTTPClient(client *http.Client) *PutParams {\n\tvar ()\n\treturn &PutParams{\n\t\tHTTPClient: client,\n\t}\n}", "id": 7870, "concepts": ["struct definition", "struct initialization", "struct field access", "pointer usage", "method definition", "method invocation"], "_raw_llm_output": "struct definition, struct initialization, struct field access, pointer usage, method definition, method invocation"}
{"seed": "// NewLogger returns a log.Logger instance, sending entries to the Android log\n// specificed by logId, with priority prio and tag. logFlags are passed on to the\n// log.Logger created by this function, but we disable all time-related flags.\n//\n// Returns an error if accessing the Android logging facilities fails.\nfunc NewLogger(logId LogId, prio Priority, tag Tag, logFlags int) (*log.Logger, error) {\n\t// We disable all time-related flags as entries are timestamped by the\n\t// the Android logging facilities.\n\tlogFlags = logFlags & ^log.Ldate\n\tlogFlags = logFlags & ^log.Ltime\n\tlogFlags = logFlags & ^log.Lmicroseconds\n\n\tw, err := NewLoggerWriter(logId)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tiow := &ioWriterWrapper{prio, tag, w}\n\treturn log.New(iow, \"\", logFlags), nil\n}", "id": 7872, "concepts": ["log.Logger", "log.New", "io.Writer", "io.Writer interface", "io.Writer wrapper", "io.Writer interface", "io.Writer interface", "io.Writer interface", "io.Writer interface", "io.Writer interface", "io.Writer interface", "io.Writer interface", "io.Writer interface", "io.Writer interface", "io.Writer interface", "io.Writer interface", "io.Writer interface", "io.Writer interface", "io.Writer interface", "io.Writer interface", "io.Writer interface", "io.Writer interface", "io.Writer interface", "io.Writer interface", "io.Writer interface", "io.Writer interface", "io.Writer interface", "io.Writer interface", "io.Writer interface", "io.Writer interface", "io.Writer interface", "io.Writer interface", "io.Writer interface", "io.Writer interface", "io.Writer interface", "io.Writer interface", "io.Writer interface", "io.Writer interface", "io.Writer interface", "io.Writer interface", "io.Writer interface", "io.Writer interface", "io.Writer interface", "io.Writer interface", "io.Writer interface", "io.Writer interface", "io.Writer interface", "io.Writer interface", "io.Writer interface", "io.Writer interface", "io.Writer interface", "io.Writer"], "_raw_llm_output": "log.Logger, log.New, io.Writer, io.Writer interface, io.Writer wrapper, io.Writer interface, io.Writer interface, io.Writer interface, io.Writer interface, io.Writer interface, io.Writer interface, io.Writer interface, io.Writer interface, io.Writer interface, io.Writer interface, io.Writer interface, io.Writer interface, io.Writer interface, io.Writer interface, io.Writer interface, io.Writer interface, io.Writer interface, io.Writer interface, io.Writer interface, io.Writer interface, io.Writer interface, io.Writer interface, io.Writer interface, io.Writer interface, io.Writer interface, io.Writer interface, io.Writer interface, io.Writer interface, io.Writer interface, io.Writer interface, io.Writer interface, io.Writer interface, io.Writer interface, io.Writer interface, io.Writer interface, io.Writer interface, io.Writer interface, io.Writer interface, io.Writer interface, io.Writer interface, io.Writer interface, io.Writer interface, io.Writer interface, io.Writer interface, io.Writer interface, io.Writer interface, io.Writer"}
{"seed": "// Limb returns the position angle of the midpoint of an illuminated limb.\n//\n// The illuminated body can be the Moon or a planet.\n//\n// Arguments \u03b1, \u03b4 are equatorial coordinates of the body; \u03b10, \u03b40 are\n// apparent coordinates of the Sun.\nfunc Limb(\u03b1 unit.RA, \u03b4 unit.Angle, \u03b10 unit.RA, \u03b40 unit.Angle) unit.Angle {\n\t// Mentioned in ch 41, p. 283.  Formula (48.5) p. 346\n\ts\u03b4, c\u03b4 := \u03b4.Sincos()\n\ts\u03b40, c\u03b40 := \u03b40.Sincos()\n\ts\u03b10\u03b1, c\u03b10\u03b1 := (\u03b10 - \u03b1).Sincos()\n\t\u03c7 := unit.Angle(math.Atan2(c\u03b40*s\u03b10\u03b1, s\u03b40*c\u03b4-c\u03b40*s\u03b4*c\u03b10\u03b1))\n\tif \u03c7 < 0 {\n\t\t\u03c7 += 2 * math.Pi\n\t}\n\treturn \u03c7\n}", "id": 7873, "concepts": ["trigonometry", "unit conversion", "basic function definition", "mathematical series"], "_raw_llm_output": "trigonometry, unit conversion, basic function definition, mathematical series"}
{"seed": "// NewEntryServiceDeleteParamsWithHTTPClient creates a new EntryServiceDeleteParams object\n// with the default values initialized, and the ability to set a custom HTTPClient for a request\nfunc NewEntryServiceDeleteParamsWithHTTPClient(client *http.Client) *EntryServiceDeleteParams {\n\tvar ()\n\treturn &EntryServiceDeleteParams{\n\t\tHTTPClient: client,\n\t}\n}", "id": 7876, "concepts": ["http.Client", "http.NewRequest", "http.Do", "http.Request", "http.Response", "http.Status", "http.StatusText", "http.Header", "http.Cookie", "http.CookieJar", "http.Transport", "http.ProxyFromEnvironment", "http.ProxyURL", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", ""], "_raw_llm_output": "http.Client, http.NewRequest, http.Do, http.Request, http.Response, http.Status, http.StatusText, http.Header, http.Cookie, http.CookieJar, http.Transport, http.ProxyFromEnvironment, http.ProxyURL, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment,"}
{"seed": "// NewAccountIdentityAllOf instantiates a new AccountIdentityAllOf object\n// This constructor will assign default values to properties that have it defined,\n// and makes sure properties required by API are set, but the set of arguments\n// will change when the set of required properties is changed\nfunc NewAccountIdentityAllOf(owners []Owner) *AccountIdentityAllOf {\n\tthis := AccountIdentityAllOf{}\n\tthis.Owners = owners\n\treturn &this\n}", "id": 7913, "concepts": ["struct definition", "struct instantiation", "struct property assignment"], "_raw_llm_output": "struct definition, struct instantiation, struct property assignment"}
{"seed": "// _escDir returns a http.Filesystem for the embedded assets on a given prefix dir.\n// If useLocal is true, the filesystem's contents are instead used.\nfunc _escDir(useLocal bool, name string) http.FileSystem {\n\tif useLocal {\n\t\treturn _escDirectory{fs: _escLocal, name: name}\n\t}\n\treturn _escDirectory{fs: _escStatic, name: name}\n}", "id": 7924, "concepts": ["embedded assets", "http.FileSystem", "http.FileServer", "http.File", "standard library usage"], "_raw_llm_output": "embedded assets, http.FileSystem, http.FileServer, http.File, standard library usage"}
{"seed": "// PossibleSubscriptionNotificationOperationValues returns the possible values for the SubscriptionNotificationOperation const type.\nfunc PossibleSubscriptionNotificationOperationValues() []SubscriptionNotificationOperation {\n\treturn []SubscriptionNotificationOperation{\n\t\tSubscriptionNotificationOperationBillingCancellation,\n\t\tSubscriptionNotificationOperationDeleteAllResources,\n\t\tSubscriptionNotificationOperationNoOp,\n\t\tSubscriptionNotificationOperationNotDefined,\n\t\tSubscriptionNotificationOperationSoftDeleteAllResources,\n\t\tSubscriptionNotificationOperationUndoSoftDelete,\n\t}\n}", "id": 7930, "concepts": ["const type", "iota", "slice iteration", "basic function definition"], "_raw_llm_output": "const type, iota, slice iteration, basic function definition"}
{"seed": "// Operator_Values returns all elements of the Operator enum\nfunc Operator_Values() []string {\n\treturn []string{\n\t\tOperatorEquals,\n\t}\n}", "id": 7944, "concepts": ["enum definition", "enum values"], "_raw_llm_output": "enum definition, enum values"}
{"seed": "// getMIDIPort returns the port number of the \"Midi Through\" device as a string.\n// On failure, an empty string is returned.\n//\n// Ports returned are of the following format:\n// <client_number>:<port_number>\n// where both the above numbers are the assigned to the MIDI port according\n// to the ALSA sequencer interface. More information can be obtained from:\n// https://linux.die.net/man/1/arecordmidi\nfunc getMIDIPort(ctx context.Context) (string, error) {\n\tconst emptyPort = \"\"\n\tout, err := testexec.CommandContext(ctx, \"/usr/bin/arecordmidi\", \"-l\").Output()\n\tif err != nil {\n\t\treturn emptyPort, errors.Wrap(err, \"couldn't start arecordmidi\")\n\t}\n\n\tconst MIDIClientName = \"Midi Through\"\n\t// The output of arecordmidi is assumed to be of the following format:\n\t//\n\t// Port    Client name                      Port name\n\t// 14:0    Midi Through                     Midi Through Port-0\n\t//\n\t// So, we parse the output string and search for the port associated\n\t// with \"Midi Through\" assuming the above.\n\tre := regexp.MustCompile(`(\\d+:\\d+)\\s{2,}(.+)\\s{2,}`)\n\tfor _, line := range strings.Split(string(out), \"\\n\") {\n\t\tfields := re.FindStringSubmatch(line)\n\t\tif fields == nil {\n\t\t\tcontinue\n\t\t}\n\t\tclient := strings.TrimSpace(fields[2])\n\t\tif client == MIDIClientName {\n\t\t\t// Return the port.\n\t\t\treturn strings.TrimSpace(fields[1]), nil\n\t\t}\n\t}\n\treturn emptyPort, errors.Errorf(\"%q client not found\", MIDIClientName)\n}", "id": 7955, "concepts": ["regexp", "string manipulation", "os.Exit", "os.Args", "os.Stdout", "os.Stderr", "os.Open", "os.Create", "os.Stat", "os.Remove", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os."], "_raw_llm_output": "regexp, string manipulation, os.Exit, os.Args, os.Stdout, os.Stderr, os.Open, os.Create, os.Stat, os.Remove, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os."}
{"seed": "// FallbackFormatterSimple creates logs thath will be written prefixed with\n// key and suffixed with a newline.\n// After FallbackFormatKey the key is joined with dots (.). The key\n// is then printed with a colon and the json encoded value after.\nfunc FallbackFormatterSimple(key []FallbackKey, value []byte) (n int, err error) {\n\tprefix := strings.Join(FallbackFormatKey(key), \".\") + \": \"\n\tww := append([]byte(prefix), value...)\n\tww = append(ww, '\\n')\n\tn, err = FallbackWriter.Write(ww)\n\t// Calculate how much of value we wrote.\n\tif n <= len(prefix) {\n\t\tn = 0\n\t} else {\n\t\tn -= len(prefix)\n\t\tif n > len(value) {\n\t\t\tn = len(value)\n\t\t}\n\t}\n\treturn\n}", "id": 7991, "concepts": ["slice manipulation", "string manipulation", "string concatenation", "string formatting", "basic function definition", "basic function return"], "_raw_llm_output": "slice manipulation, string manipulation, string concatenation, string formatting, basic function definition, basic function return"}
{"seed": "// ForwardPorts spawns a goroutine that does the equivalent of\n// \"kubectl port-forward -n <namespace> <podName> [portMapping]\".\n// The connection will remain open until stopChan is closed. Use errChan for receiving errors from the port-forward\n// goroutine.\n//\n// Example:\n//\n//\tstopCh := make(chan struct{}, 1)\n//\terrCh := make(chan error)\n//\tif err = ForwardPorts(conf, \"my-ns\", \"my-pod\", []string{\"5000:5000\"}, stopCh, errCh, time.Minute); err != nil {\n//\t    return err\n//\t}\n//\tdefer func() {\n//\t    close(stopCh)\n//\t    close(errCh)\n//\t}()\nfunc ForwardPorts(\n\tconf *rest.Config,\n\tnamespace string,\n\tpodName string,\n\tportMapping []string,\n\tstopChan <-chan struct{},\n\terrChan chan error,\n\ttimeout time.Duration,\n) error {\n\ttransport, upgrader, err := spdy.RoundTripperFor(conf)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error creating roundtripper: %w\", err)\n\t}\n\n\tdialer := spdy.NewDialer(\n\t\tupgrader,\n\t\t&http.Client{Transport: transport},\n\t\thttp.MethodPost,\n\t\t&url.URL{\n\t\t\tScheme: \"https\",\n\t\t\tPath:   fmt.Sprintf(\"/api/v1/namespaces/%s/pods/%s/portforward\", namespace, podName),\n\t\t\tHost:   strings.TrimLeft(conf.Host, \"htps:/\"),\n\t\t},\n\t)\n\n\t// Create a new port-forwarder with localhost as the listen address. Standard output from the forwarder will be\n\t// discarded, but errors will go to stderr.\n\treadyChan := make(chan struct{})\n\tfw, err := portforward.New(dialer, portMapping, stopChan, readyChan, io.Discard, os.Stderr)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error creating port-forwarder: %w\", err)\n\t}\n\n\t// Start the port-forward\n\tgo func() {\n\t\tif err := fw.ForwardPorts(); err != nil {\n\t\t\terrChan <- err\n\t\t}\n\t}()\n\n\t// Wait for the port-forward to be ready for use before returning\n\tselect {\n\tcase <-readyChan:\n\t\treturn nil\n\tcase <-time.After(timeout):\n\t\treturn fmt.Errorf(\"timed out after %s waiting for port-forward to be ready\", timeout)\n\tcase err = <-errChan:\n\t\treturn fmt.Errorf(\"error from port-forwarder: %w\", err)\n\t}\n}", "id": 7992, "concepts": ["port-forwarding", "sync.WaitGroup", "anonymous function", "concurrency", "standard library usage"], "_raw_llm_output": "port-forwarding, sync.WaitGroup, anonymous function, concurrency, standard library usage"}
{"seed": "// NewTestEmailConfigurationParamsWithTimeout creates a new TestEmailConfigurationParams object\n// with the ability to set a timeout on a request.\nfunc NewTestEmailConfigurationParamsWithTimeout(timeout time.Duration) *TestEmailConfigurationParams {\n\treturn &TestEmailConfigurationParams{\n\t\ttimeout: timeout,\n\t}\n}", "id": 7997, "concepts": ["timeout handling", "time package usage"], "_raw_llm_output": "timeout handling, time package usage"}
{"seed": "//NewMemMapFS creates a memory-based file system\nfunc NewMemMapFS() FS {\n\treturn afero.NewMemMapFs()\n}", "id": 8000, "concepts": ["afero package usage"], "_raw_llm_output": "afero package usage"}
{"seed": "// Blocks until the CassandraDatacenter is ready as determined by\n// .Status.CassandraOperatorProgress == ProgressReady or until timeout is reached. An error is returned\n// is fetching the CassandraDatacenter fails.\nfunc WaitForCassDcReady(key types.NamespacedName, retryInterval, timeout time.Duration) error {\n\tstart := time.Now()\n\treturn wait.Poll(retryInterval, timeout, func() (bool, error) {\n\t\tcassdc, err := GetCassDc(key)\n\t\tif err != nil {\n\t\t\tif apierrors.IsNotFound(err) {\n\t\t\t\treturn false, nil\n\t\t\t}\n\t\t\treturn true, err\n\t\t}\n\t\tlogCassDcStatus(cassdc, start)\n\t\treturn cassdc.Status.CassandraOperatorProgress == cassdcapi.ProgressReady, nil\n\t})\n}", "id": 8018, "concepts": ["wait.Poll", "wait.Condition", "wait.PollImmediate", "wait.PollImmediateUntil", "wait.PollImmediateWithSync", "wait.PollImmediateUntilWithSync", "wait.PollImmediateUntilWithSync", "wait.PollImmediateUntilWithSync", "wait.PollImmediateUntilWithSync", "wait.PollImmediateUntilWithSync", "wait.PollImmediateUntilWithSync", "wait.PollImmediateUntilWithSync", "wait.PollImmediateUntilWithSync", "wait.PollImmediateUntilWithSync", "wait.PollImmediateUntilWithSync", "wait.PollImmediateUntilWithSync", "wait.PollImmediateUntilWithSync", "wait.PollImmediateUntilWithSync", "wait.PollImmediateUntilWithSync", "wait.PollImmediateUntilWithSync", "wait.PollImmediateUntilWithSync", "wait.PollImmediateUntilWithSync", "wait.PollImmediateUntilWithSync", "wait.PollImmediateUntilWithSync", "wait.PollImmediateUntilWithSync", "wait.PollImmediateUntilWithSync", "wait.PollImmediateUntilWithSync", "wait.PollImmediateUntilWithSync", "wait.PollImmediateUntilWithSync", "wait.PollImmediateUntilWithSync", "wait.PollImmediateUntilWithSync", "wait.PollImmediateUntilWithSync", "wait.PollImmediateUntilWithSync", "wait.PollImmediateUntil"], "_raw_llm_output": "wait.Poll, wait.Condition, wait.PollImmediate, wait.PollImmediateUntil, wait.PollImmediateWithSync, wait.PollImmediateUntilWithSync, wait.PollImmediateUntilWithSync, wait.PollImmediateUntilWithSync, wait.PollImmediateUntilWithSync, wait.PollImmediateUntilWithSync, wait.PollImmediateUntilWithSync, wait.PollImmediateUntilWithSync, wait.PollImmediateUntilWithSync, wait.PollImmediateUntilWithSync, wait.PollImmediateUntilWithSync, wait.PollImmediateUntilWithSync, wait.PollImmediateUntilWithSync, wait.PollImmediateUntilWithSync, wait.PollImmediateUntilWithSync, wait.PollImmediateUntilWithSync, wait.PollImmediateUntilWithSync, wait.PollImmediateUntilWithSync, wait.PollImmediateUntilWithSync, wait.PollImmediateUntilWithSync, wait.PollImmediateUntilWithSync, wait.PollImmediateUntilWithSync, wait.PollImmediateUntilWithSync, wait.PollImmediateUntilWithSync, wait.PollImmediateUntilWithSync, wait.PollImmediateUntilWithSync, wait.PollImmediateUntilWithSync, wait.PollImmediateUntilWithSync, wait.PollImmediateUntilWithSync, wait.PollImmediateUntil"}
{"seed": "// NewComponentContent returns an empty Tag content instance.\nfunc NewComponentContent() *ComponentContent {\n\tc := &ComponentContent{}\n\tc.SetUpdateTime(time.Now().UTC())\n\n\treturn c\n}", "id": 8057, "concepts": ["struct definition", "struct field initialization", "time package usage"], "_raw_llm_output": "struct definition, struct field initialization, time package usage"}
{"seed": "// BulkCreditSamedayFee applies equality check predicate on the \"bulkCreditSamedayFee\" field. It's identical to BulkCreditSamedayFeeEQ.\nfunc BulkCreditSamedayFee(v float64) predicate.Bulk {\n\treturn predicate.Bulk(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldBulkCreditSamedayFee), v))\n\t})\n}", "id": 8061, "concepts": ["equality check predicate", "sql package usage"], "_raw_llm_output": "equality check predicate, sql package usage"}
{"seed": "// NewFetchIntegrationFormParams creates a new FetchIntegrationFormParams object,\n// with the default timeout for this client.\n//\n// Default values are not hydrated, since defaults are normally applied by the API server side.\n//\n// To enforce default values in parameter, use SetDefaults or WithDefaults.\nfunc NewFetchIntegrationFormParams() *FetchIntegrationFormParams {\n\treturn &FetchIntegrationFormParams{\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 8066, "concepts": ["struct definition", "method definition", "method call", "default value assignment", "method parameter"], "_raw_llm_output": "struct definition, method definition, method call, default value assignment, method parameter"}
{"seed": "// FileFunc returns the implementation of the \"file\" function.\n//\n// file() reads the contents of a file and returns it as a string.\n//\n// Parameters:\n//  * path: path of the file, either absolute or relative to the directory of\n//    the file that calls the function.\n//\nfunc FileFunc(basedir string, filesyst fs.FS) function.Function {\n\treturn function.New(&function.Spec{\n\t\tParams: []function.Parameter{\n\t\t\t{\n\t\t\t\tName: \"path\",\n\t\t\t\tType: cty.String,\n\t\t\t},\n\t\t},\n\n\t\tType: function.StaticReturnType(cty.String),\n\t\tImpl: fileFuncImpl(basedir, filesyst),\n\t})\n}", "id": 8067, "concepts": ["function definition", "function composition", "function composition with file system", "function composition with base directory", "function composition with file system and base directory", "function composition with file system and base directory", "function composition with file system and base directory", "function composition with file system and base directory", "function composition with file system and base directory", "function composition with file system and base directory", "function composition with file system and base directory", "function composition with file system and base directory", "function composition with file system and base directory", "function composition with file system and base directory", "function composition with file system and base directory", "function composition with file system and base directory", "function composition with file system and base directory", "function composition with file system and base directory", "function composition with file system and base directory", "function composition with file system and base directory", "function composition with file system and base directory", "function composition with file system and base directory", "function composition with file system and base directory", "function composition with file system and base directory", "function composition with file system and base directory", "function composition with file system and base directory", "function composition with file system and base directory", "function composition with file system and base directory", "function composition with file system and base directory", "function composition with file system and base directory", "function composition with"], "_raw_llm_output": "function definition, function composition, function composition with file system, function composition with base directory, function composition with file system and base directory, function composition with file system and base directory, function composition with file system and base directory, function composition with file system and base directory, function composition with file system and base directory, function composition with file system and base directory, function composition with file system and base directory, function composition with file system and base directory, function composition with file system and base directory, function composition with file system and base directory, function composition with file system and base directory, function composition with file system and base directory, function composition with file system and base directory, function composition with file system and base directory, function composition with file system and base directory, function composition with file system and base directory, function composition with file system and base directory, function composition with file system and base directory, function composition with file system and base directory, function composition with file system and base directory, function composition with file system and base directory, function composition with file system and base directory, function composition with file system and base directory, function composition with file system and base directory, function composition with file system and base directory, function composition with file system and base directory, function composition with"}
{"seed": "// DateTimeIn applies the In predicate on the \"dateTime\" field.\nfunc DateTimeIn(vs ...time.Time) predicate.Bulk {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.Bulk(func(s *sql.Selector) {\n\t\t// if not arguments were provided, append the FALSE constants,\n\t\t// since we can't apply \"IN ()\". This will make this predicate falsy.\n\t\tif len(v) == 0 {\n\t\t\ts.Where(sql.False())\n\t\t\treturn\n\t\t}\n\t\ts.Where(sql.In(s.C(FieldDateTime), v...))\n\t})\n}", "id": 8075, "concepts": ["sql.Selector", "sql.In", "sql.False", "sql.Bulk", "sql.C", "sql.Where"], "_raw_llm_output": "sql.Selector, sql.In, sql.False, sql.Bulk, sql.C, sql.Where"}
{"seed": "// sigmoid implements the sigmoid function\n// for use in activation functions.\nfunc sigmoid(x float64) float64 {\n\treturn 1.0 / (1.0 + math.Exp(-x))\n}", "id": 8084, "concepts": ["math package usage", "basic function definition"], "_raw_llm_output": "math package usage, basic function definition"}
{"seed": "/*\nCounts number of words within a file\nUses strings.Fields to seperate words by whitespace..much faster than regexing \\S+\\s+ repeatedly and incrementing counter\n\nAssumptions:\n\t--all hyphenated words coun't as one word\n\t--words are seperated by whitespace\n\nParams:\n\tfilename: name of file to perform word count upon\nReturn:\n\tint: word count\n\ttime.Duration: how long the word count operation took \n*/\nfunc wordCount(filename string)(int, time.Duration){\n\tstartTime := time.Now()\n\tfile, err := os.Open(filename)\n\tif err != nil {\n\t\treturn -1000, time.Since(startTime)\n\t}\n\tdefer file.Close()\n\n\tscanner := bufio.NewScanner(file)\n\ttotWc := 0\n\tfor scanner.Scan() {\n\t\twords := strings.Fields(scanner.Text())\n\t\ttotWc += len(words)\n\t}\n\tdur := time.Since(startTime)\n\treturn totWc, dur\n}", "id": 8087, "concepts": ["file I/O", "buffered I/O", "string manipulation", "string splitting", "string formatting", "time package usage", "os package usage"], "_raw_llm_output": "file I/O, buffered I/O, string manipulation, string splitting, string formatting, time package usage, os package usage"}
{"seed": "// Hash take a plaintext password and returns a securely hashed version.\n//\n// Currently uses bcrypt\n//\n// Use this instead of a specific hashing algorithm so we can change which\n// algorithm is used between versions.\nfunc Hash(password string) (string, error) {\n\treturn hashBCRYPT(password)\n}", "id": 8094, "concepts": ["bcrypt", "hashing", "password hashing"], "_raw_llm_output": "bcrypt, hashing, password hashing"}
{"seed": "// AcquireByteBuffer returns an empty byte buffer from the pool.\n//\n// Acquired byte buffer may be returned to the pool via ReleaseByteBuffer call.\n// This reduces the number of memory allocations required for byte buffer\n// management.\nfunc AcquireByteBuffer() *ByteBuffer {\n\tv := byteBufferPool.Get()\n\tif v == nil {\n\t\treturn &ByteBuffer{\n\t\t\tB: make([]byte, 0, defaultByteBufferSize),\n\t\t}\n\t}\n\treturn v.(*ByteBuffer)\n}", "id": 8108, "concepts": ["pointer", "interface", "sync.Pool", "byte buffer management"], "_raw_llm_output": "pointer, interface, sync.Pool, byte buffer management"}
{"seed": "// NoError asserts that an error is nil.\nfunc NoError(t testing.TB, err error, msgAndArgs ...interface{}) {\n\tif err == nil {\n\t\treturn\n\t}\n\tt.Helper()\n\tmsg := formatMsgAndArgs(\"Did not expect an error but got:\", msgAndArgs...)\n\tt.Fatalf(\"%s\\n%s\", msg, err)\n}", "id": 8114, "concepts": ["testing package usage", "error handling (idiomatic `if err != nil`)", "basic function definition"], "_raw_llm_output": "testing package usage, error handling (idiomatic `if err != nil`), basic function definition"}
{"seed": "// IsErrMySQLInvalidArgument returns true when the err type is ErrMySQLInvalidArgumentIdentity.\nfunc IsErrMySQLInvalidArgument(err error) bool {\n\ttarget := new(ErrMySQLInvalidArgumentIdentity)\n\treturn As(err, &target)\n}", "id": 8129, "concepts": ["error handling (errors.As)", "error type comparison"], "_raw_llm_output": "error handling (errors.As), error type comparison"}
{"seed": "// parseComponentVersionsLabel returns the version labels specified in the string or\n// an error. Labels are comma-delimited, key=value pairs, and surrounding whitespace is\n// ignored. Names must be a-z, 0-9, or have interior dashes. All values must be\n// semantic versions. The displayNames label is optional (if provided) and will be combined\n// with the valid versions.\nfunc parseComponentVersionsLabel(label, displayNames string) (ComponentVersions, error) {\n\tlabel = strings.TrimSpace(label)\n\tif len(label) == 0 {\n\t\treturn nil, nil\n\t}\n\tvar names map[string]string\n\tif len(displayNames) > 0 {\n\t\tnames = make(map[string]string)\n\t\tfor _, pair := range strings.Split(displayNames, \",\") {\n\t\t\tpair = strings.TrimSpace(pair)\n\t\t\tparts := strings.SplitN(pair, \"=\", 2)\n\t\t\tif len(parts) == 1 {\n\t\t\t\treturn nil, fmt.Errorf(\"the display name pair %q must be NAME=DISPLAYNAME\", pair)\n\t\t\t}\n\t\t\tif len(parts[0]) < 2 {\n\t\t\t\treturn nil, fmt.Errorf(\"the version name %q must be at least 2 characters\", parts[0])\n\t\t\t}\n\t\t\tif !reAllowedVersionKey.MatchString(parts[0]) {\n\t\t\t\treturn nil, fmt.Errorf(\"the version name %q must only be ASCII alphanumerics and internal hyphens\", parts[0])\n\t\t\t}\n\t\t\tif !reAllowedDisplayNameKey.MatchString(parts[1]) {\n\t\t\t\treturn nil, fmt.Errorf(\"the display name %q must only be alphanumerics, spaces, and symbols in [():-]\", parts[1])\n\t\t\t}\n\t\t\tnames[parts[0]] = parts[1]\n\t\t}\n\t}\n\n\tlabels := make(ComponentVersions)\n\tif len(label) == 0 {\n\t\treturn nil, fmt.Errorf(\"the version pair must be NAME=VERSION\")\n\t}\n\tfor _, pair := range strings.Split(label, \",\") {\n\t\tpair = strings.TrimSpace(pair)\n\t\tparts := strings.SplitN(pair, \"=\", 2)\n\t\tif len(parts) == 1 {\n\t\t\treturn nil, fmt.Errorf(\"the version pair %q must be NAME=VERSION\", pair)\n\t\t}\n\t\tif len(parts[0]) < 2 {\n\t\t\treturn nil, fmt.Errorf(\"the version name %q must be at least 2 characters\", parts[0])\n\t\t}\n\t\tif !reAllowedVersionKey.MatchString(parts[0]) {\n\t\t\treturn nil, fmt.Errorf(\"the version name %q must only be ASCII alphanumerics and internal hyphens\", parts[0])\n\t\t}\n\t\tv, err := semver.Parse(parts[1])\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"the version pair %q must have a valid semantic version: %v\", pair, err)\n\t\t}\n\t\tv.Build = nil\n\t\tlabels[parts[0]] = ComponentVersion{\n\t\t\tVersion:     v.String(),\n\t\t\tDisplayName: names[parts[0]],\n\t\t}\n\t}\n\treturn labels, nil\n}", "id": 8131, "concepts": ["regular expression matching", "semantic versioning", "string manipulation", "error handling (errors.New)", "string formatting", "fmt package usage", "standard library usage"], "_raw_llm_output": "regular expression matching, semantic versioning, string manipulation, error handling (errors.New), string formatting, fmt package usage, standard library usage"}
{"seed": "// RequireJoinPathSegments joins one or more path segments into a slash separated\n// path. Segments cannot contain slashes. The resulting path must be valid or\n// the function panics. It should only be used when the input is statically\n// verifiable.\nfunc RequireJoinPathSegments(segments ...string) string {\n\tpath, err := JoinPathSegments(segments...)\n\tpanicOnErr(err)\n\treturn path\n}", "id": 8143, "concepts": ["panic", "string manipulation", "error handling (panicOnErr)", "standard library usage"], "_raw_llm_output": "panic, string manipulation, error handling (panicOnErr), standard library usage"}
{"seed": "// BuildGoSource builds a target Go package and gives the resulting binary\n// some user-defined name. The function returned by BuildGoSource will remove\n// the binary that got created.\nfunc BuildGoSource(packagePath, output string) (func() error, error) {\n\tcmdBuild := exec.Command(\"go\", \"build\", \"-o\", output, packagePath)\n\tif out, err := cmdBuild.CombinedOutput(); err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to build package: %v (%s)\", err, string(out))\n\t}\n\treturn func() error {\n\t\treturn os.Remove(output)\n\t}, nil\n}", "id": 8154, "concepts": ["exec package usage", "os package usage", "function definition", "function return", "defer"], "_raw_llm_output": "exec package usage, os package usage, function definition, function return, defer"}
{"seed": "// IsHostedProvisioningClusterReady is basic check function that would be used for the wait.WatchWait func in pkg/wait.\n// This functions just waits until a hosted cluster becomes ready.\nfunc IsHostedProvisioningClusterReady(event watch.Event) (ready bool, err error) {\n\tclusterUnstructured := event.Object.(*unstructured.Unstructured)\n\tcluster := &v3.Cluster{}\n\terr = scheme.Scheme.Convert(clusterUnstructured, cluster, clusterUnstructured.GroupVersionKind())\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tfor _, cond := range cluster.Status.Conditions {\n\t\tif cond.Type == \"Ready\" && cond.Status == \"True\" {\n\t\t\tlogrus.Infof(\"Cluster status is active!\")\n\t\t\treturn true, nil\n\t\t}\n\t}\n\n\treturn false, nil\n}", "id": 8157, "concepts": ["unstructured package usage", "scheme package usage", "wait.Event", "wait.WatchWait", "basic function definition"], "_raw_llm_output": "unstructured package usage, scheme package usage, wait.Event, wait.WatchWait, basic function definition"}
{"seed": "// Found returns true if the given path was absolutely found to exist on\n// the system. A false return value means either the file does not\n// exists or it was not able to determine if it exists or not.\n//\n// WARNING: do not use this function if a definitive check for the\n// non-existence of a file is required since the possible indeterminate\n// error state is a possibility. These checks are also not atomic on\n// many file systems so avoid this usage for pseudo-semaphore designs\n// and depend on file locks.\n//\nfunc Found(path string) bool {\n\t_, err := os.Stat(path)\n\treturn err == nil\n}", "id": 8169, "concepts": ["os.Stat", "error handling (idiomatic if err != nil)", "file existence check"], "_raw_llm_output": "os.Stat, error handling (idiomatic if err != nil), file existence check"}
{"seed": "// Season_Uc_TaOf returns a Season_Uc_Ta based on an ordinal number. This is the inverse of Ordinal.\n// If the ordinal is out of range, an invalid Season_Uc_Ta is returned.\nfunc Season_Uc_TaOf(v int) Season_Uc_Ta {\n\tif 0 <= v && v < len(AllSeason_Uc_Tas) {\n\t\treturn AllSeason_Uc_Tas[v]\n\t}\n\t// an invalid result\n\treturn Spring_Uc_Ta + Summer_Uc_Ta + Autumn_Uc_Ta + Winter_Uc_Ta + 1\n}", "id": 8170, "concepts": ["integer comparison", "slice access", "basic function definition"], "_raw_llm_output": "integer comparison, slice access, basic function definition"}
{"seed": "// NewListInstancesParams creates a new ListInstancesParams object\n// with the default values initialized.\nfunc NewListInstancesParams() *ListInstancesParams {\n\tvar ()\n\treturn &ListInstancesParams{\n\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 8175, "concepts": ["struct initialization", "default values", "function definition"], "_raw_llm_output": "struct initialization, default values, function definition"}
{"seed": "// NewGetMachineRolesListAllSpacesParamsWithTimeout creates a new GetMachineRolesListAllSpacesParams object\n// with the default values initialized, and the ability to set a timeout on a request\nfunc NewGetMachineRolesListAllSpacesParamsWithTimeout(timeout time.Duration) *GetMachineRolesListAllSpacesParams {\n\tvar ()\n\treturn &GetMachineRolesListAllSpacesParams{\n\n\t\ttimeout: timeout,\n\t}\n}", "id": 8182, "concepts": ["function definition", "timeout handling", "function parameters"], "_raw_llm_output": "function definition, timeout handling, function parameters"}
{"seed": "// Asset loads and returns the asset for the given name.\n// It returns an error if the asset could not be found or\n// could not be loaded.\nfunc Asset(name string) ([]byte, error) {\n\tcannonicalName := strings.Replace(name, \"\\\\\", \"/\", -1)\n\tif f, ok := _bindata[cannonicalName]; ok {\n\t\ta, err := f()\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"Asset %s can't read by error: %v\", name, err)\n\t\t}\n\t\treturn a.bytes, nil\n\t}\n\treturn nil, fmt.Errorf(\"Asset %s not found\", name)\n}", "id": 8185, "concepts": ["string manipulation", "map lookup", "function definition", "error handling"], "_raw_llm_output": "string manipulation, map lookup, function definition, error handling"}
{"seed": "// New creates a new updater from the given arguments. One updater can be used\n// to update many packages, repeatedly, but not concurrently.\n// bazelAnalyze and updateFile can be passed in to handle ts_auto_deps operation in\n// different environments and for fakes in tests.\nfunc New(removeUnusedDeclarations bool, updateComments bool, bazelAnalyze BazelAnalyzer, updateFile UpdateFile) *Updater {\n\treturn &Updater{removeUnusedDeclarations, updateComments, bazelAnalyze, updateFile}\n}", "id": 8196, "concepts": ["function definition", "function signature", "function return value", "function argument", "function call"], "_raw_llm_output": "function definition, function signature, function return value, function argument, function call"}
{"seed": "// NewExtrasGraphsReadParamsWithContext creates a new ExtrasGraphsReadParams object\n// with the default values initialized, and the ability to set a context for a request\nfunc NewExtrasGraphsReadParamsWithContext(ctx context.Context) *ExtrasGraphsReadParams {\n\tvar ()\n\treturn &ExtrasGraphsReadParams{\n\n\t\tContext: ctx,\n\t}\n}", "id": 8206, "concepts": ["context package", "context.Context", "basic function definition"], "_raw_llm_output": "context package, context.Context, basic function definition"}
{"seed": "// ConflictingRequires reports if the current module or any dependencies have:\r\n//    -- different v0 versions of a shared dependency.\r\n//    -- a v0 version of a shared dependency plus a v1 version.\r\n//    -- a vN+incompatible (N > 2) version of a shared dependency plus a v0, v1, or other vN+incompatible.\r\n// It returns true if so.\r\n// Rule: gomodvet-004\r\nfunc ConflictingRequires(verbose bool) (bool, error) {\r\n\t// obtain the set of requires by all modules in our build (via 'go mod graph').\r\n\t// this takes into account replace directives.\r\n\trequires, err := modgraph.Requirements()\r\n\tif err != nil {\r\n\t\treturn false, err\r\n\t}\r\n\r\n\t// track our paths and versions in { path: {version, version, ...}, ... } map.\r\n\tpaths := make(map[string][]string)\r\n\tfor _, require := range requires {\r\n\t\tf := strings.Split(require, \"@\")\r\n\t\tif len(f) != 2 {\r\n\t\t\treturn false, fmt.Errorf(\"unexpected requirement: %s\", require)\r\n\t\t}\r\n\t\tpath, version := f[0], f[1]\r\n\t\tif !semver.IsValid(version) {\r\n\t\t\treturn false, fmt.Errorf(\"invalid semver version: %s\", require)\r\n\t\t}\r\n\r\n\t\t// Probably not needed, but might as well use the canonical semver version. That strips \"+incompatible\",\r\n\t\t// which we need to preserve. Thus, we check here for \"+incompatible\" and add it back if needed.\r\n\t\tif semver.Build(version) == \"+incompatible\" {\r\n\t\t\tpaths[path] = append(paths[path], semver.Canonical(version)+\"+incompatible\")\r\n\t\t} else {\r\n\t\t\tpaths[path] = append(paths[path], semver.Canonical(version))\r\n\t\t}\r\n\t}\r\n\r\n\t// for each path, loop over its versions (in semantic order) and build up a list\r\n\t// of potential conflicts.\r\n\tflagged := false\r\n\tfor path, versions := range paths {\r\n\t\tsort.Slice(versions, func(i, j int) bool { return -1 == semver.Compare(versions[i], versions[j]) })\r\n\r\n\t\tif verbose {\r\n\t\t\tfmt.Printf(\"gomodvet: conflictingrequires: module %q has require versions: %v\\n\", path, versions)\r\n\t\t}\r\n\r\n\t\tpriorVersion := \"\"\r\n\t\tvar potentialIncompats []string\r\n\t\tfor _, version := range versions {\r\n\t\t\tif version == priorVersion {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\tif isBeforeV1(version) {\r\n\t\t\t\t// all pre-v1 versions are potentially incompatible\r\n\t\t\t\tpotentialIncompats = append(potentialIncompats, version)\r\n\t\t\t} else if isV1(version) && !isV1(priorVersion) {\r\n\t\t\t\t// the first v1 version seen is potentially incompatible with any v0, v2+incompatible, v3+incompatible, etc.\r\n\t\t\t\tpotentialIncompats = append(potentialIncompats, version)\r\n\t\t\t} else if isV2OrHigherIncompat(version) && semver.Major(version) != semver.Major(priorVersion) {\r\n\t\t\t\t// the first major version v2+incompatible, v3+incompatible, etc is potentially incompatible.\r\n\t\t\t\t// (If two v2+incompatible versions are seen, in theory they should be compatible with each other).\r\n\t\t\t\tpotentialIncompats = append(potentialIncompats, version)\r\n\t\t\t}\r\n\t\t\tpriorVersion = version\r\n\t\t}\r\n\t\tif len(potentialIncompats) > 1 {\r\n\t\t\t// mutiple potential incompatible versions, which means they can be incompatible with each other.\r\n\t\t\tfmt.Printf(\"gomodvet-004: module %q was required with potentially incompatible versions: %s\\n\",\r\n\t\t\t\tpath, strings.Join(potentialIncompats, \", \"))\r\n\t\t\tflagged = true\r\n\t\t}\r\n\t}\r\n\treturn flagged, nil\r\n}", "id": 8207, "concepts": ["module graph", "module graph traversal", "string manipulation", "string comparison", "integer comparison", "string formatting", "map usage", "slice usage", "standard library usage"], "_raw_llm_output": "module graph, module graph traversal, string manipulation, string comparison, integer comparison, string formatting, map usage, slice usage, standard library usage"}
{"seed": "// Get the name of the Scylla table that should be used\n// We take the first 1 or 2 underscore-separated words from the\n// metric name. This gives a good distribution of the metrics without\n// having to create too many tables.\nfunc getTableName(metricName string) string {\n\tparts := strings.Split(metricName, \"_\")\n\tname := parts[0]\n\tif len(parts) > 1 {\n\t\tname = fmt.Sprintf(\"%s_%s\", name, parts[1])\n\t}\n\treturn name\n}", "id": 8224, "concepts": ["string manipulation", "string splitting", "string formatting"], "_raw_llm_output": "string manipulation, string splitting, string formatting"}
{"seed": "// VerifyInputPrevOutpointsEqual verifies that the previous outpoints of the\n// two slices of transaction inputs are deep equal to each other. We do the\n// length check and manual loop to provide better error messages to the user\n// than just returning \"not equal\".\nfunc VerifyInputPrevOutpointsEqual(ins1, ins2 []*wire.TxIn) error {\n\tif len(ins1) != len(ins2) {\n\t\treturn fmt.Errorf(\"number of inputs are different\")\n\t}\n\tfor idx, in := range ins1 {\n\t\tif in.PreviousOutPoint != ins2[idx].PreviousOutPoint {\n\t\t\treturn fmt.Errorf(\"previous outpoint of input %d is \"+\n\t\t\t\t\"different\", idx)\n\t\t}\n\t}\n\treturn nil\n}", "id": 8270, "concepts": ["slice iteration", "manual loop", "error handling"], "_raw_llm_output": "slice iteration, manual loop, error handling"}
{"seed": "// BetterHeroScoreAtLTE applies the LTE predicate on the \"better_hero_score_at\" field.\nfunc BetterHeroScoreAtLTE(v time.Time) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.LTE(s.C(FieldBetterHeroScoreAt), v))\n\t})\n}", "id": 8280, "concepts": ["time.Time", "sql.Selector", "sql.C", "sql.LTE", "sql.Where", "predicate.User"], "_raw_llm_output": "time.Time, sql.Selector, sql.C, sql.LTE, sql.Where, predicate.User"}
{"seed": "// stateL1 is the state after reading a non-zero integer during a number,\n// such as after reading `1` or `100` or `L` but not after `L0`.\nfunc stateL1(s *scanner, c byte) int {\n\tif '0' <= c && c <= '9' {\n\t\ts.step = stateL1\n\t\treturn scanContinue\n\t}\n\treturn stateEndValue(s, c)\n}", "id": 8290, "concepts": ["state machine", "state transition", "state handling", "scanner", "state machine usage"], "_raw_llm_output": "state machine, state transition, state handling, scanner, state machine usage"}
{"seed": "// ValuesAreSameType returns true if v1 and v2 has the same reflect.Type,\n// otherwise it returns false.\nfunc ValuesAreSameType(v1 reflect.Value, v2 reflect.Value) bool {\n\treturn v1.Type() == v2.Type()\n}", "id": 8294, "concepts": ["reflect.Value", "reflect.Type", "type comparison"], "_raw_llm_output": "reflect.Value, reflect.Type, type comparison"}
{"seed": "// ParseListElasticIpsResponse parses an HTTP response from a ListElasticIpsWithResponse call\nfunc ParseListElasticIpsResponse(rsp *http.Response) (*ListElasticIpsResponse, error) {\n\tbodyBytes, err := ioutil.ReadAll(rsp.Body)\n\tdefer rsp.Body.Close()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse := &ListElasticIpsResponse{\n\t\tBody:         bodyBytes,\n\t\tHTTPResponse: rsp,\n\t}\n\n\tswitch {\n\tcase strings.Contains(rsp.Header.Get(\"Content-Type\"), \"json\") && rsp.StatusCode == 200:\n\t\tvar dest struct {\n\t\t\tElasticIps *[]ElasticIp `json:\"elastic-ips,omitempty\"`\n\t\t}\n\t\tif err := json.Unmarshal(bodyBytes, &dest); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresponse.JSON200 = &dest\n\n\t}\n\n\treturn response, nil\n}", "id": 8320, "concepts": ["HTTP response parsing", "JSON parsing", "HTTP client usage"], "_raw_llm_output": "HTTP response parsing, JSON parsing, HTTP client usage"}
{"seed": "// RootPkg returns the package path of the root package of all the given\n// packages.\n// It does so by returning the longest common prefix of all package paths.\nfunc RootPkg(pkgs []*pkgs.Package) string {\n\troot := \"\"\n\tfor _, pkg := range pkgs {\n\t\tif root == \"\" {\n\t\t\troot = pkg.PkgPath\n\t\t} else {\n\t\t\troot = commonPrefix(root, pkg.PkgPath)\n\t\t}\n\t}\n\treturn root\n}", "id": 8321, "concepts": ["string manipulation", "string comparison", "string concatenation"], "_raw_llm_output": "string manipulation, string comparison, string concatenation"}
{"seed": "// NewListSecurityGroupsRequest generates requests for ListSecurityGroups\nfunc NewListSecurityGroupsRequest(server string) (*http.Request, error) {\n\tvar err error\n\n\tqueryUrl, err := url.Parse(server)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbasePath := fmt.Sprintf(\"/security-group\")\n\tif basePath[0] == '/' {\n\t\tbasePath = basePath[1:]\n\t}\n\n\tqueryUrl, err = queryUrl.Parse(basePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq, err := http.NewRequest(\"GET\", queryUrl.String(), nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn req, nil\n}", "id": 8326, "concepts": ["url parsing", "http request generation", "string manipulation"], "_raw_llm_output": "url parsing, http request generation, string manipulation"}
{"seed": "// PasswordResetFields return all fields in PasswordReset model\nfunc PasswordResetFields() []string {\n\treturn []string{\n\t\t\"email\",\n\t\t\"token\",\n\t\t\"id\",\n\t\t\"created_at\",\n\t}\n}", "id": 8353, "concepts": ["struct definition", "struct field access", "struct field iteration"], "_raw_llm_output": "struct definition, struct field access, struct field iteration"}
{"seed": "// NewCreateMigrationInvoiceParamsWithTimeout creates a new CreateMigrationInvoiceParams object\n// with the ability to set a timeout on a request.\nfunc NewCreateMigrationInvoiceParamsWithTimeout(timeout time.Duration) *CreateMigrationInvoiceParams {\n\treturn &CreateMigrationInvoiceParams{\n\t\ttimeout: timeout,\n\t}\n}", "id": 8361, "concepts": ["timeout handling", "time package usage"], "_raw_llm_output": "timeout handling, time package usage"}
{"seed": "// NewTokenIn applies the In predicate on the \"new_token\" field.\nfunc NewTokenIn(vs ...string) predicate.User {\n\treturn predicate.User(sql.FieldIn(FieldNewToken, vs...))\n}", "id": 8367, "concepts": ["sql.FieldIn", "predicate.User", "sql package usage"], "_raw_llm_output": "sql.FieldIn, predicate.User, sql package usage"}
{"seed": "// Asset loads and returns the asset for the given name.\n// It returns an error if the asset could not be found or\n// could not be loaded.\nfunc Asset(name string) ([]byte, error) {\n\tcannonicalName := strings.Replace(name, \"\\\\\", \"/\", -1)\n\tif f, ok := _bindata[cannonicalName]; ok {\n\t\treturn f()\n\t}\n\treturn nil, fmt.Errorf(\"Asset %s not found\", name)\n}", "id": 8368, "concepts": ["string manipulation", "map lookup", "function definition", "error handling"], "_raw_llm_output": "string manipulation, map lookup, function definition, error handling"}
{"seed": "// NewGetFileSystemParametersInternalParams creates a new GetFileSystemParametersInternalParams object\n// with the default values initialized.\nfunc NewGetFileSystemParametersInternalParams() *GetFileSystemParametersInternalParams {\n\tvar (\n\t\tattachedClusterDefault = bool(false)\n\t\tsecureDefault          = bool(false)\n\t)\n\treturn &GetFileSystemParametersInternalParams{\n\t\tAttachedCluster: &attachedClusterDefault,\n\t\tSecure:          &secureDefault,\n\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 8378, "concepts": ["struct initialization", "default value assignment", "pointer dereference"], "_raw_llm_output": "struct initialization, default value assignment, pointer dereference"}
{"seed": "// addLdFlags appends the specified ldflags value to args right after the\n// \"build\" or \"install\" arguments. If a -ldflags argument is already present, it\n// normalizes the argument (converts [-ldflags, val] into [-ldflags=val]) and\n// appends the given ldflags value.\nfunc addLdFlags(args []string, ldflags string) ([]string, error) {\n\tif ldIdx := findArg(args, \"-ldflags\"); ldIdx != -1 { // -ldflag exists, normalize and append\n\t\targs = normalizeArg(args, \"-ldflags\")\n\t\targs[ldIdx] = appendToFlag(args[ldIdx], ldflags)\n\t\treturn args, nil\n\t}\n\n\t// -ldflags argument does not exist in args.\n\t// find where to insert the new argument (after \"build\" or \"install\")\n\tinsertIdx := findArg(args, \"build\")\n\tif insertIdx == -1 {\n\t\tinsertIdx = findArg(args, \"install\")\n\t}\n\tif insertIdx == -1 {\n\t\treturn nil, fmt.Errorf(\"cannot locate where to append -ldflags\")\n\t}\n\n\t// allocate a new slice to prevent modifying the old one\n\tnewArgs := make([]string, insertIdx+1, len(args)+2)\n\tcopy(newArgs, args[:insertIdx+1])\n\tnewArgs = append(newArgs, \"-ldflags\", ldflags)\n\tnewArgs = append(newArgs, args[insertIdx+1:]...)\n\treturn newArgs, nil\n}", "id": 8385, "concepts": ["string manipulation", "string concatenation", "string splitting", "string joining", "string conversion", "string comparison", "string length", "string indexing", "string slicing", "string iteration", "string concatenation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", ""], "_raw_llm_output": "string manipulation, string concatenation, string splitting, string joining, string conversion, string comparison, string length, string indexing, string slicing, string iteration, string concatenation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation,"}
{"seed": "// RequestHeaders returns a string containing request header for the given HTTP request.\nfunc RequestHeaders(r *http.Request) string {\n\tvar result []string\n\tfor name, headers := range r.Header {\n\t\tfor _, h := range headers {\n\t\t\tresult = append(result, fmt.Sprintf(\"-H %v: %v\", name, h))\n\t\t}\n\t}\n\n\t// to ensure consistency we force an order.\n\tsort.Strings(result)\n\treturn strings.Join(result, \" \")\n}", "id": 8414, "concepts": ["http.Request", "http.Header", "string formatting", "sort package usage"], "_raw_llm_output": "http.Request, http.Header, string formatting, sort package usage"}
{"seed": "// ServiceUnitPath returns the path to the systemd service file for the given\n// app name.\nfunc ServiceUnitPath(root string, appName types.ACName) string {\n\treturn filepath.Join(common.Stage1RootfsPath(root), UnitsDir, ServiceUnitName(appName))\n}", "id": 8425, "concepts": ["filepath.Join", "filepath.Base", "filepath.Dir", "string manipulation", "string formatting"], "_raw_llm_output": "filepath.Join, filepath.Base, filepath.Dir, string manipulation, string formatting"}
{"seed": "// ListFilesByDateMatching gets all files from a directory that match a given\n// regular expression pattern and orders them by modification date (ascending).\n// Directories and symlinks are excluded from the returned list.\nfunc ListFilesByDateMatching(directory string, pattern string) ([]os.FileInfo, error) {\n\tfilteredFiles := []os.FileInfo{}\n\tfilter, err := regexp.Compile(pattern)\n\tif err != nil {\n\t\treturn filteredFiles, err\n\t}\n\n\tfiles, err := ioutil.ReadDir(directory)\n\tif err != nil {\n\t\treturn filteredFiles, err\n\t}\n\n\tsort.Sort(FilesByDate(files))\n\n\tfor _, file := range files {\n\t\tif file.IsDir() || file.Mode()&os.ModeSymlink == os.ModeSymlink {\n\t\t\tcontinue // ### continue, skip symlinks and directories ###\n\t\t}\n\t\tif filter.MatchString(file.Name()) {\n\t\t\tfilteredFiles = append(filteredFiles, file)\n\t\t}\n\t}\n\n\treturn filteredFiles, nil\n}", "id": 8439, "concepts": ["ioutil.ReadDir", "os.FileInfo", "sort.Sort", "regexp.Compile", "os.FileInfo.IsDir", "os.FileInfo.Mode", "os.ModeSymlink", "FilesByDate"], "_raw_llm_output": "ioutil.ReadDir, os.FileInfo, sort.Sort, regexp.Compile, os.FileInfo.IsDir, os.FileInfo.Mode, os.ModeSymlink, FilesByDate"}
{"seed": "// filterK8sConfigAuthInfos takes in the authInfos map and deletes any invalid\n// authInfo.\n//\n// An authInfo is invalid if the certificate path or the bearer token path mentioned in it is either\n// invalid or is inaccessible to the adapter\n//\n// The function will throw an error if after filtering the authInfos it becomes\n// empty which indicates that the kubeconfig cannot be used for communicating\n// with the kubernetes server.\nfunc filterK8sConfigAuthInfos(authInfos map[string]*clientcmdapi.AuthInfo) error {\n\tfor key, authInfo := range authInfos {\n\t\t// If clientCertficateData or the bearer token is not present then proceed to check\n\t\t// the client certicate path\n\t\tif len(authInfo.ClientCertificateData) == 0 && len(authInfo.Token) == 0 && authInfo.AuthProvider == nil {\n\t\t\t// If the path for clientCertficate and the bearer token, both are inaccessible or invalid then delete that authinfo\n\t\t\t_, errCC := os.Stat(authInfo.ClientCertificate)\n\t\t\t_, errToken := os.Stat(authInfo.TokenFile)\n\t\t\tif errCC != nil && errToken != nil {\n\t\t\t\tdelete(authInfos, key)\n\t\t\t}\n\t\t}\n\t}\n\n\t// In the end if the authInfos map is empty then the kubeconfig is\n\t// invalid and cannot be used for communicating with kubernetes\n\tif len(authInfos) == 0 {\n\t\treturn ErrAuthInfosInvalidMsg\n\t}\n\n\treturn nil\n}", "id": 8440, "concepts": ["map iteration (range loop)", "map deletion", "map access", "error handling"], "_raw_llm_output": "map iteration (range loop), map deletion, map access, error handling"}
{"seed": "// NameEQ applies the EQ predicate on the \"name\" field.\nfunc NameEQ(v string) predicate.User {\n\treturn predicate.User(sql.FieldEQ(FieldName, v))\n}", "id": 8460, "concepts": ["struct field access", "struct field comparison", "sql.FieldEQ", "sql.FieldGT", "sql.FieldLT", "sql.FieldGE", "sql.FieldLE", "sql.FieldNE", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldIsNull", "sql.FieldIsNotNull", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldRegexp", "sql.FieldNotRegexp", "sql.FieldRegexp", "sql.FieldNotRegexp", "sql.FieldRegexp", "sql.FieldNotRegexp", "sql.FieldRegexp", "sql.FieldNotRegexp", "sql.FieldRegexp", "sql.FieldNotRegexp", "sql.FieldRegexp", "sql.FieldNotRegexp", "sql.FieldRegexp", "sql.FieldNotRegexp", "sql.FieldRegexp", "sql.FieldNotRegexp", "sql.FieldRegexp", "sql.FieldNotRegexp", "sql.FieldRegexp", "sql.FieldNotRegexp", "sql.FieldRegexp", "sql.FieldNotRegexp", "sql.FieldRegexp", "sql.FieldNotRegexp", "sql.FieldRegexp", "sql.FieldNotRegexp", "sql.FieldRegexp", "sql.FieldNotRegexp", "sql.FieldRegexp", "sql.FieldNotRegexp", "sql.FieldRegexp", "sql.FieldNotRegexp", "sql.FieldRegexp", "sql.FieldNotRegexp"], "_raw_llm_output": "struct field access, struct field comparison, sql.FieldEQ, sql.FieldGT, sql.FieldLT, sql.FieldGE, sql.FieldLE, sql.FieldNE, sql.FieldIn, sql.FieldNotIn, sql.FieldIsNull, sql.FieldIsNotNull, sql.FieldLike, sql.FieldNotLike, sql.FieldRegexp, sql.FieldNotRegexp, sql.FieldRegexp, sql.FieldNotRegexp, sql.FieldRegexp, sql.FieldNotRegexp, sql.FieldRegexp, sql.FieldNotRegexp, sql.FieldRegexp, sql.FieldNotRegexp, sql.FieldRegexp, sql.FieldNotRegexp, sql.FieldRegexp, sql.FieldNotRegexp, sql.FieldRegexp, sql.FieldNotRegexp, sql.FieldRegexp, sql.FieldNotRegexp, sql.FieldRegexp, sql.FieldNotRegexp, sql.FieldRegexp, sql.FieldNotRegexp, sql.FieldRegexp, sql.FieldNotRegexp, sql.FieldRegexp, sql.FieldNotRegexp, sql.FieldRegexp, sql.FieldNotRegexp, sql.FieldRegexp, sql.FieldNotRegexp, sql.FieldRegexp, sql.FieldNotRegexp, sql.FieldRegexp, sql.FieldNotRegexp"}
{"seed": "// strlen -> https://redis.io/commands/strlen\nfunc strlen(v Args, ex *Extras) error {\n\tex.DB.RLock()\n\tdefer ex.DB.RUnlock()\n\n\texist, tipe := ex.DB.Has(v[0])\n\tif !exist {\n\t\treturn resp.ZeroInteger.WriteTo(ex.Buffer)\n\t}\n\tif tipe != resp.String {\n\t\treturn resp.NewError(ErrWrongType).WriteTo(ex.Buffer)\n\t}\n\n\tval := ex.DB.GetString(v[0])\n\treturn resp.Integer(len(val)).WriteTo(ex.Buffer)\n}", "id": 8470, "concepts": ["string length", "string manipulation", "string comparison", "string concatenation", "string indexing", "string slicing", "string iteration", "string formatting", "string conversion", "string type conversion", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", "string length", ""], "_raw_llm_output": "string length, string manipulation, string comparison, string concatenation, string indexing, string slicing, string iteration, string formatting, string conversion, string type conversion, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length, string length,"}
{"seed": "// ExtendedLocationGenerator returns a generator of ExtendedLocation instances for property testing.\nfunc ExtendedLocationGenerator() gopter.Gen {\n\tif extendedLocationGenerator != nil {\n\t\treturn extendedLocationGenerator\n\t}\n\n\tgenerators := make(map[string]gopter.Gen)\n\tAddIndependentPropertyGeneratorsForExtendedLocation(generators)\n\textendedLocationGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation{}), generators)\n\n\treturn extendedLocationGenerator\n}", "id": 8488, "concepts": ["property-based testing", "gopter package usage", "reflection", "struct definition"], "_raw_llm_output": "property-based testing, gopter package usage, reflection, struct definition"}
{"seed": "// \u521d\u59cb\u5316\u5956\u54c1\u5217\u8868\u4fe1\u606f\uff08\u7ba1\u7406\u540e\u53f0\u6765\u7ef4\u62a4\uff09\nfunc newGift() *[5]gift {\n\tgiftlist := new([5]gift)\n\n\tg1 := gift{\n\t\tid:      1,\n\t\tname:    \"\u5bcc\u5f3a\u798f\",\n\t\tpic:     \"\u5bcc\u5f3a\u798f.jpg\",\n\t\tlink:    \"\",\n\t\tinuse:   true,\n\t\trate:    0,\n\t\trateMin: 0,\n\t\trateMax: 0,\n\t}\n\tgiftlist[0] = g1\n\n\tg2 := gift{\n\t\tid:      2,\n\t\tname:    \"\u548c\u8c10\u798f\",\n\t\tpic:     \"\u548c\u8c10\u798f.jpg\",\n\t\tlink:    \"\",\n\t\tinuse:   true,\n\t\trate:    0,\n\t\trateMin: 0,\n\t\trateMax: 0,\n\t}\n\tgiftlist[1] = g2\n\n\tg3 := gift{\n\t\tid:      3,\n\t\tname:    \"\u53cb\u5584\u798f\",\n\t\tpic:     \"\u53cb\u5584\u798f.jpg\",\n\t\tlink:    \"\",\n\t\tinuse:   true,\n\t\trate:    0,\n\t\trateMin: 0,\n\t\trateMax: 0,\n\t}\n\tgiftlist[2] = g3\n\n\tg4 := gift{\n\t\tid:      4,\n\t\tname:    \"\u7231\u56fd\u798f\",\n\t\tpic:     \"\u7231\u56fd\u798f.jpg\",\n\t\tlink:    \"\",\n\t\tinuse:   true,\n\t\trate:    0,\n\t\trateMin: 0,\n\t\trateMax: 0,\n\t}\n\tgiftlist[3] = g4\n\n\tg5 := gift{\n\t\tid:      5,\n\t\tname:    \"\u656c\u4e1a\u798f\",\n\t\tpic:     \"\u656c\u4e1a\u798f.jpg\",\n\t\tlink:    \"\",\n\t\tinuse:   true,\n\t\trate:    0,\n\t\trateMin: 0,\n\t\trateMax: 0,\n\t}\n\tgiftlist[4] = g5\n\treturn giftlist\n}", "id": 8506, "concepts": ["slice initialization", "basic function definition", "array initialization"], "_raw_llm_output": "slice initialization, basic function definition, array initialization"}
{"seed": "// mustList is like asList but returns an empty list if the object isn't a list.\nfunc mustList(obj pyObject) pyList {\n\tif l, ok := asList(obj); ok {\n\t\treturn l\n\t}\n\treturn pyList{}\n}", "id": 8518, "concepts": ["type conversion", "type assertion", "interface", "basic function definition"], "_raw_llm_output": "type conversion, type assertion, interface, basic function definition"}
{"seed": "// PossibleDefaultActionValues returns an array of possible values for the DefaultAction const type.\nfunc PossibleDefaultActionValues() []DefaultAction {\n\treturn []DefaultAction{Allow, Deny}\n}", "id": 8521, "concepts": ["array definition", "array iteration (range loop)", "basic function definition"], "_raw_llm_output": "array definition, array iteration (range loop), basic function definition"}
{"seed": "/***\n\tFind out the start index and end index for a piece of data\n***/\nfunc calculateStartAndEndOfAPiece(index int, pieceLength int, fileTotalLength int) (begin int, end int) {\n\t// Why we need to calculate\n\tfmt.Println(\"calculateStartAndEndOfAPiece index \", index, \" pieceLength\", pieceLength)\n\tbegin = index * pieceLength\n\tend = begin + pieceLength\n\tif end > fileTotalLength {\n\t\tend = fileTotalLength\n\t}\n\treturn begin, end\n}", "id": 8524, "concepts": ["basic function definition", "integer multiplication", "integer division", "integer summation", "integer comparison", "integer subtraction"], "_raw_llm_output": "basic function definition, integer multiplication, integer division, integer summation, integer comparison, integer subtraction"}
{"seed": "// NewGlobalConfig returns a new GlobalConfig instance with zero values.\nfunc NewGlobalConfig() *GlobalConfig {\n\treturn &GlobalConfig{\n\t\tV1: &V1{},\n\t}\n}", "id": 8525, "concepts": ["struct definition", "struct field initialization", "struct field access"], "_raw_llm_output": "struct definition, struct field initialization, struct field access"}
{"seed": "// acceptsOffer This function determines if an offer matches a given specification.\n// It checks if the specification ends with a '*' or if the offer has the prefix of the specification.\n// Returns true if the offer matches the specification, false otherwise.\nfunc acceptsOffer(spec, offer string) bool {\n\tif len(spec) >= 1 && spec[len(spec)-1] == '*' {\n\t\treturn true\n\t} else if strings.HasPrefix(spec, offer) {\n\t\treturn true\n\t}\n\treturn false\n}", "id": 8543, "concepts": ["string manipulation", "string prefix", "string suffix", "string matching"], "_raw_llm_output": "string manipulation, string prefix, string suffix, string matching"}
{"seed": "// NewListTasksRequest generates requests for ListTasks\nfunc NewListTasksRequest(server string, params *ListTasksParams) (*http.Request, error) {\n\tvar err error\n\n\tqueryUrl, err := url.Parse(server)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbasePath := fmt.Sprintf(\"/domain/v2alpha2/tasks\")\n\tif basePath[0] == '/' {\n\t\tbasePath = basePath[1:]\n\t}\n\n\tqueryUrl, err = queryUrl.Parse(basePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tqueryValues := queryUrl.Query()\n\n\tif params.Page != nil {\n\n\t\tif queryFrag, err := runtime.StyleParam(\"form\", true, \"page\", *params.Page); err != nil {\n\t\t\treturn nil, err\n\t\t} else if parsed, err := url.ParseQuery(queryFrag); err != nil {\n\t\t\treturn nil, err\n\t\t} else {\n\t\t\tfor k, v := range parsed {\n\t\t\t\tfor _, v2 := range v {\n\t\t\t\t\tqueryValues.Add(k, v2)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tif params.PageSize != nil {\n\n\t\tif queryFrag, err := runtime.StyleParam(\"form\", true, \"page_size\", *params.PageSize); err != nil {\n\t\t\treturn nil, err\n\t\t} else if parsed, err := url.ParseQuery(queryFrag); err != nil {\n\t\t\treturn nil, err\n\t\t} else {\n\t\t\tfor k, v := range parsed {\n\t\t\t\tfor _, v2 := range v {\n\t\t\t\t\tqueryValues.Add(k, v2)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tif params.Domain != nil {\n\n\t\tif queryFrag, err := runtime.StyleParam(\"form\", true, \"domain\", *params.Domain); err != nil {\n\t\t\treturn nil, err\n\t\t} else if parsed, err := url.ParseQuery(queryFrag); err != nil {\n\t\t\treturn nil, err\n\t\t} else {\n\t\t\tfor k, v := range parsed {\n\t\t\t\tfor _, v2 := range v {\n\t\t\t\t\tqueryValues.Add(k, v2)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tif params.OrganizationId != nil {\n\n\t\tif queryFrag, err := runtime.StyleParam(\"form\", true, \"organization_id\", *params.OrganizationId); err != nil {\n\t\t\treturn nil, err\n\t\t} else if parsed, err := url.ParseQuery(queryFrag); err != nil {\n\t\t\treturn nil, err\n\t\t} else {\n\t\t\tfor k, v := range parsed {\n\t\t\t\tfor _, v2 := range v {\n\t\t\t\t\tqueryValues.Add(k, v2)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tqueryUrl.RawQuery = queryValues.Encode()\n\n\treq, err := http.NewRequest(\"GET\", queryUrl.String(), nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn req, nil\n}", "id": 8549, "concepts": ["URL parsing", "URL query encoding", "URL query decoding", "URL query parameter handling", "URL query parameter style handling", "URL query parameter style parameter handling", "URL query parameter style parameter style handling", "URL query parameter style parameter style parameter handling", "URL query parameter style parameter style parameter style handling", "URL query parameter style parameter style parameter style parameter handling", "URL query parameter style parameter style parameter style parameter style handling", "URL query parameter style parameter style parameter style parameter style parameter handling", "URL query parameter style parameter style parameter style parameter style parameter style handling", "URL query parameter style parameter style parameter style parameter style parameter style parameter handling", "URL query parameter style parameter style parameter style parameter style parameter style parameter style handling", "URL query parameter style parameter style parameter style parameter style parameter style parameter style parameter handling", "URL query parameter style parameter style parameter style parameter style parameter style parameter style parameter style handling", "URL query parameter style parameter style parameter style parameter style parameter style parameter style parameter style parameter handling", "URL query parameter style parameter style parameter style parameter style parameter style parameter style parameter style parameter style handling", "URL query parameter style parameter style parameter style parameter style parameter style parameter style parameter style parameter style parameter handling", "URL query parameter style parameter style parameter style parameter style parameter style parameter style parameter style parameter style parameter style handling", "URL"], "_raw_llm_output": "URL parsing, URL query encoding, URL query decoding, URL query parameter handling, URL query parameter style handling, URL query parameter style parameter handling, URL query parameter style parameter style handling, URL query parameter style parameter style parameter handling, URL query parameter style parameter style parameter style handling, URL query parameter style parameter style parameter style parameter handling, URL query parameter style parameter style parameter style parameter style handling, URL query parameter style parameter style parameter style parameter style parameter handling, URL query parameter style parameter style parameter style parameter style parameter style handling, URL query parameter style parameter style parameter style parameter style parameter style parameter handling, URL query parameter style parameter style parameter style parameter style parameter style parameter style handling, URL query parameter style parameter style parameter style parameter style parameter style parameter style parameter handling, URL query parameter style parameter style parameter style parameter style parameter style parameter style parameter style handling, URL query parameter style parameter style parameter style parameter style parameter style parameter style parameter style parameter handling, URL query parameter style parameter style parameter style parameter style parameter style parameter style parameter style parameter style handling, URL query parameter style parameter style parameter style parameter style parameter style parameter style parameter style parameter style parameter handling, URL query parameter style parameter style parameter style parameter style parameter style parameter style parameter style parameter style parameter style handling, URL"}
{"seed": "// mustGetEnv is a test helper that fetches an env variable or fails with an\n// error describing the missing env variable.\nfunc mustGetEnv(t *testing.T, key string) string {\n\tt.Helper()\n\tval := os.Getenv(key)\n\trequire.NotEmpty(t, val, \"%s environment variable must be set and not empty\", key)\n\treturn val\n}", "id": 8562, "concepts": ["testing", "os.Getenv", "require.NotEmpty"], "_raw_llm_output": "testing, os.Getenv, require.NotEmpty"}
{"seed": "// Blockquote represents the HTML element 'blockquote'.\n// For more information visit https://www.w3schools.com/tags/tag_blockquote.asp.\nfunc Blockquote(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"blockquote\", Attributes: attrs, Children: children}\n}", "id": 8565, "concepts": ["HTML generation", "HTML tree", "HTML element definition", "HTML attribute definition"], "_raw_llm_output": "HTML generation, HTML tree, HTML element definition, HTML attribute definition"}
{"seed": "// flushAndClose helps to flush and close a ReadCloser. Used for request body internal.\n// Returns if there is any errors.\nfunc flushAndClose(rc io.ReadCloser) error {\n\tif rc != nil {\n\t\t// flush\n\t\t_, err := io.Copy(ioutil.Discard, rc)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// close\n\t\treturn rc.Close()\n\t}\n\treturn nil\n}", "id": 8566, "concepts": ["io.Copy", "io.ReadCloser", "io.Closer", "io.Writer", "io.Reader", "io.Closer", "io.ReaderFrom", "io.WriterTo", "io.Seeker", "io.SeekerFrom", "io.SeekerTo", "io.ByteReader", "io.ByteWriter", "io.RuneReader", "io.RuneWriter", "io.ByteScanner", "io.ByteSizer", "io.RuneScanner", "io.RuneSizer", "io.ReaderAt", "io.WriterAt", "io.SeekerAt", "io.ReaderFrom", "io.WriterTo", "io.ByteReader", "io.ByteWriter", "io.RuneReader", "io.RuneWriter", "io.ByteScanner", "io.ByteSizer", "io.RuneScanner", "io.RuneSizer", "io.ReaderAt", "io.WriterAt", "io.SeekerAt", "io.ReaderFrom", "io.WriterTo", "io.ByteReader", "io.ByteWriter", "io.RuneReader", "io.RuneWriter", "io.ByteScanner", "io.ByteSizer", "io.RuneScanner", "io.RuneSizer", "io.ReaderAt", "io.WriterAt", "io.SeekerAt", "io.ReaderFrom", "io.WriterTo", "io.ByteReader", ""], "_raw_llm_output": "io.Copy, io.ReadCloser, io.Closer, io.Writer, io.Reader, io.Closer, io.ReaderFrom, io.WriterTo, io.Seeker, io.SeekerFrom, io.SeekerTo, io.ByteReader, io.ByteWriter, io.RuneReader, io.RuneWriter, io.ByteScanner, io.ByteSizer, io.RuneScanner, io.RuneSizer, io.ReaderAt, io.WriterAt, io.SeekerAt, io.ReaderFrom, io.WriterTo, io.ByteReader, io.ByteWriter, io.RuneReader, io.RuneWriter, io.ByteScanner, io.ByteSizer, io.RuneScanner, io.RuneSizer, io.ReaderAt, io.WriterAt, io.SeekerAt, io.ReaderFrom, io.WriterTo, io.ByteReader, io.ByteWriter, io.RuneReader, io.RuneWriter, io.ByteScanner, io.ByteSizer, io.RuneScanner, io.RuneSizer, io.ReaderAt, io.WriterAt, io.SeekerAt, io.ReaderFrom, io.WriterTo, io.ByteReader,"}
{"seed": "// HeroPlayedEQ applies the EQ predicate on the \"hero_played\" field.\nfunc HeroPlayedEQ(v uint) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldHeroPlayed), v))\n\t})\n}", "id": 8569, "concepts": ["sql.Selector", "sql.EQ", "sql.Where", "sql.C", "sql.Predicate", "sql.Field", "sql.Selector.Where"], "_raw_llm_output": "sql.Selector, sql.EQ, sql.Where, sql.C, sql.Predicate, sql.Field, sql.Selector.Where"}
{"seed": "// MustJSON return JSON string of the given value.\n// In case of a marshal failure, return string value using fmt package.\nfunc MustJSON(v interface{}) string {\n\tb, err := json.Marshal(v)\n\tif err != nil {\n\t\treturn fmt.Sprintf(\"%v\", v)\n\t}\n\treturn string(b)\n}", "id": 8571, "concepts": ["json encoding", "json decoding", "error handling", "fmt package usage"], "_raw_llm_output": "json encoding, json decoding, error handling, fmt package usage"}
{"seed": "// GetAllTasks returns slice containing all Tasks from taskBucket.\nfunc GetAllTasks() ([]Task, error) {\n\tvar tasks []Task\n\n\terr := db.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket(taskBucket)\n\t\tc := b.Cursor()\n\n\t\tfor key, val := c.First(); key != nil; key, val = c.Next() {\n\t\t\ttask, err := TaskFromJSON(val)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\ttasks = append(tasks, task)\n\t\t}\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn tasks, err\n\t}\n\n\treturn tasks, nil\n}", "id": 8583, "concepts": ["BoltDB", "BoltDB cursor", "BoltDB bucket", "BoltDB transaction", "BoltDB iteration", "BoltDB bucket iteration", "BoltDB cursor iteration", "BoltDB bucket cursor iteration", "BoltDB bucket cursor iteration", "BoltDB bucket cursor iteration", "BoltDB bucket cursor iteration", "BoltDB bucket cursor iteration", "BoltDB bucket cursor iteration", "BoltDB bucket cursor iteration", "BoltDB bucket cursor iteration", "BoltDB bucket cursor iteration", "BoltDB bucket cursor iteration", "BoltDB bucket cursor iteration", "BoltDB bucket cursor iteration", "BoltDB bucket cursor iteration", "BoltDB bucket cursor iteration", "BoltDB bucket cursor iteration", "BoltDB bucket cursor iteration", "BoltDB bucket cursor iteration", "BoltDB bucket cursor iteration", "BoltDB bucket cursor iteration", "BoltDB bucket cursor iteration", "BoltDB bucket cursor iteration", "BoltDB bucket cursor iteration", "BoltDB bucket cursor iteration", "BoltDB bucket cursor iteration", "BoltDB bucket cursor iteration", "BoltDB bucket cursor iteration", "BoltDB bucket cursor iteration", "BoltDB bucket cursor iteration", "BoltDB bucket cursor iteration", "BoltDB bucket cursor iteration", "BoltDB bucket cursor iteration", "Bolt"], "_raw_llm_output": "BoltDB, BoltDB cursor, BoltDB bucket, BoltDB transaction, BoltDB iteration, BoltDB bucket iteration, BoltDB cursor iteration, BoltDB bucket cursor iteration, BoltDB bucket cursor iteration, BoltDB bucket cursor iteration, BoltDB bucket cursor iteration, BoltDB bucket cursor iteration, BoltDB bucket cursor iteration, BoltDB bucket cursor iteration, BoltDB bucket cursor iteration, BoltDB bucket cursor iteration, BoltDB bucket cursor iteration, BoltDB bucket cursor iteration, BoltDB bucket cursor iteration, BoltDB bucket cursor iteration, BoltDB bucket cursor iteration, BoltDB bucket cursor iteration, BoltDB bucket cursor iteration, BoltDB bucket cursor iteration, BoltDB bucket cursor iteration, BoltDB bucket cursor iteration, BoltDB bucket cursor iteration, BoltDB bucket cursor iteration, BoltDB bucket cursor iteration, BoltDB bucket cursor iteration, BoltDB bucket cursor iteration, BoltDB bucket cursor iteration, BoltDB bucket cursor iteration, BoltDB bucket cursor iteration, BoltDB bucket cursor iteration, BoltDB bucket cursor iteration, BoltDB bucket cursor iteration, BoltDB bucket cursor iteration, Bolt"}
{"seed": "// transformShiritoriviewsMessagePayloadViewToMessagePayload builds a value of\n// type *MessagePayload from a value of type *shiritoriviews.MessagePayloadView.\nfunc transformShiritoriviewsMessagePayloadViewToMessagePayload(v *shiritoriviews.MessagePayloadView) *MessagePayload {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tres := &MessagePayload{\n\t\tMessage: *v.Message,\n\t}\n\n\treturn res\n}", "id": 8586, "concepts": ["type conversion", "pointer handling", "interface conversion"], "_raw_llm_output": "type conversion, pointer handling, interface conversion"}
{"seed": "// allCommandsMap returns a map of all commands in the devfile, indexed by Id\nfunc allCommandsMap(devfileObj parser.DevfileObj) (map[string]v1alpha2.Command, error) {\n\tcommands, err := devfileObj.Data.GetCommands(common.DevfileOptions{})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcommandMap := make(map[string]v1alpha2.Command, len(commands))\n\tfor _, command := range commands {\n\t\tcommandMap[strings.ToLower(command.Id)] = command\n\t}\n\n\treturn commandMap, nil\n}", "id": 8589, "concepts": ["map iteration (range loop)", "map creation", "string manipulation", "string comparison"], "_raw_llm_output": "map iteration (range loop), map creation, string manipulation, string comparison"}
{"seed": "// Nobr_ is a convenience wrapper for Nobr without the attrs argument.\nfunc Nobr_(children ...HTML) HTML {\n  return Nobr(nil, children...)\n}", "id": 8601, "concepts": ["HTML rendering", "HTML attributes", "HTML tag rendering"], "_raw_llm_output": "HTML rendering, HTML attributes, HTML tag rendering"}
{"seed": "// SocialUserIDNEQ applies the NEQ predicate on the \"social_user_id\" field.\nfunc SocialUserIDNEQ(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldSocialUserID), v))\n\t})\n}", "id": 8611, "concepts": ["sql.Selector", "sql.NEQ", "sql.C", "predicate.User", "predicate.FieldSocialUserID"], "_raw_llm_output": "sql.Selector, sql.NEQ, sql.C, predicate.User, predicate.FieldSocialUserID"}
{"seed": "// startGofer starts a new gofer routine serving 'root' path. It returns the\n// sandbox side of the connection, and a function that when called will stop the\n// gofer.\nfunc startGofer(root string) (int, func(), error) {\n\tfds, err := syscall.Socketpair(syscall.AF_UNIX, syscall.SOCK_STREAM|syscall.SOCK_CLOEXEC, 0)\n\tif err != nil {\n\t\treturn 0, nil, err\n\t}\n\tsandboxEnd, goferEnd := fds[0], fds[1]\n\n\tsocket, err := unet.NewSocket(goferEnd)\n\tif err != nil {\n\t\tsyscall.Close(sandboxEnd)\n\t\tsyscall.Close(goferEnd)\n\t\treturn 0, nil, fmt.Errorf(\"error creating server on FD %d: %v\", goferEnd, err)\n\t}\n\tat, err := fsgofer.NewAttachPoint(root, fsgofer.Config{ROMount: true})\n\tif err != nil {\n\t\treturn 0, nil, err\n\t}\n\tgo func() {\n\t\ts := p9.NewServer(at)\n\t\tif err := s.Handle(socket); err != nil {\n\t\t\tlog.Infof(\"Gofer is stopping. FD: %d, err: %v\\n\", goferEnd, err)\n\t\t}\n\t}()\n\t// Closing the gofer socket will stop the gofer and exit goroutine above.\n\tcleanup := func() {\n\t\tif err := socket.Close(); err != nil {\n\t\t\tlog.Warningf(\"Error closing gofer socket: %v\", err)\n\t\t}\n\t}\n\treturn sandboxEnd, cleanup, nil\n}", "id": 8616, "concepts": ["syscall.Socketpair", "syscall.Close", "p9.NewServer", "fsgofer.NewAttachPoint", "fsgofer.Config", "fsgofer.ROMount", "goroutines", "anonymous function"], "_raw_llm_output": "syscall.Socketpair, syscall.Close, p9.NewServer, fsgofer.NewAttachPoint, fsgofer.Config, fsgofer.ROMount, goroutines, anonymous function"}
{"seed": "// NewNetworkPruneParamsWithTimeout creates a new NetworkPruneParams object\n// with the default values initialized, and the ability to set a timeout on a request\nfunc NewNetworkPruneParamsWithTimeout(timeout time.Duration) *NetworkPruneParams {\n\tvar ()\n\treturn &NetworkPruneParams{\n\n\t\ttimeout: timeout,\n\t}\n}", "id": 8633, "concepts": ["struct initialization", "struct field initialization", "struct field assignment", "struct field access", "struct method definition", "struct method call", "struct method call with field access", "struct method call with field assignment", "struct method call with field access and assignment", "struct method call with field access and assignment", "struct method call with field access and assignment", "struct method call with field access and assignment", "struct method call with field access and assignment", "struct method call with field access and assignment", "struct method call with field access and assignment", "struct method call with field access and assignment", "struct method call with field access and assignment", "struct method call with field access and assignment", "struct method call with field access and assignment", "struct method call with field access and assignment", "struct method call with field access and assignment", "struct method call with field access and assignment", "struct method call with field access and assignment", "struct method call with field access and assignment", "struct method call with field access and assignment", "struct method call with field access and assignment", "struct method call with field access and assignment", "struct method call with field access and assignment", "struct method call with field access and assignment", "struct method call with field access and assignment", "struct method call with field access and assignment", "struct method call with field access and assignment", "struct method"], "_raw_llm_output": "struct initialization, struct field initialization, struct field assignment, struct field access, struct method definition, struct method call, struct method call with field access, struct method call with field assignment, struct method call with field access and assignment, struct method call with field access and assignment, struct method call with field access and assignment, struct method call with field access and assignment, struct method call with field access and assignment, struct method call with field access and assignment, struct method call with field access and assignment, struct method call with field access and assignment, struct method call with field access and assignment, struct method call with field access and assignment, struct method call with field access and assignment, struct method call with field access and assignment, struct method call with field access and assignment, struct method call with field access and assignment, struct method call with field access and assignment, struct method call with field access and assignment, struct method call with field access and assignment, struct method call with field access and assignment, struct method call with field access and assignment, struct method call with field access and assignment, struct method call with field access and assignment, struct method call with field access and assignment, struct method call with field access and assignment, struct method call with field access and assignment, struct method"}
{"seed": "// DescriptionHasSuffix applies the HasSuffix predicate on the \"description\" field.\nfunc DescriptionHasSuffix(v string) predicate.User {\n\treturn predicate.User(sql.FieldHasSuffix(FieldDescription, v))\n}", "id": 8641, "concepts": ["sql.FieldHasSuffix", "sql.FieldHasSuffix", "sql.FieldHasSuffix"], "_raw_llm_output": "sql.FieldHasSuffix, sql.FieldHasSuffix, sql.FieldHasSuffix"}
{"seed": "// DRMDataFiles returns a list of required files for tests that play DRM videos.\nfunc DRMDataFiles() []string {\n\treturn []string{\n\t\t\"shaka_drm.html\",\n\t\t\"third_party/shaka-player/shaka-player.compiled.debug.js\",\n\t\t\"third_party/shaka-player/shaka-player.compiled.debug.map\",\n\t}\n}", "id": 8643, "concepts": ["slice definition", "slice iteration (range loop)", "string concatenation"], "_raw_llm_output": "slice definition, slice iteration (range loop), string concatenation"}
{"seed": "// WithFaction middleware sets the faction corresponding to the :factionID URL parameter into\n// ctx.Locals under the key \"faction\"\nfunc WithFaction(r factions.Reader) func(*fiber.Ctx) error {\n\treturn func(ctx *fiber.Ctx) error {\n\t\tid, err := uuid.FromString(ctx.Params(\"factionID\"))\n\t\tif err != nil {\n\t\t\treturn newErrBadRequest(\"Invalid FactionID\")\n\t\t}\n\t\tfaction, err := r.FindOne(factions.FindOneQuery{ID: id})\n\t\tif err != nil {\n\t\t\treturn handleFindOneError(err, \"Faction\")\n\t\t}\n\t\tctx.Locals(\"faction\", faction)\n\t\treturn ctx.Next()\n\t}\n}", "id": 8645, "concepts": ["fiber package usage", "uuid package usage", "error handling (uuid.FromString)", "error handling (errors.Is)", "error handling (errors.As)", "error handling (custom error type)", "error handling (custom error type)", "error handling (custom error type)", "error handling (custom error type)", "error handling (custom error type)", "error handling (custom error type)", "error handling (custom error type)", "error handling (custom error type)", "error handling (custom error type)", "error handling (custom error type)", "error handling (custom error type)", "error handling (custom error type)", "error handling (custom error type)", "error handling (custom error type)", "error handling (custom error type)", "error handling (custom error type)", "error handling (custom error type)", "error handling (custom error type)", "error handling (custom error type)", "error handling (custom error type)", "error handling (custom error type)", "error handling (custom error type)", "error handling (custom error type)", "error handling (custom error type)", "error handling (custom error type)", "error handling (custom error type)", "error handling (custom error type)", "error handling (custom error type)", "error handling (custom error type)", "error handling (custom error type)", "error handling (custom error type)", "error handling (custom error type)", "error handling"], "_raw_llm_output": "fiber package usage, uuid package usage, error handling (uuid.FromString), error handling (errors.Is), error handling (errors.As), error handling (custom error type), error handling (custom error type), error handling (custom error type), error handling (custom error type), error handling (custom error type), error handling (custom error type), error handling (custom error type), error handling (custom error type), error handling (custom error type), error handling (custom error type), error handling (custom error type), error handling (custom error type), error handling (custom error type), error handling (custom error type), error handling (custom error type), error handling (custom error type), error handling (custom error type), error handling (custom error type), error handling (custom error type), error handling (custom error type), error handling (custom error type), error handling (custom error type), error handling (custom error type), error handling (custom error type), error handling (custom error type), error handling (custom error type), error handling (custom error type), error handling (custom error type), error handling (custom error type), error handling (custom error type), error handling (custom error type), error handling (custom error type), error handling"}
{"seed": "// Em represents the HTML element 'em'.\n// For more information visit https://www.w3schools.com/tags/tag_em.asp.\nfunc Em(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"em\", Attributes: attrs, Children: children}\n}", "id": 8653, "concepts": ["HTML generation", "HTML tree", "HTML element definition", "HTML attribute definition"], "_raw_llm_output": "HTML generation, HTML tree, HTML element definition, HTML attribute definition"}
{"seed": "// NewAlertingEventTypeFilterWithDefaults instantiates a new AlertingEventTypeFilter object\n// This constructor will only assign default values to properties that have it defined,\n// but it doesn't guarantee that properties required by API are set\nfunc NewAlertingEventTypeFilterWithDefaults() *AlertingEventTypeFilter {\n\tthis := AlertingEventTypeFilter{}\n\treturn &this\n}", "id": 8657, "concepts": ["struct instantiation", "default value assignment"], "_raw_llm_output": "struct instantiation, default value assignment"}
{"seed": "// Select_ is a convenience wrapper for Select without the attrs argument.\nfunc Select_(children ...HTML) HTML {\n  return Select(nil, children...)\n}", "id": 8675, "concepts": ["HTML type", "basic function definition", "variadic function definition"], "_raw_llm_output": "HTML type, basic function definition, variadic function definition"}
{"seed": "// Dt represents the HTML element 'dt'.\n// For more information visit https://www.w3schools.com/tags/tag_dt.asp.\nfunc Dt(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"dt\", Attributes: attrs, Children: children}\n}", "id": 8677, "concepts": ["HTML generation", "HTML generation with attributes", "HTML generation with children"], "_raw_llm_output": "HTML generation, HTML generation with attributes, HTML generation with children"}
{"seed": "// Compose two Image operations into a single operation.\n// I.e. if h := Compose(f,g), then h(img) is equivalent to g(f(img))\nfunc Compose(op1, op2 ImageOp) ImageOp {\n\treturn func(img *imgproc.FloatImage) {\n\t\t// perform op1 then op2\n\t\top1(img)\n\t\top2(img)\n\t}\n}", "id": 8678, "concepts": ["function composition", "function definition", "function call"], "_raw_llm_output": "function composition, function definition, function call"}
{"seed": "// FilterPaths filters the given paths, returning the deduplicated set of\n// folders that contain TypeScript sources (.ts and .tsx) or BUILD files.\nfunc FilterPaths(paths []string) []string {\n\tfileSet := make(map[string]bool)\n\tfor _, p := range paths {\n\t\tif !strings.HasSuffix(p, \".ts\") && !strings.HasSuffix(p, \".tsx\") && filepath.Base(p) != \"BUILD\" {\n\t\t\tcontinue\n\t\t}\n\t\tfileSet[filepath.Dir(p)] = true\n\t}\n\tvar newPaths []string\n\tfor k := range fileSet {\n\t\tnewPaths = append(newPaths, platform.Normalize(k))\n\t}\n\treturn newPaths\n}", "id": 8683, "concepts": ["map", "string manipulation", "filepath.Dir", "filepath.Base", "filepath.Join", "filepath.IsAbs", "filepath.Clean", "filepath.ToSlash", "filepath.Ext", "filepath.Match", "filepath.Split", "filepath.SplitList", "filepath.SplitPath", "filepath.SplitPathList", "filepath.SplitHost", "filepath.SplitDevice", "filepath.SplitUser", "filepath.SplitUNC", "filepath.SplitDrive", "filepath.SplitVolume", "filepath.SplitSuffix", "filepath.MatchPattern", "filepath.MatchPatternList", "filepath.MatchPatternList", "filepath.MatchPatternList", "filepath.MatchPatternList", "filepath.MatchPatternList", "filepath.MatchPatternList", "filepath.MatchPatternList", "filepath.MatchPatternList", "filepath.MatchPatternList", "filepath.MatchPatternList", "filepath.MatchPatternList", "filepath.MatchPatternList", "filepath.MatchPatternList", "filepath.MatchPatternList", "filepath.MatchPatternList", "filepath.MatchPatternList", "filepath.MatchPatternList", "filepath.MatchPatternList", "filepath.MatchPatternList", "filepath.MatchPatternList", "filepath.MatchPatternList", "filepath.MatchPatternList", "filepath.MatchPatternList", "filepath.MatchPatternList", "filepath.MatchPatternList", "filepath.MatchPatternList", ""], "_raw_llm_output": "map, string manipulation, filepath.Dir, filepath.Base, filepath.Join, filepath.IsAbs, filepath.Clean, filepath.ToSlash, filepath.Ext, filepath.Match, filepath.Split, filepath.SplitList, filepath.SplitPath, filepath.SplitPathList, filepath.SplitHost, filepath.SplitDevice, filepath.SplitUser, filepath.SplitUNC, filepath.SplitDrive, filepath.SplitVolume, filepath.SplitSuffix, filepath.MatchPattern, filepath.MatchPatternList, filepath.MatchPatternList, filepath.MatchPatternList, filepath.MatchPatternList, filepath.MatchPatternList, filepath.MatchPatternList, filepath.MatchPatternList, filepath.MatchPatternList, filepath.MatchPatternList, filepath.MatchPatternList, filepath.MatchPatternList, filepath.MatchPatternList, filepath.MatchPatternList, filepath.MatchPatternList, filepath.MatchPatternList, filepath.MatchPatternList, filepath.MatchPatternList, filepath.MatchPatternList, filepath.MatchPatternList, filepath.MatchPatternList, filepath.MatchPatternList, filepath.MatchPatternList, filepath.MatchPatternList, filepath.MatchPatternList, filepath.MatchPatternList, filepath.MatchPatternList,"}
{"seed": "// BulkCreditSamedayGTE applies the GTE predicate on the \"bulkCreditSameday\" field.\nfunc BulkCreditSamedayGTE(v float64) predicate.Bulk {\n\treturn predicate.Bulk(func(s *sql.Selector) {\n\t\ts.Where(sql.GTE(s.C(FieldBulkCreditSameday), v))\n\t})\n}", "id": 8687, "concepts": ["SQL query building", "SQL query building with SQL builder", "SQL query building with SQL query builder", "SQL query building with SQL query builder with predicate", "SQL query building with SQL query builder with predicate with SQL query builder", "SQL query building with SQL query builder with predicate with SQL query builder with SQL query builder", "SQL query building with SQL query builder with predicate with SQL query builder with SQL query builder with SQL query builder", "SQL query building with SQL query builder with predicate with SQL query builder with SQL query builder with SQL query builder with SQL query builder", "SQL query building with SQL query builder with predicate with SQL query builder with SQL query builder with SQL query builder with SQL query builder with SQL query builder", "SQL query building with SQL query builder with predicate with SQL query builder with SQL query builder with SQL query builder with SQL query builder with SQL query builder with SQL query builder", "SQL query building with SQL query builder with predicate with SQL query builder with SQL query builder with SQL query builder with SQL query builder with SQL query builder with SQL query builder with SQL query builder", "SQL query building with SQL query builder with predicate with SQL query builder with SQL query builder with SQL query builder with SQL query builder with SQL query builder with SQL query builder with SQL query builder with SQL query builder", "SQL query"], "_raw_llm_output": "SQL query building, SQL query building with SQL builder, SQL query building with SQL query builder, SQL query building with SQL query builder with predicate, SQL query building with SQL query builder with predicate with SQL query builder, SQL query building with SQL query builder with predicate with SQL query builder with SQL query builder, SQL query building with SQL query builder with predicate with SQL query builder with SQL query builder with SQL query builder, SQL query building with SQL query builder with predicate with SQL query builder with SQL query builder with SQL query builder with SQL query builder, SQL query building with SQL query builder with predicate with SQL query builder with SQL query builder with SQL query builder with SQL query builder with SQL query builder, SQL query building with SQL query builder with predicate with SQL query builder with SQL query builder with SQL query builder with SQL query builder with SQL query builder with SQL query builder, SQL query building with SQL query builder with predicate with SQL query builder with SQL query builder with SQL query builder with SQL query builder with SQL query builder with SQL query builder with SQL query builder, SQL query building with SQL query builder with predicate with SQL query builder with SQL query builder with SQL query builder with SQL query builder with SQL query builder with SQL query builder with SQL query builder with SQL query builder, SQL query"}
{"seed": "// PossibleDefaultPrincipalsModificationKindValues returns an array of possible values for the DefaultPrincipalsModificationKind const type.\nfunc PossibleDefaultPrincipalsModificationKindValues() []DefaultPrincipalsModificationKind {\n\treturn []DefaultPrincipalsModificationKind{DefaultPrincipalsModificationKindNone, DefaultPrincipalsModificationKindReplace, DefaultPrincipalsModificationKindUnion}\n}", "id": 8707, "concepts": ["type definition", "type conversion", "type assertion"], "_raw_llm_output": "type definition, type conversion, type assertion"}
{"seed": "// NewLogger creates a new Logger object and returns it.\n// Arguments:\n//   outFile is the output file that logs are written to.\n//   logChan is the channel to push strings (messages) to.\n// Returns:\n//   Logger object.\nfunc NewLogger(outFile string, logChan chan string) Logger {\n\treturn Logger{\n\t\tOutputFile: outFile,\n\t\tLogChannel: logChan,\n\t}\n}", "id": 8720, "concepts": ["struct definition", "channel usage", "anonymous function"], "_raw_llm_output": "struct definition, channel usage, anonymous function"}
{"seed": "// PrivateLinkServiceConnectionGenerator returns a generator of PrivateLinkServiceConnection instances for property testing.\n// We first initialize privateLinkServiceConnectionGenerator with a simplified generator based on the\n// fields with primitive types then replacing it with a more complex one that also handles complex fields\n// to ensure any cycles in the object graph properly terminate.\nfunc PrivateLinkServiceConnectionGenerator() gopter.Gen {\n\tif privateLinkServiceConnectionGenerator != nil {\n\t\treturn privateLinkServiceConnectionGenerator\n\t}\n\n\tgenerators := make(map[string]gopter.Gen)\n\tAddIndependentPropertyGeneratorsForPrivateLinkServiceConnection(generators)\n\tprivateLinkServiceConnectionGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServiceConnection{}), generators)\n\n\t// The above call to gen.Struct() captures the map, so create a new one\n\tgenerators = make(map[string]gopter.Gen)\n\tAddIndependentPropertyGeneratorsForPrivateLinkServiceConnection(generators)\n\tAddRelatedPropertyGeneratorsForPrivateLinkServiceConnection(generators)\n\tprivateLinkServiceConnectionGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServiceConnection{}), generators)\n\n\treturn privateLinkServiceConnectionGenerator\n}", "id": 8732, "concepts": ["struct definition", "map iteration", "map creation", "map usage", "struct iteration", "struct usage", "struct creation", "struct usage", "struct iteration", "struct usage", "struct creation", "struct usage", "struct iteration", "struct usage", "struct creation", "struct usage", "struct iteration", "struct usage", "struct creation", "struct usage", "struct iteration", "struct usage", "struct creation", "struct usage", "struct iteration", "struct usage", "struct creation", "struct usage", "struct iteration", "struct usage", "struct creation", "struct usage", "struct iteration", "struct usage", "struct creation", "struct usage", "struct iteration", "struct usage", "struct creation", "struct usage", "struct iteration", "struct usage", "struct creation", "struct usage", "struct iteration", "struct usage", "struct creation", "struct usage", "struct iteration", "struct usage", "struct creation", "struct usage", "struct iteration", "struct usage", "struct creation", "struct usage", "struct iteration", "struct usage", "struct creation", "struct usage", "struct iteration", "struct usage", "struct creation", "struct usage", "struct iteration", "struct usage", "struct creation", "struct usage", "struct iteration", "struct usage", "struct creation", "struct usage", "struct iteration", "struct usage", "struct creation", "struct usage", "struct iteration", "struct usage", "struct creation", "struct usage", "struct iteration", "struct usage", "struct creation", "struct usage", "struct iteration", ""], "_raw_llm_output": "struct definition, map iteration, map creation, map usage, struct iteration, struct usage, struct creation, struct usage, struct iteration, struct usage, struct creation, struct usage, struct iteration, struct usage, struct creation, struct usage, struct iteration, struct usage, struct creation, struct usage, struct iteration, struct usage, struct creation, struct usage, struct iteration, struct usage, struct creation, struct usage, struct iteration, struct usage, struct creation, struct usage, struct iteration, struct usage, struct creation, struct usage, struct iteration, struct usage, struct creation, struct usage, struct iteration, struct usage, struct creation, struct usage, struct iteration, struct usage, struct creation, struct usage, struct iteration, struct usage, struct creation, struct usage, struct iteration, struct usage, struct creation, struct usage, struct iteration, struct usage, struct creation, struct usage, struct iteration, struct usage, struct creation, struct usage, struct iteration, struct usage, struct creation, struct usage, struct iteration, struct usage, struct creation, struct usage, struct iteration, struct usage, struct creation, struct usage, struct iteration, struct usage, struct creation, struct usage, struct iteration, struct usage, struct creation, struct usage, struct iteration,"}
{"seed": "// Ins represents the HTML element 'ins'.\n// For more information visit https://www.w3schools.com/tags/tag_ins.asp.\nfunc Ins(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"ins\", Attributes: attrs, Children: children}\n}", "id": 8733, "concepts": ["HTML generation", "HTML generation with attributes", "HTML generation with children", "HTML generation with multiple children", "HTML generation with multiple children and attributes"], "_raw_llm_output": "HTML generation, HTML generation with attributes, HTML generation with children, HTML generation with multiple children, HTML generation with multiple children and attributes"}
{"seed": "// \u8fd4\u56de\u503c\u53ef\u4ee5\u547d\u540d\u4e5f\u53ef\u4ee5\u4e0d\u547d\u540d\n// \u8fd4\u56de\u503c\u547d\u540d,\u76f8\u5f53\u4e8e\u5728\u51fd\u6570\u4e2d\u58f0\u660e\u4e00\u4e2a\u53d8\u91cf\nfunc f4(x int, y int) (ret int) {\n\tret = x + y\n\treturn //\u4f7f\u7528\u547d\u540d\u8fd4\u56de\u503c\u53ef\u4ee5return\u540e\u7701\u7565\n}", "id": 8763, "concepts": ["return value naming", "return value declaration"], "_raw_llm_output": "return value naming, return value declaration"}
{"seed": "// RegisterConfigServiceHandler registers the http handlers for service ConfigService to \"mux\".\n// The handlers forward requests to the grpc endpoint over \"conn\".\nfunc RegisterConfigServiceHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {\n\treturn RegisterConfigServiceHandlerClient(ctx, mux, NewConfigServiceClient(conn))\n}", "id": 8764, "concepts": ["grpc", "client-server communication", "http handlers", "grpc client", "grpc server", "runtime.ServeMux"], "_raw_llm_output": "grpc, client-server communication, http handlers, grpc client, grpc server, runtime.ServeMux"}
{"seed": "// SomeUint8Err finds item in the list based on supplied function.\n//\n// Takes 2 input:\n//\t1. Function\n//\t2. List\n//\n// Returns:\n//\t(bool,err).\n//\tTrue if condition satisfies, else false\nfunc SomeUint8Err(f func(uint8) (bool, error), list []uint8) (bool, error) {\n\tif f == nil {\n\t\treturn false, nil\n\t}\n\tfor _, v := range list {\n\t\tr, err := f(v)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\tif r {\n\t\t\treturn true, nil\n\t\t}\n\t}\n\treturn false, nil\n}", "id": 8770, "concepts": ["function definition", "function composition", "function composition with error handling", "function composition with error handling", "function composition with error handling", "function composition with error handling", "function composition with error handling", "function composition with error handling", "function composition with error handling", "function composition with error handling", "function composition with error handling", "function composition with error handling", "function composition with error handling", "function composition with error handling", "function composition with error handling", "function composition with error handling", "function composition with error handling", "function composition with error handling", "function composition with error handling", "function composition with error handling", "function composition with error handling", "function composition with error handling", "function composition with error handling", "function composition with error handling", "function composition with error handling", "function composition with error handling", "function composition with error handling", "function composition with error handling", "function composition with error handling", "function composition with error handling", "function composition with error handling", "function composition with error handling", "function composition with error handling", "function composition with error handling", "function composition with error handling", "function composition with error handling", "function composition with error handling", "function composition with error handling", "function composition with error handling", "function composition with error handling", "function composition with error handling", "function composition with error handling", "function composition with error handling", "function composition with"], "_raw_llm_output": "function definition, function composition, function composition with error handling, function composition with error handling, function composition with error handling, function composition with error handling, function composition with error handling, function composition with error handling, function composition with error handling, function composition with error handling, function composition with error handling, function composition with error handling, function composition with error handling, function composition with error handling, function composition with error handling, function composition with error handling, function composition with error handling, function composition with error handling, function composition with error handling, function composition with error handling, function composition with error handling, function composition with error handling, function composition with error handling, function composition with error handling, function composition with error handling, function composition with error handling, function composition with error handling, function composition with error handling, function composition with error handling, function composition with error handling, function composition with error handling, function composition with error handling, function composition with error handling, function composition with error handling, function composition with error handling, function composition with error handling, function composition with error handling, function composition with error handling, function composition with error handling, function composition with error handling, function composition with error handling, function composition with error handling, function composition with error handling, function composition with"}
{"seed": "// This is not an actual test. It's a helper process that gets called by the\n// command executor tests. This is the same approach as in the tests for the\n// os/exec package: https://github.com/golang/go/blob/master/src/os/exec/exec_test.go\nfunc TestHelperProcess(*testing.T) {\n\tif os.Getenv(\"GO_WANT_HELPER_PROCESS\") != \"1\" {\n\t\treturn\n\t}\n\n\tdefer os.Exit(0)\n\n\targs := os.Args\n\n\tfor len(args) > 0 {\n\t\tif args[0] == \"--\" {\n\t\t\targs = args[1:]\n\t\t\tbreak\n\t\t}\n\t\targs = args[1:]\n\t}\n\n\tif len(args) == 0 {\n\t\tfmt.Fprintf(os.Stderr, \"No command\\n\")\n\t\tos.Exit(2)\n\t}\n\n\tcmd, args := args[0], args[1:]\n\n\tswitch cmd {\n\tcase \"echo\":\n\t\tiargs := []interface{}{}\n\t\tfor _, s := range args {\n\t\t\tiargs = append(iargs, s)\n\t\t}\n\t\tfmt.Println(iargs...)\n\tcase \"interrupt\":\n\t\tsignalChan := make(chan os.Signal, 1)\n\t\tsignal.Notify(signalChan, os.Interrupt)\n\n\t\tselect {\n\t\tcase <-signalChan:\n\t\t\tfmt.Println(\"SIGINT received\")\n\t\tcase <-time.After(500 * time.Millisecond):\n\t\t\tfmt.Println(\"timeout\")\n\t\t}\n\tcase \"terminated\":\n\t\tsignalChan := make(chan os.Signal, 1)\n\t\tsignal.Notify(signalChan, syscall.SIGTERM)\n\n\t\tselect {\n\t\tcase <-signalChan:\n\t\t\tfmt.Println(\"SIGTERM received\")\n\t\tcase <-time.After(500 * time.Millisecond):\n\t\t\tfmt.Println(\"timeout\")\n\t\t}\n\tdefault:\n\t\tfmt.Fprintf(os.Stderr, \"unknown command %q\\n\", cmd)\n\t\tos.Exit(2)\n\t}\n}", "id": 8782, "concepts": ["os.Exit", "os.Args", "os.Getenv", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit"], "_raw_llm_output": "os.Exit, os.Args, os.Getenv, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit"}
{"seed": "// NewListTradePairsRequestBody builds the HTTP request body from the payload\n// of the \"listTradePairs\" endpoint of the \"RestAPI\" service.\nfunc NewListTradePairsRequestBody(p *restapi.ListTradePairsPayload) *ListTradePairsRequestBody {\n\tbody := &ListTradePairsRequestBody{\n\t\tAll: p.All,\n\t}\n\treturn body\n}", "id": 8783, "concepts": ["struct definition", "struct field definition", "struct field initialization"], "_raw_llm_output": "struct definition, struct field definition, struct field initialization"}
{"seed": "// NewGenerateSksClusterKubeconfigRequest calls the generic GenerateSksClusterKubeconfig builder with application/json body\nfunc NewGenerateSksClusterKubeconfigRequest(server string, id string, body GenerateSksClusterKubeconfigJSONRequestBody) (*http.Request, error) {\n\tvar bodyReader io.Reader\n\tbuf, err := json.Marshal(body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tbodyReader = bytes.NewReader(buf)\n\treturn NewGenerateSksClusterKubeconfigRequestWithBody(server, id, \"application/json\", bodyReader)\n}", "id": 8787, "concepts": ["http.Request", "http.Client", "http.NewRequest", "http.Request.Body", "io.Reader", "json.Marshal", "json.Unmarshal"], "_raw_llm_output": "http.Request, http.Client, http.NewRequest, http.Request.Body, io.Reader, json.Marshal, json.Unmarshal"}
{"seed": "// PossibleLoggingDirectionsValues returns the possible values for the LoggingDirections const type.\nfunc PossibleLoggingDirectionsValues() []LoggingDirections {\n\treturn []LoggingDirections{\n\t\tLoggingDirectionsNone,\n\t\tLoggingDirectionsRequest,\n\t\tLoggingDirectionsResponse,\n\t}\n}", "id": 8804, "concepts": ["const type", "type definition", "type usage", "type conversion"], "_raw_llm_output": "const type, type definition, type usage, type conversion"}
{"seed": "// MemoryLimit returns server memory limit, set by cgroup.\nfunc MemoryLimit() (int64, error) {\n\tconst fname = \"/sys/fs/cgroup/memory/memory.limit_in_bytes\"\n\tbuf, err := ioutil.ReadFile(fname)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tdata := strings.TrimSpace(string(buf))\n\tv, err := strconv.ParseInt(data, 10, 64)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to parse %s: %q: %v\", fname, data, err)\n\t}\n\treturn v, nil\n}", "id": 8806, "concepts": ["ioutil.ReadFile", "strconv.ParseInt", "string trimming", "error handling"], "_raw_llm_output": "ioutil.ReadFile, strconv.ParseInt, string trimming, error handling"}
{"seed": "// MustAsset is like Asset but panics when Asset would return an error.\n// It simplifies safe initialization of global variables.\nfunc MustAsset(name string) []byte {\n\ta, err := Asset(name)\n\tif err != nil {\n\t\tpanic(\"asset: Asset(\" + name + \"): \" + err.Error())\n\t}\n\n\treturn a\n}", "id": 8819, "concepts": ["global variable initialization", "panic", "error handling"], "_raw_llm_output": "global variable initialization, panic, error handling"}
{"seed": "// New constructs a new transformation from the template strings lhs and rhs,\n// and the bindings shared by both templates.\nfunc New(lhs, rhs string, binds pattern.Binds) (*T, error) {\n\tlp, err := pattern.Parse(lhs, binds)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"parsing %q: %v\", lhs, err)\n\t}\n\trp, err := lp.Derive(rhs)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &T{lhs: lp, rhs: rp}, nil\n}", "id": 8821, "concepts": ["pattern matching", "pattern.Parse", "pattern.Derive", "error handling", "error wrapping"], "_raw_llm_output": "pattern matching, pattern.Parse, pattern.Derive, error handling, error wrapping"}
{"seed": "// UpdatedAtGTE applies the GTE predicate on the \"updated_at\" field.\nfunc UpdatedAtGTE(v time.Time) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.GTE(s.C(FieldUpdatedAt), v))\n\t})\n}", "id": 8827, "concepts": ["sql.Selector", "sql.GTE", "sql.C", "sql.Where", "sql.Predicate"], "_raw_llm_output": "sql.Selector, sql.GTE, sql.C, sql.Where, sql.Predicate"}
{"seed": "// BindingQueryGetAndPost POST\u8bf7\u6c42\uff0c\u540c\u65f6url\u6709query\u5b57\u6bb5\n// \u4f7f\u7528 ShouldBind \u53ef\u4ee5\u81ea\u52a8\u7ed1\u5b9a\u5c5e\u6027\u3002\n// POST http://localhost:18080/bind/gap?user=abcdefghijk\n// Content-Type: application/x-www-form-urlencoded\n// password=123\n// ###\nfunc BindingQueryGetAndPost(ctx *gin.Context) {\n\ttype login struct {\n\t\tUser     string `form:\"user\" json:\"usr\" xml:\"user\"  binding:\"required,my-val\"`\n\t\tPassword int    `form:\"password\" json:\"pwd\" xml:\"password\" binding:\"required\"`\n\t\tColor    string `form:\"color\" binding:\"required,iscolor\"`\n\t}\n\n\tvar usr login\n\tif err := ctx.ShouldBind(&usr); err != nil {\n\t\tif _, ok := err.(*validator.InvalidValidationError); ok {\n\t\t\tctx.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()})\n\t\t\treturn\n\t\t}\n\n\t\terrs, ok := err.(validator.ValidationErrors)\n\t\tif !ok {\n\t\t\tctx.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()})\n\t\t\treturn\n\t\t}\n\n\t\tvar errMsg string\n\n\t\tfor _, er := range errs {\n\t\t\t// service.SetupValidator() \u4e2d\u7684 RegisterTagNameFunc \u5f71\u54cd\u8fd9\u91cc\u7684 Namespace() Field() \u540d\u5b57\n\t\t\terrMsg += er.Namespace() + \" \u4e0d\u5408\u6cd5 \" + er.Tag() + \" | \"\n\t\t}\n\n\t\tctx.JSON(http.StatusBadRequest, gin.H{\"error\": errMsg})\n\t\treturn\n\t}\n\n\tlog.Println(usr)\n\n\tctx.Status(http.StatusNoContent)\n}", "id": 8831, "concepts": ["gin.Context", "gin.H", "gin.Bind", "gin.ShouldBind", "gin.BindJSON", "gin.BindXML", "gin.BindQuery", "gin.BindUri", "gin.BindHeader", "gin.BindXML", "gin.BindJSON", "gin.BindQuery", "gin.BindUri", "gin.BindHeader", "gin.BindXML", "gin.BindJSON", "gin.BindQuery", "gin.BindUri", "gin.BindHeader", "gin.BindXML", "gin.BindJSON", "gin.BindQuery", "gin.BindUri", "gin.BindHeader", "gin.BindXML", "gin.BindJSON", "gin.BindQuery", "gin.BindUri", "gin.BindHeader", "gin.BindXML", "gin.BindJSON", "gin.BindQuery", "gin.BindUri", "gin.BindHeader", "gin.BindXML", "gin.BindJSON", "gin.BindQuery", "gin.BindUri", "gin.BindHeader", "gin.BindXML", "gin.BindJSON", "gin.BindQuery", "gin.BindUri", "g"], "_raw_llm_output": "gin.Context, gin.H, gin.Bind, gin.ShouldBind, gin.BindJSON, gin.BindXML, gin.BindQuery, gin.BindUri, gin.BindHeader, gin.BindXML, gin.BindJSON, gin.BindQuery, gin.BindUri, gin.BindHeader, gin.BindXML, gin.BindJSON, gin.BindQuery, gin.BindUri, gin.BindHeader, gin.BindXML, gin.BindJSON, gin.BindQuery, gin.BindUri, gin.BindHeader, gin.BindXML, gin.BindJSON, gin.BindQuery, gin.BindUri, gin.BindHeader, gin.BindXML, gin.BindJSON, gin.BindQuery, gin.BindUri, gin.BindHeader, gin.BindXML, gin.BindJSON, gin.BindQuery, gin.BindUri, gin.BindHeader, gin.BindXML, gin.BindJSON, gin.BindQuery, gin.BindUri, g"}
{"seed": "// NewCamera constructs a camera with the provided field of view and aspect ratio\nfunc NewCamera(from, to, vup Vec3, vfov, aspect float64) Camera {\n\ttheta := vfov * math.Pi / 180\n\thalfheight := math.Tan(theta / 2)\n\thalfwidth := aspect * halfheight\n\tw := from.Sub(to).Unit()\n\tu := vup.Cross(w).Unit()\n\tv := w.Cross(u)\n\treturn Camera{\n\t\tOrigin:     from,\n\t\tBottomLeft: from.Sub(u.ScalarMul(halfwidth)).Sub(v.ScalarMul(halfheight)).Sub(w),\n\t\tHorizontal: u.ScalarMul(2 * halfwidth),\n\t\tVertical:   v.ScalarMul(2 * halfheight),\n\t}\n}", "id": 8833, "concepts": ["vector math", "Vec3", "Vec3.Unit()", "Vec3.ScalarMul()", "Vec3.Cross()", "Camera struct"], "_raw_llm_output": "vector math, Vec3, Vec3.Unit(), Vec3.ScalarMul(), Vec3.Cross(), Camera struct"}
{"seed": "// strEq compares two strings, character for character, and returns \n// true if they are the same.\nfunc strEq(s1, s2 string) bool {\n    if len(s1) != len(s2) {\n        return false\n    }\n\n    for i := range s1 {\n        if s1[i] != s2[i] {\n            return false\n        }\n    }\n\n    return true\n}", "id": 8857, "concepts": ["string comparison", "iteration"], "_raw_llm_output": "string comparison, iteration"}
{"seed": "// Var represents the HTML element 'var'.\n// For more information visit https://www.w3schools.com/tags/tag_var.asp.\nfunc Var(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"var\", Attributes: attrs, Children: children}\n}", "id": 8873, "concepts": ["HTML generation", "HTML tree traversal", "HTML element definition"], "_raw_llm_output": "HTML generation, HTML tree traversal, HTML element definition"}
{"seed": "// NopCloser returns a TokenReadCloser with a no-op Close method wrapping\n// the provided Reader r.\nfunc NopCloser(r xml.TokenReader) TokenReadCloser {\n\treturn nopCloser{r}\n}", "id": 8879, "concepts": ["xml package usage", "TokenReadCloser interface", "anonymous struct", "method overriding"], "_raw_llm_output": "xml package usage, TokenReadCloser interface, anonymous struct, method overriding"}
{"seed": "// Nobr represents the HTML element 'nobr'.\n// For more information visit https://www.w3schools.com/tags/tag_nobr.asp.\nfunc Nobr(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"nobr\", Attributes: attrs, Children: children}\n}", "id": 8881, "concepts": ["HTML generation", "HTML tree traversal", "HTML element definition"], "_raw_llm_output": "HTML generation, HTML tree traversal, HTML element definition"}
{"seed": "// HasCarWith applies the HasEdge predicate on the \"car\" edge with a given conditions (other predicates).\nfunc HasCarWith(preds ...predicate.Car) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\tstep := sqlgraph.NewStep(\n\t\t\tsqlgraph.From(Table, FieldID),\n\t\t\tsqlgraph.To(CarInverseTable, CarFieldID),\n\t\t\tsqlgraph.Edge(sqlgraph.O2M, false, CarTable, CarColumn),\n\t\t)\n\t\tsqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {\n\t\t\tfor _, p := range preds {\n\t\t\t\tp(s)\n\t\t\t}\n\t\t})\n\t})\n}", "id": 8895, "concepts": ["sqlgraph", "sql.Selector", "sql.Selector.Query", "sql.Selector.Query.Where", "sql.Selector.Query.Where.Or", "sql.Selector.Query.Where.And", "sql.Selector.Query.Where.Not", "sql.Selector.Query.Where.Not.Eq", "sql.Selector.Query.Where.Not.In", "sql.Selector.Query.Where.Not.NotIn", "sql.Selector.Query.Where.Not.Lt", "sql.Selector.Query.Where.Not.Gt", "sql.Selector.Query.Where.Not.LtEq", "sql.Selector.Query.Where.Not.GtEq", "sql.Selector.Query.Where.Not.IsNull", "sql.Selector.Query.Where.Not.IsNotNull", "sql.Selector.Query.Where.Not.Like", "sql.Selector.Query.Where.Not.NotLike", "sql.Selector.Query.Where.Not.NotRegexp", "sql.Selector.Query.Where.Not.NotRegexp", "sql.Selector.Query.Where.Not.NotRegexp", "sql.Selector.Query.Where.Not.NotRegexp", "sql.Selector.Query.Where.Not.NotRegexp", "sql.Selector."], "_raw_llm_output": "sqlgraph, sql.Selector, sql.Selector.Query, sql.Selector.Query.Where, sql.Selector.Query.Where.Or, sql.Selector.Query.Where.And, sql.Selector.Query.Where.Not, sql.Selector.Query.Where.Not.Eq, sql.Selector.Query.Where.Not.In, sql.Selector.Query.Where.Not.NotIn, sql.Selector.Query.Where.Not.Lt, sql.Selector.Query.Where.Not.Gt, sql.Selector.Query.Where.Not.LtEq, sql.Selector.Query.Where.Not.GtEq, sql.Selector.Query.Where.Not.IsNull, sql.Selector.Query.Where.Not.IsNotNull, sql.Selector.Query.Where.Not.Like, sql.Selector.Query.Where.Not.NotLike, sql.Selector.Query.Where.Not.NotRegexp, sql.Selector.Query.Where.Not.NotRegexp, sql.Selector.Query.Where.Not.NotRegexp, sql.Selector.Query.Where.Not.NotRegexp, sql.Selector.Query.Where.Not.NotRegexp, sql.Selector."}
{"seed": "// New creates a Frontier that sets SNI of requests to front\n// and network address to call to addr (or front if addr is empty).\n// Frontier roundtrips all requests through t, or through\n// http.DefaultTransport if t is nil.\nfunc New(t http.RoundTripper, front, addr string) *Frontier {\n\tfr := &Frontier{\n\t\ttransport: t,\n\t\tfront:     front,\n\t\taddr:      addr,\n\t}\n\tif fr.transport == nil {\n\t\tfr.transport = http.DefaultTransport\n\t}\n\treturn fr\n}", "id": 8898, "concepts": ["http.RoundTripper", "http.DefaultTransport", "http.Client", "http.Request", "http.Response", "http.Transport", "http.Transport.DialContext", "http.Transport.DialTLSContext", "http.Transport.DialTLS", "http.Transport.Dial", "http.Transport.TLSClientConfig", "http.Transport.TLSNextProto", "http.Transport.TLSNextProto.func", "http.Transport.TLSClientConfig.NextProtos", "http.Transport.TLSClientConfig.NextProtos.func", "http.Transport.TLSClientConfig.NextProtos.func", "http.Transport.TLSClientConfig.NextProtos.func", "http.Transport.TLSClientConfig.NextProtos.func", "http.Transport.TLSClientConfig.NextProtos.func", "http.Transport.TLSClientConfig.NextProtos.func", "http.Transport.TLSClientConfig.NextProtos.func", "http.Transport.TLSClientConfig.NextProtos.func", "http.Transport.TLSClientConfig.NextProtos.func", "http.Transport.TLSClientConfig.NextProtos.func", "http.Transport.TLSClientConfig.NextProtos.func", "http.Transport.TLSClientConfig.NextProtos.func", "http.Transport.TLSClientConfig.NextProtos.func", "http.Transport.TLSClientConfig.NextProtos"], "_raw_llm_output": "http.RoundTripper, http.DefaultTransport, http.Client, http.Request, http.Response, http.Transport, http.Transport.DialContext, http.Transport.DialTLSContext, http.Transport.DialTLS, http.Transport.Dial, http.Transport.TLSClientConfig, http.Transport.TLSNextProto, http.Transport.TLSNextProto.func, http.Transport.TLSClientConfig.NextProtos, http.Transport.TLSClientConfig.NextProtos.func, http.Transport.TLSClientConfig.NextProtos.func, http.Transport.TLSClientConfig.NextProtos.func, http.Transport.TLSClientConfig.NextProtos.func, http.Transport.TLSClientConfig.NextProtos.func, http.Transport.TLSClientConfig.NextProtos.func, http.Transport.TLSClientConfig.NextProtos.func, http.Transport.TLSClientConfig.NextProtos.func, http.Transport.TLSClientConfig.NextProtos.func, http.Transport.TLSClientConfig.NextProtos.func, http.Transport.TLSClientConfig.NextProtos.func, http.Transport.TLSClientConfig.NextProtos.func, http.Transport.TLSClientConfig.NextProtos.func, http.Transport.TLSClientConfig.NextProtos"}
{"seed": "// GetNotificationUserSubscriberBillingService returns an instance of the Notification_User_Subscriber_Billing SoftLayer service\nfunc GetNotificationUserSubscriberBillingService(sess *session.Session) Notification_User_Subscriber_Billing {\n\treturn Notification_User_Subscriber_Billing{Session: sess}\n}", "id": 8900, "concepts": ["service instantiation", "session object usage", "basic function definition"], "_raw_llm_output": "service instantiation, session object usage, basic function definition"}
{"seed": "// RecordMode returns whether it is running in record mode.\nfunc RecordMode() bool {\n\treturn mode&RecordModeFlag == RecordModeFlag\n}", "id": 8918, "concepts": ["bitwise operations", "bitwise AND", "bitwise OR", "bitwise XOR", "bitwise NOT"], "_raw_llm_output": "bitwise operations, bitwise AND, bitwise OR, bitwise XOR, bitwise NOT"}
{"seed": "// ComputePodResourceRequest returns a framework.Resource that covers the largest\n// width in each resource dimension. Because init-containers run sequentially, we collect\n// the max in each dimension iteratively. In contrast, we sum the resource vectors for\n// regular containers since they run simultaneously.\n//\n// If Pod Overhead is specified, the resources defined for Overhead\n// are added to the calculated Resource request sum\n//\n// Example:\n//\n// Pod:\n//\n//\tInitContainers\n//\t  IC1:\n//\t    CPU: 2\n//\t    Memory: 1G\n//\t  IC2:\n//\t    CPU: 2\n//\t    Memory: 3G\n//\tContainers\n//\t  C1:\n//\t    CPU: 2\n//\t    Memory: 1G\n//\t  C2:\n//\t    CPU: 1\n//\t    Memory: 1G\n//\n// Result: CPU: 3, Memory: 3G\nfunc ComputePodResourceRequest(pod *v1.Pod) *Resource {\n\tresource := &Resource{}\n\tfor _, container := range pod.Spec.Containers {\n\t\tresource.Add(container.Resources.Requests)\n\t}\n\n\t// take max_resource(sum_pod, any_init_container)\n\tfor _, container := range pod.Spec.InitContainers {\n\t\tresource.SetMaxResource(container.Resources.Requests)\n\t}\n\n\t// If Overhead is being utilized, add to the total requests for the pod\n\tif pod.Spec.Overhead != nil {\n\t\tresource.Add(pod.Spec.Overhead)\n\t}\n\n\treturn resource\n}", "id": 8926, "concepts": ["struct", "map", "pointer", "interface", "concurrency", "standard library usage"], "_raw_llm_output": "struct, map, pointer, interface, concurrency, standard library usage"}
{"seed": "// IQFunc returns an option that matches IQ stanzas.\n// For more information see IQ.\nfunc IQFunc(typ stanza.IQType, payload xml.Name, h IQHandlerFunc) Option {\n\treturn IQ(typ, payload, h)\n}", "id": 8933, "concepts": ["xml package usage", "xml.Name", "xml.StartElement", "xml.EndElement", "xml.CharData", "xml.Comment", "xml.ProcInst", "xml.Directive", "xml.EntityRef", "xml.CharData", "xml.Comment", "xml.ProcInst", "xml.Directive", "xml.EntityRef", "xml.CharData", "xml.Comment", "xml.ProcInst", "xml.Directive", "xml.EntityRef", "xml.CharData", "xml.Comment", "xml.ProcInst", "xml.Directive", "xml.EntityRef", "xml.CharData", "xml.Comment", "xml.ProcInst", "xml.Directive", "xml.EntityRef", "xml.CharData", "xml.Comment", "xml.ProcInst", "xml.Directive", "xml.EntityRef", "xml.CharData", "xml.Comment", "xml.ProcInst", "xml.Directive", "xml.EntityRef", "xml.CharData", "xml.Comment", "xml.ProcInst", "xml.Directive", "xml.EntityRef", "xml.CharData", "xml.Comment", "xml.ProcInst", "xml.Directive", "xml.EntityRef", "xml.CharData", "xml.Comment", "xml.ProcInst", "xml.Directive", "xml.EntityRef", "xml.CharData", "xml."], "_raw_llm_output": "xml package usage, xml.Name, xml.StartElement, xml.EndElement, xml.CharData, xml.Comment, xml.ProcInst, xml.Directive, xml.EntityRef, xml.CharData, xml.Comment, xml.ProcInst, xml.Directive, xml.EntityRef, xml.CharData, xml.Comment, xml.ProcInst, xml.Directive, xml.EntityRef, xml.CharData, xml.Comment, xml.ProcInst, xml.Directive, xml.EntityRef, xml.CharData, xml.Comment, xml.ProcInst, xml.Directive, xml.EntityRef, xml.CharData, xml.Comment, xml.ProcInst, xml.Directive, xml.EntityRef, xml.CharData, xml.Comment, xml.ProcInst, xml.Directive, xml.EntityRef, xml.CharData, xml.Comment, xml.ProcInst, xml.Directive, xml.EntityRef, xml.CharData, xml.Comment, xml.ProcInst, xml.Directive, xml.EntityRef, xml.CharData, xml.Comment, xml.ProcInst, xml.Directive, xml.EntityRef, xml.CharData, xml."}
{"seed": "// StoreBundleLinkAndData creates a new bundle data for a given json byte slice\n// if one does not already exist. It will create a new bundle link pointing to\n// that data. All DB access is done in a transaction, which will retry up to 3\n// times. Both the link and the data are returned, or an error if one occured.\n// Slugs are currently not allowed for user-stored bundles.\nfunc StoreBundleLinkAndData(json string) (bLink *BundleLink, bData *BundleData, retErr error) {\n\tretErr = runInTransaction(dbSeq, 3, func(tx *sqlx.Tx) (err error) {\n\t\tbLink, bData, err = storeBundle(tx, &NewBundle{Json: string(json)}, false)\n\t\tif err == errIDCollision {\n\t\t\treturn errRetryTransaction\n\t\t}\n\t\treturn err\n\t})\n\n\treturn\n}", "id": 8949, "concepts": ["sqlx package usage", "sql package usage", "sql.Tx usage", "sql.Stmt usage", "sql.Named usage", "sql.Result usage", "sql.ErrNoRows", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTxDone", "sql.ErrTx"], "_raw_llm_output": "sqlx package usage, sql package usage, sql.Tx usage, sql.Stmt usage, sql.Named usage, sql.Result usage, sql.ErrNoRows, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTxDone, sql.ErrTx"}
{"seed": "// New returns a TestClock instance set at the specified time.\nfunc New(now time.Time) TestClock {\n\treturn &testClock{\n\t\tnow: now,\n\t}\n}", "id": 8951, "concepts": ["struct definition", "pointer usage", "time package usage"], "_raw_llm_output": "struct definition, pointer usage, time package usage"}
{"seed": "// Reads from the connection byte by byte until the message length is found, according to\n// marionette's protocol.\n// the protocol say's that message length is the first part for the message until \":\" is found.\n// this signals the next bytes as the message\nfunc messageLength(c net.Conn) (int, error) {\n\tvar byteSize = make([]byte, 0)\n\ttmp := make([]byte, 1)\n\tfor {\n\t\t_, err := c.Read(tmp)\n\t\tif err != nil {\n\t\t\tif err != io.EOF {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t}\n\n\t\tif string(tmp) != \":\" {\n\t\t\tbyteSize = append(byteSize, tmp...)\n\t\t\tcontinue\n\t\t}\n\n\t\t// the message length\n\t\tintSize, err := strconv.Atoi(string(byteSize))\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\treturn intSize, err\n\t}\n}", "id": 8953, "concepts": ["net/http package usage", "string manipulation", "byte handling", "io.EOF", "io.Read", "io.Write", "io.Copy", "io.TeeReader", "io.MultiReader", "io.Pipe", "io.Reader", "io.Writer", "io.ReaderFrom", "io.Seeker", "io.WriterTo", "io.ByteReader", "io.ByteWriter", "io.ByteScanner", "io.ByteSizer", "io.RuneReader", "io.RuneWriter", "io.RuneScanner", "io.RuneSizer", "io.StringReader", "io.StringWriter", "io.ReaderAt", "io.WriterAt", "io.Seeker", "io.ReaderFrom", "io.WriterTo", "io.ByteReader", "io.ByteWriter", "io.ByteScanner", "io.ByteSizer", "io.RuneReader", "io.RuneWriter", "io.RuneScanner", "io.RuneSizer", "io.StringReader", "io.StringWriter", "io.ReaderAt", "io.WriterAt", "io.Seeker", "io.ReaderFrom", "io.WriterTo", "io.ByteReader", "io.ByteWriter", "io.ByteScanner", "io.ByteSizer", "io.RuneReader", "io.RuneWriter", "io.RuneScanner", "io.RuneSizer"], "_raw_llm_output": "net/http package usage, string manipulation, byte handling, io.EOF, io.Read, io.Write, io.Copy, io.TeeReader, io.MultiReader, io.Pipe, io.Reader, io.Writer, io.ReaderFrom, io.Seeker, io.WriterTo, io.ByteReader, io.ByteWriter, io.ByteScanner, io.ByteSizer, io.RuneReader, io.RuneWriter, io.RuneScanner, io.RuneSizer, io.StringReader, io.StringWriter, io.ReaderAt, io.WriterAt, io.Seeker, io.ReaderFrom, io.WriterTo, io.ByteReader, io.ByteWriter, io.ByteScanner, io.ByteSizer, io.RuneReader, io.RuneWriter, io.RuneScanner, io.RuneSizer, io.StringReader, io.StringWriter, io.ReaderAt, io.WriterAt, io.Seeker, io.ReaderFrom, io.WriterTo, io.ByteReader, io.ByteWriter, io.ByteScanner, io.ByteSizer, io.RuneReader, io.RuneWriter, io.RuneScanner, io.RuneSizer"}
{"seed": "// newWatchAggregator maintains state of consumers calling `Watch` so that a\n// single `watch` request is made to the underlying client.\n// There are 3 modes taken by this aggregator. If autowatch is set, a single `watch`\n// will always be invoked on the provided client. If it is not set, but a `watch client`(wc)\n// is passed, a `watch` will be run on the watch client in the absence of external watchers,\n// which will swap watching over to the main client. If no watch client is set and autowatch is off\n// then a single watch will only run when an external watch is requested.\nfunc newWatchAggregator(c, wc Client, autoWatch bool, autoWatchRetry time.Duration) *watchAggregator {\n\tif autoWatchRetry == 0 {\n\t\tautoWatchRetry = defaultAutoWatchRetry\n\t}\n\taggregator := &watchAggregator{\n\t\tClient:         c,\n\t\tpassiveClient:  wc,\n\t\tautoWatch:      autoWatch,\n\t\tautoWatchRetry: autoWatchRetry,\n\t\tlog:            log.DefaultLogger(),\n\t\tsubscribers:    make([]subscriber, 0),\n\t}\n\treturn aggregator\n}", "id": 8959, "concepts": ["struct definition", "method definition", "anonymous function", "concurrency", "standard library usage"], "_raw_llm_output": "struct definition, method definition, anonymous function, concurrency, standard library usage"}
{"seed": "// transformLabels transforms labels according to the configured mappings.\n// Returns true if all required labels in match are found.\nfunc transformLabels(labelMappings []LabelMapping, input map[string]string) (map[string]string, bool) {\n\toutput := make(map[string]string, len(input))\n\t// Convert matching labels\n\tfor _, labelMapping := range labelMappings {\n\t\tif v, ok := input[labelMapping.SourceKey]; ok {\n\t\t\toutput[labelMapping.TargetKey] = v\n\t\t} else if !labelMapping.Optional {\n\t\t\t// Required label is missing\n\t\t\treturn nil, false\n\t\t}\n\t}\n\treturn output, true\n}", "id": 8961, "concepts": ["map iteration (range loop)", "map creation", "map lookup", "map update", "map deletion", "map length"], "_raw_llm_output": "map iteration (range loop), map creation, map lookup, map update, map deletion, map length"}
{"seed": "// ValidateRouterParamsFromPath parses a router path and check the router parameter values.\n// All parsed parameter names must not be empty. Otherwise, an HTTP response 404 is automatically sent.\n// The boolean is false if the validation fails and the request should not be processed any further.\nfunc ValidateRouterParamsFromPath(w http.ResponseWriter, p httprouter.Params, routerPath string) bool {\n\tfor _, n := range getParamNamesFromRouterPath(routerPath) {\n\t\tif p.ByName(n) == \"\" {\n\t\t\thttp.Error(w, \"404 page not found\", http.StatusNotFound)\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}", "id": 8971, "concepts": ["http.ResponseWriter", "http.Error", "httprouter.Params", "httprouter.Params.ByName", "http.StatusNotFound", "string manipulation", "string parsing"], "_raw_llm_output": "http.ResponseWriter, http.Error, httprouter.Params, httprouter.Params.ByName, http.StatusNotFound, string manipulation, string parsing"}
{"seed": "// GetNextRequestID generates a string that can be used as the ID\n// of a new ProxyRequest.\nfunc GetNextRequestID() string {\n\tid := atomic.AddUint64(&currRequestID, 1)\n\treturn strings.ToUpper(strconv.FormatUint(id, 36))\n}", "id": 8976, "concepts": ["atomic operations", "string formatting", "strconv package usage"], "_raw_llm_output": "atomic operations, string formatting, strconv package usage"}
{"seed": "// IsWeekendDay returns true if the day provided is either Saturday or Sunday\nfunc IsWeekendDay(day time.Weekday) bool {\n\tif day == time.Saturday || day == time.Sunday {\n\t\treturn true\n\t}\n\treturn false\n}", "id": 8979, "concepts": ["time package usage", "time.Weekday type", "boolean logic"], "_raw_llm_output": "time package usage, time.Weekday type, boolean logic"}
{"seed": "/*\nNewAEADCipher creates a new AEAD cipher using the provided AES key.\nThe key argument should be either 16, 24, or 32 bytes to select AES-128, AES-192, or AES-256.\n\nIf the key is nil, a new 32 byte AES key is generated.\nThis option is used when the scope of key use is limited to within a single program execution.\n*/\nfunc NewAEADCipher(key []byte) (cipher.AEAD, error) {\n\tvar (\n\t\tkeyval      []byte\n\t\tcipherBlock cipher.Block\n\t\taeadCipher  cipher.AEAD\n\t\terr         error\n\t)\n\n\t//If no key is provided, generate one.\n\tif key == nil {\n\t\tkeyval = make([]byte, 32)\n\t\t_, err = rand.Read(keyval)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\tswitch len(key) {\n\t\tcase 16, 24, 36:\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"An aead key must be of length 16. 24, or 32. This key is of length: \", len(key))\n\t\t}\n\t\tkeyval = key\n\t}\n\n\t//The key is used to create an AES Cipher Block\n\tcipherBlock, err = aes.NewCipher(keyval)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t//The AES Cipher Block is used to create an AEAD GCM which is a 128-bit, block cipher wrapped\n\t//in a Galois Counter Mode with the standard nonce length.\n\t//This is used to encrypt/decrypt all subscriber identifiers in the hidden fields of TBD 2nd Factor Selection Forms.\n\taeadCipher, err = cipher.NewGCM(cipherBlock)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn aeadCipher, nil\n}", "id": 8984, "concepts": ["AES encryption", "GCM encryption", "AES key generation", "GCM key generation", "AES key length", "GCM key length", "AES key generation", "GCM key generation", "AES key length", "GCM key length", "AES key generation", "GCM key generation", "AES key length", "GCM key length", "AES key generation", "GCM key generation", "AES key length", "GCM key length", "AES key generation", "GCM key generation", "AES key length", "GCM key length", "AES key generation", "GCM key generation", "AES key length", "GCM key length", "AES key generation", "GCM key generation", "AES key length", "GCM key length", "AES key generation", "GCM key generation", "AES key length", "GCM key length", "AES key generation", "GCM key generation", "AES key length", "GCM key length", "AES key generation", "GCM key generation", "AES key length", "GCM key length", "AES key generation", "GCM key generation", "AES key length", "GCM key length", "AES key generation", "GCM key generation", "AES key length", "GCM key length", "AES key generation", "GCM key generation", "AES key length", "GCM key length", "AES key generation", "GCM key generation", "AES key length", "G"], "_raw_llm_output": "AES encryption, GCM encryption, AES key generation, GCM key generation, AES key length, GCM key length, AES key generation, GCM key generation, AES key length, GCM key length, AES key generation, GCM key generation, AES key length, GCM key length, AES key generation, GCM key generation, AES key length, GCM key length, AES key generation, GCM key generation, AES key length, GCM key length, AES key generation, GCM key generation, AES key length, GCM key length, AES key generation, GCM key generation, AES key length, GCM key length, AES key generation, GCM key generation, AES key length, GCM key length, AES key generation, GCM key generation, AES key length, GCM key length, AES key generation, GCM key generation, AES key length, GCM key length, AES key generation, GCM key generation, AES key length, GCM key length, AES key generation, GCM key generation, AES key length, GCM key length, AES key generation, GCM key generation, AES key length, GCM key length, AES key generation, GCM key generation, AES key length, G"}
{"seed": "// Codify associates the supplied gRPC error code with the given error.\n// The returned error will produce the supplied gRPC error code when processed\n// by ToStatus. Codify returns nil when passed a nil error.\n// Note this is almost https://godoc.org/google.golang.org/grpc#Errorf, except\n// that it embeds the original error and thus preserves it.\nfunc Codify(err error, code codes.Code) error {\n\tif err == nil {\n\t\treturn nil\n\t}\n\treturn &codedError{err, code}\n}", "id": 8992, "concepts": ["error embedding", "error handling (idiomatic `if err != nil`", "`errors.Is`", "`errors.As`)", "error handling (errors.New)", "error handling (errors.As)", "error handling (errors.Is)", "error handling (errors.As)", "error handling (errors.Is)", "error handling (errors.As)", "error handling (errors.Is)", "error handling (errors.As)", "error handling (errors.Is)", "error handling (errors.As)", "error handling (errors.Is)", "error handling (errors.As)", "error handling (errors.Is)", "error handling (errors.As)", "error handling (errors.Is)", "error handling (errors.As)", "error handling (errors.Is)", "error handling (errors.As)", "error handling (errors.Is)", "error handling (errors.As)", "error handling (errors.Is)", "error handling (errors.As)", "error handling (errors.Is)", "error handling (errors.Is)", "error handling (errors.Is)", "error handling (errors.Is)", "error handling (errors.Is)", "error handling (errors.Is)", "error handling (errors.Is)", "error handling (errors.Is)", "error handling (errors.Is)", "error handling (errors.Is)", "error handling (errors.Is"], "_raw_llm_output": "error embedding, error handling (idiomatic `if err != nil`, `errors.Is`, `errors.As`), error handling (errors.New), error handling (errors.As), error handling (errors.Is), error handling (errors.As), error handling (errors.Is), error handling (errors.As), error handling (errors.Is), error handling (errors.As), error handling (errors.Is), error handling (errors.As), error handling (errors.Is), error handling (errors.As), error handling (errors.Is), error handling (errors.As), error handling (errors.Is), error handling (errors.As), error handling (errors.Is), error handling (errors.As), error handling (errors.Is), error handling (errors.As), error handling (errors.Is), error handling (errors.As), error handling (errors.Is), error handling (errors.Is), error handling (errors.Is), error handling (errors.Is), error handling (errors.Is), error handling (errors.Is), error handling (errors.Is), error handling (errors.Is), error handling (errors.Is), error handling (errors.Is), error handling (errors.Is"}
{"seed": "// StringToIntWithFormat creates a binding that connects a String data item to a Int and is\n// presented using the specified format. Changes to the Int will be parsed and if the format matches and\n// the parse is successful it will be pushed to the String. Setting the Int will push a formatted value\n// into the String.\n//\n// Since: 2.0\nfunc StringToIntWithFormat(str String, format string) Int {\n\tif format == \"%d\" { // Same as not using custom format.\n\t\treturn StringToInt(str)\n\t}\n\n\tv := &stringToInt{from: str, format: format}\n\tstr.AddListener(v)\n\treturn v\n}", "id": 9005, "concepts": ["binding", "listener", "string formatting", "integer parsing"], "_raw_llm_output": "binding, listener, string formatting, integer parsing"}
{"seed": "// WorkplaceContainsFold applies the ContainsFold predicate on the \"workplace\" field.\nfunc WorkplaceContainsFold(v string) predicate.User {\n\treturn predicate.User(sql.FieldContainsFold(FieldWorkplace, v))\n}", "id": 9032, "concepts": ["predicate.User", "sql.FieldContainsFold", "predicate composition"], "_raw_llm_output": "predicate.User, sql.FieldContainsFold, predicate composition"}
{"seed": "// KeyFor returns a Plugin's unique identifying string.\nfunc KeyFor(p Plugin) string {\n\treturn Key(p.Name(), p.Version().String())\n}", "id": 9039, "concepts": ["string concatenation", "string formatting", "string manipulation", "string comparison"], "_raw_llm_output": "string concatenation, string formatting, string manipulation, string comparison"}
{"seed": "// WithConcurrency defines the number of concurrent consumers.\nfunc WithConcurrency(concurrency int) Option {\n\treturn func(opts *Options) {\n\t\topts.Concurrency = concurrency\n\t}\n}", "id": 9057, "concepts": ["function composition", "function options", "function composition"], "_raw_llm_output": "function composition, function options, function composition"}
{"seed": "// StripManifestFromStatus is an Option that configures whether the manifest\n// should be removed from the automatically populated status.\n// This is recommended if the manifest might return sensitive data (i.e.,\n// secrets).\nfunc StripManifestFromStatus(strip bool) Option {\n\treturn func(r *Reconciler) error {\n\t\tr.stripManifestFromStatus = strip\n\t\treturn nil\n\t}\n}", "id": 9058, "concepts": ["struct definition", "struct field definition", "struct field initialization", "struct field access", "struct field pointer access", "struct field pointer access", "struct field pointer access", "struct field pointer access", "struct field pointer access", "struct field pointer access", "struct field pointer access", "struct field pointer access", "struct field pointer access", "struct field pointer access", "struct field pointer access", "struct field pointer access", "struct field pointer access", "struct field pointer access", "struct field pointer access", "struct field pointer access", "struct field pointer access", "struct field pointer access", "struct field pointer access", "struct field pointer access", "struct field pointer access", "struct field pointer access", "struct field pointer access", "struct field pointer access", "struct field pointer access", "struct field pointer access", "struct field pointer access", "struct field pointer access", "struct field pointer access", "struct field pointer access", "struct field pointer access", "struct field pointer access", "struct field pointer access", "struct field pointer access", "struct field pointer access", "struct field pointer access", "struct field pointer access", "struct field pointer access", "struct field pointer access", "struct field pointer access", "struct field pointer access", "struct field pointer access", "struct field pointer access", "struct field pointer access", "struct field pointer access", "struct field pointer access", "struct field pointer access", "struct field pointer access", ""], "_raw_llm_output": "struct definition, struct field definition, struct field initialization, struct field access, struct field pointer access, struct field pointer access, struct field pointer access, struct field pointer access, struct field pointer access, struct field pointer access, struct field pointer access, struct field pointer access, struct field pointer access, struct field pointer access, struct field pointer access, struct field pointer access, struct field pointer access, struct field pointer access, struct field pointer access, struct field pointer access, struct field pointer access, struct field pointer access, struct field pointer access, struct field pointer access, struct field pointer access, struct field pointer access, struct field pointer access, struct field pointer access, struct field pointer access, struct field pointer access, struct field pointer access, struct field pointer access, struct field pointer access, struct field pointer access, struct field pointer access, struct field pointer access, struct field pointer access, struct field pointer access, struct field pointer access, struct field pointer access, struct field pointer access, struct field pointer access, struct field pointer access, struct field pointer access, struct field pointer access, struct field pointer access, struct field pointer access, struct field pointer access, struct field pointer access, struct field pointer access, struct field pointer access, struct field pointer access,"}
{"seed": "// DeleteBackupPath computes a request path to the delete action of backup.\nfunc DeleteBackupPath(backupID string) string {\n\tparam0 := backupID\n\n\treturn fmt.Sprintf(\"/backup/%s\", param0)\n}", "id": 9070, "concepts": ["string formatting", "fmt package usage"], "_raw_llm_output": "string formatting, fmt package usage"}
{"seed": "// IDGTE applies the GTE predicate on the ID field.\nfunc IDGTE(id int) predicate.Bulk {\n\treturn predicate.Bulk(func(s *sql.Selector) {\n\t\ts.Where(sql.GTE(s.C(FieldID), id))\n\t})\n}", "id": 9071, "concepts": ["sql.Selector", "sql.GTE", "sql.C", "sql.Where", "sql.Bulk", "sql.Predicate", "sql.Field"], "_raw_llm_output": "sql.Selector, sql.GTE, sql.C, sql.Where, sql.Bulk, sql.Predicate, sql.Field"}
{"seed": "// SplitBefore takes a slice and a predicate, and returns the slice chunked,\n// split before any element where the predicate returns true.\nfunc SplitBefore[T any](slice []T, predicate func(T) bool) [][]T {\n\tvar result [][]T\n\tlast := -1\n\tfor _, elem := range slice {\n\t\tif last < 0 || predicate(elem) {\n\t\t\tresult = append(result, []T{elem})\n\t\t\tlast++\n\t\t} else {\n\t\t\tresult[last] = append(result[last], elem)\n\t\t}\n\t}\n\treturn result\n}", "id": 9076, "concepts": ["slice manipulation", "predicate function", "type parameter"], "_raw_llm_output": "slice manipulation, predicate function, type parameter"}
{"seed": "// Servers_FailoverGroup_SpecGenerator returns a generator of Servers_FailoverGroup_Spec instances for property testing.\n// We first initialize servers_FailoverGroup_SpecGenerator with a simplified generator based on the\n// fields with primitive types then replacing it with a more complex one that also handles complex fields\n// to ensure any cycles in the object graph properly terminate.\nfunc Servers_FailoverGroup_SpecGenerator() gopter.Gen {\n\tif servers_FailoverGroup_SpecGenerator != nil {\n\t\treturn servers_FailoverGroup_SpecGenerator\n\t}\n\n\tgenerators := make(map[string]gopter.Gen)\n\tAddIndependentPropertyGeneratorsForServers_FailoverGroup_Spec(generators)\n\tservers_FailoverGroup_SpecGenerator = gen.Struct(reflect.TypeOf(Servers_FailoverGroup_Spec{}), generators)\n\n\t// The above call to gen.Struct() captures the map, so create a new one\n\tgenerators = make(map[string]gopter.Gen)\n\tAddIndependentPropertyGeneratorsForServers_FailoverGroup_Spec(generators)\n\tAddRelatedPropertyGeneratorsForServers_FailoverGroup_Spec(generators)\n\tservers_FailoverGroup_SpecGenerator = gen.Struct(reflect.TypeOf(Servers_FailoverGroup_Spec{}), generators)\n\n\treturn servers_FailoverGroup_SpecGenerator\n}", "id": 9079, "concepts": ["struct definition", "map iteration", "map definition", "map iteration", "map definition", "map iteration", "map definition", "map iteration", "map definition", "map iteration", "map definition", "map iteration", "map definition", "map iteration", "map definition", "map iteration", "map definition", "map iteration", "map definition", "map iteration", "map definition", "map iteration", "map definition", "map iteration", "map definition", "map iteration", "map definition", "map iteration", "map definition", "map iteration", "map definition", "map iteration", "map definition", "map iteration", "map definition", "map iteration", "map definition", "map iteration", "map definition", "map iteration", "map definition", "map iteration", "map definition", "map iteration", "map definition", "map iteration", "map definition", "map iteration", "map definition", "map iteration", "map definition", "map iteration", "map definition", "map iteration", "map definition", "map iteration", "map definition", "map iteration", "map definition", "map iteration", "map definition", "map iteration", "map definition", "map iteration", "map definition", "map iteration", "map definition", "map iteration", "map definition", "map iteration", "map definition", "map iteration", "map definition", "map iteration", "map definition", "map iteration", "map definition", "map iteration", "map definition", "map iteration", "map definition", "map iteration", "map definition", "map iteration", "map definition", ""], "_raw_llm_output": "struct definition, map iteration, map definition, map iteration, map definition, map iteration, map definition, map iteration, map definition, map iteration, map definition, map iteration, map definition, map iteration, map definition, map iteration, map definition, map iteration, map definition, map iteration, map definition, map iteration, map definition, map iteration, map definition, map iteration, map definition, map iteration, map definition, map iteration, map definition, map iteration, map definition, map iteration, map definition, map iteration, map definition, map iteration, map definition, map iteration, map definition, map iteration, map definition, map iteration, map definition, map iteration, map definition, map iteration, map definition, map iteration, map definition, map iteration, map definition, map iteration, map definition, map iteration, map definition, map iteration, map definition, map iteration, map definition, map iteration, map definition, map iteration, map definition, map iteration, map definition, map iteration, map definition, map iteration, map definition, map iteration, map definition, map iteration, map definition, map iteration, map definition, map iteration, map definition, map iteration, map definition, map iteration, map definition, map iteration, map definition,"}
{"seed": "// BulkCreditSamedayFeeLT applies the LT predicate on the \"bulkCreditSamedayFee\" field.\nfunc BulkCreditSamedayFeeLT(v float64) predicate.Bulk {\n\treturn predicate.Bulk(func(s *sql.Selector) {\n\t\ts.Where(sql.LT(s.C(FieldBulkCreditSamedayFee), v))\n\t})\n}", "id": 9080, "concepts": ["predicate.Bulk", "sql.Selector", "sql.LT", "sql.C", "sql.Where"], "_raw_llm_output": "predicate.Bulk, sql.Selector, sql.LT, sql.C, sql.Where"}
{"seed": "// AllowDev enables interpreting character or block special devices on the\n// filesystem.\nfunc AllowDev() MountOption {\n\treturn func(conf *mountConfig) error {\n\t\tconf.options[\"dev\"] = \"\"\n\t\treturn nil\n\t}\n}", "id": 9086, "concepts": ["function definition", "function composition", "function options"], "_raw_llm_output": "function definition, function composition, function options"}
{"seed": "// PossibleStateValues returns an array of possible values for the State const type.\nfunc PossibleStateValues() []State {\n\treturn []State{StateDisabled, StateEnabled}\n}", "id": 9092, "concepts": ["constant definition", "array definition", "array iteration"], "_raw_llm_output": "constant definition, array definition, array iteration"}
{"seed": "// RecentTasksActivityTypeASC function sorts data by Type field in ascending order\n// sorting layers: Type > LRStatus(ASC) > LRTime(DESC) > Name(ASC)\n// function chain according to sorting layers: RecentTasksActivityTypeASC > RecentTasksActivityLRStatusASC > subsortingByLRTimeDESC > subsortingByNameASC\nfunc RecentTasksActivityTypeASC(p1, p2 interface{}) bool {\n\tp1Type := getSortableType(p1.(RecentTasksActivity).Task.Type)\n\tp2Type := getSortableType(p2.(RecentTasksActivity).Task.Type)\n\n\tif p1Type == p2Type {\n\t\treturn RecentTasksActivityLRStatusASC(p1, p2)\n\t}\n\n\treturn p1Type < p2Type\n}", "id": 9097, "concepts": ["interface", "type assertion", "sorting", "function composition"], "_raw_llm_output": "interface, type assertion, sorting, function composition"}
{"seed": "// DecodeTDLibJSONInputInlineQueryResult implements binary de-serialization for InputInlineQueryResultClass.\nfunc DecodeTDLibJSONInputInlineQueryResult(buf tdjson.Decoder) (InputInlineQueryResultClass, error) {\n\tid, err := buf.FindTypeID()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tswitch id {\n\tcase \"inputInlineQueryResultAnimation\":\n\t\t// Decoding inputInlineQueryResultAnimation#a7335216.\n\t\tv := InputInlineQueryResultAnimation{}\n\t\tif err := v.DecodeTDLibJSON(buf); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to decode InputInlineQueryResultClass: %w\", err)\n\t\t}\n\t\treturn &v, nil\n\tcase \"inputInlineQueryResultArticle\":\n\t\t// Decoding inputInlineQueryResultArticle#75a3d10c.\n\t\tv := InputInlineQueryResultArticle{}\n\t\tif err := v.DecodeTDLibJSON(buf); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to decode InputInlineQueryResultClass: %w\", err)\n\t\t}\n\t\treturn &v, nil\n\tcase \"inputInlineQueryResultAudio\":\n\t\t// Decoding inputInlineQueryResultAudio#4b1c35d4.\n\t\tv := InputInlineQueryResultAudio{}\n\t\tif err := v.DecodeTDLibJSON(buf); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to decode InputInlineQueryResultClass: %w\", err)\n\t\t}\n\t\treturn &v, nil\n\tcase \"inputInlineQueryResultContact\":\n\t\t// Decoding inputInlineQueryResultContact#6e08b5d2.\n\t\tv := InputInlineQueryResultContact{}\n\t\tif err := v.DecodeTDLibJSON(buf); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to decode InputInlineQueryResultClass: %w\", err)\n\t\t}\n\t\treturn &v, nil\n\tcase \"inputInlineQueryResultDocument\":\n\t\t// Decoding inputInlineQueryResultDocument#227fd0cd.\n\t\tv := InputInlineQueryResultDocument{}\n\t\tif err := v.DecodeTDLibJSON(buf); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to decode InputInlineQueryResultClass: %w\", err)\n\t\t}\n\t\treturn &v, nil\n\tcase \"inputInlineQueryResultGame\":\n\t\t// Decoding inputInlineQueryResultGame#39951fd7.\n\t\tv := InputInlineQueryResultGame{}\n\t\tif err := v.DecodeTDLibJSON(buf); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to decode InputInlineQueryResultClass: %w\", err)\n\t\t}\n\t\treturn &v, nil\n\tcase \"inputInlineQueryResultLocation\":\n\t\t// Decoding inputInlineQueryResultLocation#8f7cbe56.\n\t\tv := InputInlineQueryResultLocation{}\n\t\tif err := v.DecodeTDLibJSON(buf); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to decode InputInlineQueryResultClass: %w\", err)\n\t\t}\n\t\treturn &v, nil\n\tcase \"inputInlineQueryResultPhoto\":\n\t\t// Decoding inputInlineQueryResultPhoto#bd0b361f.\n\t\tv := InputInlineQueryResultPhoto{}\n\t\tif err := v.DecodeTDLibJSON(buf); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to decode InputInlineQueryResultClass: %w\", err)\n\t\t}\n\t\treturn &v, nil\n\tcase \"inputInlineQueryResultSticker\":\n\t\t// Decoding inputInlineQueryResultSticker#10550459.\n\t\tv := InputInlineQueryResultSticker{}\n\t\tif err := v.DecodeTDLibJSON(buf); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to decode InputInlineQueryResultClass: %w\", err)\n\t\t}\n\t\treturn &v, nil\n\tcase \"inputInlineQueryResultVenue\":\n\t\t// Decoding inputInlineQueryResultVenue#2049c13d.\n\t\tv := InputInlineQueryResultVenue{}\n\t\tif err := v.DecodeTDLibJSON(buf); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to decode InputInlineQueryResultClass: %w\", err)\n\t\t}\n\t\treturn &v, nil\n\tcase \"inputInlineQueryResultVideo\":\n\t\t// Decoding inputInlineQueryResultVideo#66c344e7.\n\t\tv := InputInlineQueryResultVideo{}\n\t\tif err := v.DecodeTDLibJSON(buf); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to decode InputInlineQueryResultClass: %w\", err)\n\t\t}\n\t\treturn &v, nil\n\tcase \"inputInlineQueryResultVoiceNote\":\n\t\t// Decoding inputInlineQueryResultVoiceNote#954da949.\n\t\tv := InputInlineQueryResultVoiceNote{}\n\t\tif err := v.DecodeTDLibJSON(buf); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to decode InputInlineQueryResultClass: %w\", err)\n\t\t}\n\t\treturn &v, nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unable to decode InputInlineQueryResultClass: %w\", tdjson.NewUnexpectedID(id))\n\t}\n}", "id": 9101, "concepts": ["interface", "type assertion", "error handling (errors.Is)", "standard library usage"], "_raw_llm_output": "interface, type assertion, error handling (errors.Is), standard library usage"}
{"seed": "// RetrieveServiceByLabel returns a Service object given its label by fetching\n// the associated environment, looping through its services, and returning\n// the first one matching the given label. If no service with the given label\n// is found, nil is returned.\nfunc RetrieveServiceByLabel(label string, settings *models.Settings) *models.Service {\n\tenv := RetrieveEnvironment(\"pod\", settings)\n\tfor _, service := range *env.Data.Services {\n\t\tif service.Label == label {\n\t\t\treturn &service\n\t\t}\n\t}\n\treturn nil\n}", "id": 9119, "concepts": ["struct definition", "pointer dereference", "pointer usage", "nil handling", "string comparison"], "_raw_llm_output": "struct definition, pointer dereference, pointer usage, nil handling, string comparison"}
{"seed": "// Not returns a Matcher that negates m.\nfunc Not(m Matcher) NotMatcher {\n\treturn NotMatcher{m}\n}", "id": 9120, "concepts": ["struct", "interface", "method", "method receiver", "method definition", "method invocation", "method chaining", "method composition"], "_raw_llm_output": "struct, interface, method, method receiver, method definition, method invocation, method chaining, method composition"}
{"seed": "// GyroRoll returns the gyroscope roll value in degrees between -180 and 180.\n// Left roll is negative, right is positive.\nfunc GyroRoll(x, y, z float64) float64 {\n\twr := math.Copysign(math.Sqrt(y*y+z*z), y)\n\treturn math.Atan2(-x, wr) * 180 / math.Pi\n}", "id": 9122, "concepts": ["math", "math.Atan2", "math.Copysign", "math.Sqrt", "math.Pi", "math.Atan2", "math.Copysign", "math.Sqrt", "math.Pi", "math.Atan2", "math.Copysign", "math.Sqrt", "math.Pi", "math.Atan2", "math.Copysign", "math.Sqrt", "math.Pi", "math.Atan2", "math.Copysign", "math.Sqrt", "math.Pi", "math.Atan2", "math.Copysign", "math.Sqrt", "math.Pi", "math.Atan2", "math.Copysign", "math.Sqrt", "math.Pi", "math.Atan2", "math.Copysign", "math.Sqrt", "math.Pi", "math.Atan2", "math.Copysign", "math.Sqrt", "math.Pi", "math.Atan2", "math.Copysign", "math.Sqrt", "math.Pi", "math.Atan2", "math.Copysign", "math.Sqrt", "math.Pi", "math.Atan2", "math.Copysign", "math.Sqrt", "math.Pi", "math.Atan2", "math.Copysign", "math.Sqrt", "math.Pi", "math.Atan2", ""], "_raw_llm_output": "math, math.Atan2, math.Copysign, math.Sqrt, math.Pi, math.Atan2, math.Copysign, math.Sqrt, math.Pi, math.Atan2, math.Copysign, math.Sqrt, math.Pi, math.Atan2, math.Copysign, math.Sqrt, math.Pi, math.Atan2, math.Copysign, math.Sqrt, math.Pi, math.Atan2, math.Copysign, math.Sqrt, math.Pi, math.Atan2, math.Copysign, math.Sqrt, math.Pi, math.Atan2, math.Copysign, math.Sqrt, math.Pi, math.Atan2, math.Copysign, math.Sqrt, math.Pi, math.Atan2, math.Copysign, math.Sqrt, math.Pi, math.Atan2, math.Copysign, math.Sqrt, math.Pi, math.Atan2, math.Copysign, math.Sqrt, math.Pi, math.Atan2, math.Copysign, math.Sqrt, math.Pi, math.Atan2,"}
{"seed": "// NewColumnChunkMetaDataBuilderWithContents will construct a builder and start it with the provided\n// column chunk information rather than with an empty column chunk.\nfunc NewColumnChunkMetaDataBuilderWithContents(props *parquet.WriterProperties, column *schema.Column, chunk *format.ColumnChunk) *ColumnChunkMetaDataBuilder {\n\tb := &ColumnChunkMetaDataBuilder{\n\t\tprops:  props,\n\t\tcolumn: column,\n\t\tchunk:  chunk,\n\t}\n\tb.init(chunk)\n\treturn b\n}", "id": 9137, "concepts": ["struct", "struct initialization", "struct field access", "struct method definition", "struct method call", "struct method invocation", "struct method return value", "struct method return value assignment", "struct method return value assignment to variable", "struct method return value assignment to variable", "struct method return value assignment to variable", "struct method return value assignment to variable", "struct method return value assignment to variable", "struct method return value assignment to variable", "struct method return value assignment to variable", "struct method return value assignment to variable", "struct method return value assignment to variable", "struct method return value assignment to variable", "struct method return value assignment to variable", "struct method return value assignment to variable", "struct method return value assignment to variable", "struct method return value assignment to variable", "struct method return value assignment to variable", "struct method return value assignment to variable", "struct method return value assignment to variable", "struct method return value assignment to variable", "struct method return value assignment to variable", "struct method return value assignment to variable", "struct method return value assignment to variable", "struct method return value assignment to variable", "struct method return value assignment to variable", "struct method return value assignment to variable", "struct method return value assignment to variable", "struct method return value assignment to variable", "struct method return value assignment to variable", "struct method return value assignment to variable"], "_raw_llm_output": "struct, struct initialization, struct field access, struct method definition, struct method call, struct method invocation, struct method return value, struct method return value assignment, struct method return value assignment to variable, struct method return value assignment to variable, struct method return value assignment to variable, struct method return value assignment to variable, struct method return value assignment to variable, struct method return value assignment to variable, struct method return value assignment to variable, struct method return value assignment to variable, struct method return value assignment to variable, struct method return value assignment to variable, struct method return value assignment to variable, struct method return value assignment to variable, struct method return value assignment to variable, struct method return value assignment to variable, struct method return value assignment to variable, struct method return value assignment to variable, struct method return value assignment to variable, struct method return value assignment to variable, struct method return value assignment to variable, struct method return value assignment to variable, struct method return value assignment to variable, struct method return value assignment to variable, struct method return value assignment to variable, struct method return value assignment to variable, struct method return value assignment to variable, struct method return value assignment to variable, struct method return value assignment to variable, struct method return value assignment to variable"}
{"seed": "// PostManageForgotPasswordToken returns a forgot password token. Note: If you have the\n// UserName workflow enabled, you may replace the 'email' parameter with 'username'.\n// Post parameter is either the username: string or the email: string\nfunc PostManageForgotPasswordToken(body interface{}) (AccountTokens, error) {\n\tdata := new(AccountTokens)\n\treq, reqErr := CreateRequest(\"POST\", os.Getenv(\"DOMAIN\")+\"/identity/v2/manage/account/forgot/token\", body)\n\tif reqErr != nil {\n\t\treturn *data, reqErr\n\t}\n\n\treq.Header.Add(\"content-Type\", \"application/json\")\n\treq.Header.Add(\"X-LoginRadius-ApiKey\", os.Getenv(\"APIKEY\"))\n\treq.Header.Add(\"X-LoginRadius-ApiSecret\", os.Getenv(\"APISECRET\"))\n\n\terr := RunRequest(req, data)\n\treturn *data, err\n}", "id": 9148, "concepts": ["http request", "http response", "http request body", "http request header", "http request method", "http request parameter", "http response body", "http response header", "http response status code", "http response status message", "http response status code", "http response status message", "http response status code", "http response status message", "http response status code", "http response status message", "http response status code", "http response status message", "http response status code", "http response status message", "http response status code", "http response status message", "http response status code", "http response status message", "http response status code", "http response status message", "http response status code", "http response status message", "http response status code", "http response status message", "http response status code", "http response status message", "http response status code", "http response status message", "http response status code", "http response status message", "http response status code", "http response status message", "http response status code", "http response status message", "http response status code", "http response status message", "http response status code", "http response status message", "http response status code", "http response status message", "http response status code", "http response status message", "http response status code", "http response status message", "http response status code", "http response status message", "http response status code", ""], "_raw_llm_output": "http request, http response, http request body, http request header, http request method, http request parameter, http response body, http response header, http response status code, http response status message, http response status code, http response status message, http response status code, http response status message, http response status code, http response status message, http response status code, http response status message, http response status code, http response status message, http response status code, http response status message, http response status code, http response status message, http response status code, http response status message, http response status code, http response status message, http response status code, http response status message, http response status code, http response status message, http response status code, http response status message, http response status code, http response status message, http response status code, http response status message, http response status code, http response status message, http response status code, http response status message, http response status code, http response status message, http response status code, http response status message, http response status code, http response status message, http response status code, http response status message, http response status code, http response status message, http response status code,"}
{"seed": "// HasRecordWith applies the HasEdge predicate on the \"record\" edge with a given conditions (other predicates).\nfunc HasRecordWith(preds ...predicate.TradeRecord) predicate.TradeCorrection {\n\treturn predicate.TradeCorrection(func(s *sql.Selector) {\n\t\tstep := sqlgraph.NewStep(\n\t\t\tsqlgraph.From(Table, FieldID),\n\t\t\tsqlgraph.To(RecordInverseTable, FieldID),\n\t\t\tsqlgraph.Edge(sqlgraph.M2M, true, RecordTable, RecordPrimaryKey...),\n\t\t)\n\t\tsqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {\n\t\t\tfor _, p := range preds {\n\t\t\t\tp(s)\n\t\t\t}\n\t\t})\n\t})\n}", "id": 9160, "concepts": ["sqlgraph", "sql.Selector", "sqlgraph.HasNeighborsWith", "sqlgraph.Edge", "sqlgraph.M2M", "sqlgraph.From", "sqlgraph.To", "sqlgraph.Step", "sqlgraph.From", "sqlgraph.To", "sqlgraph.Edge", "sqlgraph.M2M", "sqlgraph.From", "sqlgraph.To", "sqlgraph.Edge", "sqlgraph.M2M", "sqlgraph.From", "sqlgraph.To", "sqlgraph.Edge", "sqlgraph.M2M", "sqlgraph.From", "sqlgraph.To", "sqlgraph.Edge", "sqlgraph.M2M", "sqlgraph.From", "sqlgraph.To", "sqlgraph.Edge", "sqlgraph.M2M", "sqlgraph.From", "sqlgraph.To", "sqlgraph.Edge", "sqlgraph.M2M", "sqlgraph.From", "sqlgraph.To", "sqlgraph.Edge", "sqlgraph.M2M", "sqlgraph.From", "sqlgraph.To", "sqlgraph.Edge", "sqlgraph.M2M", "sqlgraph.From", "sqlgraph.To", "sqlgraph.Edge", "sqlgraph.M2M", "sqlgraph.From", "sqlgraph.To", "sqlgraph.Edge", "sql"], "_raw_llm_output": "sqlgraph, sql.Selector, sqlgraph.HasNeighborsWith, sqlgraph.Edge, sqlgraph.M2M, sqlgraph.From, sqlgraph.To, sqlgraph.Step, sqlgraph.From, sqlgraph.To, sqlgraph.Edge, sqlgraph.M2M, sqlgraph.From, sqlgraph.To, sqlgraph.Edge, sqlgraph.M2M, sqlgraph.From, sqlgraph.To, sqlgraph.Edge, sqlgraph.M2M, sqlgraph.From, sqlgraph.To, sqlgraph.Edge, sqlgraph.M2M, sqlgraph.From, sqlgraph.To, sqlgraph.Edge, sqlgraph.M2M, sqlgraph.From, sqlgraph.To, sqlgraph.Edge, sqlgraph.M2M, sqlgraph.From, sqlgraph.To, sqlgraph.Edge, sqlgraph.M2M, sqlgraph.From, sqlgraph.To, sqlgraph.Edge, sqlgraph.M2M, sqlgraph.From, sqlgraph.To, sqlgraph.Edge, sqlgraph.M2M, sqlgraph.From, sqlgraph.To, sqlgraph.Edge, sql"}
{"seed": "// NewGetMarketsRegionIDHistoryParams creates a new GetMarketsRegionIDHistoryParams object\n// with the default values initialized.\nfunc NewGetMarketsRegionIDHistoryParams() *GetMarketsRegionIDHistoryParams {\n\tvar (\n\t\tdatasourceDefault = string(\"tranquility\")\n\t)\n\treturn &GetMarketsRegionIDHistoryParams{\n\t\tDatasource: &datasourceDefault,\n\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 9168, "concepts": ["struct initialization", "pointer receivers", "default values"], "_raw_llm_output": "struct initialization, pointer receivers, default values"}
{"seed": "// NewWriter constructs and returns a new Writer that writes to the supplied\n// output stream.\n// This method will write the packfile magic and header to the underlying\n// stream.\nfunc NewWriter(to io.Writer) (*Writer, error) {\n\tw := &Writer{\n\t\ttypes:   newTypes(),\n\t\tbuf:     proto.NewBuffer(make([]byte, 0, initalBufferSize)),\n\t\tsizebuf: proto.NewBuffer(make([]byte, 0, maxVarintSize)),\n\t\tto:      to,\n\t}\n\tif err := w.writeMagic(); err != nil {\n\t\treturn nil, err\n\t}\n\theader := &Header{Version: version}\n\tif err := w.writeHeader(header); err != nil {\n\t\treturn nil, err\n\t}\n\treturn w, nil\n}", "id": 9173, "concepts": ["io.Writer", "io.Reader", "io.WriterTo", "io.ReadFrom", "io.Closer", "io.Seeker", "io.ReaderAt", "io.ByteReader", "io.ByteWriter", "io.RuneReader", "io.RuneWriter", "io.SeekerAt", "io.ByteScanner", "io.ByteSizer", "io.ByteWriter", "io.WriterTo", "io.ReadFrom", "io.ReaderAt", "io.ByteReader", "io.ByteWriter", "io.RuneReader", "io.RuneWriter", "io.SeekerAt", "io.ByteScanner", "io.ByteSizer", "io.ByteWriter", "io.WriterTo", "io.ReadFrom", "io.ReaderAt", "io.ByteReader", "io.ByteWriter", "io.RuneReader", "io.RuneWriter", "io.SeekerAt", "io.ByteScanner", "io.ByteSizer", "io.ByteWriter", "io.WriterTo", "io.ReadFrom", "io.ReaderAt", "io.ByteReader", "io.ByteWriter", "io.RuneReader", "io.RuneWriter", "io.SeekerAt", "io.ByteScanner", "io.ByteSizer", "io.ByteWriter", "io.WriterTo", "io.ReadFrom", "io.ReaderAt"], "_raw_llm_output": "io.Writer, io.Reader, io.WriterTo, io.ReadFrom, io.Closer, io.Seeker, io.ReaderAt, io.ByteReader, io.ByteWriter, io.RuneReader, io.RuneWriter, io.SeekerAt, io.ByteScanner, io.ByteSizer, io.ByteWriter, io.WriterTo, io.ReadFrom, io.ReaderAt, io.ByteReader, io.ByteWriter, io.RuneReader, io.RuneWriter, io.SeekerAt, io.ByteScanner, io.ByteSizer, io.ByteWriter, io.WriterTo, io.ReadFrom, io.ReaderAt, io.ByteReader, io.ByteWriter, io.RuneReader, io.RuneWriter, io.SeekerAt, io.ByteScanner, io.ByteSizer, io.ByteWriter, io.WriterTo, io.ReadFrom, io.ReaderAt, io.ByteReader, io.ByteWriter, io.RuneReader, io.RuneWriter, io.SeekerAt, io.ByteScanner, io.ByteSizer, io.ByteWriter, io.WriterTo, io.ReadFrom, io.ReaderAt"}
{"seed": "// BetterHeroScoreAtIn applies the In predicate on the \"better_hero_score_at\" field.\nfunc BetterHeroScoreAtIn(vs ...time.Time) predicate.User {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.User(func(s *sql.Selector) {\n\t\t// if not arguments were provided, append the FALSE constants,\n\t\t// since we can't apply \"IN ()\". This will make this predicate falsy.\n\t\tif len(vs) == 0 {\n\t\t\ts.Where(sql.False())\n\t\t\treturn\n\t\t}\n\t\ts.Where(sql.In(s.C(FieldBetterHeroScoreAt), v...))\n\t})\n}", "id": 9187, "concepts": ["sql package usage", "sql.Selector", "sql.In", "sql.False", "predicate.User"], "_raw_llm_output": "sql package usage, sql.Selector, sql.In, sql.False, predicate.User"}
{"seed": "// NewDeleteSiteDeployParamsWithHTTPClient creates a new DeleteSiteDeployParams object\n// with the default values initialized, and the ability to set a custom HTTPClient for a request\nfunc NewDeleteSiteDeployParamsWithHTTPClient(client *http.Client) *DeleteSiteDeployParams {\n\tvar ()\n\treturn &DeleteSiteDeployParams{\n\t\tHTTPClient: client,\n\t}\n}", "id": 9195, "concepts": ["http.Client", "function definition", "function composition"], "_raw_llm_output": "http.Client, function definition, function composition"}
{"seed": "// IsTerminal returns true if fd is a tty.\nfunc IsTerminal(fd uintptr) bool {\n\treturn isatty.IsTerminal(fd)\n}", "id": 9198, "concepts": ["os.Stdin", "os.Stdout", "os.Stderr", "os.File", "os.File.Stat", "os.File.Fd", "os.File.Close", "os.File.WriteString", "os.File.Read", "os.File.ReadAt", "os.File.Seek", "os.File.Stat", "os.File.Sync", "os.File.Truncate", "os.File.Write", "os.File.WriteString", "os.File.WriteAt", "os.File.WriteAt", "os.File.WriteAt", "os.File.WriteAt", "os.File.WriteAt", "os.File.WriteAt", "os.File.WriteAt", "os.File.WriteAt", "os.File.WriteAt", "os.File.WriteAt", "os.File.WriteAt", "os.File.WriteAt", "os.File.WriteAt", "os.File.WriteAt", "os.File.WriteAt", "os.File.WriteAt", "os.File.WriteAt", "os.File.WriteAt", "os.File.WriteAt", "os.File.WriteAt", "os.File.WriteAt", "os.File.WriteAt", "os.File.WriteAt", "os.File."], "_raw_llm_output": "os.Stdin, os.Stdout, os.Stderr, os.File, os.File.Stat, os.File.Fd, os.File.Close, os.File.WriteString, os.File.Read, os.File.ReadAt, os.File.Seek, os.File.Stat, os.File.Sync, os.File.Truncate, os.File.Write, os.File.WriteString, os.File.WriteAt, os.File.WriteAt, os.File.WriteAt, os.File.WriteAt, os.File.WriteAt, os.File.WriteAt, os.File.WriteAt, os.File.WriteAt, os.File.WriteAt, os.File.WriteAt, os.File.WriteAt, os.File.WriteAt, os.File.WriteAt, os.File.WriteAt, os.File.WriteAt, os.File.WriteAt, os.File.WriteAt, os.File.WriteAt, os.File.WriteAt, os.File.WriteAt, os.File.WriteAt, os.File.WriteAt, os.File.WriteAt, os.File."}
{"seed": "// PossibleKindValues returns an array of possible values for the Kind const type.\nfunc PossibleKindValues() []Kind {\n\treturn []Kind{KindDatabase, KindReadOnlyFollowing, KindReadWrite}\n}", "id": 9207, "concepts": ["array definition", "array iteration (range loop)", "basic function definition"], "_raw_llm_output": "array definition, array iteration (range loop), basic function definition"}
{"seed": "//getRoutingInterface returns the first interface that has the given ip reachable through\n//its network\n//as <name>, <address>, error\n//error return if no match is found\nfunc getRoutingInterface(ip string) (name string, network *net.IPNet, err error) {\n\t_ip := net.ParseIP(ip)\n\tnics, err := net.Interfaces()\n\tif err != nil {\n\t\treturn\n\t}\n\tfor _, nic := range nics {\n\t\tvar addrs []net.Addr\n\t\taddrs, err = nic.Addrs()\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\tfor _, addr := range addrs {\n\t\t\tif addr, ok := addr.(*net.IPNet); ok {\n\t\t\t\tif addr.Contains(_ip) {\n\t\t\t\t\treturn nic.Name, addr, nil\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\terr = fmt.Errorf(\"no match found\")\n\treturn\n}", "id": 9209, "concepts": ["net.Interfaces", "net.IPNet", "net.ParseIP", "net.Interface.Addrs", "net.Interface.Name", "net.Addr.(*net.IPNet)", "net.IPNet.Contains", "error handling (errors.New)", "error handling (fmt.Errorf)"], "_raw_llm_output": "net.Interfaces, net.IPNet, net.ParseIP, net.Interface.Addrs, net.Interface.Name, net.Addr.(*net.IPNet), net.IPNet.Contains, error handling (errors.New), error handling (fmt.Errorf)"}
{"seed": "// RecentTasksActivityLRStatusDESC function sorts data by LastRunStatus field in descending order\n// sorting layers: LRStatus > LRTime(DESC)  > Name(ASC)\n// function chain according to sorting layers: RecentTasksActivityLRStatusDESC > subsortingByLRTimeDESC > subsortingByNameASC\nfunc RecentTasksActivityLRStatusDESC(p1, p2 interface{}) bool {\n\tp1Status := getSortableLastRunStatus(p1.(RecentTasksActivity).LastRunStatus)\n\tp2Status := getSortableLastRunStatus(p2.(RecentTasksActivity).LastRunStatus)\n\n\tif p1Status == p2Status {\n\t\treturn subsortingByLRTimeDESC(p1, p2)\n\t}\n\n\treturn p1Status > p2Status\n}", "id": 9220, "concepts": ["interface", "sorting", "sorting by multiple fields", "sorting by multiple fields in different sorting layers"], "_raw_llm_output": "interface, sorting, sorting by multiple fields, sorting by multiple fields in different sorting layers"}
{"seed": "// globSources finds sources in path with any of the given extensions.\n// It also filters out temporary files, dangling symlinks, and symlinks into bazel-bin specifically.\n// It returns file names relative to path.\nfunc globSources(ctx context.Context, path string, extensions []string) (srcSet, error) {\n\tvar allSourcePaths []string\n\tfor _, extension := range extensions {\n\t\tpattern := \"*.\" + extension\n\t\tmatched, err := platform.Glob(ctx, filepath.Join(path, pattern))\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"glob(%s): %s\", pattern, err)\n\t\t}\n\t\tallSourcePaths = append(allSourcePaths, matched...)\n\t}\n\tsrcs := make(srcSet)\n\tfor _, p := range allSourcePaths {\n\t\tfileName := filepath.Base(p)\n\t\tif isTempFile(fileName) {\n\t\t\tcontinue // Ignore editor swap/backup files.\n\t\t}\n\t\t// Try platform.Stat as a fallback, for Google file systems.\n\t\t_, err := platform.Stat(ctx, p)\n\t\tif os.IsNotExist(err) {\n\t\t\tplatform.Infof(\"platform.Glob returned non-existent file (dangling symlink?). Ignoring %q.\", p)\n\t\t\tcontinue\n\t\t}\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"cannot stat platform.Glob result %q: %v\", p, err)\n\t\t}\n\t\tp, err := filepath.Rel(path, p)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"filepath.Rel(%s, %s): %v\", path, p, err)\n\t\t}\n\t\tsrcs[p] = true\n\t}\n\treturn srcs, nil\n}", "id": 9223, "concepts": ["filepath.Glob", "filepath.Rel", "filepath.Join", "os.Stat", "platform.Stat", "platform.Glob", "platform.Infof", "platform.Stat", "os.IsNotExist", "filepath.Base", "filepath.Rel", "filepath.Join", "os.Stat", "platform.Stat", "os.IsNotExist", "filepath.Rel", "filepath.Join", "os.Stat", "platform.Stat", "os.IsNotExist", "filepath.Rel", "filepath.Join", "os.Stat", "platform.Stat", "os.IsNotExist", "filepath.Rel", "filepath.Join", "os.Stat", "platform.Stat", "os.IsNotExist", "filepath.Rel", "filepath.Join", "os.Stat", "platform.Stat", "os.IsNotExist", "filepath.Rel", "filepath.Join", "os.Stat", "platform.Stat", "os.IsNotExist", "filepath.Rel", "filepath.Join", "os.Stat", "platform.Stat", "os.IsNotExist", "filepath.Rel", "filepath.Join", "os.Stat", "platform.Stat", "os.IsNotExist", "filepath.Rel", "filepath.Join", "os.Stat", "platform.Stat", "os.IsNotExist", "filepath.Rel", "filepath.Join", "os.Stat", "platform.Stat", "os.IsNotExist", "filepath.Rel", ""], "_raw_llm_output": "filepath.Glob, filepath.Rel, filepath.Join, os.Stat, platform.Stat, platform.Glob, platform.Infof, platform.Stat, os.IsNotExist, filepath.Base, filepath.Rel, filepath.Join, os.Stat, platform.Stat, os.IsNotExist, filepath.Rel, filepath.Join, os.Stat, platform.Stat, os.IsNotExist, filepath.Rel, filepath.Join, os.Stat, platform.Stat, os.IsNotExist, filepath.Rel, filepath.Join, os.Stat, platform.Stat, os.IsNotExist, filepath.Rel, filepath.Join, os.Stat, platform.Stat, os.IsNotExist, filepath.Rel, filepath.Join, os.Stat, platform.Stat, os.IsNotExist, filepath.Rel, filepath.Join, os.Stat, platform.Stat, os.IsNotExist, filepath.Rel, filepath.Join, os.Stat, platform.Stat, os.IsNotExist, filepath.Rel, filepath.Join, os.Stat, platform.Stat, os.IsNotExist, filepath.Rel, filepath.Join, os.Stat, platform.Stat, os.IsNotExist, filepath.Rel,"}
{"seed": "// NewAnalysisResultsClient creates a new instance of AnalysisResultsClient with the specified values.\n//   - subscriptionID - The Azure subscription ID. This is a GUID-formatted string.\n//   - credential - used to authorize requests. Usually a credential from azidentity.\n//   - options - pass nil to accept the default values.\nfunc NewAnalysisResultsClient(subscriptionID string, credential azcore.TokenCredential, options *arm.ClientOptions) (*AnalysisResultsClient, error) {\n\tcl, err := arm.NewClient(moduleName+\".AnalysisResultsClient\", moduleVersion, credential, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tclient := &AnalysisResultsClient{\n\t\tsubscriptionID: subscriptionID,\n\t\tinternal:       cl,\n\t}\n\treturn client, nil\n}", "id": 9226, "concepts": ["struct definition", "interface definition", "pointer definition", "function definition", "method definition", "client definition", "client creation", "client initialization", "client usage", "client usage with options", "client usage with credentials", "client usage with subscription ID", "client usage with subscription ID and options", "client usage with subscription ID and credentials", "client usage with subscription ID and options and credentials", "client usage with subscription ID and options and credentials with anonymous function", "client usage with subscription ID and options and credentials with anonymous function and pointer definition", "client usage with subscription ID and options and credentials with anonymous function and pointer definition and struct definition", "client usage with subscription ID and options and credentials with anonymous function and pointer definition and struct definition and interface definition", "client usage with subscription ID and options and credentials with anonymous function and pointer definition and struct definition and interface definition and method definition", "client usage with subscription ID and options and credentials with anonymous function and pointer definition and struct definition and interface definition and method definition and client definition", "client usage with subscription ID and options and credentials with anonymous function and pointer definition and struct definition and interface definition and method definition and client definition and client creation", "client usage with subscription ID and options and credentials with anonymous function and pointer definition and struct definition and interface definition and method definition and client definition and client creation and module"], "_raw_llm_output": "struct definition, interface definition, pointer definition, function definition, method definition, client definition, client creation, client initialization, client usage, client usage with options, client usage with credentials, client usage with subscription ID, client usage with subscription ID and options, client usage with subscription ID and credentials, client usage with subscription ID and options and credentials, client usage with subscription ID and options and credentials with anonymous function, client usage with subscription ID and options and credentials with anonymous function and pointer definition, client usage with subscription ID and options and credentials with anonymous function and pointer definition and struct definition, client usage with subscription ID and options and credentials with anonymous function and pointer definition and struct definition and interface definition, client usage with subscription ID and options and credentials with anonymous function and pointer definition and struct definition and interface definition and method definition, client usage with subscription ID and options and credentials with anonymous function and pointer definition and struct definition and interface definition and method definition and client definition, client usage with subscription ID and options and credentials with anonymous function and pointer definition and struct definition and interface definition and method definition and client definition and client creation, client usage with subscription ID and options and credentials with anonymous function and pointer definition and struct definition and interface definition and method definition and client definition and client creation and module"}
{"seed": "// PossibleExtensionOptionTypeValues returns the possible values for the ExtensionOptionType const type.\nfunc PossibleExtensionOptionTypeValues() []ExtensionOptionType {\n\treturn []ExtensionOptionType{\n\t\tExtensionOptionTypeDoNotMergeExistingReadOnlyAndSecretProperties,\n\t\tExtensionOptionTypeIncludeInternalMetadata,\n\t\tExtensionOptionTypeNotSpecified,\n\t}\n}", "id": 9237, "concepts": ["const type", "const type usage", "array iteration (range loop)", "basic function definition"], "_raw_llm_output": "const type, const type usage, array iteration (range loop), basic function definition"}
{"seed": "// SocialNameHasPrefix applies the HasPrefix predicate on the \"social_name\" field.\nfunc SocialNameHasPrefix(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.HasPrefix(s.C(FieldSocialName), v))\n\t})\n}", "id": 9249, "concepts": ["sql package usage", "predicate.User", "sql.Selector", "sql.C", "sql.HasPrefix"], "_raw_llm_output": "sql package usage, predicate.User, sql.Selector, sql.C, sql.HasPrefix"}
{"seed": "// NewDeleteSiteDeployParamsWithTimeout creates a new DeleteSiteDeployParams object\n// with the default values initialized, and the ability to set a timeout on a request\nfunc NewDeleteSiteDeployParamsWithTimeout(timeout time.Duration) *DeleteSiteDeployParams {\n\tvar ()\n\treturn &DeleteSiteDeployParams{\n\n\t\ttimeout: timeout,\n\t}\n}", "id": 9273, "concepts": ["function definition", "function parameters", "function return values", "function pointer", "function composition", "function composition with return values", "function composition with timeout"], "_raw_llm_output": "function definition, function parameters, function return values, function pointer, function composition, function composition with return values, function composition with timeout"}
{"seed": "// NewTranslatingWriter returns a new WriteCloser writing to w.\n// It passes the written bytes through the given Translator.\nfunc NewTranslatingWriter(w io.Writer, tr Translator) io.WriteCloser {\n\treturn &translatingWriter{w: w, tr: tr}\n}", "id": 9299, "concepts": ["io.Writer", "io.WriteCloser", "io.Closer", "io.Reader", "io.ReaderFrom", "io.WriterTo", "io.Seeker", "io.ByteReader", "io.ByteWriter", "io.RuneReader", "io.RuneWriter", "io.RuneScanner", "io.ReaderAt", "io.WriterAt", "io.SeekerAt", "io.ByteReaderAt", "io.ByteWriterAt", "io.RuneReaderAt", "io.RuneWriterAt", "io.ReaderFromAt", "io.WriterToAt", "io.SeekerFrom", "io.SeekerTo", "io.ReaderFromTo", "io.WriterToFrom", "io.ReaderFromToAt", "io.WriterToFromAt", "io.ByteReaderFrom", "io.ByteReaderTo", "io.ByteReaderFromTo", "io.ByteReaderFromToAt", "io.ByteReaderToFrom", "io.ByteReaderToFromAt", "io.ByteReaderAtFrom", "io.ByteReaderAtTo", "io.ByteReaderAtFromTo", "io.ByteReaderAtToFrom", "io.ByteReaderAtToFromAt", "io.ByteReaderAtFromToAt", "io.ByteReaderAtToFromAt", "io.ByteWriterFrom", "io.Byte"], "_raw_llm_output": "io.Writer, io.WriteCloser, io.Closer, io.Reader, io.ReaderFrom, io.WriterTo, io.Seeker, io.ByteReader, io.ByteWriter, io.RuneReader, io.RuneWriter, io.RuneScanner, io.ReaderAt, io.WriterAt, io.SeekerAt, io.ByteReaderAt, io.ByteWriterAt, io.RuneReaderAt, io.RuneWriterAt, io.ReaderFromAt, io.WriterToAt, io.SeekerFrom, io.SeekerTo, io.ReaderFromTo, io.WriterToFrom, io.ReaderFromToAt, io.WriterToFromAt, io.ByteReaderFrom, io.ByteReaderTo, io.ByteReaderFromTo, io.ByteReaderFromToAt, io.ByteReaderToFrom, io.ByteReaderToFromAt, io.ByteReaderAtFrom, io.ByteReaderAtTo, io.ByteReaderAtFromTo, io.ByteReaderAtToFrom, io.ByteReaderAtToFromAt, io.ByteReaderAtFromToAt, io.ByteReaderAtToFromAt, io.ByteWriterFrom, io.Byte"}
{"seed": "// addKnownTypes adds the set of types defined in this package to the supplied scheme.\nfunc addKnownTypes(scheme *runtime.Scheme) error {\n\tscheme.AddKnownTypes(SchemeGroupVersion,\n\t\t&EtcdBackup{},\n\t\t&EtcdBackupList{},\n\t)\n\tmetav1.AddToGroupVersion(scheme, SchemeGroupVersion)\n\treturn nil\n}", "id": 9305, "concepts": ["runtime.Scheme", "metav1.AddToGroupVersion", "struct definition", "type definition"], "_raw_llm_output": "runtime.Scheme, metav1.AddToGroupVersion, struct definition, type definition"}
{"seed": "// Pearson correlation score to compensate for skewed scores.\n// https://en.wikipedia.org/wiki/Pearson_product-moment_correlation_coefficient#Definition\nfunc Pearson(p1 map[string]float64, p2 map[string]float64) float64 {\n\t// Find common items\n\tcommon := map[string]bool{}\n\tfor item, _ := range p1 {\n\t\t_, ok := p2[item]\n\t\tif ok {\n\t\t\tcommon[item] = true\n\t\t}\n\t}\n\tn := float64(len(common))\n\n\t// Nothing in common\n\tif n == 0 {\n\t\treturn 0\n\t}\n\n\t// sum of preferences and squares\n\tsump1 := 0.0\n\tsump1Sq := 0.0\n\tsump2 := 0.0\n\tsump2Sq := 0.0\n\tpSum := 0.0\n\tfor item, _ := range common {\n\t\tsump1 += p1[item]\n\t\tsump1Sq += math.Pow(p1[item], 2)\n\t\tsump2 += p2[item]\n\t\tsump2Sq += math.Pow(p2[item], 2)\n\t\tpSum += p1[item] * p2[item]\n\t}\n\n\t// calculate pearson score\n\tnumerator := pSum - (sump1 * sump2 / float64(len(common)))\n\tdenom := math.Sqrt((sump1Sq - math.Pow(sump1, 2)/n) * (sump2Sq - math.Pow(sump2, 2)/n))\n\tif denom == 0 {\n\t\treturn 1\n\t}\n\n\treturn numerator / denom\n}", "id": 9308, "concepts": ["map iteration (range loop)", "map summation", "map multiplication", "map division", "map subtraction", "mathematical operations", "standard library usage"], "_raw_llm_output": "map iteration (range loop), map summation, map multiplication, map division, map subtraction, mathematical operations, standard library usage"}
{"seed": "// H4 represents the HTML element 'h4'.\n// For more information visit https://www.w3schools.com/tags/tag_h4.asp.\nfunc H4(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"h4\", Attributes: attrs, Children: children}\n}", "id": 9312, "concepts": ["HTML generation", "HTML tree traversal", "HTML element definition"], "_raw_llm_output": "HTML generation, HTML tree traversal, HTML element definition"}
{"seed": "// MapInt8Uint64Ptr takes two inputs -\n// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list\nfunc MapInt8Uint64Ptr(f func(*int8) *uint64, list []*int8) []*uint64 {\n\tif f == nil {\n\t\treturn []*uint64{}\n\t}\n\tnewList := make([]*uint64, len(list))\n\tfor i, v := range list {\n\t\tnewList[i] = f(v)\n\t}\n\treturn newList\n}", "id": 9317, "concepts": ["function as parameter", "function composition", "function definition", "function return", "function call", "function pointer", "function signature", "function type", "function value", "function literal", "function application", "function application with multiple parameters", "function application with multiple return values", "function application with multiple return values and multiple parameters", "function application with multiple return values and multiple parameters and multiple return values", "function application with multiple return values and multiple parameters and multiple return values and multiple parameters", "function application with multiple return values and multiple parameters and multiple return values and multiple parameters and multiple return values", "function application with multiple return values and multiple parameters and multiple return values and multiple parameters and multiple return values and multiple parameters", "function application with multiple return values and multiple parameters and multiple return values and multiple parameters and multiple return values and multiple parameters and multiple return values", "function application with multiple return values and multiple parameters and multiple return values and multiple parameters and multiple return values and multiple parameters and multiple return values and multiple parameters", "function application with multiple return values and multiple parameters and multiple return values and multiple parameters and multiple return values and multiple parameters and multiple return values and multiple parameters and multiple return values", "function application with multiple return values and multiple parameters and multiple return values and multiple parameters and multiple return values and multiple parameters and multiple return values and"], "_raw_llm_output": "function as parameter, function composition, function definition, function return, function call, function pointer, function signature, function type, function value, function literal, function application, function application with multiple parameters, function application with multiple return values, function application with multiple return values and multiple parameters, function application with multiple return values and multiple parameters and multiple return values, function application with multiple return values and multiple parameters and multiple return values and multiple parameters, function application with multiple return values and multiple parameters and multiple return values and multiple parameters and multiple return values, function application with multiple return values and multiple parameters and multiple return values and multiple parameters and multiple return values and multiple parameters, function application with multiple return values and multiple parameters and multiple return values and multiple parameters and multiple return values and multiple parameters and multiple return values, function application with multiple return values and multiple parameters and multiple return values and multiple parameters and multiple return values and multiple parameters and multiple return values and multiple parameters, function application with multiple return values and multiple parameters and multiple return values and multiple parameters and multiple return values and multiple parameters and multiple return values and multiple parameters and multiple return values, function application with multiple return values and multiple parameters and multiple return values and multiple parameters and multiple return values and multiple parameters and multiple return values and"}
{"seed": "// NewCreateAntiAffinityGroupRequestWithBody generates requests for CreateAntiAffinityGroup with any type of body\nfunc NewCreateAntiAffinityGroupRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {\n\tvar err error\n\n\tqueryUrl, err := url.Parse(server)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbasePath := fmt.Sprintf(\"/anti-affinity-group\")\n\tif basePath[0] == '/' {\n\t\tbasePath = basePath[1:]\n\t}\n\n\tqueryUrl, err = queryUrl.Parse(basePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq, err := http.NewRequest(\"POST\", queryUrl.String(), body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Add(\"Content-Type\", contentType)\n\treturn req, nil\n}", "id": 9322, "concepts": ["url parsing", "http request generation", "io.Reader usage"], "_raw_llm_output": "url parsing, http request generation, io.Reader usage"}
{"seed": "// ContactsToStrings converts a list of Contact to the [][]string representation.\nfunc ContactsToStrings(contacts []Contact) [][]string {\n\tvar contactStrings [][]string\n\tfor i := range contacts {\n\t\tcontactStrings = append(contactStrings, contacts[i].ToStrings())\n\t}\n\n\treturn contactStrings\n}", "id": 9323, "concepts": ["struct", "slice", "interface", "method", "function"], "_raw_llm_output": "struct, slice, interface, method, function"}
{"seed": "// GenStrategyDecremental generates a number of type `typ` equal to the opposite of the converted `seed` value.\nfunc GenStrategyDecremental(typ Type, seed int) interface{} {\n\treturn typ.Convert(-seed)\n}", "id": 9332, "concepts": ["type conversion", "interface", "type definition", "type assertion"], "_raw_llm_output": "type conversion, interface, type definition, type assertion"}
{"seed": "// ensureCap returns s with a capacity of at least n bytes.\n// If cap(s) < n, then it returns a new copy of s with the\n// required capacity.\nfunc ensureCap(s []byte, n int) []byte {\n\tif n <= cap(s) {\n\t\treturn s\n\t}\n\t// logic adapted from appendslice1 in runtime\n\tm := cap(s)\n\tif m == 0 {\n\t\tm = n\n\t} else {\n\t\tfor {\n\t\t\tif m < 1024 {\n\t\t\t\tm += m\n\t\t\t} else {\n\t\t\t\tm += m / 4\n\t\t\t}\n\t\t\tif m >= n {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\tt := make([]byte, len(s), m)\n\tcopy(t, s)\n\treturn t\n}", "id": 9333, "concepts": ["slice capacity", "append", "make", "basic function definition"], "_raw_llm_output": "slice capacity, append, make, basic function definition"}
{"seed": "// Progress represents the HTML element 'progress'.\n// For more information visit https://www.w3schools.com/tags/tag_progress.asp.\nfunc Progress(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"progress\", Attributes: attrs, Children: children}\n}", "id": 9344, "concepts": ["HTML tree building", "HTML element definition", "HTML attribute definition"], "_raw_llm_output": "HTML tree building, HTML element definition, HTML attribute definition"}
{"seed": "// NoJitter is a transport option only available in tests, to disable jitter\n// between connection attempts.\nfunc NoJitter() TransportOption {\n\treturn func(options *transportOptions) {\n\t\toptions.jitter = func(n int64) int64 {\n\t\t\treturn n\n\t\t}\n\t}\n}", "id": 9349, "concepts": ["function definition", "function composition", "function options", "function options composition"], "_raw_llm_output": "function definition, function composition, function options, function options composition"}
{"seed": "// Header_ is a convenience wrapper for Header without the attrs argument.\nfunc Header_(children ...HTML) HTML {\n  return Header(nil, children...)\n}", "id": 9352, "concepts": ["function definition", "function argument", "function return value", "function call"], "_raw_llm_output": "function definition, function argument, function return value, function call"}
{"seed": "// expandHomeDir replaces a leading \"~/\" in path with the user home directory\nfunc expandHomeDir(path string) string {\n\tif !strings.HasPrefix(path, \"~/\") {\n\t\treturn path\n\t}\n\n\tcurrentUser, err := user.Current()\n\tif err != nil {\n\t\tpanic(\"unable to determine user $HOME\")\n\t}\n\treturn filepath.Join(currentUser.HomeDir, path[2:])\n}", "id": 9359, "concepts": ["string manipulation", "user.Current", "filepath.Join", "filepath.IsAbs", "filepath.Split", "filepath.SplitList", "filepath.SplitList", "filepath.Split", "filepath.SplitList", "filepath.SplitList", "filepath.Split", "filepath.SplitList", "filepath.SplitList", "filepath.Split", "filepath.SplitList", "filepath.SplitList", "filepath.Split", "filepath.SplitList", "filepath.SplitList", "filepath.Split", "filepath.SplitList", "filepath.SplitList", "filepath.Split", "filepath.SplitList", "filepath.SplitList", "filepath.Split", "filepath.SplitList", "filepath.SplitList", "filepath.Split", "filepath.SplitList", "filepath.SplitList", "filepath.Split", "filepath.SplitList", "filepath.SplitList", "filepath.Split", "filepath.SplitList", "filepath.SplitList", "filepath.Split", "filepath.SplitList", "filepath.SplitList", "filepath.Split", "filepath.SplitList", "filepath.SplitList", "filepath.Split", "filepath.SplitList", "filepath.SplitList", "filepath.Split", "filepath.SplitList", "filepath.SplitList", "filepath.Split", "filepath.SplitList", "filepath.SplitList", "filepath.Split", "filepath.SplitList", "filepath.SplitList", "filepath"], "_raw_llm_output": "string manipulation, user.Current, filepath.Join, filepath.IsAbs, filepath.Split, filepath.SplitList, filepath.SplitList, filepath.Split, filepath.SplitList, filepath.SplitList, filepath.Split, filepath.SplitList, filepath.SplitList, filepath.Split, filepath.SplitList, filepath.SplitList, filepath.Split, filepath.SplitList, filepath.SplitList, filepath.Split, filepath.SplitList, filepath.SplitList, filepath.Split, filepath.SplitList, filepath.SplitList, filepath.Split, filepath.SplitList, filepath.SplitList, filepath.Split, filepath.SplitList, filepath.SplitList, filepath.Split, filepath.SplitList, filepath.SplitList, filepath.Split, filepath.SplitList, filepath.SplitList, filepath.Split, filepath.SplitList, filepath.SplitList, filepath.Split, filepath.SplitList, filepath.SplitList, filepath.Split, filepath.SplitList, filepath.SplitList, filepath.Split, filepath.SplitList, filepath.SplitList, filepath.Split, filepath.SplitList, filepath.SplitList, filepath.Split, filepath.SplitList, filepath.SplitList, filepath"}
{"seed": "// WithValueTranslator is an Option that configures a function that translates a\n// custom resource to the values passed to Helm.\n// Use this if you need to customize the logic that translates your custom resource to Helm values.\nfunc WithValueTranslator(t values.Translator) Option {\n\treturn func(r *Reconciler) error {\n\t\tr.valueTranslator = t\n\t\treturn nil\n\t}\n}", "id": 9366, "concepts": ["function definition", "function composition", "function options", "function composition"], "_raw_llm_output": "function definition, function composition, function options, function composition"}
{"seed": "// SocketUnitPath returns the path to the systemd socket file for the given app name.\nfunc SocketUnitPath(root string, appName types.ACName) string {\n\treturn filepath.Join(common.Stage1RootfsPath(root), UnitsDir, SocketUnitName(appName))\n}", "id": 9369, "concepts": ["filepath.Join", "string manipulation", "string concatenation", "string formatting", "string conversion", "string comparison", "string length", "string indexing", "string slicing", "string substrings", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string"], "_raw_llm_output": "filepath.Join, string manipulation, string concatenation, string formatting, string conversion, string comparison, string length, string indexing, string slicing, string substrings, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string"}
{"seed": "// AssertDeviceQueueItemsFunc asserts the device-queue items with the given func.\nfunc AssertDeviceQueueItemsFunc(f func(*require.Assertions, []storage.DeviceQueueItem)) Assertion {\n\treturn func(assert *require.Assertions, ts *IntegrationTestSuite) {\n\t\tdqi, err := storage.GetDeviceQueueItemsForDevEUI(context.Background(), storage.DB(), ts.Device.DevEUI)\n\t\tassert.NoError(err)\n\t\tf(assert, dqi)\n\t}\n}", "id": 9378, "concepts": ["function definition", "function composition", "function composition with anonymous functions", "function composition with anonymous functions and function composition", "function composition with anonymous functions and function composition with anonymous functions"], "_raw_llm_output": "function definition, function composition, function composition with anonymous functions, function composition with anonymous functions and function composition, function composition with anonymous functions and function composition with anonymous functions"}
{"seed": "// ChunckedHeader returns an HTTP 1.1 header with transfer encoding set to chunked.\nfunc ChunkedHeader() string {\n\treturn fmt.Sprintf(HTTPHeader, time.Now().UTC().Format(TimeFormat))\n}", "id": 9384, "concepts": ["string formatting", "time package usage"], "_raw_llm_output": "string formatting, time package usage"}
{"seed": "// StrTrim returns s with excess whitespace removed.\nfunc StrTrim(s string) string {\n\treturn strings.TrimSpace(s)\n}", "id": 9385, "concepts": ["string manipulation", "string trimming", "standard library usage"], "_raw_llm_output": "string manipulation, string trimming, standard library usage"}
{"seed": "// NewTokenContainsFold applies the ContainsFold predicate on the \"new_token\" field.\nfunc NewTokenContainsFold(v string) predicate.User {\n\treturn predicate.User(sql.FieldContainsFold(FieldNewToken, v))\n}", "id": 9390, "concepts": ["predicate.User", "sql.FieldContainsFold", "sql.FieldContainsFold usage"], "_raw_llm_output": "predicate.User, sql.FieldContainsFold, sql.FieldContainsFold usage"}
{"seed": "// OpenWithOptions opens and parse a AWS CloudFormation template from file.\n// Works with either JSON or YAML formatted templates.\n// Parsing can be tweaked via the specified options.\nfunc OpenWithOptions(filename string, options *intrinsics.ProcessorOptions) (*cloudformation.Template, error) {\n\n\tdata, err := ioutil.ReadFile(filename)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif strings.HasSuffix(filename, \".json\") {\n\t\t// This is definitely JSON\n\t\treturn ParseJSONWithOptions(data, options)\n\t}\n\n\treturn ParseYAMLWithOptions(data, options)\n}", "id": 9391, "concepts": ["ioutil.ReadFile", "string manipulation", "file handling", "JSON parsing", "YAML parsing", "struct definition", "function definition", "function call"], "_raw_llm_output": "ioutil.ReadFile, string manipulation, file handling, JSON parsing, YAML parsing, struct definition, function definition, function call"}
{"seed": "// IsTrue returns `true` if the condition with the given condition type is found among the conditions\n// and its status is set to `true`.\n// Returns false for unknown conditions and conditions with status set to False.\nfunc IsTrue(conditions []toolchainv1alpha1.Condition, conditionType toolchainv1alpha1.ConditionType) bool {\n\tc, found := FindConditionByType(conditions, conditionType)\n\treturn found && c.Status == apiv1.ConditionTrue\n}", "id": 9395, "concepts": ["interface", "slice", "map", "function definition", "function return value", "boolean comparison", "standard library usage"], "_raw_llm_output": "interface, slice, map, function definition, function return value, boolean comparison, standard library usage"}
{"seed": "// logoutExample shows examples in logout command, and is used in auto-generated cli docs.\nfunc logoutExample() string {\n\treturn `$ pouch logout $registry\nRemove login credential for registry: $registry`\n}", "id": 9397, "concepts": ["command line interface (CLI)", "command line argument handling", "command line usage"], "_raw_llm_output": "command line interface (CLI), command line argument handling, command line usage"}
{"seed": "// getGocqlErrorTag gets a error tag for metrics based on gocql error\n// We cannot just use err.Error() as a tag because it contains invalid\n// characters like = : etc. which will be rejected by M3\nfunc getGocqlErrorTag(err error) string {\n\tif yarpcerrors.IsAlreadyExists(err) {\n\t\treturn \"already_exists\"\n\t}\n\tif yarpcerrors.IsNotFound(err) {\n\t\treturn \"not_found\"\n\t}\n\tswitch err.(type) {\n\tcase *gocql.RequestErrReadFailure:\n\t\treturn \"read_failure\"\n\tcase *gocql.RequestErrWriteFailure:\n\t\treturn \"write_failure\"\n\tcase *gocql.RequestErrAlreadyExists:\n\t\treturn \"already_exists\"\n\tcase *gocql.RequestErrReadTimeout:\n\t\treturn \"read_timeout\"\n\tcase *gocql.RequestErrWriteTimeout:\n\t\treturn \"write_timeout\"\n\tcase *gocql.RequestErrUnavailable:\n\t\treturn \"unavailable\"\n\tcase *gocql.RequestErrFunctionFailure:\n\t\treturn \"function_failure\"\n\tcase *gocql.RequestErrUnprepared:\n\t\treturn \"unprepared\"\n\tdefault:\n\t\treturn \"unknown\"\n\t}\n}", "id": 9406, "concepts": ["error handling (type assertion)", "switch statement", "gocql package usage"], "_raw_llm_output": "error handling (type assertion), switch statement, gocql package usage"}
{"seed": "// filepathExists returns true if the passed \"filepath\" is a substring\n// of any of the passed full \"filepaths\"; false otherwise. For example:\n// if filepath = \"test/a.yaml\", and filepaths includes \"/tmp/test/a.yaml\",\n// this function returns true.\nfunc filepathExists(filepath string, filepaths []string) bool {\n\tfor _, fp := range filepaths {\n\t\tif strings.Contains(fp, filepath) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}", "id": 9422, "concepts": ["string manipulation", "string comparison", "string search"], "_raw_llm_output": "string manipulation, string comparison, string search"}
{"seed": "// IDIn applies the In predicate on the ID field.\nfunc IDIn(ids ...int) predicate.User {\n\treturn predicate.User(sql.FieldIn(FieldID, ids...))\n}", "id": 9434, "concepts": ["sql.FieldIn", "predicate.User", "sql.Field", "sql.Field"], "_raw_llm_output": "sql.FieldIn, predicate.User, sql.Field, sql.Field"}
{"seed": "// NewPostSecdefSearchParamsWithTimeout creates a new PostSecdefSearchParams object\n// with the default values initialized, and the ability to set a timeout on a request\nfunc NewPostSecdefSearchParamsWithTimeout(timeout time.Duration) *PostSecdefSearchParams {\n\tvar ()\n\treturn &PostSecdefSearchParams{\n\t\ttimeout: timeout,\n\t}\n}", "id": 9436, "concepts": ["struct definition", "struct initialization", "struct field assignment", "struct field access"], "_raw_llm_output": "struct definition, struct initialization, struct field assignment, struct field access"}
{"seed": "// wmRT07 covers resizable/tablet: immerse via API from maximized.\n// Expected behavior is defined in: go/arc-wm-r RT07: resizable/tablet: immerse via API from maximized.\nfunc wmRT07(ctx context.Context, tconn *chrome.TestConn, a *arc.ARC, d *ui.Device) error {\n\tacts := []wm.TabletLaunchActivityInfo{\n\t\twm.TabletLaunchActivityInfo{\n\t\t\tActivityName: wm.ResizableLandscapeActivity,\n\t\t\tDesiredDO:    display.OrientationLandscapePrimary,\n\t\t},\n\t\twm.TabletLaunchActivityInfo{\n\t\t\tActivityName: wm.ResizableUnspecifiedActivity,\n\t\t\tDesiredDO:    display.OrientationLandscapePrimary,\n\t\t},\n\t\twm.TabletLaunchActivityInfo{\n\t\t\tActivityName: wm.ResizablePortraitActivity,\n\t\t\tDesiredDO:    display.OrientationPortraitPrimary,\n\t\t},\n\t\twm.TabletLaunchActivityInfo{\n\t\t\tActivityName: wm.ResizableUnspecifiedActivity,\n\t\t\tDesiredDO:    display.OrientationPortraitPrimary,\n\t\t},\n\t}\n\n\treturn wm.TabletImmerseViaAPI(ctx, tconn, a, d, acts)\n}", "id": 9447, "concepts": ["ARC", "ARC API usage", "display orientation", "activity launching", "UI testing", "standard library usage"], "_raw_llm_output": "ARC, ARC API usage, display orientation, activity launching, UI testing, standard library usage"}
{"seed": "// ParseListAntiAffinityGroupsResponse parses an HTTP response from a ListAntiAffinityGroupsWithResponse call\nfunc ParseListAntiAffinityGroupsResponse(rsp *http.Response) (*ListAntiAffinityGroupsResponse, error) {\n\tbodyBytes, err := ioutil.ReadAll(rsp.Body)\n\tdefer rsp.Body.Close()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse := &ListAntiAffinityGroupsResponse{\n\t\tBody:         bodyBytes,\n\t\tHTTPResponse: rsp,\n\t}\n\n\tswitch {\n\tcase strings.Contains(rsp.Header.Get(\"Content-Type\"), \"json\") && rsp.StatusCode == 200:\n\t\tvar dest struct {\n\t\t\tAntiAffinityGroups *[]AntiAffinityGroup `json:\"anti-affinity-groups,omitempty\"`\n\t\t}\n\t\tif err := json.Unmarshal(bodyBytes, &dest); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresponse.JSON200 = &dest\n\n\t}\n\n\treturn response, nil\n}", "id": 9457, "concepts": ["HTTP response parsing", "JSON parsing", "error handling"], "_raw_llm_output": "HTTP response parsing, JSON parsing, error handling"}
{"seed": "// Base represents the HTML void element 'base'.\n// For more information visit https://www.w3schools.com/tags/tag_base.asp.\nfunc Base(attrs []htmlgo.Attribute) HTML {\n\treturn &htmlgo.Tree{Tag: \"base\", Attributes: attrs, SelfClosing: true}\n}", "id": 9461, "concepts": ["HTML generation", "HTML tree building", "HTML void element", "HTML attribute"], "_raw_llm_output": "HTML generation, HTML tree building, HTML void element, HTML attribute"}
{"seed": "// RefererHandler adds the request's referer as a field to the context's logger\n// using fieldKey as field key.\nfunc RefererHandler(fieldKey string) func(next httpserver.Handler) httpserver.Handler {\n\treturn func(next httpserver.Handler) httpserver.Handler {\n\t\treturn httpserver.HandlerFunc(func(w http.ResponseWriter, r *http.Request) (int, error) {\n\t\t\tif ref := r.Header.Get(\"Referer\"); ref != \"\" {\n\t\t\t\tlog := zerolog.Ctx(r.Context())\n\t\t\t\tlog.UpdateContext(func(c zerolog.Context) zerolog.Context {\n\t\t\t\t\treturn c.Str(fieldKey, ref)\n\t\t\t\t})\n\t\t\t}\n\t\t\treturn next.ServeHTTP(w, r)\n\t\t})\n\t}\n}", "id": 9470, "concepts": ["http server", "http.ResponseWriter", "http.Request", "context", "zerolog", "http.HandlerFunc", "http.Handler", "middleware"], "_raw_llm_output": "http server, http.ResponseWriter, http.Request, context, zerolog, http.HandlerFunc, http.Handler, middleware"}
{"seed": "// SocialTypeNEQ applies the NEQ predicate on the \"social_type\" field.\nfunc SocialTypeNEQ(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldSocialType), v))\n\t})\n}", "id": 9483, "concepts": ["sql package usage", "sql.Selector", "sql.NEQ", "sql.Where", "sql.C", "predicate.User", "anonymous function"], "_raw_llm_output": "sql package usage, sql.Selector, sql.NEQ, sql.Where, sql.C, predicate.User, anonymous function"}
{"seed": "// DnsTableColumns returns the columns that our table will return.\nfunc DnsTableColumns() []table.ColumnDefinition {\n\treturn []table.ColumnDefinition{\n\t\ttable.TextColumn(\"Time\"),\n\t\ttable.TextColumn(\"Name\"),\n\t\ttable.TextColumn(\"Type\"),\n\t\ttable.TextColumn(\"IP_CNAME\"),\n\t\ttable.TextColumn(\"Protocol\"),\n\t}\n}", "id": 9484, "concepts": ["table package usage", "table.ColumnDefinition", "table.TextColumn"], "_raw_llm_output": "table package usage, table.ColumnDefinition, table.TextColumn"}
{"seed": "// ValidateSelfSubjectAccessReviewSpec validates a SelfSubjectAccessReviewSpec and returns an\n// ErrorList with any errors.\nfunc ValidateSelfSubjectAccessReviewSpec(spec authorizationapi.SelfSubjectAccessReviewSpec, fldPath *field.Path) field.ErrorList {\n\tallErrs := field.ErrorList{}\n\tif spec.ResourceAttributes != nil && spec.NonResourceAttributes != nil {\n\t\tallErrs = append(allErrs, field.Invalid(fldPath.Child(\"nonResourceAttributes\"), spec.NonResourceAttributes, `cannot be specified in combination with resourceAttributes`))\n\t}\n\tif spec.ResourceAttributes == nil && spec.NonResourceAttributes == nil {\n\t\tallErrs = append(allErrs, field.Invalid(fldPath.Child(\"resourceAttributes\"), spec.NonResourceAttributes, `exactly one of nonResourceAttributes or resourceAttributes must be specified`))\n\t}\n\n\treturn allErrs\n}", "id": 9487, "concepts": ["field.ErrorList", "field.Invalid", "field.Path", "field.Error", "field.Child", "field.Invalid", "field.Invalid", "field.Invalid"], "_raw_llm_output": "field.ErrorList, field.Invalid, field.Path, field.Error, field.Child, field.Invalid, field.Invalid, field.Invalid"}
{"seed": "// Unmarshals configuration data from bytes into the provided interface, strictness is\n// enabled which returns an error in the case that an unknown field is provided.\nfunc unmarshalStrict(data []byte, out interface{}) error {\n\tdec := yaml.NewDecoder(bytes.NewReader(data))\n\tdec.KnownFields(true)\n\tif err := dec.Decode(out); err != nil && !errors.Is(err, io.EOF) {\n\t\treturn err\n\t}\n\treturn nil\n}", "id": 9491, "concepts": ["yaml package usage", "io.EOF", "errors.Is"], "_raw_llm_output": "yaml package usage, io.EOF, errors.Is"}
{"seed": "// SanitizeName cleans a stat or datapoint name to be representable in a wide\n// range of data collection software.\nfunc SanitizeName(name string) string {\n\trname := []byte(name)\n\tfor i, r := range rname {\n\t\tswitch {\n\t\tcase r >= 'A' && r <= 'Z':\n\t\tcase r >= 'a' && r <= 'z':\n\t\tcase r >= '0' && r <= '9':\n\t\tdefault:\n\t\t\tswitch r {\n\t\t\tcase '_', '.', '-':\n\t\t\tcase '/':\n\t\t\t\trname[i] = '.'\n\t\t\tdefault:\n\t\t\t\trname[i] = '_'\n\t\t\t}\n\t\t}\n\t}\n\treturn string(rname)\n}", "id": 9492, "concepts": ["string manipulation", "byte manipulation", "character comparison"], "_raw_llm_output": "string manipulation, byte manipulation, character comparison"}
{"seed": "// PrivateEndpointGenerator returns a generator of PrivateEndpoint instances for property testing.\nfunc PrivateEndpointGenerator() gopter.Gen {\n\tif privateEndpointGenerator != nil {\n\t\treturn privateEndpointGenerator\n\t}\n\n\tgenerators := make(map[string]gopter.Gen)\n\tAddRelatedPropertyGeneratorsForPrivateEndpoint(generators)\n\tprivateEndpointGenerator = gen.Struct(reflect.TypeOf(PrivateEndpoint{}), generators)\n\n\treturn privateEndpointGenerator\n}", "id": 9502, "concepts": ["reflection", "map", "struct", "anonymous function", "property testing"], "_raw_llm_output": "reflection, map, struct, anonymous function, property testing"}
{"seed": "// _escFSMustString is the string version of _escFSMustByte.\nfunc _escFSMustString(useLocal bool, name string) string {\n\treturn string(_escFSMustByte(useLocal, name))\n}", "id": 9503, "concepts": ["string manipulation", "byte handling"], "_raw_llm_output": "string manipulation, byte handling"}
{"seed": "// EmptyData returns an \"empty\" Data object with the given URL and error\nfunc EmptyData(url string, err error) Data {\n\treturn Data{\n\t\tURL: url,\n\t\tErr: err,\n\t}\n}", "id": 9524, "concepts": ["struct definition", "basic function definition"], "_raw_llm_output": "struct definition, basic function definition"}
{"seed": "// IsUserInProtectBranchWhitelist returns true if given user is in the whitelist of a branch in a repository.\nfunc IsUserInProtectBranchWhitelist(repoID, userID int64, branch string) bool {\n\thas, err := x.Where(\"repo_id = ?\", repoID).And(\"user_id = ?\", userID).And(\"name = ?\", branch).Get(new(ProtectBranchWhitelist))\n\treturn has && err == nil\n}", "id": 9527, "concepts": ["database query", "database query with condition", "database query with multiple conditions", "database query with multiple conditions and order by", "database query with multiple conditions and order by and limit", "database query with multiple conditions and order by and limit and return count", "database query with multiple conditions and order by and limit and return count and return bool", "database query with multiple conditions and order by and limit and return count and return bool and return struct", "database query with multiple conditions and order by and limit and return count and return bool and return struct and return error", "database query with multiple conditions and order by and limit and return count and return bool and return struct and return error and return bool", "database query with multiple conditions and order by and limit and return count and return bool and return struct and return error and return bool and return struct", "database query with multiple conditions and order by and limit and return count and return bool and return struct and return error and return bool and return struct and return error", "database query with multiple conditions and order by and limit and return count and return bool and return struct and return error and return bool and return struct and return error and return bool", "database query with multiple conditions and order by and limit and return count and return bool and return struct and return error and return bool"], "_raw_llm_output": "database query, database query with condition, database query with multiple conditions, database query with multiple conditions and order by, database query with multiple conditions and order by and limit, database query with multiple conditions and order by and limit and return count, database query with multiple conditions and order by and limit and return count and return bool, database query with multiple conditions and order by and limit and return count and return bool and return struct, database query with multiple conditions and order by and limit and return count and return bool and return struct and return error, database query with multiple conditions and order by and limit and return count and return bool and return struct and return error and return bool, database query with multiple conditions and order by and limit and return count and return bool and return struct and return error and return bool and return struct, database query with multiple conditions and order by and limit and return count and return bool and return struct and return error and return bool and return struct and return error, database query with multiple conditions and order by and limit and return count and return bool and return struct and return error and return bool and return struct and return error and return bool, database query with multiple conditions and order by and limit and return count and return bool and return struct and return error and return bool"}
{"seed": "// NameLTE applies the LTE predicate on the \"name\" field.\nfunc NameLTE(v string) predicate.User {\n\treturn predicate.User(sql.FieldLTE(FieldName, v))\n}", "id": 9533, "concepts": ["predicate.User", "sql.FieldLTE", "sql.FieldName"], "_raw_llm_output": "predicate.User, sql.FieldLTE, sql.FieldName"}
{"seed": "// ActiveEQ applies the EQ predicate on the \"active\" field.\nfunc ActiveEQ(v bool) predicate.User {\n\treturn predicate.User(sql.FieldEQ(FieldActive, v))\n}", "id": 9543, "concepts": ["predicate.User", "sql.FieldEQ", "sql.Field"], "_raw_llm_output": "predicate.User, sql.FieldEQ, sql.Field"}
{"seed": "// retryBuildConfig determines if the given error is caused by an invalid trigger\n// error on a BuildConfig. If that is the case, it will remove all triggers with a\n// type that is not in the whitelist for an older server.\nfunc retryBuildConfig(obj *unstructured.Unstructured, err error) *unstructured.Unstructured {\n\tif obj == nil {\n\t\treturn nil\n\t}\n\ttriggerTypeWhiteList := map[buildv1.BuildTriggerType]struct{}{\n\t\tbuildv1.GitHubWebHookBuildTriggerType:    {},\n\t\tbuildv1.GenericWebHookBuildTriggerType:   {},\n\t\tbuildv1.ImageChangeBuildTriggerType:      {},\n\t\tbuildv1.GitLabWebHookBuildTriggerType:    {},\n\t\tbuildv1.BitbucketWebHookBuildTriggerType: {},\n\t}\n\tif build.Kind(\"BuildConfig\") == obj.GroupVersionKind().GroupKind() && isInvalidTriggerError(err) {\n\t\tvar bc *buildv1.BuildConfig\n\t\terr := runtime.DefaultUnstructuredConverter.FromUnstructured(obj.Object, bc)\n\t\tif err != nil {\n\t\t\treturn nil\n\t\t}\n\n\t\ttriggers := []buildv1.BuildTriggerPolicy{}\n\t\tfor _, t := range bc.Spec.Triggers {\n\t\t\tif _, inList := triggerTypeWhiteList[t.Type]; inList {\n\t\t\t\ttriggers = append(triggers, t)\n\t\t\t}\n\t\t}\n\t\tbc.Spec.Triggers = triggers\n\n\t\tretUnstructured, err := runtime.DefaultUnstructuredConverter.ToUnstructured(bc)\n\t\tif err != nil {\n\t\t\treturn nil\n\t\t}\n\t\treturn &unstructured.Unstructured{Object: retUnstructured}\n\t}\n\treturn nil\n}", "id": 9545, "concepts": ["error handling (errors.As)", "struct comparison", "map iteration", "map lookup", "type assertion", "type conversion", "type switch", "standard library usage"], "_raw_llm_output": "error handling (errors.As), struct comparison, map iteration, map lookup, type assertion, type conversion, type switch, standard library usage"}
{"seed": "// Tokens returns a slice of tuples (token, key), where token is just key with\n// triple square brackets, and could also be constructed simply as\n// \"[[[\" + key + \"]]]\"\". The key is the lookup key for the Locales map. The\n// token is what must be replaced in the raw template.\nfunc Tokens(tmpl []byte) [][][]byte {\n\treturn keyRegExp.FindAllSubmatch(tmpl, -1)\n}", "id": 9548, "concepts": ["regular expression", "string manipulation", "string comparison"], "_raw_llm_output": "regular expression, string manipulation, string comparison"}
{"seed": "// PrivateLinkServiceConnection_STATUSGenerator returns a generator of PrivateLinkServiceConnection_STATUS instances for property testing.\n// We first initialize privateLinkServiceConnection_STATUSGenerator with a simplified generator based on the\n// fields with primitive types then replacing it with a more complex one that also handles complex fields\n// to ensure any cycles in the object graph properly terminate.\nfunc PrivateLinkServiceConnection_STATUSGenerator() gopter.Gen {\n\tif privateLinkServiceConnection_STATUSGenerator != nil {\n\t\treturn privateLinkServiceConnection_STATUSGenerator\n\t}\n\n\tgenerators := make(map[string]gopter.Gen)\n\tAddIndependentPropertyGeneratorsForPrivateLinkServiceConnection_STATUS(generators)\n\tprivateLinkServiceConnection_STATUSGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServiceConnection_STATUS{}), generators)\n\n\t// The above call to gen.Struct() captures the map, so create a new one\n\tgenerators = make(map[string]gopter.Gen)\n\tAddIndependentPropertyGeneratorsForPrivateLinkServiceConnection_STATUS(generators)\n\tAddRelatedPropertyGeneratorsForPrivateLinkServiceConnection_STATUS(generators)\n\tprivateLinkServiceConnection_STATUSGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServiceConnection_STATUS{}), generators)\n\n\treturn privateLinkServiceConnection_STATUSGenerator\n}", "id": 9559, "concepts": ["struct", "map", "reflect package usage", "property testing"], "_raw_llm_output": "struct, map, reflect package usage, property testing"}
{"seed": "// ReadRentableType reads a full RentableType structure of data from the database based on the supplied Row pointer.\nfunc ReadRentableType(row *sql.Row, a *RentableType) error {\n\terr := row.Scan(&a.RTID, &a.BID, &a.Style, &a.Name, &a.RentCycle, &a.Proration, &a.GSRPC, &a.ARID, &a.FLAGS, &a.CreateTS, &a.CreateBy, &a.LastModTime, &a.LastModBy)\n\tSkipSQLNoRowsError(&err)\n\treturn err\n}", "id": 9565, "concepts": ["sql.Row", "sql.Scan", "sql.ErrNoRows", "error handling", "sql package usage"], "_raw_llm_output": "sql.Row, sql.Scan, sql.ErrNoRows, error handling, sql package usage"}
{"seed": "// castCRegionKey convert C regionkey_t to GO TRegionKey.\nfunc castCRegionKey(rk C.regionkey_t) TRegionKey {\n\treturn TRegionKey{\n\t\tChrom:    uint8(rk.chrom),\n\t\tStartPos: uint32(rk.startpos),\n\t\tEndPos:   uint32(rk.endpos),\n\t\tStrand:   uint8(rk.strand),\n\t}\n}", "id": 9572, "concepts": ["C.regionkey_t", "GO TRegionKey", "C.uint8_t", "C.uint32_t", "C.uint8_t", "C.uint32_t", "C.uint8_t", "C.uint32_t", "C.uint8_t", "C.uint32_t", "C.uint8_t", "C.uint32_t", "C.uint8_t", "C.uint32_t", "C.uint8_t", "C.uint32_t", "C.uint8_t", "C.uint32_t", "C.uint8_t", "C.uint32_t", "C.uint8_t", "C.uint32_t", "C.uint8_t", "C.uint32_t", "C.uint8_t", "C.uint32_t", "C.uint8_t", "C.uint32_t", "C.uint8_t", "C.uint32_t", "C.uint8_t", "C.uint32_t", "C.uint8_t", "C.uint32_t", "C.uint"], "_raw_llm_output": "C.regionkey_t, GO TRegionKey, C.uint8_t, C.uint32_t, C.uint8_t, C.uint32_t, C.uint8_t, C.uint32_t, C.uint8_t, C.uint32_t, C.uint8_t, C.uint32_t, C.uint8_t, C.uint32_t, C.uint8_t, C.uint32_t, C.uint8_t, C.uint32_t, C.uint8_t, C.uint32_t, C.uint8_t, C.uint32_t, C.uint8_t, C.uint32_t, C.uint8_t, C.uint32_t, C.uint8_t, C.uint32_t, C.uint8_t, C.uint32_t, C.uint8_t, C.uint32_t, C.uint8_t, C.uint32_t, C.uint"}
{"seed": "// RequestIDHandler returns a handler setting a unique id to the request which can\n// be gathered using IDFromRequest(req). This generated id is added as a field to the\n// logger using the passed fieldKey as field name. The id is also added as a response\n// header if the headerName is not empty.\n//\n// The generated id is a URL safe base64 encoded mongo object-id-like unique id.\n// Mongo unique id generation algorithm has been selected as a trade-off between\n// size and ease of use: UUID is less space efficient and snowflake requires machine\n// configuration.\nfunc RequestIDHandler(fieldKey, headerName string) func(next httpserver.Handler) httpserver.Handler {\n\treturn func(next httpserver.Handler) httpserver.Handler {\n\t\treturn httpserver.HandlerFunc(func(w http.ResponseWriter, r *http.Request) (int, error) {\n\t\t\tctx := r.Context()\n\t\t\tid, err := IDFromRequest(r, headerName)\n\t\t\tif err != nil {\n\t\t\t\tid = xid.New()\n\t\t\t}\n\t\t\tif fieldKey != \"\" {\n\t\t\t\tlog := zerolog.Ctx(ctx)\n\t\t\t\tlog.UpdateContext(func(c zerolog.Context) zerolog.Context {\n\t\t\t\t\treturn c.Str(fieldKey, id.String())\n\t\t\t\t})\n\t\t\t}\n\t\t\tif headerName != \"\" {\n\t\t\t\tr.Header.Set(headerName, id.String())\n\t\t\t}\n\t\t\treturn next.ServeHTTP(w, r)\n\t\t})\n\t}\n}", "id": 9578, "concepts": ["http.ResponseWriter", "http.Request", "http.Handler", "httpserver.Handler", "httpserver.HandlerFunc", "context.Context", "zerolog.Context", "zerolog.UpdateContext", "zerolog.Str", "xid.New", "xid.String"], "_raw_llm_output": "http.ResponseWriter, http.Request, http.Handler, httpserver.Handler, httpserver.HandlerFunc, context.Context, zerolog.Context, zerolog.UpdateContext, zerolog.Str, xid.New, xid.String"}
{"seed": "// CreateTooManyGlobalAdminsAssignedToTenantAlertConfigurationFromDiscriminatorValue creates a new instance of the appropriate class based on discriminator value\nfunc CreateTooManyGlobalAdminsAssignedToTenantAlertConfigurationFromDiscriminatorValue(parseNode i878a80d2330e89d26896388a3f487eef27b0a0e6c010c493bf80be1452208f91.ParseNode)(i878a80d2330e89d26896388a3f487eef27b0a0e6c010c493bf80be1452208f91.Parsable, error) {\n    return NewTooManyGlobalAdminsAssignedToTenantAlertConfiguration(), nil\n}", "id": 9582, "concepts": ["interface implementation", "error handling (errors.As)", "type assertion"], "_raw_llm_output": "interface implementation, error handling (errors.As), type assertion"}
{"seed": "// IsInsufficientError checks if an error is the `InsufficientError` type.\nfunc IsInsufficientError(e error) bool {\n\t_, ok := e.(InsufficientError)\n\treturn ok\n}", "id": 9584, "concepts": ["type assertion", "type assertion (type switch)", "error type assertion"], "_raw_llm_output": "type assertion, type assertion (type switch), error type assertion"}
{"seed": "// ListenAndServeAsync starts an http server. The server will run until\n// Shutdown() or Close() is called, but this function will return once the\n// listening socket is established.  This means that when this function\n// returns, the server is immediately available for an http GET to be run\n// against it.\n//\n// Returns a non-nil error if the listening socket can't be established. Logs a\n// fatal error if the server dies for a reason besides ErrServerClosed. If the\n// server.Addr is set to :0, then after this function returns server.Addr will\n// contain the address and port which this server is listening on.\nfunc ListenAndServeAsync(server *http.Server) error {\n\t// Start listening synchronously.\n\tlistener, err := net.Listen(tcpNetwork.Value, server.Addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif strings.HasSuffix(server.Addr, \":0\") {\n\t\t// Allow :0 to select a random port, and then update the server with the\n\t\t// selected port and address.  This is very useful for unit tests.\n\t\tserver.Addr = listener.Addr().String()\n\t}\n\t// Serve asynchronously.\n\tgo serve(server, tcpKeepAliveListener{listener.(*net.TCPListener)})\n\treturn nil\n}", "id": 9589, "concepts": ["net/http package usage", "net/net package usage", "anonymous function", "concurrency", "standard library usage"], "_raw_llm_output": "net/http package usage, net/net package usage, anonymous function, concurrency, standard library usage"}
{"seed": "// parseVisibility converts a visibility string to a build label.\n// Mostly they are just build labels but other things are allowed too (e.g. \"PUBLIC\").\nfunc parseVisibility(s *scope, vis string) core.BuildLabel {\n\tif vis == \"PUBLIC\" || (s.state.Config.Bazel.Compatibility && vis == \"//visibility:public\") {\n\t\treturn core.WholeGraph[0]\n\t}\n\tl := s.parseLabelInPackage(vis, s.pkg)\n\tif s.state.Config.Bazel.Compatibility {\n\t\t// Bazel has a couple of special aliases for this stuff.\n\t\tif l.Name == \"__pkg__\" {\n\t\t\tl.Name = \"all\"\n\t\t} else if l.Name == \"__subpackages__\" {\n\t\t\tl.Name = \"...\"\n\t\t}\n\t}\n\treturn l\n}", "id": 9592, "concepts": ["string parsing", "string manipulation", "label parsing", "label definition", "label usage", "string comparison", "string equality", "string concatenation", "string formatting", "string conversion", "string to integer", "string to boolean", "string to rune", "string to float", "string to complex", "string to time", "string to duration", "string to slice", "string to map", "string to struct", "string to interface", "string to channel", "string to pointer", "string to function", "string to error", "string to regexp", "string to bytes", "string to runes", "string to rune slice", "string to rune array", "string to rune map", "string to rune struct", "string to rune interface", "string to rune channel", "string to rune pointer", "string to rune function", "string to rune error", "string to rune regexp", "string to rune bytes", "string to rune runes", "string to rune rune slice", "string to rune rune array", "string to rune rune map", "string to rune rune struct", "string to rune rune interface", "string to rune rune channel", "string to rune rune pointer", "string to rune rune function", "string to rune rune error", "string to rune run"], "_raw_llm_output": "string parsing, string manipulation, label parsing, label definition, label usage, string comparison, string equality, string concatenation, string formatting, string conversion, string to integer, string to boolean, string to rune, string to float, string to complex, string to time, string to duration, string to slice, string to map, string to struct, string to interface, string to channel, string to pointer, string to function, string to error, string to regexp, string to bytes, string to runes, string to rune slice, string to rune array, string to rune map, string to rune struct, string to rune interface, string to rune channel, string to rune pointer, string to rune function, string to rune error, string to rune regexp, string to rune bytes, string to rune runes, string to rune rune slice, string to rune rune array, string to rune rune map, string to rune rune struct, string to rune rune interface, string to rune rune channel, string to rune rune pointer, string to rune rune function, string to rune rune error, string to rune run"}
{"seed": "// BetterHeroScoreAtNotNil applies the NotNil predicate on the \"better_hero_score_at\" field.\nfunc BetterHeroScoreAtNotNil() predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.NotNull(s.C(FieldBetterHeroScoreAt)))\n\t})\n}", "id": 9613, "concepts": ["sql.Selector", "sql.NotNull", "sql.C", "sql.Where", "sql.Predicate", "sql.Field", "sql.And", "sql.Or", "sql.Not", "sql.IsNull", "sql.NotEq", "sql.Eq", "sql.Gt", "sql.Lt", "sql.Gte", "sql.Lte", "sql.IsNull", "sql.NotEq", "sql.Eq", "sql.Gt", "sql.Lt", "sql.Gte", "sql.Lte", "sql.IsNull", "sql.NotEq", "sql.Eq", "sql.Gt", "sql.Lt", "sql.Gte", "sql.Lte", "sql.IsNull", "sql.NotEq", "sql.Eq", "sql.Gt", "sql.Lt", "sql.Gte", "sql.Lte", "sql.IsNull", "sql.NotEq", "sql.Eq", "sql.Gt", "sql.Lt", "sql.Gte", "sql.Lte", "sql.IsNull", "sql.NotEq", "sql.Eq", "sql.Gt", "sql.Lt", "sql.Gte", "sql.Lte", "sql.IsNull", "sql.NotEq", "sql.Eq", "sql.Gt", "sql.Lt", "sql.Gte", "sql.Lte", "sql."], "_raw_llm_output": "sql.Selector, sql.NotNull, sql.C, sql.Where, sql.Predicate, sql.Field, sql.And, sql.Or, sql.Not, sql.IsNull, sql.NotEq, sql.Eq, sql.Gt, sql.Lt, sql.Gte, sql.Lte, sql.IsNull, sql.NotEq, sql.Eq, sql.Gt, sql.Lt, sql.Gte, sql.Lte, sql.IsNull, sql.NotEq, sql.Eq, sql.Gt, sql.Lt, sql.Gte, sql.Lte, sql.IsNull, sql.NotEq, sql.Eq, sql.Gt, sql.Lt, sql.Gte, sql.Lte, sql.IsNull, sql.NotEq, sql.Eq, sql.Gt, sql.Lt, sql.Gte, sql.Lte, sql.IsNull, sql.NotEq, sql.Eq, sql.Gt, sql.Lt, sql.Gte, sql.Lte, sql.IsNull, sql.NotEq, sql.Eq, sql.Gt, sql.Lt, sql.Gte, sql.Lte, sql."}
{"seed": "// FromBig is a convenience-constructor from big.Int.\n// returns a new Int and whether overflow occurred\nfunc FromBig(int *big.Int) (*Int, bool) {\n\t// Let's not ruin the argument\n\tz := &Int{}\n\toverflow := z.SetFromBig(int)\n\treturn z, overflow\n}", "id": 9619, "concepts": ["big.Int", "big.Int.SetFromBig", "big.Int.Set", "big.Int.SetInt64", "big.Int.SetUint64", "big.Int.SetBytes", "big.Int.SetBytes", "big.Int.SetBytes", "big.Int.SetBytes", "big.Int.SetBytes", "big.Int.SetBytes", "big.Int.SetBytes", "big.Int.SetBytes", "big.Int.SetBytes", "big.Int.SetBytes", "big.Int.SetBytes", "big.Int.SetBytes", "big.Int.SetBytes", "big.Int.SetBytes", "big.Int.SetBytes", "big.Int.SetBytes", "big.Int.SetBytes", "big.Int.SetBytes", "big.Int.SetBytes", "big.Int.SetBytes", "big.Int.SetBytes", "big.Int.SetBytes", "big.Int.SetBytes", "big.Int.SetBytes", "big.Int.SetBytes", "big.Int.SetBytes", "big.Int.SetBytes", "big.Int.SetBytes", "big.Int.SetBytes", "big.Int.SetBytes", "big.Int.SetBytes", "big."], "_raw_llm_output": "big.Int, big.Int.SetFromBig, big.Int.Set, big.Int.SetInt64, big.Int.SetUint64, big.Int.SetBytes, big.Int.SetBytes, big.Int.SetBytes, big.Int.SetBytes, big.Int.SetBytes, big.Int.SetBytes, big.Int.SetBytes, big.Int.SetBytes, big.Int.SetBytes, big.Int.SetBytes, big.Int.SetBytes, big.Int.SetBytes, big.Int.SetBytes, big.Int.SetBytes, big.Int.SetBytes, big.Int.SetBytes, big.Int.SetBytes, big.Int.SetBytes, big.Int.SetBytes, big.Int.SetBytes, big.Int.SetBytes, big.Int.SetBytes, big.Int.SetBytes, big.Int.SetBytes, big.Int.SetBytes, big.Int.SetBytes, big.Int.SetBytes, big.Int.SetBytes, big.Int.SetBytes, big.Int.SetBytes, big.Int.SetBytes, big."}
{"seed": "// DescriptionLT applies the LT predicate on the \"description\" field.\nfunc DescriptionLT(v string) predicate.User {\n\treturn predicate.User(sql.FieldLT(FieldDescription, v))\n}", "id": 9634, "concepts": ["sql.FieldLT", "sql.FieldGT", "sql.FieldEQ", "sql.FieldNE", "sql.FieldIN", "sql.FieldNotIn", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldIs", "sql.FieldIsNot", "sql.FieldIsNull", "sql.FieldIsNotNull", "sql.FieldContains", "sql.FieldNotContains", "sql.FieldStartsWith", "sql.FieldNotStartsWith", "sql.FieldEndsWith", "sql.FieldNotEndsWith", "sql.FieldContainsAny", "sql.FieldNotContainsAny", "sql.FieldContainsAll", "sql.FieldNotContainsAll", "sql.FieldContainsAll", "sql.FieldNotContainsAll", "sql.FieldContainsAll", "sql.FieldNotContainsAll", "sql.FieldContainsAll", "sql.FieldNotContainsAll", "sql.FieldContainsAll", "sql.FieldNotContainsAll", "sql.FieldContainsAll", "sql.FieldNotContainsAll", "sql.FieldContainsAll", "sql.FieldNotContainsAll", "sql.FieldContainsAll", "sql.FieldNotContainsAll", "sql.FieldContainsAll", "sql.FieldNotContainsAll", "sql.FieldContainsAll", "sql.FieldNotContainsAll", "sql.FieldContainsAll", "sql.FieldNotContainsAll", "sql.FieldContainsAll"], "_raw_llm_output": "sql.FieldLT, sql.FieldGT, sql.FieldEQ, sql.FieldNE, sql.FieldIN, sql.FieldNotIn, sql.FieldLike, sql.FieldNotLike, sql.FieldIs, sql.FieldIsNot, sql.FieldIsNull, sql.FieldIsNotNull, sql.FieldContains, sql.FieldNotContains, sql.FieldStartsWith, sql.FieldNotStartsWith, sql.FieldEndsWith, sql.FieldNotEndsWith, sql.FieldContainsAny, sql.FieldNotContainsAny, sql.FieldContainsAll, sql.FieldNotContainsAll, sql.FieldContainsAll, sql.FieldNotContainsAll, sql.FieldContainsAll, sql.FieldNotContainsAll, sql.FieldContainsAll, sql.FieldNotContainsAll, sql.FieldContainsAll, sql.FieldNotContainsAll, sql.FieldContainsAll, sql.FieldNotContainsAll, sql.FieldContainsAll, sql.FieldNotContainsAll, sql.FieldContainsAll, sql.FieldNotContainsAll, sql.FieldContainsAll, sql.FieldNotContainsAll, sql.FieldContainsAll, sql.FieldNotContainsAll, sql.FieldContainsAll, sql.FieldNotContainsAll, sql.FieldContainsAll"}
{"seed": "// MSEDataFiles returns a list of required files for tests that play MSE videos.\nfunc MSEDataFiles() []string {\n\treturn []string{\n\t\t\"shaka.html\",\n\t\t\"third_party/shaka-player/shaka-player.compiled.debug.js\",\n\t\t\"third_party/shaka-player/shaka-player.compiled.debug.map\",\n\t}\n}", "id": 9640, "concepts": ["slice", "basic function definition"], "_raw_llm_output": "slice, basic function definition"}
{"seed": "// NewDeclineCurrentUserInviteNoContent creates a DeclineCurrentUserInviteNoContent with default headers values\nfunc NewDeclineCurrentUserInviteNoContent() *DeclineCurrentUserInviteNoContent {\n\treturn &DeclineCurrentUserInviteNoContent{}\n}", "id": 9641, "concepts": ["struct definition", "struct field definition", "struct field initialization", "struct field access", "struct field assignment", "struct field type conversion", "struct field pointer access", "struct field pointer assignment", "struct field pointer type conversion", "struct field pointer nil check", "struct field pointer nil check with nil value assignment", "struct field pointer nil check with nil value assignment with nil value assignment", "struct field pointer nil check with nil value assignment with nil value assignment with nil value assignment", "struct field pointer nil check with nil value assignment with nil value assignment with nil value assignment with nil value assignment", "struct field pointer nil check with nil value assignment with nil value assignment with nil value assignment with nil value assignment with nil value assignment", "struct field pointer nil check with nil value assignment with nil value assignment with nil value assignment with nil value assignment with nil value assignment with nil value assignment", "struct field pointer nil check with nil value assignment with nil value assignment with nil value assignment with nil value assignment with nil value assignment with nil value assignment with nil value assignment", "struct field pointer nil check with nil value assignment with nil value assignment with nil value assignment with nil value assignment with nil value assignment with nil value assignment with nil value assignment with nil value assignment", "struct field pointer nil check with nil value assignment with nil value assignment with nil value assignment"], "_raw_llm_output": "struct definition, struct field definition, struct field initialization, struct field access, struct field assignment, struct field type conversion, struct field pointer access, struct field pointer assignment, struct field pointer type conversion, struct field pointer nil check, struct field pointer nil check with nil value assignment, struct field pointer nil check with nil value assignment with nil value assignment, struct field pointer nil check with nil value assignment with nil value assignment with nil value assignment, struct field pointer nil check with nil value assignment with nil value assignment with nil value assignment with nil value assignment, struct field pointer nil check with nil value assignment with nil value assignment with nil value assignment with nil value assignment with nil value assignment, struct field pointer nil check with nil value assignment with nil value assignment with nil value assignment with nil value assignment with nil value assignment with nil value assignment, struct field pointer nil check with nil value assignment with nil value assignment with nil value assignment with nil value assignment with nil value assignment with nil value assignment with nil value assignment, struct field pointer nil check with nil value assignment with nil value assignment with nil value assignment with nil value assignment with nil value assignment with nil value assignment with nil value assignment with nil value assignment, struct field pointer nil check with nil value assignment with nil value assignment with nil value assignment"}
{"seed": "// toSliceType returns the element type of the given object, if the object is a\n// \"*[]*Element\" or \"*[]Element\". If not, returns nil.\n// err is returned if the user was trying to pass a pointer-to-slice but failed.\nfunc toSliceType(i interface{}) (reflect.Type, error) {\n\tt := reflect.TypeOf(i)\n\tif t.Kind() != reflect.Ptr {\n\t\t// If it's a slice, return a more helpful error message\n\t\tif t.Kind() == reflect.Slice {\n\t\t\treturn nil, fmt.Errorf(\"database_template: Cannot SELECT into a non-pointer slice: %v\", t)\n\t\t}\n\t\treturn nil, nil\n\t}\n\tif t = t.Elem(); t.Kind() != reflect.Slice {\n\t\treturn nil, nil\n\t}\n\treturn t.Elem(), nil\n}", "id": 9650, "concepts": ["reflect package usage", "pointer handling", "type conversion"], "_raw_llm_output": "reflect package usage, pointer handling, type conversion"}
{"seed": "// NewDataExportQuery instantiates a new DataExportQuery object\n// This constructor will assign default values to properties that have it defined,\n// and makes sure properties required by API are set, but the set of arguments\n// will change when the set of required properties is changed\nfunc NewDataExportQuery() *DataExportQuery {\n\tthis := DataExportQuery{}\n\treturn &this\n}", "id": 9665, "concepts": ["constructor", "basic function definition", "struct definition", "struct initialization"], "_raw_llm_output": "constructor, basic function definition, struct definition, struct initialization"}
{"seed": "// IsCRD returns true if the passed Unstructured object has\n// GroupKind == Extensions/CustomResourceDefinition; false otherwise.\nfunc IsCRD(u *unstructured.Unstructured) bool {\n\tif u == nil {\n\t\treturn false\n\t}\n\tgvk := u.GroupVersionKind()\n\treturn ExtensionsCRD == gvk.GroupKind()\n}", "id": 9674, "concepts": ["unstructured.Unstructured", "GroupKind", "GroupVersionKind", "type assertion"], "_raw_llm_output": "unstructured.Unstructured, GroupKind, GroupVersionKind, type assertion"}
{"seed": "// NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded_ARMGenerator returns a generator of NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded_ARM instances for property testing.\n// We first initialize networkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded_ARMGenerator with a simplified generator based on the\n// fields with primitive types then replacing it with a more complex one that also handles complex fields\n// to ensure any cycles in the object graph properly terminate.\nfunc NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded_ARMGenerator() gopter.Gen {\n\tif networkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded_ARMGenerator != nil {\n\t\treturn networkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded_ARMGenerator\n\t}\n\n\tgenerators := make(map[string]gopter.Gen)\n\tAddIndependentPropertyGeneratorsForNetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded_ARM(generators)\n\tnetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded_ARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded_ARM{}), generators)\n\n\t// The above call to gen.Struct() captures the map, so create a new one\n\tgenerators = make(map[string]gopter.Gen)\n\tAddIndependentPropertyGeneratorsForNetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded_ARM(generators)\n\tAddRelatedPropertyGeneratorsForNetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded_ARM(generators)\n\tnetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded_ARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded_ARM{}), generators)\n\n\treturn networkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded_ARMGenerator\n}", "id": 9680, "concepts": ["struct definition", "anonymous struct definition", "interface definition", "generator definition", "generator usage", "property definition", "property usage", "property generation", "property testing", "property testing with generator", "property testing with generator and property generation", "property testing with generator and property generation and property usage"], "_raw_llm_output": "struct definition, anonymous struct definition, interface definition, generator definition, generator usage, property definition, property usage, property generation, property testing, property testing with generator, property testing with generator and property generation, property testing with generator and property generation and property usage"}
{"seed": "// ExecForm format instruction arguments to an exec form, like [\"/bin/bash\"]\nfunc ExecForm(node *parser.Node) (arguments string) {\n\ttmp := []string{}\n\n\tfor n := node.Next; n != nil; n = n.Next {\n\t\tvalue := n.Value\n\t\tif strings.HasPrefix(n.Value, `\"`) && strings.HasSuffix(n.Value, `\"`) {\n\t\t\tvalue = strings.TrimPrefix(value, `\"`)\n\t\t\tvalue = strings.TrimSuffix(value, `\"`)\n\t\t}\n\t\ttmp = append(tmp, `\"`+strings.ReplaceAll(value, `\"`, `\\\"`)+`\"`)\n\t}\n\n\targuments = `[ ` + strings.Join(tmp, `,`) + ` ]`\n\n\tif len(node.Flags) > 0 {\n\t\targuments = fmt.Sprintf(\"%s %s\", strings.Join(node.Flags, \" \"), arguments)\n\t}\n\n\treturn arguments + \"\\n\"\n}", "id": 9697, "concepts": ["string manipulation", "string formatting", "string joining", "string splitting", "string trimming", "string escaping", "string concatenation", "string comparison", "string length", "string prefix/suffix check", "string regular expression matching", "string regular expression substitution"], "_raw_llm_output": "string manipulation, string formatting, string joining, string splitting, string trimming, string escaping, string concatenation, string comparison, string length, string prefix/suffix check, string regular expression matching, string regular expression substitution"}
{"seed": "// BulkCreditSamedayFeeNotNil applies the NotNil predicate on the \"bulkCreditSamedayFee\" field.\nfunc BulkCreditSamedayFeeNotNil() predicate.Bulk {\n\treturn predicate.Bulk(func(s *sql.Selector) {\n\t\ts.Where(sql.NotNull(s.C(FieldBulkCreditSamedayFee)))\n\t})\n}", "id": 9720, "concepts": ["sql.Selector", "sql.NotNull", "sql.C", "sql.Where", "sql.Bulk", "sql.Predicate", "sql.Field", "sql.Selector.C", "sql.Selector.Where", "sql.Selector.Where.sql.NotNull", "sql.Selector.Where.sql.C", "sql.Selector.Where.sql.Where", "sql.Selector.Where.sql.Where.sql.C", "sql.Selector.Where.sql.Where.sql.Where", "sql.Selector.Where.sql.Where.sql.Where.sql.C", "sql.Selector.Where.sql.Where.sql.Where.sql.Where", "sql.Selector.Where.sql.Where.sql.Where.sql.Where.sql.C", "sql.Selector.Where.sql.Where.sql.Where.sql.Where.sql.Where", "sql.Selector.Where.sql.Where.sql.Where.sql.Where.sql.Where.sql.C", "sql.Selector.Where.sql.Where.sql.Where.sql.Where.sql.Where.sql.Where", "sql.Selector.Where.sql.Where.sql.Where.sql.Where.sql.Where.sql.Where"], "_raw_llm_output": "sql.Selector, sql.NotNull, sql.C, sql.Where, sql.Bulk, sql.Predicate, sql.Field, sql.Selector.C, sql.Selector.Where, sql.Selector.Where.sql.NotNull, sql.Selector.Where.sql.C, sql.Selector.Where.sql.Where, sql.Selector.Where.sql.Where.sql.C, sql.Selector.Where.sql.Where.sql.Where, sql.Selector.Where.sql.Where.sql.Where.sql.C, sql.Selector.Where.sql.Where.sql.Where.sql.Where, sql.Selector.Where.sql.Where.sql.Where.sql.Where.sql.C, sql.Selector.Where.sql.Where.sql.Where.sql.Where.sql.Where, sql.Selector.Where.sql.Where.sql.Where.sql.Where.sql.Where.sql.C, sql.Selector.Where.sql.Where.sql.Where.sql.Where.sql.Where.sql.Where, sql.Selector.Where.sql.Where.sql.Where.sql.Where.sql.Where.sql.Where"}
{"seed": "// DropOptionalEqualFold applies the EqualFold predicate on the \"drop_optional\" field.\nfunc DropOptionalEqualFold(v string) predicate.User {\n\treturn predicate.User(sql.FieldEqualFold(FieldDropOptional, v))\n}", "id": 9726, "concepts": ["sql.FieldEqualFold", "predicate.User", "predicate.FieldEqualFold"], "_raw_llm_output": "sql.FieldEqualFold, predicate.User, predicate.FieldEqualFold"}
{"seed": "// Input_ is a convenience wrapper for Input without the attrs argument.\nfunc Input_() HTML {\n  return Input(nil)\n}", "id": 9730, "concepts": ["HTML tag definition", "function definition", "function call", "function return"], "_raw_llm_output": "HTML tag definition, function definition, function call, function return"}
{"seed": "// NewGetStoresParams creates a new GetStoresParams object\n// with the default values initialized.\nfunc NewGetStoresParams() *GetStoresParams {\n\tvar ()\n\treturn &GetStoresParams{\n\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 9734, "concepts": ["struct definition", "struct initialization", "default values"], "_raw_llm_output": "struct definition, struct initialization, default values"}
{"seed": "// DropOptionalEQ applies the EQ predicate on the \"drop_optional\" field.\nfunc DropOptionalEQ(v string) predicate.User {\n\treturn predicate.User(sql.FieldEQ(FieldDropOptional, v))\n}", "id": 9735, "concepts": ["sql package usage", "predicate definition"], "_raw_llm_output": "sql package usage, predicate definition"}
{"seed": "// NewPostDockerRegistriesUUIDSearchListParamsWithTimeout creates a new PostDockerRegistriesUUIDSearchListParams object\n// with the default values initialized, and the ability to set a timeout on a request\nfunc NewPostDockerRegistriesUUIDSearchListParamsWithTimeout(timeout time.Duration) *PostDockerRegistriesUUIDSearchListParams {\n\tvar ()\n\treturn &PostDockerRegistriesUUIDSearchListParams{\n\n\t\ttimeout: timeout,\n\t}\n}", "id": 9736, "concepts": ["struct definition", "struct initialization", "struct field initialization", "struct field assignment", "struct field access", "struct field pointer access", "struct field pointer assignment", "struct field pointer access", "struct field pointer assignment", "struct field pointer access", "struct field pointer assignment", "struct field pointer access", "struct field pointer assignment", "struct field pointer access", "struct field pointer assignment", "struct field pointer access", "struct field pointer assignment", "struct field pointer access", "struct field pointer assignment", "struct field pointer access", "struct field pointer assignment", "struct field pointer access", "struct field pointer assignment", "struct field pointer access", "struct field pointer assignment", "struct field pointer access", "struct field pointer assignment", "struct field pointer access", "struct field pointer assignment", "struct field pointer access", "struct field pointer assignment", "struct field pointer access", "struct field pointer assignment", "struct field pointer access", "struct field pointer assignment", "struct field pointer access", "struct field pointer assignment", "struct field pointer access", "struct field pointer assignment", "struct field pointer access", "struct field pointer assignment", "struct field pointer access", "struct field pointer assignment", "struct field pointer access", "struct field pointer assignment", "struct field pointer access", "struct field pointer assignment", "struct field pointer access", "struct field pointer assignment", "struct field pointer access", "struct field pointer assignment", "struct field pointer access", "struct field"], "_raw_llm_output": "struct definition, struct initialization, struct field initialization, struct field assignment, struct field access, struct field pointer access, struct field pointer assignment, struct field pointer access, struct field pointer assignment, struct field pointer access, struct field pointer assignment, struct field pointer access, struct field pointer assignment, struct field pointer access, struct field pointer assignment, struct field pointer access, struct field pointer assignment, struct field pointer access, struct field pointer assignment, struct field pointer access, struct field pointer assignment, struct field pointer access, struct field pointer assignment, struct field pointer access, struct field pointer assignment, struct field pointer access, struct field pointer assignment, struct field pointer access, struct field pointer assignment, struct field pointer access, struct field pointer assignment, struct field pointer access, struct field pointer assignment, struct field pointer access, struct field pointer assignment, struct field pointer access, struct field pointer assignment, struct field pointer access, struct field pointer assignment, struct field pointer access, struct field pointer assignment, struct field pointer access, struct field pointer assignment, struct field pointer access, struct field pointer assignment, struct field pointer access, struct field pointer assignment, struct field pointer access, struct field pointer assignment, struct field pointer access, struct field pointer assignment, struct field pointer access, struct field"}
{"seed": "// Creates and returns a new Art Tree with a nil root and a size of 0.\nfunc NewArtTree() *ArtTree {\n\treturn &ArtTree{root: nil, size: 0}\n}", "id": 9737, "concepts": ["struct definition", "struct field access", "basic function definition"], "_raw_llm_output": "struct definition, struct field access, basic function definition"}
{"seed": "// Param_ is a convenience wrapper for Param without the attrs argument.\nfunc Param_() HTML {\n  return Param(nil)\n}", "id": 9742, "concepts": ["HTML tag definition", "HTML tag attribute definition", "HTML tag attribute value definition", "HTML tag attribute value definition"], "_raw_llm_output": "HTML tag definition, HTML tag attribute definition, HTML tag attribute value definition, HTML tag attribute value definition"}
{"seed": "// ----------------------------------------------------------------------------\n// Helpers\n// ----------------------------------------------------------------------------\n\n// cleanPath returns the canonical path for p, eliminating . and .. elements.\n// Borrowed from the net/http package.\nfunc cleanPath(p string) string {\n\tif p == \"\" {\n\t\treturn \"/\"\n\t}\n\tif p[0] != '/' {\n\t\tp = \"/\" + p\n\t}\n\tnp := path.Clean(p)\n\t// path.Clean removes trailing slash except for root;\n\t// put the trailing slash back if necessary.\n\tif p[len(p)-1] == '/' && np != \"/\" {\n\t\tnp += \"/\"\n\t}\n\treturn np\n}", "id": 9746, "concepts": ["path manipulation", "path.Clean", "string manipulation"], "_raw_llm_output": "path manipulation, path.Clean, string manipulation"}
{"seed": "// NewKubernetesEthernetMatcherWithDefaults instantiates a new KubernetesEthernetMatcher object\n// This constructor will only assign default values to properties that have it defined,\n// but it doesn't guarantee that properties required by API are set\nfunc NewKubernetesEthernetMatcherWithDefaults() *KubernetesEthernetMatcher {\n\tthis := KubernetesEthernetMatcher{}\n\tvar classId string = \"kubernetes.EthernetMatcher\"\n\tthis.ClassId = classId\n\tvar objectType string = \"kubernetes.EthernetMatcher\"\n\tthis.ObjectType = objectType\n\tvar type_ string = \"Name\"\n\tthis.Type = &type_\n\treturn &this\n}", "id": 9752, "concepts": ["constructor", "default value assignment", "pointer dereference"], "_raw_llm_output": "constructor, default value assignment, pointer dereference"}
{"seed": "// isStablePlan checks whether the given plan is a stable or evolving plan\n// by checking the partition-node assignments of partitions belonging to\n// each of the indexes. If all the partitions belonging to an index is having\n// same exact node assignments count, then the partition assignment is considered\n// stable for that index. If all the indexes in a plan is having stable node,\n// assignments then that plan is considered stable and can be stored for recovery.\nfunc isStablePlan(planPIndexes *PlanPIndexes) bool {\n\tif planPIndexes == nil || planPIndexes.PlanPIndexes == nil {\n\t\treturn false\n\t}\n\t// group planPIndexes per index.\n\tplanPIndexesPerIndex := make(map[string][]*PlanPIndex)\n\tfor _, pi := range planPIndexes.PlanPIndexes {\n\t\tplanPIndexesPerIndex[pi.IndexName] = append(\n\t\t\tplanPIndexesPerIndex[pi.IndexName], pi)\n\t}\n\n\t// consider partitions per index.\n\tfor _, planPIndexes := range planPIndexesPerIndex {\n\t\t// check whether all the index partitions are having same number of\n\t\t// node assignments.\n\t\tnodeCount := -1\n\t\tfor _, p := range planPIndexes {\n\t\t\tif nodeCount == -1 {\n\t\t\t\tnodeCount = len(p.Nodes)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif len(p.Nodes) != nodeCount {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\treturn true\n}", "id": 9762, "concepts": ["map iteration", "map value iteration", "map key iteration", "map value iteration", "map key iteration", "map value iteration", "map key iteration", "map value iteration", "map key iteration", "map value iteration", "map key iteration", "map value iteration", "map key iteration", "map value iteration", "map key iteration", "map value iteration", "map key iteration", "map value iteration", "map key iteration", "map value iteration", "map key iteration", "map value iteration", "map key iteration", "map value iteration", "map key iteration", "map value iteration", "map key iteration", "map value iteration", "map key iteration", "map value iteration", "map key iteration", "map value iteration", "map key iteration", "map value iteration", "map key iteration", "map value iteration", "map key iteration", "map value iteration", "map key iteration", "map value iteration", "map key iteration", "map value iteration", "map key iteration", "map value iteration", "map key iteration", "map value iteration", "map key iteration", "map value iteration", "map key iteration", "map value iteration", "map key iteration", "map value iteration", "map key iteration", "map value iteration", "map key iteration", "map value iteration", "map key iteration", "map value iteration", "map key iteration", "map value iteration", "map key iteration", "map value iteration", "map key iteration", "map value iteration", ""], "_raw_llm_output": "map iteration, map value iteration, map key iteration, map value iteration, map key iteration, map value iteration, map key iteration, map value iteration, map key iteration, map value iteration, map key iteration, map value iteration, map key iteration, map value iteration, map key iteration, map value iteration, map key iteration, map value iteration, map key iteration, map value iteration, map key iteration, map value iteration, map key iteration, map value iteration, map key iteration, map value iteration, map key iteration, map value iteration, map key iteration, map value iteration, map key iteration, map value iteration, map key iteration, map value iteration, map key iteration, map value iteration, map key iteration, map value iteration, map key iteration, map value iteration, map key iteration, map value iteration, map key iteration, map value iteration, map key iteration, map value iteration, map key iteration, map value iteration, map key iteration, map value iteration, map key iteration, map value iteration, map key iteration, map value iteration, map key iteration, map value iteration, map key iteration, map value iteration, map key iteration, map value iteration, map key iteration, map value iteration, map key iteration, map value iteration,"}
{"seed": "// GetSearchSoftwareSourceModulesDetailsSortOrderEnumValues Enumerates the set of values for SearchSoftwareSourceModulesDetailsSortOrderEnum\nfunc GetSearchSoftwareSourceModulesDetailsSortOrderEnumValues() []SearchSoftwareSourceModulesDetailsSortOrderEnum {\n\tvalues := make([]SearchSoftwareSourceModulesDetailsSortOrderEnum, 0)\n\tfor _, v := range mappingSearchSoftwareSourceModulesDetailsSortOrderEnum {\n\t\tvalues = append(values, v)\n\t}\n\treturn values\n}", "id": 9763, "concepts": ["enumerations", "mapping", "standard library usage"], "_raw_llm_output": "enumerations, mapping, standard library usage"}
{"seed": "// StringValue returns a Value holding the given arg.\nfunc StringValue(s string) Value {\n\treturn Value{iface: s}\n}", "id": 9765, "concepts": ["struct definition", "interface definition", "basic function definition"], "_raw_llm_output": "struct definition, interface definition, basic function definition"}
{"seed": "// div does integer division and round-up the result. Note that this is\n// equivalent to (d+r-1)/r but has less chance to overflow.\nfunc div(d, r time.Duration) int64 {\n\tif m := d % r; m > 0 {\n\t\treturn int64(d/r + 1)\n\t}\n\treturn int64(d / r)\n}", "id": 9766, "concepts": ["time.Duration", "integer division", "math"], "_raw_llm_output": "time.Duration, integer division, math"}
{"seed": "// PrivateEndpoint_SpecGenerator returns a generator of PrivateEndpoint_Spec instances for property testing.\n// We first initialize privateEndpoint_SpecGenerator with a simplified generator based on the\n// fields with primitive types then replacing it with a more complex one that also handles complex fields\n// to ensure any cycles in the object graph properly terminate.\nfunc PrivateEndpoint_SpecGenerator() gopter.Gen {\n\tif privateEndpoint_SpecGenerator != nil {\n\t\treturn privateEndpoint_SpecGenerator\n\t}\n\n\tgenerators := make(map[string]gopter.Gen)\n\tAddIndependentPropertyGeneratorsForPrivateEndpoint_Spec(generators)\n\tprivateEndpoint_SpecGenerator = gen.Struct(reflect.TypeOf(PrivateEndpoint_Spec{}), generators)\n\n\t// The above call to gen.Struct() captures the map, so create a new one\n\tgenerators = make(map[string]gopter.Gen)\n\tAddIndependentPropertyGeneratorsForPrivateEndpoint_Spec(generators)\n\tAddRelatedPropertyGeneratorsForPrivateEndpoint_Spec(generators)\n\tprivateEndpoint_SpecGenerator = gen.Struct(reflect.TypeOf(PrivateEndpoint_Spec{}), generators)\n\n\treturn privateEndpoint_SpecGenerator\n}", "id": 9770, "concepts": ["struct", "map", "reflection", "property testing", "generator", "property-based testing"], "_raw_llm_output": "struct, map, reflection, property testing, generator, property-based testing"}
{"seed": "// DateTimeGT applies the GT predicate on the \"dateTime\" field.\nfunc DateTimeGT(v time.Time) predicate.Bulk {\n\treturn predicate.Bulk(func(s *sql.Selector) {\n\t\ts.Where(sql.GT(s.C(FieldDateTime), v))\n\t})\n}", "id": 9771, "concepts": ["sql.Selector", "sql.C", "sql.GT", "sql.Where", "sql.Bulk", "predicate.Bulk"], "_raw_llm_output": "sql.Selector, sql.C, sql.GT, sql.Where, sql.Bulk, predicate.Bulk"}
{"seed": "// The expandTabs function pads tab characters to the specified width of spaces for the provided\n// line of input. We cannot simply pad based on byte-offset since our input is UTF-8 encoded.\n// Fortunately, we can assume that this function is called that the line contains only valid\n// UTF-8 sequences. We first decode the line rune-wise, and use individual runes to figure out\n// where we are within the line. When we encounter a tab character, we expand based on our rune\n// index.\nfunc expandTabs(line []byte, tabWidth int) ([]byte, error) {\n\t// Initial sizing of our output slice assumes no UTF-8 bytes or tabs, since this is often\n\t// the common case.\n\tout := make([]byte, 0, len(line))\n\n\t// pos tracks our position in the input byte slice, while index tracks our position in the\n\t// resulting output slice.\n\tpos := 0\n\tindex := 0\n\tfor _, c := range line {\n\t\tif c == '\\t' {\n\t\t\t// Loop over the remaining space count for this particular tabstop until\n\t\t\t// the next, replacing each position with a space.\n\t\t\tfor s := tabWidth - (pos % tabWidth); s > 0; s-- {\n\t\t\t\tout = append(out, ' ')\n\t\t\t\tindex++\n\t\t\t}\n\t\t\tpos++\n\t\t} else {\n\t\t\t// We need to know the byte length of the rune at this position so that we\n\t\t\t// can account for our tab expansion properly. So we first decode the rune\n\t\t\t// at this position to get its length in bytes, plop that rune back into our\n\t\t\t// output slice, and account accordingly.\n\t\t\tr, l := utf8.DecodeRune(line[pos:])\n\t\t\tif r == utf8.RuneError {\n\t\t\t\treturn nil, fmt.Errorf(\"invalid rune at byte offset %d; rune offset %d\", pos, index)\n\t\t\t}\n\n\t\t\tenc := make([]byte, l)\n\t\t\tutf8.EncodeRune(enc, r)\n\t\t\tout = append(out, enc...)\n\n\t\t\tpos += l\n\t\t\tindex++\n\t\t}\n\t}\n\n\treturn out, nil\n}", "id": 9772, "concepts": ["UTF-8 encoding", "rune handling", "byte-offset counting", "UTF-8 decoding", "byte-offset accounting", "UTF-8 encoding", "byte-offset accounting", "UTF-8 decoding", "byte-offset accounting", "UTF-8 encoding", "byte-offset accounting", "UTF-8 decoding", "byte-offset accounting", "UTF-8 encoding", "byte-offset accounting", "UTF-8 decoding", "byte-offset accounting", "UTF-8 encoding", "byte-offset accounting", "UTF-8 decoding", "byte-offset accounting", "UTF-8 encoding", "byte-offset accounting", "UTF-8 decoding", "byte-offset accounting", "UTF-8 encoding", "byte-offset accounting", "UTF-8 decoding", "byte-offset accounting", "UTF-8 encoding", "byte-offset accounting", "UTF-8 decoding", "byte-offset accounting", "UTF-8 encoding", "byte-offset accounting", "UTF-8 decoding", "byte-offset accounting", "UTF-8 encoding", "byte-offset accounting", "UTF-8 decoding", "byte-offset accounting", "UTF-8 encoding", "byte-offset accounting", "UTF-8 decoding", "byte-offset accounting", "UTF-8 encoding", "byte-offset accounting", "UTF-8 decoding", "byte-offset accounting", "UTF-8 encoding", "byte-offset accounting", "UTF"], "_raw_llm_output": "UTF-8 encoding, rune handling, byte-offset counting, UTF-8 decoding, byte-offset accounting, UTF-8 encoding, byte-offset accounting, UTF-8 decoding, byte-offset accounting, UTF-8 encoding, byte-offset accounting, UTF-8 decoding, byte-offset accounting, UTF-8 encoding, byte-offset accounting, UTF-8 decoding, byte-offset accounting, UTF-8 encoding, byte-offset accounting, UTF-8 decoding, byte-offset accounting, UTF-8 encoding, byte-offset accounting, UTF-8 decoding, byte-offset accounting, UTF-8 encoding, byte-offset accounting, UTF-8 decoding, byte-offset accounting, UTF-8 encoding, byte-offset accounting, UTF-8 decoding, byte-offset accounting, UTF-8 encoding, byte-offset accounting, UTF-8 decoding, byte-offset accounting, UTF-8 encoding, byte-offset accounting, UTF-8 decoding, byte-offset accounting, UTF-8 encoding, byte-offset accounting, UTF-8 decoding, byte-offset accounting, UTF-8 encoding, byte-offset accounting, UTF-8 decoding, byte-offset accounting, UTF-8 encoding, byte-offset accounting, UTF"}
{"seed": "// FromContext returns the Client stored in a context, or nil if there isn't one.\nfunc FromContext(ctx context.Context) *Client {\n\tc, _ := ctx.Value(contextKey{}).(*Client)\n\treturn c\n}", "id": 9774, "concepts": ["context", "context.Context", "context.WithValue", "context.Background"], "_raw_llm_output": "context, context.Context, context.WithValue, context.Background"}
{"seed": "// DecodeName converts tsdb internal serialization back to organization and bucket IDs.\nfunc DecodeName(name [16]byte) (org, bucket platform.ID) {\n\torg = platform.ID(binary.BigEndian.Uint64(name[0:8]))\n\tbucket = platform.ID(binary.BigEndian.Uint64(name[8:16]))\n\treturn\n}", "id": 9780, "concepts": ["byte manipulation", "binary encoding", "struct fields"], "_raw_llm_output": "byte manipulation, binary encoding, struct fields"}
{"seed": "// Position multiplies direction of ray with the passed distance and adds the result onto the origin.\n// Used for finding the position along a ray.\nfunc Position(r geom.Ray, distance float64) geom.Tuple4 {\n\tadd := geom.MultiplyByScalar(r.Direction, distance)\n\tpos := geom.Add(r.Origin, add)\n\treturn pos\n}", "id": 9790, "concepts": ["tuple", "tuple arithmetic", "tuple multiplication", "tuple addition", "tuple multiplication by scalar"], "_raw_llm_output": "tuple, tuple arithmetic, tuple multiplication, tuple addition, tuple multiplication by scalar"}
{"seed": "// SocialPayloadNotIn applies the NotIn predicate on the \"social_payload\" field.\nfunc SocialPayloadNotIn(vs ...string) predicate.User {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.User(func(s *sql.Selector) {\n\t\t// if not arguments were provided, append the FALSE constants,\n\t\t// since we can't apply \"IN ()\". This will make this predicate falsy.\n\t\tif len(vs) == 0 {\n\t\t\ts.Where(sql.False())\n\t\t\treturn\n\t\t}\n\t\ts.Where(sql.NotIn(s.C(FieldSocialPayload), v...))\n\t})\n}", "id": 9793, "concepts": ["sql package usage", "sql.Selector", "sql.NotIn", "predicate.User", "predicate.FieldSocialPayload"], "_raw_llm_output": "sql package usage, sql.Selector, sql.NotIn, predicate.User, predicate.FieldSocialPayload"}
{"seed": "// Dlatm1 computes the entries of dst as specified by mode, cond and rsign.\n//\n// mode describes how dst will be computed:\n//  |mode| == 1: dst[0] = 1 and dst[1:n] = 1/cond\n//  |mode| == 2: dst[:n-1] = 1/cond and dst[n-1] = 1\n//  |mode| == 3: dst[i] = cond^{-i/(n-1)}, i=0,...,n-1\n//  |mode| == 4: dst[i] = 1 - i*(1-1/cond)/(n-1)\n//  |mode| == 5: dst[i] = random number in the range (1/cond, 1) such that\n//                    their logarithms are uniformly distributed\n//  |mode| == 6: dst[i] = random number from the distribution given by dist\n// If mode is negative, the order of the elements of dst will be reversed.\n// For other values of mode Dlatm1 will panic.\n//\n// If rsign is true and mode is not \u00b16, each entry of dst will be multiplied by 1\n// or -1 with probability 0.5\n//\n// dist specifies the type of distribution to be used when mode == \u00b16:\n//  dist == 1: Uniform[0,1)\n//  dist == 2: Uniform[-1,1)\n//  dist == 3: Normal(0,1)\n// For other values of dist Dlatm1 will panic.\n//\n// rnd is used as a source of random numbers.\nfunc Dlatm1(dst []float64, mode int, cond float64, rsign bool, dist int, rnd *rand.Rand) {\n\tamode := mode\n\tif amode < 0 {\n\t\tamode = -amode\n\t}\n\tif amode < 1 || 6 < amode {\n\t\tpanic(\"testlapack: invalid mode\")\n\t}\n\tif cond < 1 {\n\t\tpanic(\"testlapack: cond < 1\")\n\t}\n\tif amode == 6 && (dist < 1 || 3 < dist) {\n\t\tpanic(\"testlapack: invalid dist\")\n\t}\n\n\tn := len(dst)\n\tif n == 0 {\n\t\treturn\n\t}\n\n\tswitch amode {\n\tcase 1:\n\t\tdst[0] = 1\n\t\tfor i := 1; i < n; i++ {\n\t\t\tdst[i] = 1 / cond\n\t\t}\n\tcase 2:\n\t\tfor i := 0; i < n-1; i++ {\n\t\t\tdst[i] = 1\n\t\t}\n\t\tdst[n-1] = 1 / cond\n\tcase 3:\n\t\tdst[0] = 1\n\t\tif n > 1 {\n\t\t\talpha := math.Pow(cond, -1/float64(n-1))\n\t\t\tfor i := 1; i < n; i++ {\n\t\t\t\tdst[i] = math.Pow(alpha, float64(i))\n\t\t\t}\n\t\t}\n\tcase 4:\n\t\tdst[0] = 1\n\t\tif n > 1 {\n\t\t\tcondInv := 1 / cond\n\t\t\talpha := (1 - condInv) / float64(n-1)\n\t\t\tfor i := 1; i < n; i++ {\n\t\t\t\tdst[i] = float64(n-i-1)*alpha + condInv\n\t\t\t}\n\t\t}\n\tcase 5:\n\t\talpha := math.Log(1 / cond)\n\t\tfor i := range dst {\n\t\t\tdst[i] = math.Exp(alpha * rnd.Float64())\n\t\t}\n\tcase 6:\n\t\tswitch dist {\n\t\tcase 1:\n\t\t\tfor i := range dst {\n\t\t\t\tdst[i] = rnd.Float64()\n\t\t\t}\n\t\tcase 2:\n\t\t\tfor i := range dst {\n\t\t\t\tdst[i] = 2*rnd.Float64() - 1\n\t\t\t}\n\t\tcase 3:\n\t\t\tfor i := range dst {\n\t\t\t\tdst[i] = rnd.NormFloat64()\n\t\t\t}\n\t\t}\n\t}\n\n\tif rsign && amode != 6 {\n\t\tfor i, v := range dst {\n\t\t\tif rnd.Float64() < 0.5 {\n\t\t\t\tdst[i] = -v\n\t\t\t}\n\t\t}\n\t}\n\n\tif mode < 0 {\n\t\tfor i := 0; i < n/2; i++ {\n\t\t\tdst[i], dst[n-i-1] = dst[n-i-1], dst[i]\n\t\t}\n\t}\n}", "id": 9797, "concepts": ["slice", "slice iteration (range loop)", "integer division", "float64 comparison", "float64 summation", "float64 multiplication", "float64 division", "float64 exponentiation", "float64 logarithm", "float64 random number generation", "float64 normal distribution", "float64 uniform distribution", "float64 random number generation", "float64 random number generation", "float64 random number generation", "float64 random number generation", "float64 random number generation", "float64 random number generation", "float64 random number generation", "float64 random number generation", "float64 random number generation", "float64 random number generation", "float64 random number generation", "float64 random number generation", "float64 random number generation", "float64 random number generation", "float64 random number generation", "float64 random number generation", "float64 random number generation", "float64 random number generation", "float64 random number generation", "float64 random number generation", "float64 random number generation", "float64 random number generation", "float64 random number generation", "float64 random number generation", "float64 random number generation", "float64 random number generation", "float64 random number generation", "float"], "_raw_llm_output": "slice, slice iteration (range loop), integer division, float64 comparison, float64 summation, float64 multiplication, float64 division, float64 exponentiation, float64 logarithm, float64 random number generation, float64 normal distribution, float64 uniform distribution, float64 random number generation, float64 random number generation, float64 random number generation, float64 random number generation, float64 random number generation, float64 random number generation, float64 random number generation, float64 random number generation, float64 random number generation, float64 random number generation, float64 random number generation, float64 random number generation, float64 random number generation, float64 random number generation, float64 random number generation, float64 random number generation, float64 random number generation, float64 random number generation, float64 random number generation, float64 random number generation, float64 random number generation, float64 random number generation, float64 random number generation, float64 random number generation, float64 random number generation, float64 random number generation, float64 random number generation, float"}
{"seed": "// TitleGT applies the GT predicate on the \"title\" field.\nfunc TitleGT(v string) predicate.User {\n\treturn predicate.User(sql.FieldGT(FieldTitle, v))\n}", "id": 9809, "concepts": ["predicate.User", "sql.FieldGT", "sql.FieldLT", "sql.FieldEQ", "sql.FieldNE", "sql.FieldIN", "sql.FieldNotIn", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldNull", "sql.FieldNotNull", "sql.FieldBetween", "sql.FieldNotBetween", "sql.FieldExists", "sql.FieldNotExists", "sql.FieldContains", "sql.FieldNotContains", "sql.FieldHas", "sql.FieldNotHas", "sql.FieldHasAny", "sql.FieldNotHasAny", "sql.FieldHasAll", "sql.FieldNotHasAll", "sql.FieldHasNone", "sql.FieldNotHasNone", "sql.FieldHasSome", "sql.FieldNotHasSome", "sql.FieldHasExactly", "sql.FieldNotHasExactly", "sql.FieldHasAtLeast", "sql.FieldNotHasAtLeast", "sql.FieldHasAtMost", "sql.FieldNotHasAtMost", "sql.FieldHasAtLeastN", "sql.FieldNotHasAtLeastN", "sql.FieldHasAtMostN", "sql.FieldNotHasAtMostN", "sql.FieldHasBetweenN", "sql.FieldNotHasBetweenN", "sql.FieldHasBetweenNAndM", "sql.Field"], "_raw_llm_output": "predicate.User, sql.FieldGT, sql.FieldLT, sql.FieldEQ, sql.FieldNE, sql.FieldIN, sql.FieldNotIn, sql.FieldLike, sql.FieldNotLike, sql.FieldNull, sql.FieldNotNull, sql.FieldBetween, sql.FieldNotBetween, sql.FieldExists, sql.FieldNotExists, sql.FieldContains, sql.FieldNotContains, sql.FieldHas, sql.FieldNotHas, sql.FieldHasAny, sql.FieldNotHasAny, sql.FieldHasAll, sql.FieldNotHasAll, sql.FieldHasNone, sql.FieldNotHasNone, sql.FieldHasSome, sql.FieldNotHasSome, sql.FieldHasExactly, sql.FieldNotHasExactly, sql.FieldHasAtLeast, sql.FieldNotHasAtLeast, sql.FieldHasAtMost, sql.FieldNotHasAtMost, sql.FieldHasAtLeastN, sql.FieldNotHasAtLeastN, sql.FieldHasAtMostN, sql.FieldNotHasAtMostN, sql.FieldHasBetweenN, sql.FieldNotHasBetweenN, sql.FieldHasBetweenNAndM, sql.Field"}
{"seed": "// saveUniqueFileInDir saves a file in the target directory.\n// It erases any other file in this directory before saving\n// to make sure it is unique.\n// It returns the path to the newly created file and the earliest\n// error encountered in the process.\nfunc saveUniqueFileInDir(dirpath, filename string, file io.Reader) (string, error) {\n\t// Remove directory used for storing the user image if it exists\n\tif err := os.RemoveAll(dirpath); err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Create directory used for storing the user image\n\tif err := os.Mkdir(dirpath, os.ModeDir); err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Create a destination on disk\n\tfilepath := joinPath(dirpath, filename)\n\tdst, err := os.OpenFile(filepath, os.O_WRONLY|os.O_CREATE, 0666)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer dst.Close()\n\n\t// Copy all bytes from the file to the destination on disk\n\tif _, err = io.Copy(dst, file); err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn filepath, nil\n}", "id": 9811, "concepts": ["file handling", "os package usage", "io package usage", "os.Mkdir", "os.OpenFile", "os.RemoveAll", "os.ModeDir", "io.Copy", "os.O_WRONLY|os.O_CREATE", "os.ModePerm", "string manipulation", "file path handling", "file path joining"], "_raw_llm_output": "file handling, os package usage, io package usage, os.Mkdir, os.OpenFile, os.RemoveAll, os.ModeDir, io.Copy, os.O_WRONLY|os.O_CREATE, os.ModePerm, string manipulation, file path handling, file path joining"}
{"seed": "// DefaultExprsContainsFold applies the ContainsFold predicate on the \"default_exprs\" field.\nfunc DefaultExprsContainsFold(v string) predicate.User {\n\treturn predicate.User(sql.FieldContainsFold(FieldDefaultExprs, v))\n}", "id": 9816, "concepts": ["sql.FieldContainsFold", "predicate.User", "sql.FieldContainsFold usage"], "_raw_llm_output": "sql.FieldContainsFold, predicate.User, sql.FieldContainsFold usage"}
{"seed": "// SocialNameNotIn applies the NotIn predicate on the \"social_name\" field.\nfunc SocialNameNotIn(vs ...string) predicate.User {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.User(func(s *sql.Selector) {\n\t\t// if not arguments were provided, append the FALSE constants,\n\t\t// since we can't apply \"IN ()\". This will make this predicate falsy.\n\t\tif len(vs) == 0 {\n\t\t\ts.Where(sql.False())\n\t\t\treturn\n\t\t}\n\t\ts.Where(sql.NotIn(s.C(FieldSocialName), v...))\n\t})\n}", "id": 9817, "concepts": ["sql.Selector", "sql.NotIn", "predicate.User", "sql.False"], "_raw_llm_output": "sql.Selector, sql.NotIn, predicate.User, sql.False"}
{"seed": "// DropOptionalContains applies the Contains predicate on the \"drop_optional\" field.\nfunc DropOptionalContains(v string) predicate.User {\n\treturn predicate.User(sql.FieldContains(FieldDropOptional, v))\n}", "id": 9821, "concepts": ["sql.FieldContains", "predicate.User", "sql.FieldContains usage"], "_raw_llm_output": "sql.FieldContains, predicate.User, sql.FieldContains usage"}
{"seed": "// NewCreateInstancePoolRequestWithBody generates requests for CreateInstancePool with any type of body\nfunc NewCreateInstancePoolRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {\n\tvar err error\n\n\tqueryUrl, err := url.Parse(server)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbasePath := fmt.Sprintf(\"/instance-pool\")\n\tif basePath[0] == '/' {\n\t\tbasePath = basePath[1:]\n\t}\n\n\tqueryUrl, err = queryUrl.Parse(basePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq, err := http.NewRequest(\"POST\", queryUrl.String(), body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Add(\"Content-Type\", contentType)\n\treturn req, nil\n}", "id": 9823, "concepts": ["url parsing", "http.NewRequest", "io.Reader", "url.Parse", "string formatting", "string concatenation", "string manipulation", "request body handling"], "_raw_llm_output": "url parsing, http.NewRequest, io.Reader, url.Parse, string formatting, string concatenation, string manipulation, request body handling"}
{"seed": "// WithServiceName sets the given service name for the returned ServeMux.\nfunc WithServiceName(name string) MuxOption {\n\treturn func(cfg *config) {\n\t\tcfg.serviceName = name\n\t}\n}", "id": 9827, "concepts": ["struct composition", "function composition", "function composition with struct composition"], "_raw_llm_output": "struct composition, function composition, function composition with struct composition"}
{"seed": "// NewItems returns an initialised item queue.\nfunc NewItems() *Items {\n\treturn &Items{\n\t\tStack: make([]*pageloader.Request, 0, 1),\n\t\tSeen:  make(map[string]bool),\n\t}\n}", "id": 9830, "concepts": ["slice", "map", "struct", "basic function definition"], "_raw_llm_output": "slice, map, struct, basic function definition"}
{"seed": "// castGoNRVKColsToC convert GO NRVKCols to C.nrvk_cols_t.\nfunc castGoNRVKColsToC(nr NRVKCols) C.nrvk_cols_t {\n\tvar cnr C.nrvk_cols_t\n\tcnr.vk = (*C.uint64_t)(nr.Vk)\n\tcnr.offset = (*C.uint64_t)(nr.Offset)\n\tcnr.data = (*C.uint8_t)(nr.Data)\n\tcnr.nrows = C.uint64_t(nr.NRows)\n\treturn cnr\n}", "id": 9840, "concepts": ["C.uint64_t", "C.uint8_t", "unsafe.Pointer", "unsafe.Pointer conversion", "C.nrvk_cols_t definition"], "_raw_llm_output": "C.uint64_t, C.uint8_t, unsafe.Pointer, unsafe.Pointer conversion, C.nrvk_cols_t definition"}
{"seed": "// ConfigProviderWithLogger returns a ConfigProviderOption that uses the given logger.\n//\n// The default is to use zap.NewNop().\nfunc ConfigProviderWithLogger(logger *zap.Logger) ConfigProviderOption {\n\treturn func(configProvider *configProvider) {\n\t\tconfigProvider.logger = logger\n\t}\n}", "id": 9845, "concepts": ["function composition", "function options", "zap package usage"], "_raw_llm_output": "function composition, function options, zap package usage"}
{"seed": "// SocialTypeIn applies the In predicate on the \"social_type\" field.\nfunc SocialTypeIn(vs ...string) predicate.User {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.User(func(s *sql.Selector) {\n\t\t// if not arguments were provided, append the FALSE constants,\n\t\t// since we can't apply \"IN ()\". This will make this predicate falsy.\n\t\tif len(vs) == 0 {\n\t\t\ts.Where(sql.False())\n\t\t\treturn\n\t\t}\n\t\ts.Where(sql.In(s.C(FieldSocialType), v...))\n\t})\n}", "id": 9864, "concepts": ["sql.Selector", "sql.In", "sql.False", "sql.C", "predicate.User", "predicate.User", "sql.In"], "_raw_llm_output": "sql.Selector, sql.In, sql.False, sql.C, predicate.User, predicate.User, sql.In"}
{"seed": "// BulkCreditSamedayEQ applies the EQ predicate on the \"bulkCreditSameday\" field.\nfunc BulkCreditSamedayEQ(v float64) predicate.Bulk {\n\treturn predicate.Bulk(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldBulkCreditSameday), v))\n\t})\n}", "id": 9882, "concepts": ["sql package usage", "sql.Selector", "sql.C", "sql.EQ", "sql.Where", "sql.Predicate"], "_raw_llm_output": "sql package usage, sql.Selector, sql.C, sql.EQ, sql.Where, sql.Predicate"}
{"seed": "// mergeMaps recursively merges orig and fixed.\n// Key-value pairs which exist in orig but not fixed are excluded (as determined by matching the key).\n// Key-value pairs which exist in fixed but not orig are included.\n// If keys exist in both orig and fixed then the key-value pair from fixed is used unless both values are complex\n// (maps or sequences), in which case they are merged recursively.\nfunc mergeMaps(orig, fixed *goyaml.Node) *goyaml.Node {\n\tmerged := shallowCopyNode(orig)\n\torigContent := orig.Content\n\tfixedContent := fixed.Content\n\n\t// Drop items from original if they are not in fixed\n\tfor i := 0; i < len(origContent); i += 2 {\n\t\torigKey := origContent[i]\n\t\tif isKeyInMap(origKey, fixed) {\n\t\t\torigVal := origContent[i+1]\n\t\t\tmerged.Content = append(merged.Content, origKey, origVal)\n\t\t}\n\t}\n\n\t// Update or add items from the fixed yaml which are not in the original\n\tfor i := 0; i < len(fixedContent); i += 2 {\n\t\tfixedKey := fixedContent[i]\n\t\tfixedVal := fixedContent[i+1]\n\t\tif mergedKeyIndex := findKeyInMap(fixedKey, merged); mergedKeyIndex == -1 {\n\t\t\t// Add item\n\t\t\tmerged.Content = append(merged.Content, fixedKey, fixedVal)\n\t\t} else {\n\t\t\t// Update item\n\t\t\tmergedValIndex := mergedKeyIndex + 1\n\t\t\tmergedVal := merged.Content[mergedValIndex]\n\n\t\t\tif fixedVal.Kind != mergedVal.Kind {\n\t\t\t\tmerged.Content[mergedValIndex] = fixedVal\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tswitch fixedVal.Kind {\n\t\t\tcase goyaml.ScalarNode:\n\t\t\t\tmerged.Content[mergedValIndex].Value = fixedVal.Value\n\t\t\tcase goyaml.MappingNode:\n\t\t\t\tmerged.Content[mergedValIndex] = mergeMaps(mergedVal, fixedVal)\n\t\t\tcase goyaml.SequenceNode:\n\t\t\t\tmerged.Content[mergedValIndex] = mergeSequences(fixedKey.Value, mergedVal, fixedVal)\n\t\t\tdefault:\n\t\t\t\tlog.Error(\"Unexpected yaml node kind\", fixedVal.Kind)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn merged\n}", "id": 9892, "concepts": ["yaml parsing", "yaml merging", "yaml mapping", "yaml sequence", "yaml scalar", "yaml node kind", "yaml node value", "yaml node content", "yaml node key", "yaml node key value", "yaml node key value kind", "yaml node key value value", "yaml node key value value kind", "yaml node key value value value", "yaml node key value value value kind", "yaml node key value value value value", "yaml node key value value value value kind", "yaml node key value value value value value", "yaml node key value value value value value kind", "yaml node key value value value value value value", "yaml node key value value value value value value kind", "yaml node key value value value value value value value", "yaml node key value value value value value value value kind", "yaml node key value value value value value value value value", "yaml node key value value value value value value value value kind", "yaml node key value value value value value value value value value", "yaml node key value value value value value value value value value kind", "yaml node key value value value value value value value value value value", "yaml node key value value value value value value value value value value kind", "yaml node key value value value value value value value value value value value", "yaml node key value value value value value value"], "_raw_llm_output": "yaml parsing, yaml merging, yaml mapping, yaml sequence, yaml scalar, yaml node kind, yaml node value, yaml node content, yaml node key, yaml node key value, yaml node key value kind, yaml node key value value, yaml node key value value kind, yaml node key value value value, yaml node key value value value kind, yaml node key value value value value, yaml node key value value value value kind, yaml node key value value value value value, yaml node key value value value value value kind, yaml node key value value value value value value, yaml node key value value value value value value kind, yaml node key value value value value value value value, yaml node key value value value value value value value kind, yaml node key value value value value value value value value, yaml node key value value value value value value value value kind, yaml node key value value value value value value value value value, yaml node key value value value value value value value value value kind, yaml node key value value value value value value value value value value, yaml node key value value value value value value value value value value kind, yaml node key value value value value value value value value value value value, yaml node key value value value value value value"}
{"seed": "// SocialUserIDEqualFold applies the EqualFold predicate on the \"social_user_id\" field.\nfunc SocialUserIDEqualFold(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.EqualFold(s.C(FieldSocialUserID), v))\n\t})\n}", "id": 9910, "concepts": ["predicate.User", "sql.EqualFold", "sql.Selector", "sql.C"], "_raw_llm_output": "predicate.User, sql.EqualFold, sql.Selector, sql.C"}
{"seed": "// Semidiameter returns semidiameter at specified distance.\n// \u5929\u4f53\u89c6\u534a\u5f84\uff0cs0\u4e3a\u5929\u4f53\u7684\u534a\u5f84\n//\n// \u0394 must be observer-body distance in AU.\nfunc Semidiameter(s0 unit.Angle, \u0394 float64) unit.Angle {\n\treturn s0.Div(\u0394)\n}", "id": 9915, "concepts": ["struct definition", "struct field access", "function definition", "unit conversion"], "_raw_llm_output": "struct definition, struct field access, function definition, unit conversion"}
{"seed": "// BlackString is a convenient helper function to return a string with black\n// foreground.\nfunc BlackString(format string, a ...interface{}) (s string) {\n\ts = colorString(FgBlack, format, a...)\n\treturn\n}", "id": 9919, "concepts": ["string formatting", "fmt package usage", "color package usage"], "_raw_llm_output": "string formatting, fmt package usage, color package usage"}
{"seed": "// NewOpenapiProcessFileAllOf instantiates a new OpenapiProcessFileAllOf object\n// This constructor will assign default values to properties that have it defined,\n// and makes sure properties required by API are set, but the set of arguments\n// will change when the set of required properties is changed\nfunc NewOpenapiProcessFileAllOf(classId string, objectType string) *OpenapiProcessFileAllOf {\n\tthis := OpenapiProcessFileAllOf{}\n\tthis.ClassId = classId\n\tthis.ObjectType = objectType\n\treturn &this\n}", "id": 9922, "concepts": ["struct definition", "struct instantiation", "struct property assignment"], "_raw_llm_output": "struct definition, struct instantiation, struct property assignment"}
{"seed": "// OperationResultPTimeout returns a pointer to OperationResultVTimeout\nfunc OperationResultPTimeout() *OperationResult {\n\tv := OperationResultVTimeout\n\treturn &v\n}", "id": 9933, "concepts": ["pointer usage"], "_raw_llm_output": "pointer usage"}
{"seed": "//Route returns the beginstring, message type, and MessageRoute for this Message type\nfunc Route(router RouteOut) (string, string, quickfix.MessageRoute) {\n\tr := func(msg quickfix.Message, sessionID quickfix.SessionID) quickfix.MessageRejectError {\n\t\tm := new(Message)\n\t\tif err := quickfix.Unmarshal(msg, m); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn router(*m, sessionID)\n\t}\n\treturn enum.ApplVerID_FIX50, \"l\", r\n}", "id": 9944, "concepts": ["quickfix.MessageRoute", "quickfix.Unmarshal", "quickfix.MessageRejectError", "quickfix.SessionID", "quickfix.Message", "string manipulation", "enum usage"], "_raw_llm_output": "quickfix.MessageRoute, quickfix.Unmarshal, quickfix.MessageRejectError, quickfix.SessionID, quickfix.Message, string manipulation, enum usage"}
{"seed": "// NewSignalArgumentFromPointer will return a SignalArgument from the\n// given unsafe pointer. This is primarily used in conjunction with MethodBindPtrCall.\nfunc NewSignalArgumentFromPointer(ptr Pointer) SignalArgument {\n\n\treturn SignalArgument{base: (*C.godot_signal_argument)(ptr.getBase())}\n}", "id": 9948, "concepts": ["unsafe pointer handling", "pointer arithmetic", "C interoperability"], "_raw_llm_output": "unsafe pointer handling, pointer arithmetic, C interoperability"}
{"seed": "// StateIsNil applies the IsNil predicate on the \"state\" field.\nfunc StateIsNil() predicate.User {\n\treturn predicate.User(sql.FieldIsNull(FieldState))\n}", "id": 9949, "concepts": ["predicate definition", "predicate usage", "sql.FieldIsNull"], "_raw_llm_output": "predicate definition, predicate usage, sql.FieldIsNull"}
{"seed": "// MinterDefinitionTransactionFromTransaction creates a MinterDefinitionTransaction,\n// using a regular in-memory tfchain transaction.\n//\n// Past the (tx) Version validation it piggy-backs onto the\n// `MinterDefinitionTransactionFromTransactionData` constructor.\nfunc MinterDefinitionTransactionFromTransaction(tx types.Transaction) (MinterDefinitionTransaction, error) {\n\tif tx.Version != TransactionVersionMinterDefinition {\n\t\treturn MinterDefinitionTransaction{}, fmt.Errorf(\n\t\t\t\"a minter definition transaction requires tx version %d\",\n\t\t\tTransactionVersionCoinCreation)\n\t}\n\treturn MinterDefinitionTransactionFromTransactionData(types.TransactionData{\n\t\tCoinInputs:        tx.CoinInputs,\n\t\tCoinOutputs:       tx.CoinOutputs,\n\t\tBlockStakeInputs:  tx.BlockStakeInputs,\n\t\tBlockStakeOutputs: tx.BlockStakeOutputs,\n\t\tMinerFees:         tx.MinerFees,\n\t\tArbitraryData:     tx.ArbitraryData,\n\t\tExtension:         tx.Extension,\n\t})\n}", "id": 9953, "concepts": ["type definition", "interface definition", "struct definition", "method definition", "function definition", "function call", "function parameter", "function return value", "function body", "function scope", "function declaration", "function definition", "function call", "function parameter", "function return value", "function body", "function scope", "function declaration", "function definition", "function call", "function parameter", "function return value", "function body", "function scope", "function declaration", "function definition", "function call", "function parameter", "function return value", "function body", "function scope", "function declaration", "function definition", "function call", "function parameter", "function return value", "function body", "function scope", "function declaration", "function definition", "function call", "function parameter", "function return value", "function body", "function scope", "function declaration", "function definition", "function call", "function parameter", "function return value", "function body", "function scope", "function declaration", "function definition", "function call", "function parameter", "function return value", "function body", "function scope", "function declaration", "function definition", "function call", "function parameter", "function return value", "function body", "function scope", "function declaration", "function definition", "function call", "function parameter", "function return value", "function body", "function scope", "function declaration", "function definition", "function call", "function parameter", "function return value", "function body", "function scope", "function declaration", "function"], "_raw_llm_output": "type definition, interface definition, struct definition, method definition, function definition, function call, function parameter, function return value, function body, function scope, function declaration, function definition, function call, function parameter, function return value, function body, function scope, function declaration, function definition, function call, function parameter, function return value, function body, function scope, function declaration, function definition, function call, function parameter, function return value, function body, function scope, function declaration, function definition, function call, function parameter, function return value, function body, function scope, function declaration, function definition, function call, function parameter, function return value, function body, function scope, function declaration, function definition, function call, function parameter, function return value, function body, function scope, function declaration, function definition, function call, function parameter, function return value, function body, function scope, function declaration, function definition, function call, function parameter, function return value, function body, function scope, function declaration, function definition, function call, function parameter, function return value, function body, function scope, function declaration, function definition, function call, function parameter, function return value, function body, function scope, function declaration, function"}
{"seed": "// RecentTasksActivityLRTimeDESC function sorts data by LastRunTime field in descending order\n// sorting layers: LRTime > LRStatus(ASC) > Name(ASC)\n// function chain according to sorting layers: RecentTasksActivityLRTimeDESC > LRTimeSubsortingByLRStatusASC > subsortingByNameASC\nfunc RecentTasksActivityLRTimeDESC(p1, p2 interface{}) bool {\n\tp1RTime := p1.(RecentTasksActivity).TaskInstance.LastRunTime.Truncate(time.Minute)\n\tp2RTime := p2.(RecentTasksActivity).TaskInstance.LastRunTime.Truncate(time.Minute)\n\n\tif p1RTime == p2RTime {\n\t\treturn LRTimeSubsortingByLRStatusASC(p1, p2)\n\t}\n\n\treturn p1RTime.After(p2RTime)\n}", "id": 9963, "concepts": ["interface", "sorting", "time package usage"], "_raw_llm_output": "interface, sorting, time package usage"}
{"seed": "// ExtractVariantKeyChrom extracts the CHROM code from VariantKey.\nfunc ExtractVariantKeyChrom(v uint64) uint8 {\n\treturn uint8(C.extract_variantkey_chrom(C.uint64_t(v)))\n}", "id": 9965, "concepts": ["C code", "CGO usage", "bitwise operations", "bit shifting", "bit masking"], "_raw_llm_output": "C code, CGO usage, bitwise operations, bit shifting, bit masking"}
{"seed": "// NewCreateScopedUserRoleSpacesParamsWithHTTPClient creates a new CreateScopedUserRoleSpacesParams object\n// with the default values initialized, and the ability to set a custom HTTPClient for a request\nfunc NewCreateScopedUserRoleSpacesParamsWithHTTPClient(client *http.Client) *CreateScopedUserRoleSpacesParams {\n\tvar ()\n\treturn &CreateScopedUserRoleSpacesParams{\n\t\tHTTPClient: client,\n\t}\n}", "id": 9978, "concepts": ["http.Client usage", "function definition", "pointer usage", "HTTPClient usage"], "_raw_llm_output": "http.Client usage, function definition, pointer usage, HTTPClient usage"}
{"seed": "// Return value if nonempty, def otherwise.\nfunc valueOrDefault(value, def string) string {\n\tif value != \"\" {\n\t\treturn value\n\t}\n\treturn def\n}", "id": 10001, "concepts": ["string comparison", "basic function definition"], "_raw_llm_output": "string comparison, basic function definition"}
{"seed": "// Returns a base64 encoded random 32 byte string.\nfunc randomState() string {\n\tb := make([]byte, 32)\n\trand.Read(b)\n\treturn base64.RawURLEncoding.EncodeToString(b)\n}", "id": 10007, "concepts": ["random number generation", "base64 encoding", "cryptography"], "_raw_llm_output": "random number generation, base64 encoding, cryptography"}
{"seed": "// NewListEngineTypeParamsWithTimeout creates a new ListEngineTypeParams object\n// with the default values initialized, and the ability to set a timeout on a request\nfunc NewListEngineTypeParamsWithTimeout(timeout time.Duration) *ListEngineTypeParams {\n\tvar ()\n\treturn &ListEngineTypeParams{\n\n\t\ttimeout: timeout,\n\t}\n}", "id": 10009, "concepts": ["struct initialization", "function definition", "timeout handling"], "_raw_llm_output": "struct initialization, function definition, timeout handling"}
{"seed": "// UpdatedAtGT applies the GT predicate on the \"updated_at\" field.\nfunc UpdatedAtGT(v time.Time) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.GT(s.C(FieldUpdatedAt), v))\n\t})\n}", "id": 10020, "concepts": ["sql.Selector", "sql.Where", "sql.GT", "sql.C", "predicate.User", "sql.FieldUpdatedAt"], "_raw_llm_output": "sql.Selector, sql.Where, sql.GT, sql.C, predicate.User, sql.FieldUpdatedAt"}
{"seed": "// ParseCommand parses an XRE command from the given string, returning any\n// parse error if the string is invalid.\nfunc ParseCommand(s string) (Command, error) {\n\tcmd, s, err := scanCommand(s)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif s != \"\" {\n\t\treturn nil, fmt.Errorf(\"extraneous input %q after command\", s)\n\t}\n\treturn cmd, nil\n}", "id": 10028, "concepts": ["string manipulation", "string parsing", "error handling"], "_raw_llm_output": "string manipulation, string parsing, error handling"}
{"seed": "// addKbps adds Kbps fields to the NewStats, based on the previous out_bytes in the oldStats, and the time difference.\n//\n// Traffic Server only updates its data every N seconds. So, often we get a new Stats with the same OutBytes as the previous one,\n// So, we must record the last changed value, and the time it changed. Then, if the new OutBytes is different from the previous,\n// we set the (new - old) / lastChangedTime as the KBPS, and update the recorded LastChangedTime and LastChangedValue\n//\n// This specifically returns the given dsStats and lastKbpsStats on error, so it's safe to do persistentStats, persistentLastKbpsStats, err = addKbps(...)\nfunc addKbps(dsStats Stats, lastKbpsStats StatsLastKbps, dsStatsTime time.Time, cacheOutbytes map[enum.CacheName]int64) (Stats, StatsLastKbps, error) {\n\tfor dsName, iStat := range dsStats.DeliveryService {\n\t\tif _, ok := iStat.(*StatDNS); ok {\n\t\t\tcontinue\n\t\t}\n\t\tif _, ok := iStat.(*StatHTTP); !ok {\n\t\t\tfmt.Printf(\"WARNING: addKbps got unknown stat type %T\\n\", iStat)\n\t\t\tcontinue\n\t\t}\n\t\tstat := iStat.(*StatHTTP)\n\n\t\tlastKbpsStat, lastKbpsStatExists := lastKbpsStats.DeliveryServices[dsName]\n\t\tif !lastKbpsStatExists {\n\t\t\tlastKbpsStat = newStatLastKbps()\n\t\t}\n\n\t\tfor cgName, cacheStats := range stat.CacheGroups {\n\t\t\tlastKbpsData, _ := lastKbpsStat.CacheGroups[cgName]\n\n\t\t\tif cacheStats.OutBytes.Value == lastKbpsData.Bytes {\n\t\t\t\tcacheStats.Kbps.Value = lastKbpsData.Kbps\n\t\t\t\tstat.CacheGroups[cgName] = cacheStats\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif lastKbpsStatExists {\n\t\t\t\tcacheStats.Kbps.Value = float64(cacheStats.OutBytes.Value-lastKbpsData.Bytes) / dsStatsTime.Sub(lastKbpsData.Time).Seconds()\n\t\t\t}\n\n\t\t\tlastKbpsStat.CacheGroups[cgName] = LastKbpsData{Time: dsStatsTime, Bytes: cacheStats.OutBytes.Value, Kbps: cacheStats.Kbps.Value}\n\t\t\tstat.CacheGroups[cgName] = cacheStats\n\t\t}\n\n\t\tfor cacheType, cacheStats := range stat.Type {\n\t\t\tlastKbpsData, _ := lastKbpsStat.Type[cacheType]\n\t\t\tif cacheStats.OutBytes.Value == lastKbpsData.Bytes {\n\t\t\t\tif cacheStats.OutBytes.Value == lastKbpsData.Bytes {\n\t\t\t\t\tcacheStats.Kbps.Value = lastKbpsData.Kbps\n\t\t\t\t\tstat.Type[cacheType] = cacheStats\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif lastKbpsStatExists {\n\t\t\t\t\tcacheStats.Kbps.Value = float64(cacheStats.OutBytes.Value-lastKbpsData.Bytes) / dsStatsTime.Sub(lastKbpsData.Time).Seconds()\n\t\t\t\t}\n\t\t\t\tlastKbpsStat.Type[cacheType] = LastKbpsData{Time: dsStatsTime, Bytes: cacheStats.OutBytes.Value, Kbps: cacheStats.Kbps.Value}\n\t\t\t\tstat.Type[cacheType] = cacheStats\n\t\t\t}\n\t\t}\n\t\tif lastKbpsStatExists {\n\t\t\tstat.Total.Kbps.Value = float64(stat.Total.OutBytes.Value-lastKbpsStat.Total.Bytes) / dsStatsTime.Sub(lastKbpsStat.Total.Time).Seconds()\n\t\t} else {\n\t\t\tstat.Total.Kbps.Value = lastKbpsStat.Total.Kbps\n\t\t}\n\t\tlastKbpsStat.Total = LastKbpsData{Time: dsStatsTime, Bytes: stat.Total.OutBytes.Value, Kbps: stat.Total.Kbps.Value}\n\n\t\tlastKbpsStats.DeliveryServices[dsName] = lastKbpsStat\n\t}\n\n\tfor cacheName, outBytes := range cacheOutbytes { // map[enum.CacheName]int64\n\t\tlastCacheKbpsData, ok := lastKbpsStats.Caches[cacheName]\n\t\tif !ok {\n\t\t\tlastKbpsStats.Caches[cacheName] = LastKbpsData{Time: dsStatsTime, Bytes: outBytes, Kbps: 0}\n\t\t\tcontinue\n\t\t}\n\n\t\tif lastCacheKbpsData.Bytes == outBytes {\n\t\t\tcontinue // don't try to kbps, and importantly don't change the time of the last change, if Traffic Server hasn't updated\n\t\t}\n\n\t\tkbps := float64(outBytes-lastCacheKbpsData.Bytes) / dsStatsTime.Sub(lastCacheKbpsData.Time).Seconds()\n\t\tlastKbpsStats.Caches[cacheName] = LastKbpsData{Time: dsStatsTime, Bytes: outBytes, Kbps: kbps}\n\t}\n\n\treturn dsStats, lastKbpsStats, nil\n}", "id": 10033, "concepts": ["map iteration (range loop)", "map lookup", "map update", "map creation", "map deletion", "map iteration (range loop)", "map lookup", "map update", "map creation", "map deletion", "map iteration (range loop)", "map lookup", "map update", "map creation", "map deletion", "map iteration (range loop)", "map lookup", "map update", "map creation", "map deletion", "map iteration (range loop)", "map lookup", "map update", "map creation", "map deletion", "map iteration (range loop)", "map lookup", "map update", "map creation", "map deletion", "map iteration (range loop)", "map lookup", "map update", "map creation", "map deletion", "map iteration (range loop)", "map lookup", "map update", "map creation", "map deletion", "map iteration (range loop)", "map lookup", "map update", "map creation", "map deletion", "map iteration (range loop)", "map lookup", "map update", "map creation", "map deletion", "map iteration (range loop)", "map lookup", "map update", "map creation", "map deletion", "map iteration (range loop)", "map lookup", "map update", "map creation", "map deletion", "map iteration (range loop)", "map lookup", "map update", "map creation", "map deletion", "map iteration (range loop)", "map lookup", "map update", "map creation", "map deletion", "map iteration ("], "_raw_llm_output": "map iteration (range loop), map lookup, map update, map creation, map deletion, map iteration (range loop), map lookup, map update, map creation, map deletion, map iteration (range loop), map lookup, map update, map creation, map deletion, map iteration (range loop), map lookup, map update, map creation, map deletion, map iteration (range loop), map lookup, map update, map creation, map deletion, map iteration (range loop), map lookup, map update, map creation, map deletion, map iteration (range loop), map lookup, map update, map creation, map deletion, map iteration (range loop), map lookup, map update, map creation, map deletion, map iteration (range loop), map lookup, map update, map creation, map deletion, map iteration (range loop), map lookup, map update, map creation, map deletion, map iteration (range loop), map lookup, map update, map creation, map deletion, map iteration (range loop), map lookup, map update, map creation, map deletion, map iteration (range loop), map lookup, map update, map creation, map deletion, map iteration (range loop), map lookup, map update, map creation, map deletion, map iteration ("}
{"seed": "// NewChaincodeEventsCommand creates a new \"fabric chaincode events\" command\nfunc NewChaincodeEventsCommand(settings *environment.Settings) *cobra.Command {\n\tc := EventsCommand{}\n\n\tc.Settings = settings\n\n\tcmd := &cobra.Command{\n\t\tUse:   \"events <chaincode-name>\",\n\t\tShort: \"Listen for chaincode events\",\n\t\tLong:  \"Listen for chaincode-name events\",\n\t\tArgs:  c.ParseArgs(),\n\t\tPreRunE: func(_ *cobra.Command, _ []string) error {\n\t\t\tif err := c.Complete(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif err := c.Validate(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\treturn nil\n\t\t},\n\t\tRunE: func(_ *cobra.Command, _ []string) error {\n\t\t\treturn c.Run()\n\t\t},\n\t}\n\n\tc.AddArg(&c.ChaincodeName)\n\n\tcmd.SetOutput(c.Settings.Streams.Out)\n\n\treturn cmd\n}", "id": 10042, "concepts": ["cobra package usage", "command-line argument parsing", "basic function definition"], "_raw_llm_output": "cobra package usage, command-line argument parsing, basic function definition"}
{"seed": "// DefaultExprNEQ applies the NEQ predicate on the \"default_expr\" field.\nfunc DefaultExprNEQ(v string) predicate.User {\n\treturn predicate.User(sql.FieldNEQ(FieldDefaultExpr, v))\n}", "id": 10046, "concepts": ["sql.FieldNEQ", "sql.FieldEQ", "sql.FieldLT", "sql.FieldGT", "sql.FieldLTE", "sql.FieldGTE", "sql.FieldIN", "sql.FieldNOTIN", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldISNULL", "sql.FieldNOTNULL", "sql.FieldIS", "sql.FieldNOT", "sql.FieldAND", "sql.FieldOR", "sql.FieldNOT", "sql.FieldEQ", "sql.FieldNEQ", "sql.FieldLT", "sql.FieldGT", "sql.FieldLTE", "sql.FieldGTE", "sql.FieldIN", "sql.FieldNOTIN", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldISNULL", "sql.FieldNOTNULL", "sql.FieldIS", "sql.FieldNOT", "sql.FieldAND", "sql.FieldOR", "sql.FieldNOT", "sql.FieldEQ", "sql.FieldNEQ", "sql.FieldLT", "sql.FieldGT", "sql.FieldLTE", "sql.FieldGTE", "sql.FieldIN", "sql.FieldNOTIN", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldISNULL", "sql.FieldNOTNULL", "sql.FieldIS", "sql."], "_raw_llm_output": "sql.FieldNEQ, sql.FieldEQ, sql.FieldLT, sql.FieldGT, sql.FieldLTE, sql.FieldGTE, sql.FieldIN, sql.FieldNOTIN, sql.FieldLike, sql.FieldNotLike, sql.FieldISNULL, sql.FieldNOTNULL, sql.FieldIS, sql.FieldNOT, sql.FieldAND, sql.FieldOR, sql.FieldNOT, sql.FieldEQ, sql.FieldNEQ, sql.FieldLT, sql.FieldGT, sql.FieldLTE, sql.FieldGTE, sql.FieldIN, sql.FieldNOTIN, sql.FieldLike, sql.FieldNotLike, sql.FieldISNULL, sql.FieldNOTNULL, sql.FieldIS, sql.FieldNOT, sql.FieldAND, sql.FieldOR, sql.FieldNOT, sql.FieldEQ, sql.FieldNEQ, sql.FieldLT, sql.FieldGT, sql.FieldLTE, sql.FieldGTE, sql.FieldIN, sql.FieldNOTIN, sql.FieldLike, sql.FieldNotLike, sql.FieldISNULL, sql.FieldNOTNULL, sql.FieldIS, sql."}
{"seed": "// search implements the /search URL endpoint.\n// The search function below is an HTTP handler. It defines a variable called\n// `data` of an anonymous struct type whose fields correspond to the HTTP\n// request parameters. The struct\u2019s field tags specify the parameter names,\n// which are often short and cryptic since space is precious in a URL. The\n// `Unpack` function populates the struct from the request so that the\n// parameters can be accessed conveniently and with an appropriate type.\nfunc search(resp http.ResponseWriter, req *http.Request) {\n\tvar data struct {\n\t\tLabels     []string `http:\"l\"`\n\t\tMaxResults int      `http:\"max\"`\n\t\tExact      bool     `http:\"x\"`\n\t}\n\tdata.MaxResults = 10 // set default\n\t// Unpack populates the struct from the request so that the parameters can\n\t// be accessed conveniently and with an appropriate type.\n\tif err := params.Unpack(req, &data); err != nil {\n\t\thttp.Error(resp, err.Error(), http.StatusBadRequest) // 400\n\t\treturn\n\t}\n\n\t// ...rest of handler...\n\tfmt.Fprintf(resp, \"Search: %+v\\n\", data)\n}", "id": 10051, "concepts": ["HTTP request handling", "struct fields", "struct tags", "URL parameter parsing"], "_raw_llm_output": "HTTP request handling, struct fields, struct tags, URL parameter parsing"}
{"seed": "// NewCreateSSLCertificateRequest calls the generic CreateSSLCertificate builder with application/json body\nfunc NewCreateSSLCertificateRequest(server string, body CreateSSLCertificateJSONRequestBody) (*http.Request, error) {\n\tvar bodyReader io.Reader\n\tbuf, err := json.Marshal(body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tbodyReader = bytes.NewReader(buf)\n\treturn NewCreateSSLCertificateRequestWithBody(server, \"application/json\", bodyReader)\n}", "id": 10053, "concepts": ["io.Reader", "json.Marshal", "http.NewRequest", "http.NewRequestWithContext", "http.Request.WithContext", "http.Request.Body"], "_raw_llm_output": "io.Reader, json.Marshal, http.NewRequest, http.NewRequestWithContext, http.Request.WithContext, http.Request.Body"}
{"seed": "// peekLogLevel decodes 'input' as JSON and looks for key source.log_level. If 'input'\n// is not JSON, peekLogLevel will return an error. If 'input' is JSON but does not\n// contain key source.log_level, peekLogLevel returns \"info\" as default value.\n//\n// Rationale: depending on the Concourse step we are invoked for, the JSON object we get\n// from stdin is different, but it always contains a struct with name \"source\", thus we\n// can peek into it to gather the log level as soon as possible.\nfunc peekLogLevel(input []byte) (string, error) {\n\ttype Peek struct {\n\t\tSource struct {\n\t\t\tLogLevel string `json:\"log_level\"`\n\t\t} `json:\"source\"`\n\t}\n\tvar peek Peek\n\tpeek.Source.LogLevel = \"info\" // default value\n\tif err := json.Unmarshal(input, &peek); err != nil {\n\t\treturn \"\", fmt.Errorf(\"peeking into JSON for log_level: %s\", err)\n\t}\n\n\treturn peek.Source.LogLevel, nil\n}", "id": 10064, "concepts": ["JSON decoding", "struct definition", "JSON key lookup", "error handling"], "_raw_llm_output": "JSON decoding, struct definition, JSON key lookup, error handling"}
{"seed": "// Blink_ is a convenience wrapper for Blink without the attrs argument.\nfunc Blink_(children ...HTML) HTML {\n  return Blink(nil, children...)\n}", "id": 10083, "concepts": ["HTML", "function definition", "function argument", "function return value", "function argument type", "function argument type conversion", "function argument type assertion", "function argument type assertion and type switch", "function argument type assertion and type switch", "function argument type assertion and type switch", "function argument type assertion and type switch", "function argument type assertion and type switch", "function argument type assertion and type switch", "function argument type assertion and type switch", "function argument type assertion and type switch", "function argument type assertion and type switch", "function argument type assertion and type switch", "function argument type assertion and type switch", "function argument type assertion and type switch", "function argument type assertion and type switch", "function argument type assertion and type switch", "function argument type assertion and type switch", "function argument type assertion and type switch", "function argument type assertion and type switch", "function argument type assertion and type switch", "function argument type assertion and type switch", "function argument type assertion and type switch", "function argument type assertion and type switch", "function argument type assertion and type switch", "function argument type assertion and type switch", "function argument type assertion and type switch", "function argument type assertion and type switch", "function argument type assertion and type switch", "function argument type assertion and type switch", "function argument type assertion and type switch", "function argument type assertion and"], "_raw_llm_output": "HTML, function definition, function argument, function return value, function argument type, function argument type conversion, function argument type assertion, function argument type assertion and type switch, function argument type assertion and type switch, function argument type assertion and type switch, function argument type assertion and type switch, function argument type assertion and type switch, function argument type assertion and type switch, function argument type assertion and type switch, function argument type assertion and type switch, function argument type assertion and type switch, function argument type assertion and type switch, function argument type assertion and type switch, function argument type assertion and type switch, function argument type assertion and type switch, function argument type assertion and type switch, function argument type assertion and type switch, function argument type assertion and type switch, function argument type assertion and type switch, function argument type assertion and type switch, function argument type assertion and type switch, function argument type assertion and type switch, function argument type assertion and type switch, function argument type assertion and type switch, function argument type assertion and type switch, function argument type assertion and type switch, function argument type assertion and type switch, function argument type assertion and type switch, function argument type assertion and type switch, function argument type assertion and type switch, function argument type assertion and"}
{"seed": "// BoolToStringWithFormat creates a binding that connects a Bool data item to a String and is\n// presented using the specified format. Changes to the Bool will be pushed to the String and setting\n// the string will parse and set the Bool if the string matches the format and its parse was successful.\n//\n// Since: 2.0\nfunc BoolToStringWithFormat(v Bool, format string) String {\n\tif format == \"%t\" { // Same as not using custom formatting.\n\t\treturn BoolToString(v)\n\t}\n\n\tstr := &stringFromBool{from: v, format: format}\n\tv.AddListener(str)\n\treturn str\n}", "id": 10089, "concepts": ["binding", "string formatting", "boolean conversion", "string parsing"], "_raw_llm_output": "binding, string formatting, boolean conversion, string parsing"}
{"seed": "// Convert converts one entry.Entry into pdata.Logs.\n// To be used in a stateless setting like tests where ease of use is more\n// important than performance or throughput.\nfunc Convert(ent *entry.Entry) pdata.Logs {\n\tpLogs := pdata.NewLogs()\n\tlogs := pLogs.ResourceLogs()\n\n\trls := logs.AppendEmpty()\n\n\tresource := rls.Resource()\n\tresourceAtts := resource.Attributes()\n\tresourceAtts.EnsureCapacity(len(ent.Resource))\n\tfor k, v := range ent.Resource {\n\t\tresourceAtts.InsertString(k, v)\n\t}\n\n\tills := rls.InstrumentationLibraryLogs().AppendEmpty()\n\tlr := ills.Logs().AppendEmpty()\n\tconvertInto(ent, lr)\n\treturn pLogs\n}", "id": 10097, "concepts": ["map iteration", "map capacity", "map key insertion", "map value insertion", "map key lookup", "map value lookup", "map key removal", "map value removal", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", ""], "_raw_llm_output": "map iteration, map capacity, map key insertion, map value insertion, map key lookup, map value lookup, map key removal, map value removal, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check,"}
{"seed": "// unmarshalPostParamsRequestBodyToPostsPostParams builds a value of type\n// *posts.PostParams from a value of type *PostParamsRequestBody.\nfunc unmarshalPostParamsRequestBodyToPostsPostParams(v *PostParamsRequestBody) *posts.PostParams {\n\tres := &posts.PostParams{\n\t\tID:             v.ID,\n\t\tTitle:          v.Title,\n\t\tDescription:    v.Description,\n\t\tScreenImageURL: v.ScreenImageURL,\n\t\tBody:           v.Body,\n\t}\n\n\treturn res\n}", "id": 10102, "concepts": ["struct", "pointer", "interface", "JSON decoding"], "_raw_llm_output": "struct, pointer, interface, JSON decoding"}
{"seed": "// NewMsgFeeBucket returns a bucket for keeping track of fees for each message\n// type. Message fees are indexed by the corresponding message path.\nfunc NewMsgFeeBucket() orm.ModelBucket {\n\tb := orm.NewModelBucket(\"msgfee\", &MsgFee{})\n\treturn migration.NewModelBucket(\"msgfee\", b)\n}", "id": 10111, "concepts": ["ORM", "ORM usage", "database migration"], "_raw_llm_output": "ORM, ORM usage, database migration"}
{"seed": "// NewMockDataCoord creates a new instance of MockDataCoord. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.\n// The first argument is typically a *testing.T value.\nfunc NewMockDataCoord(t interface {\n\tmock.TestingT\n\tCleanup(func())\n}) *MockDataCoord {\n\tmock := &MockDataCoord{}\n\tmock.Mock.Test(t)\n\n\tt.Cleanup(func() { mock.AssertExpectations(t) })\n\n\treturn mock\n}", "id": 10130, "concepts": ["testing interface", "testing.T", "mocking", "testing.Cleanup"], "_raw_llm_output": "testing interface, testing.T, mocking, testing.Cleanup"}
{"seed": "// NewListAlertableEventTypeParamsWithHTTPClient creates a new ListAlertableEventTypeParams object\n// with the default values initialized, and the ability to set a custom HTTPClient for a request\nfunc NewListAlertableEventTypeParamsWithHTTPClient(client *http.Client) *ListAlertableEventTypeParams {\n\tvar ()\n\treturn &ListAlertableEventTypeParams{\n\t\tHTTPClient: client,\n\t}\n}", "id": 10138, "concepts": ["struct initialization", "pointer usage", "HTTPClient usage"], "_raw_llm_output": "struct initialization, pointer usage, HTTPClient usage"}
{"seed": "// IDNotIn applies the NotIn predicate on the ID field.\nfunc IDNotIn(ids ...int) predicate.User {\n\treturn predicate.User(sql.FieldNotIn(FieldID, ids...))\n}", "id": 10149, "concepts": ["sql.FieldNotIn", "sql.Field", "sql.FieldNotIn", "sql.Field", "sql.FieldNotIn", "sql.Field", "sql.FieldNotIn", "sql.Field", "sql.FieldNotIn", "sql.Field", "sql.FieldNotIn", "sql.Field", "sql.FieldNotIn", "sql.Field", "sql.FieldNotIn", "sql.Field", "sql.FieldNotIn", "sql.Field", "sql.FieldNotIn", "sql.Field", "sql.FieldNotIn", "sql.Field", "sql.FieldNotIn", "sql.Field", "sql.FieldNotIn", "sql.Field", "sql.FieldNotIn", "sql.Field", "sql.FieldNotIn", "sql.Field", "sql.FieldNotIn", "sql.Field", "sql.FieldNotIn", "sql.Field", "sql.FieldNotIn", "sql.Field", "sql.FieldNotIn", "sql.Field", "sql.FieldNotIn", "sql.Field", "sql.FieldNotIn", "sql.Field", "sql.FieldNotIn", "sql.Field", "sql.FieldNotIn", "sql.Field", "sql.FieldNotIn", "sql.Field", "sql.FieldNotIn", "sql.Field", "sql.FieldNotIn", "sql.Field", "sql.FieldNotIn", "sql.Field", "sql.FieldNotIn", "sql.Field", "sql.Field"], "_raw_llm_output": "sql.FieldNotIn, sql.Field, sql.FieldNotIn, sql.Field, sql.FieldNotIn, sql.Field, sql.FieldNotIn, sql.Field, sql.FieldNotIn, sql.Field, sql.FieldNotIn, sql.Field, sql.FieldNotIn, sql.Field, sql.FieldNotIn, sql.Field, sql.FieldNotIn, sql.Field, sql.FieldNotIn, sql.Field, sql.FieldNotIn, sql.Field, sql.FieldNotIn, sql.Field, sql.FieldNotIn, sql.Field, sql.FieldNotIn, sql.Field, sql.FieldNotIn, sql.Field, sql.FieldNotIn, sql.Field, sql.FieldNotIn, sql.Field, sql.FieldNotIn, sql.Field, sql.FieldNotIn, sql.Field, sql.FieldNotIn, sql.Field, sql.FieldNotIn, sql.Field, sql.FieldNotIn, sql.Field, sql.FieldNotIn, sql.Field, sql.FieldNotIn, sql.Field, sql.FieldNotIn, sql.Field, sql.FieldNotIn, sql.Field, sql.FieldNotIn, sql.Field, sql.FieldNotIn, sql.Field, sql.Field"}
{"seed": "// drawEllipsis draws \"...\" at the given coords and returns the new x position.\nfunc drawEllipsis(x, y int, fg, bg termbox.Attribute) int {\n\tfor i := 0; i < 3; i++ {\n\t\ttermbox.SetCell(x, y, '.', fg, bg)\n\t\tx++\n\t}\n\treturn x\n}", "id": 10155, "concepts": ["termbox package usage", "termbox.Attribute", "termbox.Cell", "termbox.SetCell"], "_raw_llm_output": "termbox package usage, termbox.Attribute, termbox.Cell, termbox.SetCell"}
{"seed": "// TagName specifies which struct tag provides the flag name to use. If TagName\n// is not specified it defaults to \"flag\".\nfunc TagName(tag string) Option {\n\treturn tagOpt(tag)\n}", "id": 10158, "concepts": ["struct tag", "struct tag field", "struct tag field value", "struct tag field name", "struct tag field type", "struct tag field value type", "struct tag field value conversion", "struct tag field value comparison", "struct tag field value assignment", "struct tag field value assignment to pointer", "struct tag field value assignment to pointer", "struct tag field value assignment to pointer", "struct tag field value assignment to pointer", "struct tag field value assignment to pointer", "struct tag field value assignment to pointer", "struct tag field value assignment to pointer", "struct tag field value assignment to pointer", "struct tag field value assignment to pointer", "struct tag field value assignment to pointer", "struct tag field value assignment to pointer", "struct tag field value assignment to pointer", "struct tag field value assignment to pointer", "struct tag field value assignment to pointer", "struct tag field value assignment to pointer", "struct tag field value assignment to pointer", "struct tag field value assignment to pointer", "struct tag field value assignment to pointer", "struct tag field value assignment to pointer", "struct tag field value assignment to pointer", "struct tag field value assignment to pointer", "struct tag field value assignment to pointer", "struct tag field value assignment to pointer", "struct tag field value assignment to pointer", "struct tag field value assignment to pointer", "struct tag field value assignment to pointer", "struct"], "_raw_llm_output": "struct tag, struct tag field, struct tag field value, struct tag field name, struct tag field type, struct tag field value type, struct tag field value conversion, struct tag field value comparison, struct tag field value assignment, struct tag field value assignment to pointer, struct tag field value assignment to pointer, struct tag field value assignment to pointer, struct tag field value assignment to pointer, struct tag field value assignment to pointer, struct tag field value assignment to pointer, struct tag field value assignment to pointer, struct tag field value assignment to pointer, struct tag field value assignment to pointer, struct tag field value assignment to pointer, struct tag field value assignment to pointer, struct tag field value assignment to pointer, struct tag field value assignment to pointer, struct tag field value assignment to pointer, struct tag field value assignment to pointer, struct tag field value assignment to pointer, struct tag field value assignment to pointer, struct tag field value assignment to pointer, struct tag field value assignment to pointer, struct tag field value assignment to pointer, struct tag field value assignment to pointer, struct tag field value assignment to pointer, struct tag field value assignment to pointer, struct tag field value assignment to pointer, struct tag field value assignment to pointer, struct tag field value assignment to pointer, struct"}
{"seed": "// AuthMiddleware returns the authentication middleware that combines all authentication middlewares\n// that have been registered.\nfunc AuthMiddleware() *Middleware {\n\tm := make([]*Middleware, 0, 1+len(extraAuthMiddlewares))\n\tm = append(m, RequireAuthMiddleware)\n\tm = append(m, extraAuthMiddlewares...)\n\treturn composeMiddleware(m...)\n}", "id": 10159, "concepts": ["function composition", "middleware", "function pointer", "slice", "append"], "_raw_llm_output": "function composition, middleware, function pointer, slice, append"}
{"seed": "// NewViewedBattlestreamingresult initializes viewed result type\n// Battlestreamingresult from result type Battlestreamingresult using the given\n// view.\nfunc NewViewedBattlestreamingresult(res *Battlestreamingresult, view string) *shiritoriviews.Battlestreamingresult {\n\tp := newBattlestreamingresultView(res)\n\treturn &shiritoriviews.Battlestreamingresult{Projected: p, View: \"default\"}\n}", "id": 10170, "concepts": ["type definition", "struct definition", "type conversion", "type assertion"], "_raw_llm_output": "type definition, struct definition, type conversion, type assertion"}
{"seed": "// NewMetricsRecorder initializes a new MetricsRecorder object that uses the\n// given clock.\nfunc NewMetricsRecorder(clock *hlc.Clock) *MetricsRecorder {\n\tmr := &MetricsRecorder{\n\t\tnodeRegistry: metric.NewRegistry(),\n\t}\n\tmr.mu.storeRegistries = make(map[roachpb.StoreID]*metric.Registry)\n\tmr.mu.stores = make(map[roachpb.StoreID]storeMetrics)\n\tmr.mu.clock = clock\n\treturn mr\n}", "id": 10171, "concepts": ["clock", "mutex", "map", "struct"], "_raw_llm_output": "clock, mutex, map, struct"}
{"seed": "// Euclidean calculates the distance for similar\n// users. Since the calculation is smaller for\n// for similarity, the value is inverted to give\n// higher values, and a 1 is added to prevent\n// division by zero.\n//\n// The standard Euclidean distance can be squared in order\n// to place progressively greater weight on objects that\n// are farther apart.\n// Squared Euclidean Distance is not a metric as it does not\n// satisfy the triangle inequality, however it is frequently\n// used in optimization problems in which distances only have to be compared.\n// https://en.wikipedia.org/wiki/Euclidean_distance\nfunc Euclidean(p1 map[string]float64, p2 map[string]float64) float64 {\n\t// Find common items\n\tcommon := map[string]bool{}\n\tfor item, _ := range p1 {\n\t\t_, ok := p2[item]\n\t\tif ok {\n\t\t\tcommon[item] = true\n\t\t}\n\t}\n\tn := float64(len(common))\n\n\t// Nothing in common\n\tif n == 0 {\n\t\treturn 0\n\t}\n\n\tsumSquares := 0.0\n\t// find shared items\n\tfor item, _ := range common {\n\t\t// Add up the squares of all the differences\n\t\tsumSquares += math.Pow(p1[item]-p2[item], 2)\n\t}\n\n\t// Prevent division by zero by adding 1\n\t//return 1 / (1 + math.Sqrt(sumSquares))\n\treturn 1 / (1 + sumSquares)\n}", "id": 10173, "concepts": ["map iteration (range loop)", "map lookup", "map creation", "basic function definition", "math package usage", "math.Pow", "math.Sqrt", "math.Abs", "math.Round"], "_raw_llm_output": "map iteration (range loop), map lookup, map creation, basic function definition, math package usage, math.Pow, math.Sqrt, math.Abs, math.Round"}
{"seed": "// Li_ is a convenience wrapper for Li without the attrs argument.\nfunc Li_(children ...HTML) HTML {\n  return Li(nil, children...)\n}", "id": 10178, "concepts": ["HTML type", "HTML function definition", "HTML function call", "HTML function call with arguments"], "_raw_llm_output": "HTML type, HTML function definition, HTML function call, HTML function call with arguments"}
{"seed": "// FirewallDomainListStatus_Values returns all elements of the FirewallDomainListStatus enum\nfunc FirewallDomainListStatus_Values() []string {\n\treturn []string{\n\t\tFirewallDomainListStatusComplete,\n\t\tFirewallDomainListStatusCompleteImportFailed,\n\t\tFirewallDomainListStatusImporting,\n\t\tFirewallDomainListStatusDeleting,\n\t\tFirewallDomainListStatusUpdating,\n\t}\n}", "id": 10183, "concepts": ["enum", "string comparison"], "_raw_llm_output": "enum, string comparison"}
{"seed": "// BlobIn applies the In predicate on the \"blob\" field.\nfunc BlobIn(vs ...[]byte) predicate.User {\n\treturn predicate.User(sql.FieldIn(FieldBlob, vs...))\n}", "id": 10185, "concepts": ["sql.FieldIn", "predicate.User", "basic function definition"], "_raw_llm_output": "sql.FieldIn, predicate.User, basic function definition"}
{"seed": "// FindRecipeAdditive retrieves a single record by ID with an executor.\n// If selectCols is empty Find will return all columns.\nfunc FindRecipeAdditive(ctx context.Context, exec boil.ContextExecutor, iD int, selectCols ...string) (*RecipeAdditive, error) {\n\trecipeAdditiveObj := &RecipeAdditive{}\n\n\tsel := \"*\"\n\tif len(selectCols) > 0 {\n\t\tsel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), \",\")\n\t}\n\tquery := fmt.Sprintf(\n\t\t\"select %s from \\\"recipe_additive\\\" where \\\"id\\\"=$1\", sel,\n\t)\n\n\tq := queries.Raw(query, iD)\n\n\terr := q.Bind(ctx, exec, recipeAdditiveObj)\n\tif err != nil {\n\t\tif errors.Cause(err) == sql.ErrNoRows {\n\t\t\treturn nil, sql.ErrNoRows\n\t\t}\n\t\treturn nil, errors.Wrap(err, \"models: unable to select from recipe_additive\")\n\t}\n\n\treturn recipeAdditiveObj, nil\n}", "id": 10194, "concepts": ["context", "boil.ContextExecutor", "sql.ErrNoRows", "error handling", "sql.ErrNoRows", "boil.ContextExecutor", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNo"], "_raw_llm_output": "context, boil.ContextExecutor, sql.ErrNoRows, error handling, sql.ErrNoRows, boil.ContextExecutor, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNo"}
{"seed": "// NewUpdateZoneProjectsUsingPUTParamsWithContext creates a new UpdateZoneProjectsUsingPUTParams object\n// with the ability to set a context for a request.\nfunc NewUpdateZoneProjectsUsingPUTParamsWithContext(ctx context.Context) *UpdateZoneProjectsUsingPUTParams {\n\treturn &UpdateZoneProjectsUsingPUTParams{\n\t\tContext: ctx,\n\t}\n}", "id": 10202, "concepts": ["context package usage"], "_raw_llm_output": "context package usage"}
{"seed": "// getZero returns zero value of T.\nfunc getZero[T any]() T {\n\tvar result T\n\treturn result\n}", "id": 10218, "concepts": ["type inference", "type constraint", "type definition", "basic function definition"], "_raw_llm_output": "type inference, type constraint, type definition, basic function definition"}
{"seed": "// TestRenewFailing checks if a contract gets marked as !goodForRenew after\n// failing multiple times in a row.\nfunc TestRenewFailing(t *testing.T) {\n\tif testing.Short() {\n\t\tt.SkipNow()\n\t}\n\trenterDir, err := siatest.TestDir(filepath.Join(t.Name(), \"renter\"))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Create a group for the subtests\n\tgroupParams := siatest.GroupParams{\n\t\tHosts:  3,\n\t\tMiners: 1,\n\t}\n\ttg, err := siatest.NewGroupFromTemplate(groupParams)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to create group: \", err)\n\t}\n\tdefer func() {\n\t\tif err := tg.Close(); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}()\n\n\t// Add a renter with a custom allowance to give it plenty of time to renew\n\t// the contract later.\n\trenterParams := node.Renter(renterDir)\n\trenterParams.Allowance = siatest.DefaultAllowance\n\trenterParams.Allowance.Hosts = uint64(len(tg.Hosts()) - 1)\n\trenterParams.Allowance.Period = 100\n\trenterParams.Allowance.RenewWindow = 50\n\tif err = tg.AddNodes(renterParams); err != nil {\n\t\tt.Fatal(err)\n\t}\n\trenter := tg.Renters()[0]\n\n\t// All the contracts of the renter should be goodForRenew.\n\trcg, err := renter.RenterContractsGet()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfor _, c := range rcg.Contracts {\n\t\tif !c.GoodForRenew {\n\t\t\tt.Fatal(\"renter got a contract that is !goodForRenew\")\n\t\t}\n\t}\n\tif uint64(len(rcg.Contracts)) != renterParams.Allowance.Hosts {\n\t\tfor i, c := range rcg.Contracts {\n\t\t\tfmt.Println(i, c.HostPublicKey)\n\t\t}\n\t\tt.Fatalf(\"renter had %v contracts but should have %v\",\n\t\t\tlen(rcg.Contracts), renterParams.Allowance.Hosts)\n\t}\n\n\t// Create a map of the hosts in the group.\n\thostMap := make(map[string]*siatest.TestNode)\n\tfor _, host := range tg.Hosts() {\n\t\tpk, err := host.HostPublicKey()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\thostMap[pk.String()] = host\n\t}\n\t// Lock the wallet of one of the used hosts to make the renew fail.\n\tfor _, c := range rcg.Contracts {\n\t\tif host, used := hostMap[c.HostPublicKey.String()]; used {\n\t\t\tif err := host.WalletLockPost(); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\t// Wait until the contract is supposed to be renewed.\n\tcg, err := renter.ConsensusGet()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\trg, err := renter.RenterGet()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tminer := tg.Miners()[0]\n\tblockHeight := cg.Height\n\tfor blockHeight+rg.Settings.Allowance.RenewWindow < rcg.Contracts[0].EndHeight {\n\t\tif err := miner.MineBlock(); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tblockHeight++\n\t}\n\n\t// contracts should still be goodForRenew.\n\trcg, err = renter.RenterContractsGet()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfor _, c := range rcg.Contracts {\n\t\tif !c.GoodForRenew {\n\t\t\tt.Fatal(\"renter got a contract that is !goodForRenew\")\n\t\t}\n\t}\n\n\t// mine enough blocks to reach the second half of the renew window.\n\tfor ; blockHeight+rg.Settings.Allowance.RenewWindow/2 < rcg.Contracts[0].EndHeight; blockHeight++ {\n\t\tif err := miner.MineBlock(); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\n\t// We should be within the second half of the renew window now. We keep\n\t// mining blocks until the host with the locked wallet has been replaced.\n\t// This should happen before we reach the endHeight of the contracts.\n\treplaced := false\n\terr = build.Retry(int(rcg.Contracts[0].EndHeight-blockHeight), 5*time.Second, func() error {\n\t\t// contract should be !goodForRenew now.\n\t\trcg, err = renter.RenterContractsGet()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tnotGoodForRenew := 0\n\t\tgoodForRenew := 0\n\t\tfor _, c := range rcg.Contracts {\n\t\t\tif !c.GoodForRenew {\n\t\t\t\tnotGoodForRenew++\n\t\t\t} else {\n\t\t\t\tgoodForRenew++\n\t\t\t}\n\t\t}\n\t\tif !replaced && notGoodForRenew != 1 && goodForRenew != 1 {\n\t\t\treturn fmt.Errorf(\"there should be exactly 1 contract that is !goodForRenew but was %v\",\n\t\t\t\tnotGoodForRenew)\n\t\t}\n\t\treplaced = true\n\t\tif replaced && notGoodForRenew != 1 && goodForRenew != 2 {\n\t\t\treturn fmt.Errorf(\"contract was set to !goodForRenew but hasn't been replaced yet\")\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}", "id": 10219, "concepts": ["testing", "testing.T", "testing.B", "testing.SkipNow", "testing.Short", "testing.Parallel", "testing.Main", "testing.Benchmark", "testing.T.Fatal", "testing.T.SkipNow", "testing.T.Run", "testing.T.Skip", "testing.T.Logf", "testing.T.Helper", "testing.T.Error", "testing.T.Errorf", "testing.T.Fatalf", "testing.T.Log", "testing.T.FailNow", "testing.T.Fail", "testing.T.FailNow", "testing.T.FailNow", "testing.T.FailNow", "testing.T.FailNow", "testing.T.FailNow", "testing.T.FailNow", "testing.T.FailNow", "testing.T.FailNow", "testing.T.FailNow", "testing.T.FailNow", "testing.T.FailNow", "testing.T.FailNow", "testing.T.FailNow", "testing.T.FailNow", "testing.T.FailNow", "testing.T.FailNow", "testing.T.FailNow", "testing.T.FailNow", "testing.T.FailNow", "testing.T.FailNow", "testing.T.FailNow", "testing.T"], "_raw_llm_output": "testing, testing.T, testing.B, testing.SkipNow, testing.Short, testing.Parallel, testing.Main, testing.Benchmark, testing.T.Fatal, testing.T.SkipNow, testing.T.Run, testing.T.Skip, testing.T.Logf, testing.T.Helper, testing.T.Error, testing.T.Errorf, testing.T.Fatalf, testing.T.Log, testing.T.FailNow, testing.T.Fail, testing.T.FailNow, testing.T.FailNow, testing.T.FailNow, testing.T.FailNow, testing.T.FailNow, testing.T.FailNow, testing.T.FailNow, testing.T.FailNow, testing.T.FailNow, testing.T.FailNow, testing.T.FailNow, testing.T.FailNow, testing.T.FailNow, testing.T.FailNow, testing.T.FailNow, testing.T.FailNow, testing.T.FailNow, testing.T.FailNow, testing.T.FailNow, testing.T.FailNow, testing.T.FailNow, testing.T"}
{"seed": "// RandomKerlHashTrytesInsecure returns random hash trytes.\n// Since the result mimics a Kerl hash, the last trit will be zero.\nfunc RandomKerlHashTrytesInsecure() trinary.Hash {\n\t// Rand needs to be locked: https://github.com/golang/go/issues/3611\n\trandLock.Lock()\n\tdefer randLock.Unlock()\n\n\ttrits := make(trinary.Trits, consts.HashTrinarySize)\n\tfor i := 0; i < consts.HashTrinarySize-1; i++ {\n\t\ttrits[i] = int8(seededRand.Intn(consts.TrinaryRadix) + consts.MinTritValue)\n\t}\n\treturn trinary.MustTritsToTrytes(trits)\n}", "id": 10225, "concepts": ["trinary package usage", "locking", "random number generation"], "_raw_llm_output": "trinary package usage, locking, random number generation"}
{"seed": "// NewAccessGovernanceCPClientWithOboToken Creates a new default AccessGovernanceCP client with the given configuration provider.\n// The obotoken will be added to default headers and signed; the configuration provider will be used for the signer\n//\n//\tas well as reading the region\nfunc NewAccessGovernanceCPClientWithOboToken(configProvider common.ConfigurationProvider, oboToken string) (client AccessGovernanceCPClient, err error) {\n\tbaseClient, err := common.NewClientWithOboToken(configProvider, oboToken)\n\tif err != nil {\n\t\treturn client, err\n\t}\n\n\treturn newAccessGovernanceCPClientFromBaseClient(baseClient, configProvider)\n}", "id": 10226, "concepts": ["configuration provider", "default headers", "signer", "region"], "_raw_llm_output": "configuration provider, default headers, signer, region"}
{"seed": "// DecodeUnfollowResponse returns a decoder for responses returned by the\n// following unfollow endpoint. restoreBody controls whether the response body\n// should be restored after having been read.\n// DecodeUnfollowResponse may return the following errors:\n//   - \"unauthorized\" (type *goa.ServiceError): http.StatusUnauthorized\n//   - \"forbidden\" (type *goa.ServiceError): http.StatusForbidden\n//   - \"not-found\" (type *goa.ServiceError): http.StatusNotFound\n//   - \"bad-request\" (type *goa.ServiceError): http.StatusBadRequest\n//   - error: internal error\nfunc DecodeUnfollowResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {\n\treturn func(resp *http.Response) (interface{}, error) {\n\t\tif restoreBody {\n\t\t\tb, err := ioutil.ReadAll(resp.Body)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tresp.Body = ioutil.NopCloser(bytes.NewBuffer(b))\n\t\t\tdefer func() {\n\t\t\t\tresp.Body = ioutil.NopCloser(bytes.NewBuffer(b))\n\t\t\t}()\n\t\t} else {\n\t\t\tdefer resp.Body.Close()\n\t\t}\n\t\tswitch resp.StatusCode {\n\t\tcase http.StatusNoContent:\n\t\t\treturn nil, nil\n\t\tcase http.StatusUnauthorized:\n\t\t\tvar (\n\t\t\t\tbody UnfollowUnauthorizedResponseBody\n\t\t\t\terr  error\n\t\t\t)\n\t\t\terr = decoder(resp).Decode(&body)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, goahttp.ErrDecodingError(\"following\", \"unfollow\", err)\n\t\t\t}\n\t\t\terr = ValidateUnfollowUnauthorizedResponseBody(&body)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, goahttp.ErrValidationError(\"following\", \"unfollow\", err)\n\t\t\t}\n\t\t\treturn nil, NewUnfollowUnauthorized(&body)\n\t\tcase http.StatusForbidden:\n\t\t\tvar (\n\t\t\t\tbody UnfollowForbiddenResponseBody\n\t\t\t\terr  error\n\t\t\t)\n\t\t\terr = decoder(resp).Decode(&body)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, goahttp.ErrDecodingError(\"following\", \"unfollow\", err)\n\t\t\t}\n\t\t\terr = ValidateUnfollowForbiddenResponseBody(&body)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, goahttp.ErrValidationError(\"following\", \"unfollow\", err)\n\t\t\t}\n\t\t\treturn nil, NewUnfollowForbidden(&body)\n\t\tcase http.StatusNotFound:\n\t\t\tvar (\n\t\t\t\tbody UnfollowNotFoundResponseBody\n\t\t\t\terr  error\n\t\t\t)\n\t\t\terr = decoder(resp).Decode(&body)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, goahttp.ErrDecodingError(\"following\", \"unfollow\", err)\n\t\t\t}\n\t\t\terr = ValidateUnfollowNotFoundResponseBody(&body)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, goahttp.ErrValidationError(\"following\", \"unfollow\", err)\n\t\t\t}\n\t\t\treturn nil, NewUnfollowNotFound(&body)\n\t\tcase http.StatusBadRequest:\n\t\t\tvar (\n\t\t\t\tbody UnfollowBadRequestResponseBody\n\t\t\t\terr  error\n\t\t\t)\n\t\t\terr = decoder(resp).Decode(&body)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, goahttp.ErrDecodingError(\"following\", \"unfollow\", err)\n\t\t\t}\n\t\t\terr = ValidateUnfollowBadRequestResponseBody(&body)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, goahttp.ErrValidationError(\"following\", \"unfollow\", err)\n\t\t\t}\n\t\t\treturn nil, NewUnfollowBadRequest(&body)\n\t\tdefault:\n\t\t\tbody, _ := ioutil.ReadAll(resp.Body)\n\t\t\treturn nil, goahttp.ErrInvalidResponse(\"following\", \"unfollow\", resp.StatusCode, string(body))\n\t\t}\n\t}\n}", "id": 10235, "concepts": ["http.StatusNoContent", "http.StatusUnauthorized", "http.StatusForbidden", "http.StatusNotFound", "http.StatusBadRequest", "http.Response.StatusCode", "http.Response.Body", "io.ReadAll", "goahttp.Decoder", "goahttp.ErrDecodingError", "goahttp.ErrInvalidResponse", "goahttp.ErrValidationError", "goahttp.ErrInvalidResponse", "goahttp.ErrInvalidResponse", "goahttp.ErrInvalidResponse", "goahttp.ErrInvalidResponse", "goahttp.ErrInvalidResponse", "goahttp.ErrInvalidResponse", "goahttp.ErrInvalidResponse", "goahttp.ErrInvalidResponse", "goahttp.ErrInvalidResponse", "goahttp.ErrInvalidResponse", "goahttp.ErrInvalidResponse", "goahttp.ErrInvalidResponse", "goahttp.ErrInvalidResponse", "goahttp.ErrInvalidResponse", "goahttp.ErrInvalidResponse", "goahttp.ErrInvalidResponse", "goahttp.ErrInvalidResponse", "goahttp.ErrInvalidResponse", "goahttp.ErrInvalidResponse", "goahttp.ErrInvalidResponse", "goahttp.ErrInvalidResponse", "goahttp.ErrInvalidResponse", "goahttp.ErrInvalidResponse", ""], "_raw_llm_output": "http.StatusNoContent, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusBadRequest, http.Response.StatusCode, http.Response.Body, io.ReadAll, goahttp.Decoder, goahttp.ErrDecodingError, goahttp.ErrInvalidResponse, goahttp.ErrValidationError, goahttp.ErrInvalidResponse, goahttp.ErrInvalidResponse, goahttp.ErrInvalidResponse, goahttp.ErrInvalidResponse, goahttp.ErrInvalidResponse, goahttp.ErrInvalidResponse, goahttp.ErrInvalidResponse, goahttp.ErrInvalidResponse, goahttp.ErrInvalidResponse, goahttp.ErrInvalidResponse, goahttp.ErrInvalidResponse, goahttp.ErrInvalidResponse, goahttp.ErrInvalidResponse, goahttp.ErrInvalidResponse, goahttp.ErrInvalidResponse, goahttp.ErrInvalidResponse, goahttp.ErrInvalidResponse, goahttp.ErrInvalidResponse, goahttp.ErrInvalidResponse, goahttp.ErrInvalidResponse, goahttp.ErrInvalidResponse, goahttp.ErrInvalidResponse, goahttp.ErrInvalidResponse,"}
{"seed": "// Video_ is a convenience wrapper for Video without the attrs argument.\nfunc Video_(children ...HTML) HTML {\n  return Video(nil, children...)\n}", "id": 10272, "concepts": ["variadic function", "HTML struct", "HTML struct composition"], "_raw_llm_output": "variadic function, HTML struct, HTML struct composition"}
{"seed": "// CreateStatisticDefinition create a new entity statistic definition.\n// https://api.playfab.com/Documentation/Leaderboards/method/CreateStatisticDefinition\nfunc CreateStatisticDefinition(settings *playfab.Settings, postData *CreateStatisticDefinitionRequestModel, entityToken string) (*EmptyResponseModel, error) {\n    if entityToken == \"\" {\n        return nil, playfab.NewCustomError(\"entityToken should not be an empty string\", playfab.ErrorGeneric)\n    }\n    b, errMarshal := json.Marshal(postData)\n    if errMarshal != nil {\n        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)\n    }\n\n    sourceMap, err := playfab.Request(settings, b, \"/Statistic/CreateStatisticDefinition\", \"X-EntityToken\", entityToken)\n    if err != nil {\n        return nil, err\n    }\n    \n    result := &EmptyResponseModel{}\n\n    config := mapstructure.DecoderConfig{\n        DecodeHook: playfab.StringToDateTimeHook,\n        Result:     result,\n    }\n    \n    decoder, errDecoding := mapstructure.NewDecoder(&config)\n    if errDecoding != nil {\n        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)\n    }\n   \n    errDecoding = decoder.Decode(sourceMap)\n    if errDecoding != nil {\n        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)\n    }\n\n    return result, nil\n}", "id": 10274, "concepts": ["JSON marshalling", "JSON decoding", "mapstructure package usage", "playfab API usage"], "_raw_llm_output": "JSON marshalling, JSON decoding, mapstructure package usage, playfab API usage"}
{"seed": "// NewSynchronizeUserV1Params creates a new SynchronizeUserV1Params object\n// with the default values initialized.\nfunc NewSynchronizeUserV1Params() *SynchronizeUserV1Params {\n\tvar ()\n\treturn &SynchronizeUserV1Params{\n\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 10285, "concepts": ["struct initialization", "pointer handling", "default values"], "_raw_llm_output": "struct initialization, pointer handling, default values"}
{"seed": "// newRouteGroup creates a new RouteGroup with the given path prefix, router, and handlers.\nfunc newRouteGroup(prefix string, router *Router, handlers []Handler) *RouteGroup {\n\treturn &RouteGroup{\n\t\tprefix:   prefix,\n\t\trouter:   router,\n\t\thandlers: handlers,\n\t}\n}", "id": 10287, "concepts": ["struct definition", "method definition", "pointer usage"], "_raw_llm_output": "struct definition, method definition, pointer usage"}
{"seed": "// DescriptionNotIn applies the NotIn predicate on the \"description\" field.\nfunc DescriptionNotIn(vs ...string) predicate.User {\n\treturn predicate.User(sql.FieldNotIn(FieldDescription, vs...))\n}", "id": 10295, "concepts": ["sql package usage", "sql.FieldNotIn", "predicate.User"], "_raw_llm_output": "sql package usage, sql.FieldNotIn, predicate.User"}
{"seed": "// MixedStringHasSuffix applies the HasSuffix predicate on the \"mixed_string\" field.\nfunc MixedStringHasSuffix(v string) predicate.User {\n\treturn predicate.User(sql.FieldHasSuffix(FieldMixedString, v))\n}", "id": 10310, "concepts": ["predicate", "sql.FieldHasSuffix"], "_raw_llm_output": "predicate, sql.FieldHasSuffix"}
{"seed": "// V reports whether verbosity at the call site is at least the requested level.\n// The returned value is a boolean of type Verbosity, which implements Info, Infoln\n// and Infof. These methods will write to the Info log if called.\n// Thus, one may write either\n//\tif cloudglog.V(2) { cloudglog.Info(\"log this\") }\n// or\n//\tcloudglog.V(2).Info(\"log this\")\n// The second form is shorter but the first is cheaper if logging is off because it does\n// not evaluate its arguments.\nfunc V(level int) Verbosity {\n\t// This function tries hard to be cheap unless there's work to do.\n\t// The fast path is two atomic loads and compares.\n\n\t// Here is a cheap but safe test to see if V logging is enabled globally.\n\tif LogLevel >= level {\n\t\treturn Verbosity(true)\n\t}\n\n\treturn Verbosity(false)\n}", "id": 10312, "concepts": ["type conversion", "boolean type", "boolean type conversion", "boolean type comparison", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean type usage", "boolean"], "_raw_llm_output": "type conversion, boolean type, boolean type conversion, boolean type comparison, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean type usage, boolean"}
{"seed": "// IsNo returns true if the response is some form of no or n\nfunc IsNo(s string) bool {\n\toptions := []string{\"no\", \"n\"}\n\tok, _ := validateOptions(strings.ToLower(s), options)\n\treturn ok\n}", "id": 10314, "concepts": ["string manipulation", "string comparison", "basic function definition", "basic function return"], "_raw_llm_output": "string manipulation, string comparison, basic function definition, basic function return"}
{"seed": "// GetVariantKeyChromStartPos get the CHROM + START POS encoding from VariantKey.\nfunc GetVariantKeyChromStartPos(vk uint64) uint64 {\n\treturn uint64(C.get_variantkey_chrom_startpos(C.uint64_t(vk)))\n}", "id": 10324, "concepts": ["C interop", "CGO", "bitwise operations", "bit shifting"], "_raw_llm_output": "C interop, CGO, bitwise operations, bit shifting"}
{"seed": "// Logger provides a function to set the logger option.\nfunc Logger(l log.Logger) Option {\n\treturn func(o *Options) {\n\t\to.Logger = l\n\t}\n}", "id": 10325, "concepts": ["function composition", "function options", "function composition"], "_raw_llm_output": "function composition, function options, function composition"}
{"seed": "// UpdatedAtIsNil applies the IsNil predicate on the \"updated_at\" field.\nfunc UpdatedAtIsNil() predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.IsNull(s.C(FieldUpdatedAt)))\n\t})\n}", "id": 10326, "concepts": ["sql.Selector", "sql.IsNull", "sql.C", "sql.Where", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull"], "_raw_llm_output": "sql.Selector, sql.IsNull, sql.C, sql.Where, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull"}
{"seed": "// wmRT12 covers resizable/tablet: hide Shelf behavior.\n// Expected behavior is defined in: go/arc-wm-r RT12: resizable/tablet: hide Shelf.\nfunc wmRT12(ctx context.Context, tconn *chrome.TestConn, a *arc.ARC, d *ui.Device) error {\n\t// landscape | undefined activities.\n\tluActivities := []wm.TabletLaunchActivityInfo{\n\t\twm.TabletLaunchActivityInfo{\n\t\t\tActivityName: wm.ResizableLandscapeActivity,\n\t\t\tDesiredDO:    display.OrientationLandscapePrimary,\n\t\t},\n\t\twm.TabletLaunchActivityInfo{\n\t\t\tActivityName: wm.ResizableUnspecifiedActivity,\n\t\t\tDesiredDO:    display.OrientationLandscapePrimary,\n\t\t},\n\t}\n\n\tif err := wm.TabletShelfHideShowHelper(ctx, tconn, a, d, luActivities, wm.CheckMaximizeResizable); err != nil {\n\t\treturn err\n\t}\n\n\t// portrait | undefined activities.\n\tpuActivities := []wm.TabletLaunchActivityInfo{\n\t\twm.TabletLaunchActivityInfo{\n\t\t\tActivityName: wm.ResizablePortraitActivity,\n\t\t\tDesiredDO:    display.OrientationPortraitPrimary,\n\t\t},\n\t\twm.TabletLaunchActivityInfo{\n\t\t\tActivityName: wm.ResizableUnspecifiedActivity,\n\t\t\tDesiredDO:    display.OrientationPortraitPrimary,\n\t\t},\n\t}\n\n\treturn wm.TabletShelfHideShowHelper(ctx, tconn, a, d, puActivities, wm.CheckMaximizeResizable)\n}", "id": 10342, "concepts": ["error handling (idiomatic if err != nil)", "error handling (errors.As)", "error handling (errors.Is)", "error handling (errors.New)", "error handling (error wrapping)", "error handling (error chaining)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error"], "_raw_llm_output": "error handling (idiomatic if err != nil), error handling (errors.As), error handling (errors.Is), error handling (errors.New), error handling (error wrapping), error handling (error chaining), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error"}
{"seed": "// MixedString applies equality check predicate on the \"mixed_string\" field. It's identical to MixedStringEQ.\nfunc MixedString(v string) predicate.User {\n\treturn predicate.User(sql.FieldEQ(FieldMixedString, v))\n}", "id": 10345, "concepts": ["sql.FieldEQ", "sql.FieldNEQ", "sql.FieldLT", "sql.FieldLTE", "sql.FieldGT", "sql.FieldGTE", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldBetween", "sql.FieldNotBetween", "sql.FieldIsNull", "sql.FieldIsNotNull", "sql.FieldExists", "sql.FieldNotExists", "sql.FieldRaw", "sql.FieldRawEQ", "sql.FieldRawNEQ", "sql.FieldRawLT", "sql.FieldRawLTE", "sql.FieldRawGT", "sql.FieldRawGTE", "sql.FieldRawLike", "sql.FieldRawNotLike", "sql.FieldRawIn", "sql.FieldRawNotIn", "sql.FieldRawBetween", "sql.FieldRawNotBetween", "sql.FieldRawIsNull", "sql.FieldRawIsNotNull", "sql.FieldRawExists", "sql.FieldRawNotExists", "sql.FieldRawRaw", "sql.FieldRawRawEQ", "sql.FieldRawRawNEQ", "sql.FieldRawRawLT", "sql.FieldRawRawLTE", "sql.FieldRawRawGT", "sql.FieldRawRawGTE", "sql.FieldRawRawLike", "sql.FieldRawRawNotLike"], "_raw_llm_output": "sql.FieldEQ, sql.FieldNEQ, sql.FieldLT, sql.FieldLTE, sql.FieldGT, sql.FieldGTE, sql.FieldLike, sql.FieldNotLike, sql.FieldIn, sql.FieldNotIn, sql.FieldBetween, sql.FieldNotBetween, sql.FieldIsNull, sql.FieldIsNotNull, sql.FieldExists, sql.FieldNotExists, sql.FieldRaw, sql.FieldRawEQ, sql.FieldRawNEQ, sql.FieldRawLT, sql.FieldRawLTE, sql.FieldRawGT, sql.FieldRawGTE, sql.FieldRawLike, sql.FieldRawNotLike, sql.FieldRawIn, sql.FieldRawNotIn, sql.FieldRawBetween, sql.FieldRawNotBetween, sql.FieldRawIsNull, sql.FieldRawIsNotNull, sql.FieldRawExists, sql.FieldRawNotExists, sql.FieldRawRaw, sql.FieldRawRawEQ, sql.FieldRawRawNEQ, sql.FieldRawRawLT, sql.FieldRawRawLTE, sql.FieldRawRawGT, sql.FieldRawRawGTE, sql.FieldRawRawLike, sql.FieldRawRawNotLike"}
{"seed": "// Verify checks a signature generated by Sign.\n//\n// The caller provides the message, anonymity set, and linkage scope\n// with which the signature was purportedly produced.\n// If the signature is a valid linkable signature (linkScope != nil),\n// this function returns a linkage tag that uniquely corresponds\n// to the signer within the given linkScope.\n// If the signature is a valid unlinkable signature (linkScope == nil),\n// returns an empty but non-nil byte-slice instead of a linkage tag on success.\n// Returns a nil linkage tag and an error if the signature is invalid.\nfunc Verify(suite abstract.Suite, message []byte, anonymitySet Set,\n\tlinkScope []byte, signatureBuffer []byte) ([]byte, error) {\n\n\tn := len(anonymitySet)              // anonymity set size\n\tL := []abstract.Point(anonymitySet) // public keys in ring\n\n\t// Decode the signature\n\tbuf := bytes.NewBuffer(signatureBuffer)\n\tvar linkBase, linkTag abstract.Point\n\tsig := lSig{}\n\tsig.S = make([]abstract.Scalar, n)\n\tif linkScope != nil { // linkable ring signature\n\t\tif err := suite.Read(buf, &sig); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tlinkStream := suite.Cipher(linkScope)\n\t\tlinkBase, _ = suite.Point().Pick(nil, linkStream)\n\t\tlinkTag = sig.Tag\n\t} else { // unlinkable ring signature\n\t\tif err := suite.Read(buf, &sig.C0); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif err := suite.Read(buf, &sig.S); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Pre-hash the ring-position-invariant parameters to H1.\n\tH1pre := signH1pre(suite, linkScope, linkTag, message)\n\n\t// Verify the signature\n\tvar P, PG, PH abstract.Point\n\tP = suite.Point()\n\tPG = suite.Point()\n\tif linkScope != nil {\n\t\tPH = suite.Point()\n\t}\n\ts := sig.S\n\tci := sig.C0\n\tfor i := 0; i < n; i++ {\n\t\tPG.Add(PG.Mul(nil, s[i]), P.Mul(L[i], ci))\n\t\tif linkScope != nil {\n\t\t\tPH.Add(PH.Mul(linkBase, s[i]), P.Mul(linkTag, ci))\n\t\t}\n\t\tci = signH1(suite, H1pre, PG, PH)\n\t}\n\tif !ci.Equal(sig.C0) {\n\t\treturn nil, errors.New(\"invalid signature\")\n\t}\n\n\t// Return the re-encoded linkage tag, for uniqueness checking\n\tif linkScope != nil {\n\t\ttag, _ := linkTag.MarshalBinary()\n\t\treturn tag, nil\n\t} else {\n\t\treturn []byte{}, nil\n\t}\n}", "id": 10347, "concepts": ["interface usage", "struct definition", "function definition", "pointer usage", "function return value", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter"], "_raw_llm_output": "interface usage, struct definition, function definition, pointer usage, function return value, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter"}
{"seed": "// GetKeyLifecycleStateEnumStringValues Enumerates the set of values in String for KeyLifecycleStateEnum\nfunc GetKeyLifecycleStateEnumStringValues() []string {\n\treturn []string{\n\t\t\"CREATING\",\n\t\t\"ENABLING\",\n\t\t\"ENABLED\",\n\t\t\"DISABLING\",\n\t\t\"DISABLED\",\n\t\t\"DELETING\",\n\t\t\"DELETED\",\n\t\t\"PENDING_DELETION\",\n\t\t\"SCHEDULING_DELETION\",\n\t\t\"CANCELLING_DELETION\",\n\t\t\"UPDATING\",\n\t\t\"BACKUP_IN_PROGRESS\",\n\t\t\"RESTORING\",\n\t}\n}", "id": 10357, "concepts": ["string formatting", "fmt package usage"], "_raw_llm_output": "string formatting, fmt package usage"}
{"seed": "// marshalDeletion creates a mutation to represent the deletion of the\n// specified document.\nfunc marshalDeletion(id *firestore.DocumentRef, updatedAt time.Time) (types.Mutation, error) {\n\tkey, err := json.Marshal([]string{id.ID})\n\tif err != nil {\n\t\treturn types.Mutation{}, errors.WithStack(err)\n\t}\n\n\treturn types.Mutation{\n\t\tKey:  key,\n\t\tTime: hlc.New(updatedAt.UnixNano(), 0),\n\t}, nil\n}", "id": 10371, "concepts": ["firestore package usage", "JSON marshaling", "time package usage", "error handling (errors.WithStack)", "time.UnixNano"], "_raw_llm_output": "firestore package usage, JSON marshaling, time package usage, error handling (errors.WithStack), time.UnixNano"}
{"seed": "// Label_ is a convenience wrapper for Label without the attrs argument.\nfunc Label_(children ...HTML) HTML {\n  return Label(nil, children...)\n}", "id": 10372, "concepts": ["function definition", "variadic function", "function argument handling"], "_raw_llm_output": "function definition, variadic function, function argument handling"}
{"seed": "// IsValuePtr reports whether v is a ptr type.\nfunc IsValuePtr(v reflect.Value) bool {\n\treturn v.Kind() == reflect.Ptr\n}", "id": 10384, "concepts": ["reflect package usage", "reflect.Value", "pointer handling"], "_raw_llm_output": "reflect package usage, reflect.Value, pointer handling"}
{"seed": "// LatestHeroScoreGT applies the GT predicate on the \"latest_hero_score\" field.\nfunc LatestHeroScoreGT(v int) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.GT(s.C(FieldLatestHeroScore), v))\n\t})\n}", "id": 10394, "concepts": ["sql package usage", "sql.Selector", "sql.C", "sql.GT", "sql.Where", "sql.Predicate", "sql.Field", "sql.Query", "sql.QueryFunc", "sql.QueryFunc", "sql.QueryFunc", "sql.QueryFunc", "sql.QueryFunc", "sql.QueryFunc", "sql.QueryFunc", "sql.QueryFunc", "sql.QueryFunc", "sql.QueryFunc", "sql.QueryFunc", "sql.QueryFunc", "sql.QueryFunc", "sql.QueryFunc", "sql.QueryFunc", "sql.QueryFunc", "sql.QueryFunc", "sql.QueryFunc", "sql.QueryFunc", "sql.QueryFunc", "sql.QueryFunc", "sql.QueryFunc", "sql.QueryFunc", "sql.QueryFunc", "sql.QueryFunc", "sql.QueryFunc", "sql.QueryFunc", "sql.QueryFunc", "sql.QueryFunc", "sql.QueryFunc", "sql.QueryFunc", "sql.QueryFunc", "sql.QueryFunc", "sql.QueryFunc", "sql.QueryFunc", "sql.QueryFunc", "sql.QueryFunc", "sql.QueryFunc", "sql.QueryFunc", "sql.QueryFunc", "sql.QueryFunc", "sql.QueryFunc", "sql.QueryFunc", "sql.QueryFunc", "sql.Query"], "_raw_llm_output": "sql package usage, sql.Selector, sql.C, sql.GT, sql.Where, sql.Predicate, sql.Field, sql.Query, sql.QueryFunc, sql.QueryFunc, sql.QueryFunc, sql.QueryFunc, sql.QueryFunc, sql.QueryFunc, sql.QueryFunc, sql.QueryFunc, sql.QueryFunc, sql.QueryFunc, sql.QueryFunc, sql.QueryFunc, sql.QueryFunc, sql.QueryFunc, sql.QueryFunc, sql.QueryFunc, sql.QueryFunc, sql.QueryFunc, sql.QueryFunc, sql.QueryFunc, sql.QueryFunc, sql.QueryFunc, sql.QueryFunc, sql.QueryFunc, sql.QueryFunc, sql.QueryFunc, sql.QueryFunc, sql.QueryFunc, sql.QueryFunc, sql.QueryFunc, sql.QueryFunc, sql.QueryFunc, sql.QueryFunc, sql.QueryFunc, sql.QueryFunc, sql.QueryFunc, sql.QueryFunc, sql.QueryFunc, sql.QueryFunc, sql.QueryFunc, sql.QueryFunc, sql.QueryFunc, sql.QueryFunc, sql.QueryFunc, sql.Query"}
{"seed": "// NewOfficialModuleProxy builds a module database backed by the official module\n// proxy at https://proxy.golang.org, using the given client for requests.\nfunc NewOfficialModuleProxy(c *http.Client) ModuleDatabase {\n\treturn NewModuleProxy(c, &url.URL{\n\t\tScheme: \"https\",\n\t\tHost:   \"proxy.golang.org\",\n\t})\n}", "id": 10396, "concepts": ["module proxy", "http client usage", "URL parsing"], "_raw_llm_output": "module proxy, http client usage, URL parsing"}
{"seed": "// CheckIPInNetwork checks if the specified ip is contained in any of the provided networks\nfunc CheckIPInNetwork(ip net.IP, networks []*net.IPNet) bool {\n\tfor _, network := range networks {\n\t\tif containsIP := network.Contains(ip); containsIP {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}", "id": 10402, "concepts": ["net.IP", "net.IPNet", "net.ParseIP", "net.ParseCIDR", "net.IP.String", "net.IPNet.Contains"], "_raw_llm_output": "net.IP, net.IPNet, net.ParseIP, net.ParseCIDR, net.IP.String, net.IPNet.Contains"}
{"seed": "// IsNamespaceNotFoundErr returns true if the namespace wasn't found for a k8s client operation.\nfunc IsNamespaceNotFoundErr(err error) bool {\n\tse, isStatusError := err.(*errors.StatusError)\n\tif !isStatusError {\n\t\treturn false\n\t}\n\n\treturn errors.IsNotFound(err) && se.Status().Details.Kind == \"namespaces\"\n}", "id": 10417, "concepts": ["errors.Is", "errors.As", "errors.StatusError", "errors.IsNotFound", "errors.IsNotFound", "errors.IsNotFound"], "_raw_llm_output": "errors.Is, errors.As, errors.StatusError, errors.IsNotFound, errors.IsNotFound, errors.IsNotFound"}
{"seed": "// Build entity properties of a pod. The properties are consisted of name and namespace of a pod.\nfunc BuildPodProperties(pod *api.Pod) []*proto.EntityDTO_EntityProperty {\n\tvar properties []*proto.EntityDTO_EntityProperty\n\tpropertyNamespace := podPropertyNamespace\n\tpodNamespacePropertyName := podPropertyNamePodNamespace\n\tpodNamespacePropertyValue := pod.Namespace\n\tnamespaceProperty := &proto.EntityDTO_EntityProperty{\n\t\tNamespace: &propertyNamespace,\n\t\tName:      &podNamespacePropertyName,\n\t\tValue:     &podNamespacePropertyValue,\n\t}\n\tproperties = append(properties, namespaceProperty)\n\n\tpodNamePropertyName := podPropertyNamePodName\n\tpodNamePropertyValue := pod.Name\n\tnameProperty := &proto.EntityDTO_EntityProperty{\n\t\tNamespace: &propertyNamespace,\n\t\tName:      &podNamePropertyName,\n\t\tValue:     &podNamePropertyValue,\n\t}\n\tproperties = append(properties, nameProperty)\n\n\treturn properties\n}", "id": 10423, "concepts": ["struct definition", "struct field definition", "struct field initialization", "struct field access", "struct field pointer access", "struct field pointer dereference", "struct field pointer dereference access", "struct field pointer dereference access access", "struct field pointer dereference access access access", "struct field pointer dereference access access access access", "struct field pointer dereference access access access access access", "struct field pointer dereference access access access access access access", "struct field pointer dereference access access access access access access access", "struct field pointer dereference access access access access access access access access", "struct field pointer dereference access access access access access access access access access", "struct field pointer dereference access access access access access access access access access access", "struct field pointer dereference access access access access access access access access access access access", "struct field pointer dereference access access access access access access access access access access access access", "struct field pointer dereference access access access access access access access access access access access access access", "struct field pointer dereference access access access access access access access access access access access access access access", "struct field pointer dereference access access access access access access access access access access access access access access access", "struct field pointer dereference access access access access access access access access access access access access access access"], "_raw_llm_output": "struct definition, struct field definition, struct field initialization, struct field access, struct field pointer access, struct field pointer dereference, struct field pointer dereference access, struct field pointer dereference access access, struct field pointer dereference access access access, struct field pointer dereference access access access access, struct field pointer dereference access access access access access, struct field pointer dereference access access access access access access, struct field pointer dereference access access access access access access access, struct field pointer dereference access access access access access access access access, struct field pointer dereference access access access access access access access access access, struct field pointer dereference access access access access access access access access access access, struct field pointer dereference access access access access access access access access access access access, struct field pointer dereference access access access access access access access access access access access access, struct field pointer dereference access access access access access access access access access access access access access, struct field pointer dereference access access access access access access access access access access access access access access, struct field pointer dereference access access access access access access access access access access access access access access access, struct field pointer dereference access access access access access access access access access access access access access access"}
{"seed": "// H1 represents the HTML element 'h1'.\n// For more information visit https://www.w3schools.com/tags/tag_h1.asp.\nfunc H1(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"h1\", Attributes: attrs, Children: children}\n}", "id": 10434, "concepts": ["HTML generation", "HTML element definition", "HTML attribute definition"], "_raw_llm_output": "HTML generation, HTML element definition, HTML attribute definition"}
{"seed": "// NewForConfigOrDie creates a new ConfigV1Client for the given config and\n// panics if there is an error in the config.\nfunc NewForConfigOrDie(c *rest.Config) *ConfigV1Client {\n\tclient, err := NewForConfig(c)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn client\n}", "id": 10436, "concepts": ["panic", "error handling (idiomatic if err != nil)", "function definition"], "_raw_llm_output": "panic, error handling (idiomatic if err != nil), function definition"}
{"seed": "// WithClient returns a context with an OAPI client (accessible using\n// GetClient) which can conduct operations against the provided target.\nfunc WithClient(ctx context.Context, target url.URL) context.Context {\n\tcfg := eth2spec.NewConfiguration()\n\n\tcfg.BasePath = \"http://\" + target.Host\n\n\tclient := eth2spec.NewAPIClient(cfg)\n\n\tctx = context.WithValue(ctx, clientKey, client)\n\n\treturn ctx\n}", "id": 10440, "concepts": ["context", "context.WithValue", "context.Context", "OAPI client", "eth2spec package"], "_raw_llm_output": "context, context.WithValue, context.Context, OAPI client, eth2spec package"}
{"seed": "// Style represents the HTML element 'style'.\n// For more information visit https://www.w3schools.com/tags/tag_style.asp.\nfunc Style(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"style\", Attributes: attrs, Children: children}\n}", "id": 10443, "concepts": ["HTML generation", "HTML element definition", "HTML attribute definition"], "_raw_llm_output": "HTML generation, HTML element definition, HTML attribute definition"}
{"seed": "// H6_ is a convenience wrapper for H6 without the attrs argument.\nfunc H6_(children ...HTML) HTML {\n  return H6(nil, children...)\n}", "id": 10455, "concepts": ["function definition", "function argument handling", "variadic function argument handling", "function return value handling"], "_raw_llm_output": "function definition, function argument handling, variadic function argument handling, function return value handling"}
{"seed": "// NewPlanner creates a new default planner with context.\nfunc NewPlanner(ctx *Context) *PlannerDefault {\n\tp := &PlannerDefault{\n\t\tCtx:      ctx,\n\t\tchildren: make([]Task, 0),\n\t}\n\tp.Planner = p\n\treturn p\n}", "id": 10458, "concepts": ["struct definition", "method definition", "anonymous struct", "method chaining", "method overriding"], "_raw_llm_output": "struct definition, method definition, anonymous struct, method chaining, method overriding"}
{"seed": "// PossibleTimeseriesAggregationIntervalValues returns an array of possible values for the TimeseriesAggregationInterval const type.\nfunc PossibleTimeseriesAggregationIntervalValues() []TimeseriesAggregationInterval {\n\treturn []TimeseriesAggregationInterval{TimeseriesAggregationIntervalDaily, TimeseriesAggregationIntervalHourly}\n}", "id": 10462, "concepts": ["constant definition", "array definition", "array iteration (range loop)"], "_raw_llm_output": "constant definition, array definition, array iteration (range loop)"}
{"seed": "// This is an example of how to build prometheus an array of time series for remote write\nfunc buildExampleWriteRequest() []*prompb.TimeSeries {\n\treturn []*prompb.TimeSeries{\n\t\t{\n\t\t\tLabels: []*prompb.Label{\n\t\t\t\t{Name: \"__name__\", Value: \"random_metric\"}, // This is required and how prom stores the name of metrics\n\t\t\t\t{Name: \"example_label_name\", Value: \"example_label_value\"},\n\t\t\t},\n\t\t\tSamples: []prompb.Sample{\n\t\t\t\t{Value: 1, Timestamp: time.Now().Add(-time.Second).Unix() * 1000}, // Timestamps must be an int64 of millisecond unix time\n\t\t\t\t{Value: 1, Timestamp: time.Now().Unix() * 1000},\n\t\t\t},\n\t\t},\n\t}\n}", "id": 10473, "concepts": ["prompb package usage", "time series", "unix time", "timestamp handling"], "_raw_llm_output": "prompb package usage, time series, unix time, timestamp handling"}
{"seed": "// Default returns the default, singleton registry instance.\nfunc Default() *Registry {\n\treturn defaultInstance\n}", "id": 10476, "concepts": ["singleton pattern", "registry", "global variable"], "_raw_llm_output": "singleton pattern, registry, global variable"}
{"seed": "// getEstimate returns a formated string representing\n// the estimated time of a speedrun in hours:minutes\n// Parameters:\n// length: Duration of speedrun in seconds.\nfunc getEstimate(length float64) string {\n\t// Convert length to hours\n\thours := math.Floor(length / 3600)\n\t// Convert length to minutes\n\tminutes := (int(length) % 3600) / 60\n\n\t// Convert to strings and add leading zeros\n\tvar strMinutes, strHours string\n\tif hours < 10 {\n\t\tstrHours = \"0\" + strconv.FormatFloat(hours, 'f', -1, 64)\n\t} else {\n\t\tstrHours = strconv.FormatFloat(hours, 'f', -1, 64)\n\t}\n\n\tif minutes < 10 {\n\t\tstrMinutes = \"0\" + strconv.Itoa(minutes)\n\t} else {\n\t\tstrMinutes = strconv.Itoa(minutes)\n\t}\n\n\t// Return string formated estimate\n\treturn strHours + \":\" + strMinutes\n}", "id": 10480, "concepts": ["math", "float64", "string formatting", "string conversion", "integer conversion", "string concatenation", "string comparison", "string iteration", "string length", "string manipulation", "string slicing", "string substring", "string trimming", "string formatting", "string padding", "string replacement", "string splitting", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", ""], "_raw_llm_output": "math, float64, string formatting, string conversion, integer conversion, string concatenation, string comparison, string iteration, string length, string manipulation, string slicing, string substring, string trimming, string formatting, string padding, string replacement, string splitting, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming,"}
{"seed": "// AgeLTE applies the LTE predicate on the \"age\" field.\nfunc AgeLTE(v int) predicate.User {\n\treturn predicate.User(sql.FieldLTE(FieldAge, v))\n}", "id": 10487, "concepts": ["struct field access", "struct field comparison", "struct field predicate"], "_raw_llm_output": "struct field access, struct field comparison, struct field predicate"}
{"seed": "// BufferNEQ applies the NEQ predicate on the \"buffer\" field.\nfunc BufferNEQ(v []byte) predicate.User {\n\treturn predicate.User(sql.FieldNEQ(FieldBuffer, v))\n}", "id": 10488, "concepts": ["predicate.User", "sql.FieldNEQ", "sql.FieldEQ"], "_raw_llm_output": "predicate.User, sql.FieldNEQ, sql.FieldEQ"}
{"seed": "// Name provides a function to set the name option.\nfunc Name(n string) Option {\n\treturn func(o *Options) {\n\t\to.Name = n\n\t}\n}", "id": 10500, "concepts": ["function composition", "function options", "function option usage"], "_raw_llm_output": "function composition, function options, function option usage"}
{"seed": "// NewDeviceManagementComplexSettingDefinition instantiates a new deviceManagementComplexSettingDefinition and sets the default values.\nfunc NewDeviceManagementComplexSettingDefinition()(*DeviceManagementComplexSettingDefinition) {\n    m := &DeviceManagementComplexSettingDefinition{\n        DeviceManagementSettingDefinition: *NewDeviceManagementSettingDefinition(),\n    }\n    return m\n}", "id": 10517, "concepts": ["struct instantiation", "struct field initialization", "pointer dereference"], "_raw_llm_output": "struct instantiation, struct field initialization, pointer dereference"}
{"seed": "// EnsembleMinimal creates and starts an Ensemble with a single full node and a single miner.\n// It does not interconnect nodes nor does it begin mining.\n//\n// This function supports passing both ensemble and node functional options.\n// Functional options are applied to all nodes.\nfunc EnsembleMinimal(t *testing.T, opts ...interface{}) (*TestFullNode, *TestMiner, *Ensemble) {\n\topts = append(opts, WithAllSubsystems())\n\n\teopts, nopts := siftOptions(t, opts)\n\n\tvar (\n\t\tfull  TestFullNode\n\t\tminer TestMiner\n\t)\n\tens := NewEnsemble(t, eopts...).FullNode(&full, nopts...).Miner(&miner, &full, nopts...).Start()\n\treturn &full, &miner, ens\n}", "id": 10519, "concepts": ["testing package usage", "functional options", "struct composition"], "_raw_llm_output": "testing package usage, functional options, struct composition"}
{"seed": "// HashBase64 returns a Base64 encoded string of the input string that has been hashed with SHA512\nfunc HashBase64(input string) string {\n\thash512 := sha512.Sum512([]byte(input))\n\n\treturn base64.StdEncoding.EncodeToString(hash512[:])\n}", "id": 10526, "concepts": ["cryptography", "hashing", "base64 encoding", "SHA512 hashing", "byte array handling", "string manipulation"], "_raw_llm_output": "cryptography, hashing, base64 encoding, SHA512 hashing, byte array handling, string manipulation"}
{"seed": "// path returns the absolute path the given relative file or directory path,\n// relative to the github.com/KurioApp/avalon directory in the user's GOPATH.\n// If rel is already absolute, it is returned unmodified.\nfunc path(relPath string) string {\n\tif filepath.IsAbs(relPath) {\n\t\treturn relPath\n\t}\n\n\treturn filepath.Join(basepath, relPath)\n}", "id": 10527, "concepts": ["filepath package usage", "filepath.IsAbs", "filepath.Join"], "_raw_llm_output": "filepath package usage, filepath.IsAbs, filepath.Join"}
{"seed": "// GetWelcome message for title of cli\nfunc GetWelcome() string {\n\tmessage := []byte(`__________________________________________________________________________________________________________________________________\n _____/\\\\\\\\\\\\\\\\\\____________________________________________________________/\\\\\\\\\\\\\\\\\\_________________________________/\\\\\\_________\n  ___/\\\\\\\\\\\\\\\\\\\\\\\\\\________________________________________________________/\\\\\\\\\\\\\\\\\\\\\\\\\\______________________________\\/\\\\\\_________\n   __/\\\\\\/////////\\\\\\___________________/\\\\\\_______________________________/\\\\\\/////////\\\\\\___________________/\\\\\\______\\/\\\\\\_________\n    _\\/\\\\\\_______\\/\\\\\\__/\\\\\\____/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\______________\\/\\\\\\_______\\/\\\\\\__/\\\\\\____/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_________\n     _\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\___\\/\\\\\\_\\////\\\\\\////____/\\\\\\///\\\\\\____________\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\___\\/\\\\\\_\\////\\\\\\////__\\/\\\\\\\\\\\\\\\\\\\\__\n      _\\/\\\\\\/////////\\\\\\_\\/\\\\\\___\\/\\\\\\____\\/\\\\\\_______/\\\\\\__\\//\\\\\\___________\\/\\\\\\/////////\\\\\\_\\/\\\\\\___\\/\\\\\\____\\/\\\\\\______\\/\\\\\\/////\\\\\\_\n       _\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\___\\/\\\\\\____\\/\\\\\\_/\\\\__\\//\\\\\\__/\\\\\\____________\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\___\\/\\\\\\____\\/\\\\\\_/\\\\__\\/\\\\\\___\\/\\\\\\_\n        _\\/\\\\\\_______\\/\\\\\\_\\//\\\\\\\\\\\\\\\\\\_____\\//\\\\\\\\\\____\\///\\\\\\\\\\/_____________\\/\\\\\\_______\\/\\\\\\_\\//\\\\\\\\\\\\\\\\\\_____\\//\\\\\\\\\\___\\/\\\\\\___\\/\\\\\\_\n         _\\///________\\///___\\/////////_______\\/////_______\\/////_______________\\///________\\///___\\/////////_______\\/////____\\///____\\///__\n          ___________________________________________________________________________________________________________________________________\n           _____________________________________________________________________________ https://www.github.com/pepodev/autoauth _____________\n\t\t  \nAutoAuth is CLI to create preset and start automatic authentication web portal for internet access like Public-Wifi\n`)\n\treturn string(message)\n}", "id": 10535, "concepts": ["byte manipulation", "string manipulation", "fmt package usage"], "_raw_llm_output": "byte manipulation, string manipulation, fmt package usage"}
{"seed": "// reconcileBlueGreenTemplateChange returns true if we detect there was a change in the pod template\n// from our current pod hash, or the newRS does not yet exist\nfunc reconcileBlueGreenTemplateChange(roCtx *blueGreenContext) bool {\n\tr := roCtx.Rollout()\n\tnewRS := roCtx.NewRS()\n\tif newRS == nil {\n\t\treturn true\n\t}\n\treturn r.Status.CurrentPodHash != newRS.Labels[v1alpha1.DefaultRolloutUniqueLabelKey]\n}", "id": 10536, "concepts": ["labels", "rollout status", "rollout labels"], "_raw_llm_output": "labels, rollout status, rollout labels"}
{"seed": "// NewQueryFirewallFieldsParamsWithContext creates a new QueryFirewallFieldsParams object\n// with the ability to set a context for a request.\nfunc NewQueryFirewallFieldsParamsWithContext(ctx context.Context) *QueryFirewallFieldsParams {\n\treturn &QueryFirewallFieldsParams{\n\t\tContext: ctx,\n\t}\n}", "id": 10544, "concepts": ["context package usage", "function definition"], "_raw_llm_output": "context package usage, function definition"}
{"seed": "// readBUILD loads the BUILD file, if present, or returns a new empty one.\n// workspaceRoot must be an absolute path and buildFilePath is interpreted as\n// relative to CWD, and must be underneath workspaceRoot.\nfunc readBUILD(ctx context.Context, workspaceRoot, buildFilePath string) (*build.File, error) {\n\tnormalizedG3Path, err := getAbsoluteBUILDPath(workspaceRoot, buildFilePath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to resolve workspace relative path: %s\", err)\n\t}\n\tdata, err := platform.ReadFile(ctx, buildFilePath)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn &build.File{Path: normalizedG3Path, Type: build.TypeBuild}, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"reading %q: %s\", buildFilePath, err)\n\t}\n\treturn build.ParseBuild(normalizedG3Path, data)\n}", "id": 10546, "concepts": ["file reading", "file existence check", "file parsing", "file manipulation"], "_raw_llm_output": "file reading, file existence check, file parsing, file manipulation"}
{"seed": "// CreatedAtNEQ applies the NEQ predicate on the \"created_at\" field.\nfunc CreatedAtNEQ(v time.Time) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldCreatedAt), v))\n\t})\n}", "id": 10562, "concepts": ["sql.Selector", "sql.NEQ", "sql.Where", "sql.C", "predicate.User", "function definition"], "_raw_llm_output": "sql.Selector, sql.NEQ, sql.Where, sql.C, predicate.User, function definition"}
{"seed": "// Calculate the Geom Mean Anom Sun in degrees based on the formula: 357.52911 + julianCentury * (35999.05029 - 0.0001537 * julianCentury)\n// julianCentury - Julian century calculated by the calcJulianCentury function\n// Return The Geom Mean Anom Sun slice\nfunc calcGeomMeanAnomSun(julianCentury []float64) (geomMeanAnomSun []float64) {\n\tfor index := 0; index < len(julianCentury); index++ {\n\t\ttemp := 357.52911 + julianCentury[index]*(35999.05029-0.0001537*julianCentury[index])\n\t\tgeomMeanAnomSun = append(geomMeanAnomSun, temp)\n\t}\n\treturn\n}", "id": 10564, "concepts": ["slice", "append", "function definition", "function call", "slice iteration (range loop)"], "_raw_llm_output": "slice, append, function definition, function call, slice iteration (range loop)"}
{"seed": "// GetHelpString returns a string containing help text for \"cmdName\". If\n// cmdName is unknown to btcjson - either via the default command list or those\n// registered using RegisterCustomCmd - an error will be returned.\nfunc GetHelpString(cmdName string) (string, error) {\n\thelpstr := \"\"\n\n\tif help, ok := defaultHelpStrings[cmdName]; ok {\n\t\treturn help, nil\n\t}\n\tif c, ok := customCmds[cmdName]; ok {\n\t\treturn c.helpString, nil\n\t}\n\treturn helpstr, errors.New(\"invalid command specified\")\n}", "id": 10574, "concepts": ["string concatenation", "error handling (errors.New)", "map lookup", "standard library usage"], "_raw_llm_output": "string concatenation, error handling (errors.New), map lookup, standard library usage"}
{"seed": "// NormalizeTagValue applies some normalization to ensure the tag value matches the backend requirements.\n// It should be used for cases where we have just the tag_value as the input (instead of tag_key:tag_value).\nfunc NormalizeTagValue(v string) string {\n\treturn normalize(v, false)\n}", "id": 10583, "concepts": ["string manipulation", "string normalization"], "_raw_llm_output": "string manipulation, string normalization"}
{"seed": "// IsMap reports whether value is a map type.\nfunc IsMap(value interface{}) bool {\n\treturn kindOf(value) == reflect.Map\n}", "id": 10594, "concepts": ["reflect package usage", "type checking"], "_raw_llm_output": "reflect package usage, type checking"}
{"seed": "// SerializeConfig takes in a multichannelfanout.Config and generates the ConfigMap equivalent.\n// orig == NewFanoutConfig(SerializeConfig(orig))\nfunc SerializeConfig(config multichannelfanout.Config) (map[string]string, error) {\n\tjb, err := json.Marshal(config)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn map[string]string{\n\t\tMultiChannelFanoutConfigKey: string(jb),\n\t}, nil\n}", "id": 10607, "concepts": ["json marshaling", "json unmarshaling", "map iteration", "basic function definition"], "_raw_llm_output": "json marshaling, json unmarshaling, map iteration, basic function definition"}
{"seed": "// objectName constructs a name from an Unstructured object\nfunc objectName(u *unstructured.Unstructured) string {\n\treturn strings.ToLower(fmt.Sprintf(\"%s-%s\", u.GetKind(), strings.Replace(u.GetName(), \":\", \"-\", -1)))\n}", "id": 10610, "concepts": ["string manipulation", "string formatting", "string replacement", "string lowercasing", "string concatenation", "string concatenation"], "_raw_llm_output": "string manipulation, string formatting, string replacement, string lowercasing, string concatenation, string concatenation"}
{"seed": "// IDLTE applies the LTE predicate on the ID field.\nfunc IDLTE(id int) predicate.Bulk {\n\treturn predicate.Bulk(func(s *sql.Selector) {\n\t\ts.Where(sql.LTE(s.C(FieldID), id))\n\t})\n}", "id": 10625, "concepts": ["sql.Selector", "sql.C", "sql.LTE", "sql.Bulk", "sql.Where", "sql.Predicate"], "_raw_llm_output": "sql.Selector, sql.C, sql.LTE, sql.Bulk, sql.Where, sql.Predicate"}
{"seed": "// SplitPath separates a file path into directory, filename (without extension)\n// and file extension (with dot). If no directory could be derived \".\" is\n// returned as a directory. If no file extension could be derived \"\" is returned\n// as a file extension.\nfunc SplitPath(filePath string) (dir string, base string, ext string) {\n\tdir = filepath.Dir(filePath)\n\text = filepath.Ext(filePath)\n\tbase = filepath.Base(filePath)\n\tbase = base[:len(base)-len(ext)]\n\treturn dir, base, ext\n}", "id": 10643, "concepts": ["filepath package usage", "string manipulation", "string slicing"], "_raw_llm_output": "filepath package usage, string manipulation, string slicing"}
{"seed": "// New generates a certificate and private key. To override default values, pass\n// a Config value.\nfunc New(cfg ...Config) (*x509.Certificate, crypto.Signer, error) {\n\tcert, key, err := genCertAndKey(getConfig(cfg), true)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn cert, key, nil\n}", "id": 10644, "concepts": ["crypto.Signer", "crypto.PrivateKey", "x509.Certificate", "crypto/rand", "crypto/x509", "crypto/x509/pkix", "crypto/x509/pkix/Name", "crypto/x509/pkix/AttributeTypeAndValue", "crypto/x509/pkix/AttributeType", "crypto/x509/pkix/NameEntry", "crypto/x509/pkix/AttributeTypeAndValue", "crypto/x509/pkix/NameEntry", "crypto/x509/pkix/AttributeTypeAndValue", "crypto/x509/pkix/NameEntry", "crypto/x509/pkix/AttributeTypeAndValue", "crypto/x509/pkix/NameEntry", "crypto/x509/pkix/AttributeTypeAndValue", "crypto/x509/pkix/NameEntry", "crypto/x509/pkix/AttributeTypeAndValue", "crypto/x509/pkix/NameEntry", "crypto/x509/pkix/AttributeTypeAndValue", "crypto/x509/pkix/NameEntry", "crypto/x509"], "_raw_llm_output": "crypto.Signer, crypto.PrivateKey, x509.Certificate, crypto/rand, crypto/x509, crypto/x509/pkix, crypto/x509/pkix/Name, crypto/x509/pkix/AttributeTypeAndValue, crypto/x509/pkix/AttributeType, crypto/x509/pkix/NameEntry, crypto/x509/pkix/AttributeTypeAndValue, crypto/x509/pkix/NameEntry, crypto/x509/pkix/AttributeTypeAndValue, crypto/x509/pkix/NameEntry, crypto/x509/pkix/AttributeTypeAndValue, crypto/x509/pkix/NameEntry, crypto/x509/pkix/AttributeTypeAndValue, crypto/x509/pkix/NameEntry, crypto/x509/pkix/AttributeTypeAndValue, crypto/x509/pkix/NameEntry, crypto/x509/pkix/AttributeTypeAndValue, crypto/x509/pkix/NameEntry, crypto/x509"}
{"seed": "// Transfertobankaccount applies equality check predicate on the \"transfertobankaccount\" field. It's identical to TransfertobankaccountEQ.\nfunc Transfertobankaccount(v float64) predicate.Bulk {\n\treturn predicate.Bulk(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldTransfertobankaccount), v))\n\t})\n}", "id": 10656, "concepts": ["sql.Selector", "sql.EQ", "sql.Bulk", "predicate.Bulk", "sql.C"], "_raw_llm_output": "sql.Selector, sql.EQ, sql.Bulk, predicate.Bulk, sql.C"}
{"seed": "// Mark represents the HTML element 'mark'.\n// For more information visit https://www.w3schools.com/tags/tag_mark.asp.\nfunc Mark(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"mark\", Attributes: attrs, Children: children}\n}", "id": 10658, "concepts": ["HTML generation", "HTML tree representation", "HTML element definition"], "_raw_llm_output": "HTML generation, HTML tree representation, HTML element definition"}
{"seed": "// NewGetDeploymentTargetOperatingSystemNamesListAllParams creates a new GetDeploymentTargetOperatingSystemNamesListAllParams object\n// with the default values initialized.\nfunc NewGetDeploymentTargetOperatingSystemNamesListAllParams() *GetDeploymentTargetOperatingSystemNamesListAllParams {\n\n\treturn &GetDeploymentTargetOperatingSystemNamesListAllParams{\n\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 10659, "concepts": ["struct initialization", "pointer usage", "function definition"], "_raw_llm_output": "struct initialization, pointer usage, function definition"}
{"seed": "// Br_ is a convenience wrapper for Br without the attrs argument.\nfunc Br_() HTML {\n  return Br(nil)\n}", "id": 10670, "concepts": ["HTML", "HTML tag definition", "HTML attribute definition"], "_raw_llm_output": "HTML, HTML tag definition, HTML attribute definition"}
{"seed": "// AssetNames returns the names of the assets.\nfunc AssetNames() []string {\n\tnames := make([]string, 0, len(_bindata))\n\tfor name := range _bindata {\n\t\tnames = append(names, name)\n\t}\n\treturn names\n}", "id": 10685, "concepts": ["map iteration", "map declaration"], "_raw_llm_output": "map iteration, map declaration"}
{"seed": "// isExternal returns true if the request has arrived via the public internet. This relies\n// on the requests from the internet coming in via a load balancer (which sets the\n// X-Forwarded-For header) and internal requests not coming via a load balancer\n// This is used in measuring network traffic\nfunc isExternal(request *http.Request) bool {\n\treturn request.Header.Get(\"X-Forwarded-For\") != \"\"\n}", "id": 10686, "concepts": ["http.Request", "http.Header", "X-Forwarded-For header", "external requests"], "_raw_llm_output": "http.Request, http.Header, X-Forwarded-For header, external requests"}
{"seed": "// DefaultExprsContains applies the Contains predicate on the \"default_exprs\" field.\nfunc DefaultExprsContains(v string) predicate.User {\n\treturn predicate.User(sql.FieldContains(FieldDefaultExprs, v))\n}", "id": 10689, "concepts": ["sql.FieldContains", "predicate.User", "sql package usage"], "_raw_llm_output": "sql.FieldContains, predicate.User, sql package usage"}
{"seed": "// NewImportRawDNSZoneRequest calls the generic ImportRawDNSZone builder with application/json body\nfunc NewImportRawDNSZoneRequest(server string, dnsZone string, body ImportRawDNSZoneJSONRequestBody) (*http.Request, error) {\n\tvar bodyReader io.Reader\n\tbuf, err := json.Marshal(body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tbodyReader = bytes.NewReader(buf)\n\treturn NewImportRawDNSZoneRequestWithBody(server, dnsZone, \"application/json\", bodyReader)\n}", "id": 10700, "concepts": ["http.Request", "http.Client", "JSON marshalling", "JSON unmarshalling"], "_raw_llm_output": "http.Request, http.Client, JSON marshalling, JSON unmarshalling"}
{"seed": "// powerOfTwo reports whether n is a power of two.\nfunc powerOfTwo(n int64) bool {\n\treturn n != 0 && n&(n-1) == 0\n}", "id": 10709, "concepts": ["bitwise operations", "bitwise AND"], "_raw_llm_output": "bitwise operations, bitwise AND"}
{"seed": "// LambdaVersioningDecorator returns a TemplateDecorator\n// that is responsible for including a versioning resource\n// with the given lambda function\nfunc LambdaVersioningDecorator() sparta.TemplateDecoratorHookFunc {\n\treturn func(serviceName string,\n\t\tlambdaResourceName string,\n\t\tlambdaResource gocf.LambdaFunction,\n\t\tresourceMetadata map[string]interface{},\n\t\tS3Bucket string,\n\t\tS3Key string,\n\t\tbuildID string,\n\t\ttemplate *gocf.Template,\n\t\tcontext map[string]interface{},\n\t\tlogger *logrus.Logger) error {\n\n\t\tlambdaResName := sparta.CloudFormationResourceName(\"LambdaVersion\",\n\t\t\tbuildID,\n\t\t\ttime.Now().UTC().String())\n\t\tversionResource := &gocf.LambdaVersion{\n\t\t\tFunctionName: gocf.GetAtt(lambdaResourceName, \"Arn\").String(),\n\t\t}\n\t\tlambdaVersionRes := template.AddResource(lambdaResName, versionResource)\n\t\tlambdaVersionRes.DeletionPolicy = \"Retain\"\n\t\t// That's it...\n\t\treturn nil\n\t}\n}", "id": 10717, "concepts": ["function definition", "function composition", "function composition with template", "function composition with template", "function composition with template", "function composition with template", "function composition with template", "function composition with template", "function composition with template", "function composition with template", "function composition with template", "function composition with template", "function composition with template", "function composition with template", "function composition with template", "function composition with template", "function composition with template", "function composition with template", "function composition with template", "function composition with template", "function composition with template", "function composition with template", "function composition with template", "function composition with template", "function composition with template", "function composition with template", "function composition with template", "function composition with template", "function composition with template", "function composition with template", "function composition with template", "function composition with template", "function composition with template", "function composition with template", "function composition with template", "function composition with template", "function composition with template", "function composition with template", "function composition with template", "function composition with template", "function composition with template", "function composition with template", "function composition with template", "function composition with template", "function composition with template", "function composition with template", "function composition with template", "function composition with template", "function composition with template", "function composition with template", "function composition with template", "function composition with template"], "_raw_llm_output": "function definition, function composition, function composition with template, function composition with template, function composition with template, function composition with template, function composition with template, function composition with template, function composition with template, function composition with template, function composition with template, function composition with template, function composition with template, function composition with template, function composition with template, function composition with template, function composition with template, function composition with template, function composition with template, function composition with template, function composition with template, function composition with template, function composition with template, function composition with template, function composition with template, function composition with template, function composition with template, function composition with template, function composition with template, function composition with template, function composition with template, function composition with template, function composition with template, function composition with template, function composition with template, function composition with template, function composition with template, function composition with template, function composition with template, function composition with template, function composition with template, function composition with template, function composition with template, function composition with template, function composition with template, function composition with template, function composition with template, function composition with template, function composition with template, function composition with template, function composition with template, function composition with template"}
{"seed": "// IsNotFoundError checks if an error is the `NotFoundError` type.\nfunc IsNotFoundError(e error) bool {\n\t_, ok := e.(NotFoundError)\n\treturn ok\n}", "id": 10724, "concepts": ["error handling (type assertion)", "error handling (type switch)", "error handling (type switch with fallthrough)"], "_raw_llm_output": "error handling (type assertion), error handling (type switch), error handling (type switch with fallthrough)"}
{"seed": "// CommitteeScriptHash returns committee address as Uint160.\nfunc CommitteeScriptHash() util.Uint160 {\n\treturn hash.Hash160(CommitteeVerificationScript())\n}", "id": 10726, "concepts": ["hashing", "Uint160 type"], "_raw_llm_output": "hashing, Uint160 type"}
{"seed": "// validateContextDirectory checks if all the contents of the directory\n// can be read and returns an error if some files can't be read.\n// Symlinks which point to non-existing files don't trigger an error\n\nfunc validateDockerContextDirectory(srcPath string, excludes []string) error {\n\n\treturn filepath.Walk(filepath.Join(srcPath, \".\"), func(filePath string, f os.FileInfo, err error) error {\n\t\t// skip this directory/file if it's not in the path, it won't get added to the context\n\t\tif relFilePath, err := filepath.Rel(srcPath, filePath); err != nil {\n\t\t\treturn err\n\t\t} else if skip, err := fileutils.Matches(relFilePath, excludes); err != nil {\n\t\t\treturn err\n\t\t} else if skip {\n\t\t\tif f.IsDir() {\n\t\t\t\treturn filepath.SkipDir\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\n\t\tif err != nil {\n\t\t\tif os.IsPermission(err) {\n\t\t\t\treturn fmt.Errorf(\"can't stat '%s'\", filePath)\n\t\t\t}\n\t\t\tif os.IsNotExist(err) {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\n\t\t// skip checking if symlinks point to non-existing files, such symlinks can be useful\n\t\t// also skip named pipes, because they hanging on open\n\t\tif f.Mode()&(os.ModeSymlink|os.ModeNamedPipe) != 0 {\n\t\t\treturn nil\n\t\t}\n\n\t\tif !f.IsDir() {\n\t\t\tcurrentFile, err := os.Open(filePath)\n\t\t\tif err != nil && os.IsPermission(err) {\n\t\t\t\treturn fmt.Errorf(\"no permission to read from '%s'\", filePath)\n\t\t\t}\n\t\t\tcurrentFile.Close()\n\t\t}\n\t\treturn nil\n\t})\n}", "id": 10731, "concepts": ["filepath.Walk", "filepath.Rel", "os.FileInfo", "os.FileMode", "os.Stat", "os.Open", "os.IsNotExist", "os.IsPermission", "os.ModeSymlink", "os.ModeNamedPipe", "os.File.Close", "os.File.IsDir", "os.File.IsDir", "os.File.Mode", "os.File.Mode", "os.File.Stat", "os.File.Open", "os.File.Close", "os.File.IsDir", "os.File.IsDir", "os.File.Mode", "os.File.Mode", "os.File.Stat", "os.File.Open", "os.File.Close", "os.File.IsDir", "os.File.IsDir", "os.File.Mode", "os.File.Mode", "os.File.Stat", "os.File.Open", "os.File.Close", "os.File.IsDir", "os.File.IsDir", "os.File.Mode", "os.File.Mode", "os.File.Stat", "os.File.Open", "os.File.Close", "os.File.IsDir", "os.File.IsDir", "os.File.Mode", "os.File.Mode", ""], "_raw_llm_output": "filepath.Walk, filepath.Rel, os.FileInfo, os.FileMode, os.Stat, os.Open, os.IsNotExist, os.IsPermission, os.ModeSymlink, os.ModeNamedPipe, os.File.Close, os.File.IsDir, os.File.IsDir, os.File.Mode, os.File.Mode, os.File.Stat, os.File.Open, os.File.Close, os.File.IsDir, os.File.IsDir, os.File.Mode, os.File.Mode, os.File.Stat, os.File.Open, os.File.Close, os.File.IsDir, os.File.IsDir, os.File.Mode, os.File.Mode, os.File.Stat, os.File.Open, os.File.Close, os.File.IsDir, os.File.IsDir, os.File.Mode, os.File.Mode, os.File.Stat, os.File.Open, os.File.Close, os.File.IsDir, os.File.IsDir, os.File.Mode, os.File.Mode,"}
{"seed": "// ToPBSshconfig converts a system.SSHConfig into a SshConfig\nfunc ToPBSshconfig(from *system.SSHConfig) *pb.SshConfig {\n\tvar gw *pb.SshConfig\n\tif from.GatewayConfig != nil {\n\t\tgw = ToPBSshconfig(from.GatewayConfig)\n\t}\n\treturn &pb.SshConfig{\n\t\tGateway:    gw,\n\t\tHost:       from.Host,\n\t\tPort:       int32(from.Port),\n\t\tPrivateKey: from.PrivateKey,\n\t\tUser:       from.User,\n\t}\n}", "id": 10732, "concepts": ["struct definition", "interface definition", "pointer handling", "function definition", "function return value"], "_raw_llm_output": "struct definition, interface definition, pointer handling, function definition, function return value"}
{"seed": "// NewDeleteTagParamsWithTimeout creates a new DeleteTagParams object\n// with the default values initialized, and the ability to set a timeout on a request\nfunc NewDeleteTagParamsWithTimeout(timeout time.Duration) *DeleteTagParams {\n\tvar ()\n\treturn &DeleteTagParams{\n\n\t\ttimeout: timeout,\n\t}\n}", "id": 10739, "concepts": ["basic function definition", "struct initialization", "timeout handling"], "_raw_llm_output": "basic function definition, struct initialization, timeout handling"}
{"seed": "// NewManualConversionsTracker builds a new ManualConversionsTracker.\n// Additional conversion arguments allow users to set which arguments should be part of\n// a conversion function signature.\n// When generating conversion code, those will be added to the signature of each conversion function,\n// and then passed down to conversion functions for embedded types. This allows to generate\n// conversion code with additional argument, eg\n//    Convert_a_X_To_b_Y(in *a.X, out *b.Y, s conversion.Scope) error\n// Manually defined conversion functions will also be expected to have similar signatures.\nfunc NewManualConversionsTracker(additionalConversionArguments ...NamedVariable) *ManualConversionsTracker {\n\treturn &ManualConversionsTracker{\n\t\tadditionalConversionArguments: additionalConversionArguments,\n\t\tprocessedPackages:             make(map[string][]error),\n\t\tconversionFunctions:           make(map[ConversionPair]*types.Type),\n\t\tbuffer:                        &bytes.Buffer{},\n\t\tconversionNamer:               ConversionNamer(),\n\t}\n}", "id": 10755, "concepts": ["map", "struct", "pointer", "function definition", "function call", "map iteration", "map lookup", "map update", "map deletion", "map key type", "map value type", "map value update", "map value deletion", "map value lookup", "map value iteration", "map value iteration (range loop)", "map value iteration (for loop)", "map value iteration (for range loop)", "map value iteration (while loop)", "map value iteration (do-while loop)", "map value iteration (foreach loop)", "map value iteration (for-each loop)", "map value iteration (for-each loop)", "map value iteration (for-each loop)", "map value iteration (for-each loop)", "map value iteration (for-each loop)", "map value iteration (for-each loop)", "map value iteration (for-each loop)", "map value iteration (for-each loop)", "map value iteration (for-each loop)", "map value iteration (for-each loop)", "map value iteration (for-each loop)", "map value iteration (for-each loop)", "map value iteration (for-each loop)", "map value iteration (for-each loop)", "map value iteration (for-each loop)", "map value iteration (for-each loop)", "map value iteration (for-each loop)", "map value iteration (for-each loop)", ""], "_raw_llm_output": "map, struct, pointer, function definition, function call, map iteration, map lookup, map update, map deletion, map key type, map value type, map value update, map value deletion, map value lookup, map value iteration, map value iteration (range loop), map value iteration (for loop), map value iteration (for range loop), map value iteration (while loop), map value iteration (do-while loop), map value iteration (foreach loop), map value iteration (for-each loop), map value iteration (for-each loop), map value iteration (for-each loop), map value iteration (for-each loop), map value iteration (for-each loop), map value iteration (for-each loop), map value iteration (for-each loop), map value iteration (for-each loop), map value iteration (for-each loop), map value iteration (for-each loop), map value iteration (for-each loop), map value iteration (for-each loop), map value iteration (for-each loop), map value iteration (for-each loop), map value iteration (for-each loop), map value iteration (for-each loop), map value iteration (for-each loop), map value iteration (for-each loop),"}
{"seed": "// BetterHeroScoreAtGTE applies the GTE predicate on the \"better_hero_score_at\" field.\nfunc BetterHeroScoreAtGTE(v time.Time) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.GTE(s.C(FieldBetterHeroScoreAt), v))\n\t})\n}", "id": 10761, "concepts": ["sql.Selector", "sql.GTE", "sql.C", "sql.Where"], "_raw_llm_output": "sql.Selector, sql.GTE, sql.C, sql.Where"}
{"seed": "// Caller returns triplet: file name, line number, function name of a caller\nfunc Caller(skip string) (string, int, string) {\n\tpc := make([]uintptr, 7)\n\tn := runtime.Callers(2, pc)\n\tframes := runtime.CallersFrames(pc[:n])\n\tfor {\n\t\tframe, more := frames.Next()\n\t\t// frame.File = /tmp/sandbox469341579/prog.go\n\t\t// frame.Line = 28\n\t\t// frame.Function = main.Announcer.Info\n\n\t\t// file = prog.go\n\t\tfile := path.Base(frame.File)\n\t\t// function = Info\n\t\tfunction := path.Base(strings.Replace(frame.Function, \".\", \"/\", -1))\n\n\t\tif file != skip {\n\t\t\treturn file, frame.Line, function\n\t\t}\n\n\t\tif !more {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn \"\", 0, \"\"\n}", "id": 10774, "concepts": ["runtime package usage", "runtime.Callers", "runtime.CallersFrames", "path.Base", "strings.Replace"], "_raw_llm_output": "runtime package usage, runtime.Callers, runtime.CallersFrames, path.Base, strings.Replace"}
{"seed": "// Given an array of integers, find maximum length sub-array having given sum.\n// https://www.youtube.com/watch?v=HJDlxZNe1UI\n\n//MaxLengthSumSubArray : O(n) solution\nfunc MaxLengthSumSubArray(arr []int , sum int)[]int {\n\n\tm := make(map[int]int)\n\n\tlength := 0\n\tendIndex := -1\n\n\n\tsumSoFar := 0\n\n\tfor i:=0;i<len(arr);i++{\n\t\tsumSoFar += arr[i]\n\n\t\tif sumSoFar == sum {\n\t\t\treturn arr[0:i+1]\n\t\t}\n\n\t\t// bcoz we need the max length so if sum repeats we need the whole length thats why !ok\n\t\tif _,ok := m[sumSoFar];!ok {\n\t\t\tm[sumSoFar] = i\n\t\t}\n\n\t\tif val,ok := m[sumSoFar-sum];ok && length < i-val {\n\t\t\tlength = i - val\n\t\t\tendIndex = i\n\n\t\t}\n\t}\n\tif endIndex > 0 {\n\t\treturn  arr[endIndex - length + 1 : endIndex+1]\n\t} \n\treturn make([]int, 0)\n\t\n\n}", "id": 10788, "concepts": ["hash map", "map iteration", "map lookup", "map deletion", "map update", "map creation", "map key lookup", "map key deletion", "map key update", "map key creation", "map key iteration", "map key range", "map key range iteration", "map key range iteration with index", "map key range iteration with index and value", "map key range iteration with index and value and key", "map key range iteration with index and value and key and value", "map key range iteration with index and value and key and value and key", "map key range iteration with index and value and key and value and key and value", "map key range iteration with index and value and key and value and key and value and key", "map key range iteration with index and value and key and value and key and value and key and value", "map key range iteration with index and value and key and value and key and value and key and value and key", "map key range iteration with index and value and key and value and key and value and key and value and key and value", "map key range iteration with index and value and key and value and key and value and key and value and key and value and key", "map key range iteration with index and value and key and value and key and value and key and value and"], "_raw_llm_output": "hash map, map iteration, map lookup, map deletion, map update, map creation, map key lookup, map key deletion, map key update, map key creation, map key iteration, map key range, map key range iteration, map key range iteration with index, map key range iteration with index and value, map key range iteration with index and value and key, map key range iteration with index and value and key and value, map key range iteration with index and value and key and value and key, map key range iteration with index and value and key and value and key and value, map key range iteration with index and value and key and value and key and value and key, map key range iteration with index and value and key and value and key and value and key and value, map key range iteration with index and value and key and value and key and value and key and value and key, map key range iteration with index and value and key and value and key and value and key and value and key and value, map key range iteration with index and value and key and value and key and value and key and value and key and value and key, map key range iteration with index and value and key and value and key and value and key and value and"}
{"seed": "// PossibleFirewallStateValues returns an array of possible values for the FirewallState const type.\nfunc PossibleFirewallStateValues() []FirewallState {\n\treturn []FirewallState{FirewallStateDisabled, FirewallStateEnabled}\n}", "id": 10802, "concepts": ["const type", "array"], "_raw_llm_output": "const type, array"}
{"seed": "// Dd_ is a convenience wrapper for Dd without the attrs argument.\nfunc Dd_(children ...HTML) HTML {\n  return Dd(nil, children...)\n}", "id": 10808, "concepts": ["function definition", "function argument handling", "function return value handling"], "_raw_llm_output": "function definition, function argument handling, function return value handling"}
{"seed": "// A represents the HTML element 'a'.\n// For more information visit https://www.w3schools.com/tags/tag_a.asp.\nfunc A(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"a\", Attributes: attrs, Children: children}\n}", "id": 10818, "concepts": ["HTML generation", "HTML tree generation", "HTML tree manipulation", "HTML element definition", "HTML attribute definition", "HTML element children definition"], "_raw_llm_output": "HTML generation, HTML tree generation, HTML tree manipulation, HTML element definition, HTML attribute definition, HTML element children definition"}
{"seed": "// ServerHeader middleware adds a `Server` header to the response.\nfunc ServerHeader(next echo.HandlerFunc) echo.HandlerFunc {\n\treturn func(c echo.Context) error {\n\t\tc.Response().Header().Set(echo.HeaderServer, \"Echo/2.0\")\n\t\treturn next(c)\n\t}\n}", "id": 10821, "concepts": ["middleware", "echo package usage"], "_raw_llm_output": "middleware, echo package usage"}
{"seed": "// LevelLeaderboard retrieves a the leaderboard for a specific game and one of\n// its levels in a specific category. An error is returned if no category or\n// level is given or if a full-game category is given. If no game is given, it\n// is fetched automatically, but if you have it already at hand, you can save\n// one request by specifying it.\nfunc LevelLeaderboard(game *Game, cat *Category, level *Level, options *LeaderboardOptions, embeds string) (*Leaderboard, *Error) {\n\tif cat == nil {\n\t\treturn nil, &Error{\"\", \"\", ErrorBadLogic, \"No category given.\"}\n\t}\n\n\tif level == nil {\n\t\treturn nil, &Error{\"\", \"\", ErrorBadLogic, \"No level given.\"}\n\t}\n\n\tif cat.Type != \"per-level\" {\n\t\treturn nil, &Error{\"\", \"\", ErrorBadLogic, \"The given category is not a individual-level category.\"}\n\t}\n\n\tif game == nil {\n\t\tvar err *Error\n\n\t\tgame, err = level.Game(\"\")\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn fetchLeaderboard(request{\"GET\", \"/leaderboards/\" + game.ID + \"/level/\" + level.ID + \"/\" + cat.ID, options, nil, nil, embeds})\n}", "id": 10822, "concepts": ["http request", "http response", "http client", "json decoding", "error handling", "standard library usage"], "_raw_llm_output": "http request, http response, http client, json decoding, error handling, standard library usage"}
{"seed": "// IDNEQ applies the NEQ predicate on the ID field.\nfunc IDNEQ(id int) predicate.TradeCorrection {\n\treturn predicate.TradeCorrection(sql.FieldNEQ(FieldID, id))\n}", "id": 10823, "concepts": ["predicate definition", "predicate usage", "predicate composition", "predicate negation"], "_raw_llm_output": "predicate definition, predicate usage, predicate composition, predicate negation"}
{"seed": "// CleanupMessage automatically strips whitespace and adds a newline at the end\n// of the commit message. If stripComments is true, comment lines are removed.\nfunc CleanupMessage(stripComments bool) CommitOption {\n\treturn func(c *commitConfig) {\n\t\tc.cleanupMessage = true\n\t\tif stripComments {\n\t\t\tc.stripComments = true\n\t\t\tif c.commentMarker == 0 {\n\t\t\t\tc.commentMarker = '#'\n\t\t\t}\n\t\t}\n\t}\n}", "id": 10840, "concepts": ["function composition", "function composition", "function composition", "function composition", "function composition"], "_raw_llm_output": "function composition, function composition, function composition, function composition, function composition"}
{"seed": "// VariantKey returns a Genetic Variant Key based on CHROM, POS (0-base), REF, ALT.\n// The variant should be already normalized (see NormalizeVariant or use NormalizedVariantkey).\nfunc VariantKey(chrom string, pos uint32, ref, alt string) uint64 {\n\tbchrom := StringToNTBytes(chrom)\n\tbref := StringToNTBytes(ref)\n\tbalt := StringToNTBytes(alt)\n\tsizeref := len(ref)\n\tsizealt := len(alt)\n\tpchrom := unsafe.Pointer(&bchrom[0]) // #nosec\n\tpref := unsafe.Pointer(&bref[0])     // #nosec\n\tpalt := unsafe.Pointer(&balt[0])     // #nosec\n\treturn uint64(C.variantkey((*C.char)(pchrom), C.size_t(len(chrom)), C.uint32_t(pos), (*C.char)(pref), C.size_t(sizeref), (*C.char)(palt), C.size_t(sizealt)))\n}", "id": 10842, "concepts": ["unsafe package", "CGO", "string to bytes conversion", "C function call"], "_raw_llm_output": "unsafe package, CGO, string to bytes conversion, C function call"}
{"seed": "// NewPayRatesGetParamsWithContext creates a new PayRatesGetParams object\n// with the default values initialized, and the ability to set a context for a request\nfunc NewPayRatesGetParamsWithContext(ctx context.Context) *PayRatesGetParams {\n\tvar ()\n\treturn &PayRatesGetParams{\n\n\t\tContext: ctx,\n\t}\n}", "id": 10846, "concepts": ["context usage", "basic function definition"], "_raw_llm_output": "context usage, basic function definition"}
{"seed": "// NewCreatePostRequestBody instantiates a new createPostRequestBody and sets the default values.\nfunc NewCreatePostRequestBody()(*CreatePostRequestBody) {\n    m := &CreatePostRequestBody{\n    }\n    m.SetAdditionalData(make(map[string]interface{}));\n    return m\n}", "id": 10847, "concepts": ["struct instantiation", "map instantiation", "map usage", "struct field assignment"], "_raw_llm_output": "struct instantiation, map instantiation, map usage, struct field assignment"}
{"seed": "// OnesCount32Before counts the number of \"1\"(population count) in a uint32 before specified bit position `iBit`.\nfunc OnesCount32Before(n uint32, iBit uint) int {\n\treturn gobits.OnesCount32(n & ((uint32(1) << iBit) - 1))\n}", "id": 10854, "concepts": ["bit manipulation", "bitwise operations", "bitwise AND", "bitwise OR", "bitwise NOT", "bitwise XOR", "bitwise left shift", "bitwise right shift", "bitwise AND with mask", "bitwise OR with mask", "bitwise NOT with mask", "bitwise XOR with mask", "bitwise left shift with mask", "bitwise right shift with mask", "bitwise AND with mask", "bitwise OR with mask", "bitwise NOT with mask", "bitwise XOR with mask", "bitwise left shift with mask", "bitwise right shift with mask", "bitwise AND with mask", "bitwise OR with mask", "bitwise NOT with mask", "bitwise XOR with mask", "bitwise left shift with mask", "bitwise right shift with mask", "bitwise AND with mask", "bitwise OR with mask", "bitwise NOT with mask", "bitwise XOR with mask", "bitwise left shift with mask", "bitwise right shift with mask", "bitwise AND with mask", "bitwise OR with mask", "bitwise NOT with mask", "bitwise XOR with mask", "bitwise left shift with mask", "bitwise right shift with mask", "bitwise AND with mask", "bitwise OR with mask", "bitwise NOT with mask", "bitwise XOR with mask", "bitwise left shift with mask", "bit"], "_raw_llm_output": "bit manipulation, bitwise operations, bitwise AND, bitwise OR, bitwise NOT, bitwise XOR, bitwise left shift, bitwise right shift, bitwise AND with mask, bitwise OR with mask, bitwise NOT with mask, bitwise XOR with mask, bitwise left shift with mask, bitwise right shift with mask, bitwise AND with mask, bitwise OR with mask, bitwise NOT with mask, bitwise XOR with mask, bitwise left shift with mask, bitwise right shift with mask, bitwise AND with mask, bitwise OR with mask, bitwise NOT with mask, bitwise XOR with mask, bitwise left shift with mask, bitwise right shift with mask, bitwise AND with mask, bitwise OR with mask, bitwise NOT with mask, bitwise XOR with mask, bitwise left shift with mask, bitwise right shift with mask, bitwise AND with mask, bitwise OR with mask, bitwise NOT with mask, bitwise XOR with mask, bitwise left shift with mask, bitwise right shift with mask, bitwise AND with mask, bitwise OR with mask, bitwise NOT with mask, bitwise XOR with mask, bitwise left shift with mask, bit"}
{"seed": "// WorkerMaxFails retrieves maximal level of concurrency based on ATHENS_WORKER_MAX_FAILS.\n// Defaults to 5.\nfunc WorkerMaxFails() uint {\n\tdefaultMaxFails := uint(5)\n\tmaxFailsEnv, err := envy.MustGet(\"ATHENS_WORKER_MAX_FAILS\")\n\tif err != nil {\n\t\treturn defaultMaxFails\n\t}\n\n\tmc, err := strconv.Atoi(maxFailsEnv)\n\tif err != nil {\n\t\treturn defaultMaxFails\n\t}\n\n\treturn uint(mc)\n}", "id": 10868, "concepts": ["environment variable usage", "strconv package usage"], "_raw_llm_output": "environment variable usage, strconv package usage"}
{"seed": "//PollUpdater is a utility function to convert a periodic polling updater to Updater type, catching\n//any panics of the poller and converting them to errors. If a panic occurs we'll\n//re-launch the updater and hopefully it won't happen again.\nfunc PollUpdater(fetch func() (Points, error), interval time.Duration) Updater {\n\treturn func(result chan Points, stop chan bool) (retErr error) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r != nil {\n\t\t\t\tif err, ok := r.(error); ok {\n\t\t\t\t\tretErr = err\n\t\t\t\t} else {\n\t\t\t\t\tretErr = errors.New(\"panic in poll updater\")\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-time.After(interval):\n\t\t\t\tpoints, err := fetch()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tresult <- points\n\t\t\tcase <-stop:\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t}\n\t}\n}", "id": 10884, "concepts": ["panic handling", "error handling (errors.New)", "time.After", "channel handling", "concurrency"], "_raw_llm_output": "panic handling, error handling (errors.New), time.After, channel handling, concurrency"}
{"seed": "// Frequency counts the frequency of each rune in a given text and returns this\n// data as a FreqMap.\nfunc Frequency(s string) FreqMap {\n\tm := FreqMap{}\n\tfor _, r := range s {\n\t\tm[r]++\n\t}\n\treturn m\n}", "id": 10902, "concepts": ["map iteration (range loop)", "map key access", "map value access"], "_raw_llm_output": "map iteration (range loop), map key access, map value access"}
{"seed": "// TraceID returns traceid provided by WithTraceField and ContextWithTrace helpers.\nfunc TraceID(ctx context.Context) string {\n\tval := ctx.Value(traceIDKey{})\n\tif val == nil {\n\t\treturn \"\"\n\t}\n\treturn val.(string)\n}", "id": 10904, "concepts": ["context", "context.Context", "context.WithValue", "context.Value", "context.Context.Value", "context.Context.WithValue", "context.Context.Value", "context.Context.Value", "context.Context.Value", "context.Context.Value", "context.Context.Value", "context.Context.Value", "context.Context.Value", "context.Context.Value", "context.Context.Value", "context.Context.Value", "context.Context.Value", "context.Context.Value", "context.Context.Value", "context.Context.Value", "context.Context.Value", "context.Context.Value", "context.Context.Value", "context.Context.Value", "context.Context.Value", "context.Context.Value", "context.Context.Value", "context.Context.Value", "context.Context.Value", "context.Context.Value", "context.Context.Value", "context.Context.Value", "context.Context.Value", "context.Context.Value", "context.Context.Value", "context.Context.Value", "context.Context.Value", "context.Context.Value", "context.Context.Value", "context.Context.Value", "context.Context.Value", "context.Context.Value", "context.Context.Value", "context.Context.Value", "context"], "_raw_llm_output": "context, context.Context, context.WithValue, context.Value, context.Context.Value, context.Context.WithValue, context.Context.Value, context.Context.Value, context.Context.Value, context.Context.Value, context.Context.Value, context.Context.Value, context.Context.Value, context.Context.Value, context.Context.Value, context.Context.Value, context.Context.Value, context.Context.Value, context.Context.Value, context.Context.Value, context.Context.Value, context.Context.Value, context.Context.Value, context.Context.Value, context.Context.Value, context.Context.Value, context.Context.Value, context.Context.Value, context.Context.Value, context.Context.Value, context.Context.Value, context.Context.Value, context.Context.Value, context.Context.Value, context.Context.Value, context.Context.Value, context.Context.Value, context.Context.Value, context.Context.Value, context.Context.Value, context.Context.Value, context.Context.Value, context.Context.Value, context.Context.Value, context"}
{"seed": "// Summary_ is a convenience wrapper for Summary without the attrs argument.\nfunc Summary_(children ...HTML) HTML {\n  return Summary(nil, children...)\n}", "id": 10906, "concepts": ["function definition", "variadic function", "function composition"], "_raw_llm_output": "function definition, variadic function, function composition"}
{"seed": "// getWMCOVersion returns the version of the operator. This is sourced from the WMCO binary used to create the operator image.\n// This function will return an error if the binary is missing.\nfunc getWMCOVersion() (string, error) {\n\tcmd := exec.Command(wmcoPath, \"version\")\n\tout, err := cmd.Output()\n\tif err != nil {\n\t\treturn \"\", errors.Wrapf(err, \"error running %s\", cmd.String())\n\t}\n\t// out is formatted like:\n\t// ./build/_output/bin/windows-machine-config-operator version: \"0.0.1+4165dda-dirty\", go version: \"go1.13.7 linux/amd64\"\n\tversionSplit := strings.Split(string(out), \"\\\"\")\n\tif len(versionSplit) < 3 {\n\t\treturn \"\", fmt.Errorf(\"unexpected version output\")\n\t}\n\treturn versionSplit[1], nil\n}", "id": 10909, "concepts": ["exec package usage", "string manipulation", "string splitting", "error handling"], "_raw_llm_output": "exec package usage, string manipulation, string splitting, error handling"}
{"seed": "// CalendarSharingActionImportancePPrimary returns a pointer to CalendarSharingActionImportanceVPrimary\nfunc CalendarSharingActionImportancePPrimary() *CalendarSharingActionImportance {\n\tv := CalendarSharingActionImportanceVPrimary\n\treturn &v\n}", "id": 10920, "concepts": ["pointer", "pointer dereference"], "_raw_llm_output": "pointer, pointer dereference"}
{"seed": "// ByteKeySet creates a Byte from a keys of a map[byte](? extends interface{}).\n// If the value passed in is not actually a map, this will panic.\nfunc ByteKeySet(theMap interface{}) Byte {\n\tv := reflect.ValueOf(theMap)\n\tret := Byte{}\n\n\tfor _, keyValue := range v.MapKeys() {\n\t\tret.Insert(keyValue.Interface().(byte))\n\t}\n\treturn ret\n}", "id": 10943, "concepts": ["reflect package usage", "map iteration", "interface conversion"], "_raw_llm_output": "reflect package usage, map iteration, interface conversion"}
{"seed": "// RedString is a convenient helper function to return a string with red\n// foreground.\nfunc RedString(format string, a ...interface{}) (s string) {\n\ts = colorString(FgRed, format, a...)\n\treturn\n}", "id": 10948, "concepts": ["string formatting", "fmt package usage", "color formatting"], "_raw_llm_output": "string formatting, fmt package usage, color formatting"}
{"seed": "// NewMonitoringSettingsClient creates a new instance of MonitoringSettingsClient with the specified values.\n//   - subscriptionID - Gets subscription ID which uniquely identify the Microsoft Azure subscription. The subscription ID forms\n//     part of the URI for every service call.\n//   - credential - used to authorize requests. Usually a credential from azidentity.\n//   - options - pass nil to accept the default values.\nfunc NewMonitoringSettingsClient(subscriptionID string, credential azcore.TokenCredential, options *arm.ClientOptions) (*MonitoringSettingsClient, error) {\n\tcl, err := arm.NewClient(moduleName+\".MonitoringSettingsClient\", moduleVersion, credential, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tclient := &MonitoringSettingsClient{\n\t\tsubscriptionID: subscriptionID,\n\t\tinternal:       cl,\n\t}\n\treturn client, nil\n}", "id": 10953, "concepts": ["module name", "module version", "client options", "client creation", "client initialization"], "_raw_llm_output": "module name, module version, client options, client creation, client initialization"}
{"seed": "// Convert an HEIF encoded image to JPEG and save to outpath.\n// The image will be resized and cropped to width, height.\n// If necessary, the result image will be cropped to match provided aspect ratio.\nfunc ConvertAndResize(inpath, outpath string, width, height int) error {\n\tcmd := exec.Command(\n\t\t\"tifig\",\n\t\tinpath,\n\t\toutpath,\n\t\t\"--crop\",\n\t\t\"-w\", strconv.Itoa(width),\n\t\t\"-h\", strconv.Itoa(height),\n\t)\n\tout, err := cmd.CombinedOutput()\n\tif err != nil {\n\t\terr = fmt.Errorf(\"%v: %s\", err, out)\n\t}\n\treturn err\n}", "id": 10963, "concepts": ["command execution", "exec.Command", "error handling", "string conversion", "flag parsing", "image manipulation"], "_raw_llm_output": "command execution, exec.Command, error handling, string conversion, flag parsing, image manipulation"}
{"seed": "// FindRepository retrieves a single record by ID with an executor.\n// If selectCols is empty Find will return all columns.\nfunc FindRepository(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) (*Repository, error) {\n\trepositoryObj := &Repository{}\n\n\tsel := \"*\"\n\tif len(selectCols) > 0 {\n\t\tsel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), \",\")\n\t}\n\tquery := fmt.Sprintf(\n\t\t\"select %s from `repositories` where `id`=?\", sel,\n\t)\n\n\tq := queries.Raw(query, iD)\n\n\terr := q.Bind(ctx, exec, repositoryObj)\n\tif err != nil {\n\t\tif errors.Cause(err) == sql.ErrNoRows {\n\t\t\treturn nil, sql.ErrNoRows\n\t\t}\n\t\treturn nil, errors.Wrap(err, \"models: unable to select from repositories\")\n\t}\n\n\treturn repositoryObj, nil\n}", "id": 10984, "concepts": ["context", "boil.ContextExecutor", "sql.ErrNoRows", "error handling (errors.Cause)", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", ""], "_raw_llm_output": "context, boil.ContextExecutor, sql.ErrNoRows, error handling (errors.Cause), sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows,"}
{"seed": "// SensitivityPNormal returns a pointer to SensitivityVNormal\nfunc SensitivityPNormal() *Sensitivity {\n\tv := SensitivityVNormal\n\treturn &v\n}", "id": 10992, "concepts": ["pointer usage", "pointer dereference", "pointer declaration"], "_raw_llm_output": "pointer usage, pointer dereference, pointer declaration"}
{"seed": "// NewAmazonResourceEvidence instantiates a new amazonResourceEvidence and sets the default values.\nfunc NewAmazonResourceEvidence()(*AmazonResourceEvidence) {\n    m := &AmazonResourceEvidence{\n        AlertEvidence: *NewAlertEvidence(),\n    }\n    odataTypeValue := \"#microsoft.graph.security.amazonResourceEvidence\"\n    m.SetOdataType(&odataTypeValue)\n    return m\n}", "id": 10994, "concepts": ["struct definition", "pointer usage", "struct field initialization"], "_raw_llm_output": "struct definition, pointer usage, struct field initialization"}
{"seed": "// validateStructTag parses the struct tag and returns an error if it is not\n// in the canonical format, which is a space-separated list of key:\"value\"\n// settings. The value may contain spaces.\nfunc validateStructTag(tag string) error {\n\t// This code is based on the StructTag.Get code in package reflect.\n\n\tn := 0\n\tfor ; tag != \"\"; n++ {\n\t\tif n > 0 && tag != \"\" && tag[0] != ' ' {\n\t\t\t// More restrictive than reflect, but catches likely mistakes\n\t\t\t// like `x:\"foo\",y:\"bar\"`, which parses as `x:\"foo\" ,y:\"bar\"` with second key \",y\".\n\t\t\treturn errTagSpace\n\t\t}\n\t\t// Skip leading space.\n\t\ti := 0\n\t\tfor i < len(tag) && tag[i] == ' ' {\n\t\t\ti++\n\t\t}\n\t\ttag = tag[i:]\n\t\tif tag == \"\" {\n\t\t\tbreak\n\t\t}\n\n\t\t// Scan to colon. A space, a quote or a control character is a syntax error.\n\t\t// Strictly speaking, control chars include the range [0x7f, 0x9f], not just\n\t\t// [0x00, 0x1f], but in practice, we ignore the multi-byte control characters\n\t\t// as it is simpler to inspect the tag's bytes than the tag's runes.\n\t\ti = 0\n\t\tfor i < len(tag) && tag[i] > ' ' && tag[i] != ':' && tag[i] != '\"' && tag[i] != 0x7f {\n\t\t\ti++\n\t\t}\n\t\tif i == 0 {\n\t\t\treturn errTagKeySyntax\n\t\t}\n\t\tif i+1 >= len(tag) || tag[i] != ':' {\n\t\t\treturn errTagSyntax\n\t\t}\n\t\tif tag[i+1] != '\"' {\n\t\t\treturn errTagValueSyntax\n\t\t}\n\t\tkey := tag[:i]\n\t\ttag = tag[i+1:]\n\n\t\t// Scan quoted string to find value.\n\t\ti = 1\n\t\tfor i < len(tag) && tag[i] != '\"' {\n\t\t\tif tag[i] == '\\\\' {\n\t\t\t\ti++\n\t\t\t}\n\t\t\ti++\n\t\t}\n\t\tif i >= len(tag) {\n\t\t\treturn errTagValueSyntax\n\t\t}\n\t\tqvalue := tag[:i+1]\n\t\ttag = tag[i+1:]\n\n\t\tvalue, err := strconv.Unquote(qvalue)\n\t\tif err != nil {\n\t\t\treturn errTagValueSyntax\n\t\t}\n\n\t\tif !checkTagSpaces[key] {\n\t\t\tcontinue\n\t\t}\n\n\t\tswitch key {\n\t\tcase \"xml\":\n\t\t\t// If the first or last character in the XML tag is a space, it is\n\t\t\t// suspicious.\n\t\t\tif strings.Trim(value, \" \") != value {\n\t\t\t\treturn errTagValueSpace\n\t\t\t}\n\n\t\t\t// If there are multiple spaces, they are suspicious.\n\t\t\tif strings.Count(value, \" \") > 1 {\n\t\t\t\treturn errTagValueSpace\n\t\t\t}\n\n\t\t\t// If there is no comma, skip the rest of the checks.\n\t\t\tcomma := strings.IndexRune(value, ',')\n\t\t\tif comma < 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// If the character before a comma is a space, this is suspicious.\n\t\t\tif comma > 0 && value[comma-1] == ' ' {\n\t\t\t\treturn errTagValueSpace\n\t\t\t}\n\t\t\tvalue = value[comma+1:]\n\t\tcase \"json\":\n\t\t\t// JSON allows using spaces in the name, so skip it.\n\t\t\tcomma := strings.IndexRune(value, ',')\n\t\t\tif comma < 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tvalue = value[comma+1:]\n\t\t}\n\n\t\tif strings.IndexByte(value, ' ') >= 0 {\n\t\t\treturn errTagValueSpace\n\t\t}\n\t}\n\treturn nil\n}", "id": 11005, "concepts": ["string manipulation", "string parsing", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", ""], "_raw_llm_output": "string manipulation, string parsing, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation,"}
{"seed": "// MoonTopocentric returns observed topocentric semidiameter of the Moon.\n// \u5728\u5730\u9762\u4e0a(\u7ad9\u5fc3)\u770b\u5230\u7684\u6708\u4eae\u89c6\u534a\u5f84\n//\n//\t\u0394 is distance to Moon in AU.\n//\t\u03b4 is declination of Moon.\n//\tH is hour angle of Moon.\n//\t\u03c1s\u03c6\u02b9, \u03c1c\u03c6\u02b9 are parallax constants as returned by\n//\t    globe.Ellipsoid.ParallaxConstants, for example.\nfunc MoonTopocentric(\u0394 float64, \u03b4 unit.Angle, H unit.HourAngle, \u03c1s\u03c6\u02b9, \u03c1c\u03c6\u02b9 float64) float64 {\n\tconst k = .272481\n\ts\u03c0 := parallax.Horizontal(\u0394).Sin()\n\t// q computed by (40.6, 40.7) p. 280, ch 40.\n\ts\u03b4, c\u03b4 := \u03b4.Sincos()\n\tsH, cH := H.Sincos()\n\tA := c\u03b4 * sH\n\tB := c\u03b4*cH - \u03c1c\u03c6\u02b9*s\u03c0\n\tC := s\u03b4 - \u03c1s\u03c6\u02b9*s\u03c0\n\tq := math.Sqrt(A*A + B*B + C*C)\n\treturn k / q * s\u03c0\n}", "id": 11026, "concepts": ["unit handling (unit.Angle", "unit.HourAngle)", "math.Sqrt", "math.Sin", "math.Cos", "math.Abs", "math.Sqrt", "math.Pow", "math.Pi", "math.Sqrt", "math.Sin", "math.Cos", "math.Abs", "math.Sqrt", "math.Sin", "math.Cos", "math.Abs", "math.Sqrt", "math.Sin", "math.Cos", "math.Abs", "math.Sqrt", "math.Sin", "math.Cos", "math.Abs", "math.Sqrt", "math.Sin", "math.Cos", "math.Abs", "math.Sqrt", "math.Sin", "math.Cos", "math.Abs", "math.Sqrt", "math.Sin", "math.Cos", "math.Abs", "math.Sqrt", "math.Sin", "math.Cos", "math.Abs", "math.Sqrt", "math.Sin", "math.Cos", "math.Abs", "math.Sqrt", "math.Sin", "math.Cos", "math.Abs", "math.Sqrt", "math.Sin", "math.Cos", "math.Abs", "math.Sqrt", "math.Sin", "math.Cos", "math.Abs", "math.Sqrt", "math.Sin", "math.Cos", "math.Abs", "math.Sqrt", "math.Sin"], "_raw_llm_output": "unit handling (unit.Angle, unit.HourAngle), math.Sqrt, math.Sin, math.Cos, math.Abs, math.Sqrt, math.Pow, math.Pi, math.Sqrt, math.Sin, math.Cos, math.Abs, math.Sqrt, math.Sin, math.Cos, math.Abs, math.Sqrt, math.Sin, math.Cos, math.Abs, math.Sqrt, math.Sin, math.Cos, math.Abs, math.Sqrt, math.Sin, math.Cos, math.Abs, math.Sqrt, math.Sin, math.Cos, math.Abs, math.Sqrt, math.Sin, math.Cos, math.Abs, math.Sqrt, math.Sin, math.Cos, math.Abs, math.Sqrt, math.Sin, math.Cos, math.Abs, math.Sqrt, math.Sin, math.Cos, math.Abs, math.Sqrt, math.Sin, math.Cos, math.Abs, math.Sqrt, math.Sin, math.Cos, math.Abs, math.Sqrt, math.Sin, math.Cos, math.Abs, math.Sqrt, math.Sin"}
{"seed": "// CreateUpdateRulesAttributeResponse creates a response to parse from UpdateRulesAttribute response\nfunc CreateUpdateRulesAttributeResponse() (response *UpdateRulesAttributeResponse) {\n\tresponse = &UpdateRulesAttributeResponse{\n\t\tBaseResponse: &responses.BaseResponse{},\n\t}\n\treturn\n}", "id": 11035, "concepts": ["response struct", "pointer", "struct definition"], "_raw_llm_output": "response struct, pointer, struct definition"}
{"seed": "// StrRandom returns random string of given length.\nfunc StrRandom(length int) string {\n\tresult := make([]rune, length)\n\tfor i := range result {\n\t\tresult[i] = alphaNumeric[rand.Intn(len(alphaNumeric))]\n\t}\n\treturn string(result)\n}", "id": 11036, "concepts": ["string manipulation", "random number generation", "slice creation"], "_raw_llm_output": "string manipulation, random number generation, slice creation"}
{"seed": "// GetNotificationMobileService returns an instance of the Notification_Mobile SoftLayer service\nfunc GetNotificationMobileService(sess *session.Session) Notification_Mobile {\n\treturn Notification_Mobile{Session: sess}\n}", "id": 11044, "concepts": ["basic function definition", "struct definition", "interface definition", "method definition"], "_raw_llm_output": "basic function definition, struct definition, interface definition, method definition"}
{"seed": "// ParseDERString decodes a DER-encoded string and puts the value in parsedVal.\n// Returns an error if the unmarshalling fails or if there are trailing bytes in the encoding.\nfunc ParseDERString(val []byte, parsedVal *string) error {\n\trest, err := asn1.Unmarshal(val, parsedVal)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unexpected error unmarshalling DER-encoded string: %v\", err)\n\t}\n\tif len(rest) != 0 {\n\t\treturn errors.New(\"unexpected trailing bytes in DER-encoded string\")\n\t}\n\treturn nil\n}", "id": 11045, "concepts": ["asn1 package usage", "ASN.1 encoding", "ASN.1 decoding"], "_raw_llm_output": "asn1 package usage, ASN.1 encoding, ASN.1 decoding"}
{"seed": "// unlist transforms a single markdown list entry to a flat note entry\nfunc unlist(note string) string {\n\tif !strings.HasPrefix(note, listPrefix) {\n\t\treturn note\n\t}\n\n\tres := strings.Builder{}\n\tscanner := bufio.NewScanner(strings.NewReader(note))\n\tfirstLine := true\n\ttrim := true\n\tfor scanner.Scan() {\n\t\tline := scanner.Text()\n\n\t\t// Per default strip the two dashes from the list\n\t\tprefix := \"  \"\n\n\t\tif strings.HasPrefix(line, listPrefix) {\n\t\t\tif firstLine {\n\t\t\t\t// First list item, strip the prefix\n\t\t\t\tprefix = listPrefix\n\t\t\t\tfirstLine = false\n\t\t\t} else {\n\t\t\t\t// Another list item? Treat it as sublist and do not trim any\n\t\t\t\t// more.\n\t\t\t\ttrim = false\n\t\t\t}\n\t\t}\n\n\t\tif trim {\n\t\t\tline = strings.TrimPrefix(line, prefix)\n\t\t}\n\n\t\tres.WriteString(line + \"\\n\")\n\t}\n\treturn res.String()\n}", "id": 11052, "concepts": ["string manipulation", "string trimming", "string formatting", "string concatenation", "string iteration (range loop)", "string builder", "string prefix matching", "string prefix removal", "string prefix replacement", "string prefix trimming", "string prefix stripping", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", "string prefix removal", ""], "_raw_llm_output": "string manipulation, string trimming, string formatting, string concatenation, string iteration (range loop), string builder, string prefix matching, string prefix removal, string prefix replacement, string prefix trimming, string prefix stripping, string prefix removal, string prefix removal, string prefix removal, string prefix removal, string prefix removal, string prefix removal, string prefix removal, string prefix removal, string prefix removal, string prefix removal, string prefix removal, string prefix removal, string prefix removal, string prefix removal, string prefix removal, string prefix removal, string prefix removal, string prefix removal, string prefix removal, string prefix removal, string prefix removal, string prefix removal, string prefix removal, string prefix removal, string prefix removal, string prefix removal, string prefix removal, string prefix removal, string prefix removal, string prefix removal, string prefix removal, string prefix removal, string prefix removal, string prefix removal, string prefix removal, string prefix removal, string prefix removal, string prefix removal, string prefix removal, string prefix removal, string prefix removal, string prefix removal, string prefix removal, string prefix removal, string prefix removal, string prefix removal, string prefix removal, string prefix removal, string prefix removal, string prefix removal, string prefix removal, string prefix removal,"}
{"seed": "// CheckCompatibility checks a pair of versioned components\n// for compatibility based on specific interoperability constraints\n// or general rules.\n//\n// The design is aimed at allowing a component to verify compatibility\n// with another component, and the logic can be customized by callers\n// for specific requirements at the call site.\n//\n// e.g. \"I am server v2.0.0. Am I compatible with agent v1.2.0?\"\nfunc CheckCompatibility(self, other *VersionedComponent, customRules ...InteropRule) error {\n\tif self == nil || other == nil {\n\t\treturn errors.New(\"nil components\")\n\t}\n\n\t// If the versions are equal, there's nothing else to check.\n\tif self.Version.Equals(other.Version) {\n\t\treturn nil\n\t}\n\n\t// Apply custom rules first (if any), then apply the default rules.\n\tfor _, rule := range append(customRules, defaultRules...) {\n\t\tif rule.Self.Matches(self.Component) && rule.Other.Matches(other.Component) {\n\t\t\tif !rule.Check(self, other) {\n\t\t\t\treturn errors.Wrap(errIncompatComponents(self, other), rule.Description)\n\t\t\t}\n\t\t\tif rule.StopOnSuccess {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\t// At this point, we can assume that the components are compatible.\n\treturn nil\n}", "id": 11053, "concepts": ["struct definition", "struct field access", "interface definition", "interface method definition", "function definition", "function call", "function return", "function parameter", "function return value", "function return value type", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type"], "_raw_llm_output": "struct definition, struct field access, interface definition, interface method definition, function definition, function call, function return, function parameter, function return value, function return value type, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type"}
{"seed": "// cat outputs the content of a provided file or standard input (when the\n// provided file path is \"-\").\nfunc cat(filePath string) (err error) {\n\t// Open file.\n\tvar fr *os.File\n\tif filePath == StdinFileName {\n\t\tfr = os.Stdin\n\t} else {\n\t\tfr, err = os.Open(filePath)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer fr.Close()\n\t}\n\n\t// Write file contents to standard output.\n\t_, err = io.Copy(os.Stdout, fr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "id": 11061, "concepts": ["file handling", "io.Copy", "os.Stdin", "os.Open", "os.Stdout", "os.File", "io.Writer", "io.Reader", "io.ReaderFrom", "io.WriterTo", "io.Closer", "io.CopyBuffer", "io.CopyN", "io.CopyN", "io.ReaderAt", "io.ReaderFrom", "io.WriterAt", "io.WriterTo", "io.Seeker", "io.SeekerFrom", "io.SeekerTo", "io.SeekerAt", "io.SeekerFrom", "io.SeekerTo", "io.SeekerAt", "io.SeekerFrom", "io.SeekerTo", "io.SeekerAt", "io.SeekerFrom", "io.SeekerTo", "io.SeekerAt", "io.SeekerFrom", "io.SeekerTo", "io.SeekerAt", "io.SeekerFrom", "io.SeekerTo", "io.SeekerAt", "io.SeekerFrom", "io.SeekerTo", "io.SeekerAt", "io.SeekerFrom", "io.SeekerTo", "io.SeekerAt", "io.SeekerFrom", "io.SeekerTo", "io.SeekerAt", "io.SeekerFrom", "io"], "_raw_llm_output": "file handling, io.Copy, os.Stdin, os.Open, os.Stdout, os.File, io.Writer, io.Reader, io.ReaderFrom, io.WriterTo, io.Closer, io.CopyBuffer, io.CopyN, io.CopyN, io.ReaderAt, io.ReaderFrom, io.WriterAt, io.WriterTo, io.Seeker, io.SeekerFrom, io.SeekerTo, io.SeekerAt, io.SeekerFrom, io.SeekerTo, io.SeekerAt, io.SeekerFrom, io.SeekerTo, io.SeekerAt, io.SeekerFrom, io.SeekerTo, io.SeekerAt, io.SeekerFrom, io.SeekerTo, io.SeekerAt, io.SeekerFrom, io.SeekerTo, io.SeekerAt, io.SeekerFrom, io.SeekerTo, io.SeekerAt, io.SeekerFrom, io.SeekerTo, io.SeekerAt, io.SeekerFrom, io.SeekerTo, io.SeekerAt, io.SeekerFrom, io"}
{"seed": "// TestContext returns context with initalized log field \"testname\" equal t.Name() value.\nfunc TestContext(t *testing.T) context.Context {\n\tctx, _ := WithField(context.Background(), \"testname\", t.Name())\n\treturn ctx\n}", "id": 11065, "concepts": ["context package usage", "context.Background", "context.WithField"], "_raw_llm_output": "context package usage, context.Background, context.WithField"}
{"seed": "// CreateAddStudioLayoutRequest creates a request to invoke AddStudioLayout API\nfunc CreateAddStudioLayoutRequest() (request *AddStudioLayoutRequest) {\n\trequest = &AddStudioLayoutRequest{\n\t\tRpcRequest: &requests.RpcRequest{},\n\t}\n\trequest.InitWithApiInfo(\"live\", \"2016-11-01\", \"AddStudioLayout\", \"live\", \"openAPI\")\n\trequest.Method = requests.POST\n\treturn\n}", "id": 11069, "concepts": ["struct definition", "method definition", "method invocation", "pointer usage", "API invocation"], "_raw_llm_output": "struct definition, method definition, method invocation, pointer usage, API invocation"}
{"seed": "// NewTokenNEQ applies the NEQ predicate on the \"new_token\" field.\nfunc NewTokenNEQ(v string) predicate.User {\n\treturn predicate.User(sql.FieldNEQ(FieldNewToken, v))\n}", "id": 11085, "concepts": ["sql package usage", "predicate.User", "sql.FieldNEQ"], "_raw_llm_output": "sql package usage, predicate.User, sql.FieldNEQ"}
{"seed": "// NewMessageRule instantiates a new messageRule and sets the default values.\nfunc NewMessageRule()(*MessageRule) {\n    m := &MessageRule{\n        Entity: *NewEntity(),\n    }\n    return m\n}", "id": 11094, "concepts": ["struct definition", "struct field initialization", "pointer receivers", "pointer dereference"], "_raw_llm_output": "struct definition, struct field initialization, pointer receivers, pointer dereference"}
{"seed": "// CreatedAtGTE applies the GTE predicate on the \"created_at\" field.\nfunc CreatedAtGTE(v time.Time) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.GTE(s.C(FieldCreatedAt), v))\n\t})\n}", "id": 11100, "concepts": ["sql.Selector", "sql.GTE", "sql.C", "sql.Where", "predicate.User", "struct composition"], "_raw_llm_output": "sql.Selector, sql.GTE, sql.C, sql.Where, predicate.User, struct composition"}
{"seed": "// Blockquote_ is a convenience wrapper for Blockquote without the attrs argument.\nfunc Blockquote_(children ...HTML) HTML {\n  return Blockquote(nil, children...)\n}", "id": 11101, "concepts": ["HTML", "function definition", "function overloading", "basic function definition"], "_raw_llm_output": "HTML, function definition, function overloading, basic function definition"}
{"seed": "// Colgroup represents the HTML element 'colgroup'.\n// For more information visit https://www.w3schools.com/tags/tag_colgroup.asp.\nfunc Colgroup(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"colgroup\", Attributes: attrs, Children: children}\n}", "id": 11125, "concepts": ["HTML generation", "HTML tree traversal", "HTML element definition", "HTML attribute definition"], "_raw_llm_output": "HTML generation, HTML tree traversal, HTML element definition, HTML attribute definition"}
{"seed": "// Time represents the HTML element 'time'.\n// For more information visit https://www.w3schools.com/tags/tag_time.asp.\nfunc Time(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"time\", Attributes: attrs, Children: children}\n}", "id": 11128, "concepts": ["HTML generation", "HTML tree building", "HTML element definition"], "_raw_llm_output": "HTML generation, HTML tree building, HTML element definition"}
{"seed": "// splitEntryName splits the POSIX name into hierarchical arms. Each directory\n// finishes with slash (\"/\"). Example: \"a/b/c\" will be split into: [\"a/\",\"b/\",\"c\"]\n// whereas \"a/b/c/\" will be split into: [\"a/\", \"b/\", \"c/\"].\nfunc splitEntryName(name string) []string {\n\tcmn.AssertMsg(name != \"\", name)\n\tarms := make([]string, 0, strings.Count(name, separator))\n\tfor {\n\t\tidx := strings.Index(name, separator)\n\t\tif idx == -1 {\n\t\t\tarms = append(arms, name)\n\t\t\tbreak\n\t\t}\n\n\t\tarms = append(arms, name[:idx+1])\n\t\tname = name[idx+1:]\n\t\tif name == \"\" {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn arms\n}", "id": 11141, "concepts": ["string manipulation", "string counting", "string indexing", "string slicing"], "_raw_llm_output": "string manipulation, string counting, string indexing, string slicing"}
{"seed": "// BetterHeroScoreAtNEQ applies the NEQ predicate on the \"better_hero_score_at\" field.\nfunc BetterHeroScoreAtNEQ(v time.Time) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldBetterHeroScoreAt), v))\n\t})\n}", "id": 11174, "concepts": ["sql.Selector", "sql.NEQ", "sql.Where"], "_raw_llm_output": "sql.Selector, sql.NEQ, sql.Where"}
{"seed": "// IsDir \u5224\u65ad\u6240\u7ed9\u8def\u5f84\u662f\u5426\u4e3a\u6587\u4ef6\u5939\nfunc IsDir(path string) bool {\n\ts, err := os.Stat(path)\n\tif err != nil {\n\t\treturn false\n\t}\n\treturn s.IsDir()\n}", "id": 11177, "concepts": ["os.Stat", "os.IsDir", "basic function definition"], "_raw_llm_output": "os.Stat, os.IsDir, basic function definition"}
{"seed": "// wmLightsOutIn verifies that the activity can go from maximized to fullscreen mode, an vice-versa as defined in go/arc-wm-p:\n// \"Clamshell: lights out or fullscreen\" (slide #19) and \"Clamshell: exit lights out or fullscreen\" (slide #20).\nfunc wmLightsOutIn(ctx context.Context, tconn *chrome.TestConn, a *arc.ARC, d *ui.Device) error {\n\t// Slides #19 and #20 describe this scenario with \"Landscape\" activities. But using \"unspecified\" since\n\t// a tablet in portrait mode (like Dru) + keyboard means that we have a clamshell device in portrait mode.\n\tact, err := arc.NewActivity(a, wm.Pkg24, wm.ResizableUnspecifiedActivity)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer act.Close()\n\n\tfor _, test := range []struct {\n\t\tname        string\n\t\tlightsOutFn func() error\n\t\tlightsInFn  func() error\n\t}{\n\t\t{\"Using Zoom Toggle key\",\n\t\t\tfunc() error { return wm.ToggleFullscreen(ctx, tconn) },\n\t\t\tfunc() error { return wm.ToggleFullscreen(ctx, tconn) }},\n\t\t{\"Using Android API\",\n\t\t\tfunc() error { return wm.UIClickImmersive(ctx, act, d) },\n\t\t\tfunc() error { return wm.UIClickNormal(ctx, act, d) }},\n\t} {\n\t\tif err := func() error {\n\t\t\ttesting.ContextLogf(ctx, \"Running subtest %q\", test.name)\n\t\t\tif err := act.StartWithDefaultOptions(ctx, tconn); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t// Stop activity at exit time so that the next WM test can launch a different activity from the same package.\n\t\t\tdefer act.Stop(ctx, tconn)\n\n\t\t\tif err := wm.WaitUntilActivityIsReady(ctx, tconn, act, d); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// As the default launch behavior is different depending on the ARC version, we need to ensure it's maximized first.\n\t\t\tif _, err := ash.SetARCAppWindowState(ctx, tconn, act.PackageName(), ash.WMEventMaximize); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// Initial state: maximized with visible caption.\n\t\t\tif err := ash.WaitForARCAppWindowState(ctx, tconn, act.PackageName(), ash.WindowStateMaximized); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif err := wm.WaitUntilFrameMatchesCondition(ctx, tconn, act.PackageName(), true, ash.FrameModeNormal); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// Invoke fullscreen method.\n\t\t\tif err := test.lightsOutFn(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif err := ash.WaitForARCAppWindowState(ctx, tconn, act.PackageName(), ash.WindowStateFullscreen); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif err := wm.WaitUntilFrameMatchesCondition(ctx, tconn, act.PackageName(), false, ash.FrameModeImmersive); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// Invoke maximized method.\n\t\t\tif err := test.lightsInFn(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif err := ash.WaitForARCAppWindowState(ctx, tconn, act.PackageName(), ash.WindowStateMaximized); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\treturn nil\n\t\t}(); err != nil {\n\t\t\treturn errors.Wrapf(err, \"%q subtest failed\", test.name)\n\t\t}\n\t}\n\treturn nil\n}", "id": 11178, "concepts": ["error handling (errors.Wrapf)", "function definition", "anonymous function", "error handling (errors.Is)", "if statement", "for loop", "function call", "function return", "function parameter", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value"], "_raw_llm_output": "error handling (errors.Wrapf), function definition, anonymous function, error handling (errors.Is), if statement, for loop, function call, function return, function parameter, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value"}
{"seed": "// Gets the sequences from the .seq file and returns them in an array of Sequence structs\n// Assuming you have the following in the .seq file:\n//    >99_forward\n//    ACGT\n// You will get a Sequence struct with the following fields:\n//    name = \"99_forward\"\n//    seq = \"ACGT\"\n//    isForward = true\n//    val = 99\nfunc getSeqs(seqFile string) ([]Sequence) {\n\n  var out []Sequence\n\n  // Open the .seq file\n  fi, err := os.Open(seqFile)\n  if err != nil {\n    fmt.Println(\"Error - couldn't open .seq file\")\n    os.Exit(1)\n  }\n  scanner := bufio.NewScanner(fi)\n\n  // For each line in the file\n  for scanner.Scan() {\n\n    var temp Sequence\n\n    // Get name\n    line := scanner.Text()[1:]\n    temp.name = line\n\n    // Get value\n    split_line := strings.Split(line, \"_\")\n    temp.val, _ = strconv.Atoi(split_line[0])\n\n    // Get isForward\n    if split_line[1] == \"forward\" {\n      temp.isForward = true\n    } else {\n      temp.isForward = false\n    }\n\n    // Get sequence\n    scanner.Scan()\n    temp.seq = scanner.Text()\n\n    out = append(out, temp)\n  }\n\n  return out\n}", "id": 11191, "concepts": ["file handling", "string manipulation", "string parsing", "string conversion", "file reading", "file writing", "file scanning", "string splitting", "string indexing", "string concatenation", "string comparison", "string length", "string iteration", "string range loop", "string iteration (range loop)", "string iteration (range loop)", "string iteration (range loop)", "string iteration (range loop)", "string iteration (range loop)", "string iteration (range loop)", "string iteration (range loop)", "string iteration (range loop)", "string iteration (range loop)", "string iteration (range loop)", "string iteration (range loop)", "string iteration (range loop)", "string iteration (range loop)", "string iteration (range loop)", "string iteration (range loop)", "string iteration (range loop)", "string iteration (range loop)", "string iteration (range loop)", "string iteration (range loop)", "string iteration (range loop)", "string iteration (range loop)", "string iteration (range loop)", "string iteration (range loop)", "string iteration (range loop)", "string iteration (range loop)", "string iteration (range loop)", "string iteration (range loop)", "string iteration (range loop)", "string iteration (range loop)", "string iteration (range loop)", "string iteration (range loop)", "string iteration (range loop)", "string iteration (range loop)", "string iteration (range loop)", "string iteration (range loop)", "string"], "_raw_llm_output": "file handling, string manipulation, string parsing, string conversion, file reading, file writing, file scanning, string splitting, string indexing, string concatenation, string comparison, string length, string iteration, string range loop, string iteration (range loop), string iteration (range loop), string iteration (range loop), string iteration (range loop), string iteration (range loop), string iteration (range loop), string iteration (range loop), string iteration (range loop), string iteration (range loop), string iteration (range loop), string iteration (range loop), string iteration (range loop), string iteration (range loop), string iteration (range loop), string iteration (range loop), string iteration (range loop), string iteration (range loop), string iteration (range loop), string iteration (range loop), string iteration (range loop), string iteration (range loop), string iteration (range loop), string iteration (range loop), string iteration (range loop), string iteration (range loop), string iteration (range loop), string iteration (range loop), string iteration (range loop), string iteration (range loop), string iteration (range loop), string iteration (range loop), string iteration (range loop), string iteration (range loop), string iteration (range loop), string iteration (range loop), string"}
{"seed": "// SocialAvatarURLContains applies the Contains predicate on the \"social_avatar_url\" field.\nfunc SocialAvatarURLContains(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.Contains(s.C(FieldSocialAvatarURL), v))\n\t})\n}", "id": 11198, "concepts": ["sql.Selector", "sql.Contains", "sql.C", "sql.Where", "sql.Predicate", "sql.Selector.Where", "sql.Selector.C", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where"], "_raw_llm_output": "sql.Selector, sql.Contains, sql.C, sql.Where, sql.Predicate, sql.Selector.Where, sql.Selector.C, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where"}
{"seed": "// toMilliseconds converts duration to milliseconds, precision 0.02.\nfunc toMilliseconds(duration time.Duration) float64 {\n\tif duration < time.Microsecond*10 {\n\t\treturn 0\n\t}\n\n\tms := float64(duration) / float64(time.Millisecond)\n\t// Round time to 0.02 precision\n\treturn math.Round(ms*100) / 100\n}", "id": 11214, "concepts": ["time package usage", "floating-point arithmetic", "time.Duration", "math package usage"], "_raw_llm_output": "time package usage, floating-point arithmetic, time.Duration, math package usage"}
{"seed": "// NewSettingsObjectUpdateWithDefaults instantiates a new SettingsObjectUpdate object\n// This constructor will only assign default values to properties that have it defined,\n// but it doesn't guarantee that properties required by API are set\nfunc NewSettingsObjectUpdateWithDefaults() *SettingsObjectUpdate {\n\tthis := SettingsObjectUpdate{}\n\treturn &this\n}", "id": 11294, "concepts": ["constructor", "default value assignment", "API usage"], "_raw_llm_output": "constructor, default value assignment, API usage"}
{"seed": "// ParseJSONWithOptions an AWS CloudFormation template (expects a []byte of valid JSON)\n// Parsing can be tweaked via the specified options.\nfunc ParseJSONWithOptions(data []byte, options *intrinsics.ProcessorOptions) (*cloudformation.Template, error) {\n\n\t// Process all AWS CloudFormation intrinsic functions (e.g. Fn::Join)\n\tintrinsified, err := intrinsics.ProcessJSON(data, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn unmarshal(intrinsified)\n\n}", "id": 11304, "concepts": ["error handling (errors.As)", "JSON parsing", "AWS CloudFormation intrinsic functions"], "_raw_llm_output": "error handling (errors.As), JSON parsing, AWS CloudFormation intrinsic functions"}
{"seed": "// NewDcimRacksListParams creates a new DcimRacksListParams object,\n// with the default timeout for this client.\n//\n// Default values are not hydrated, since defaults are normally applied by the API server side.\n//\n// To enforce default values in parameter, use SetDefaults or WithDefaults.\nfunc NewDcimRacksListParams() *DcimRacksListParams {\n\treturn &DcimRacksListParams{\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 11306, "concepts": ["struct definition", "function definition", "default value assignment"], "_raw_llm_output": "struct definition, function definition, default value assignment"}
{"seed": "// ParseInsecure parses and validates a JWT-SVID token and returns the\n// JWT-SVID. The JWT-SVID signature is not verified.\nfunc ParseInsecure(token string, audience []string) (*SVID, error) {\n\treturn parse(token, audience, func(tok *jwt.JSONWebToken, td spiffeid.TrustDomain) (map[string]interface{}, error) {\n\t\t// Obtain the token claims insecurely, i.e. without signature verification\n\t\tclaimsMap := make(map[string]interface{})\n\t\tif err := tok.UnsafeClaimsWithoutVerification(&claimsMap); err != nil {\n\t\t\treturn nil, jwtsvidErr.New(\"unable to get claims from token: %v\", err)\n\t\t}\n\n\t\treturn claimsMap, nil\n\t})\n}", "id": 11307, "concepts": ["jwt parsing", "jwt verification", "jwt claims", "jwt signature verification"], "_raw_llm_output": "jwt parsing, jwt verification, jwt claims, jwt signature verification"}
{"seed": "// NotEqual asserts that \"expected\" is not equal to \"actual\".\n//\n// If they are equal the expected value will be displayed.\nfunc NotEqual[T any](t testing.TB, expected, actual T, msgAndArgs ...interface{}) {\n\tif !objectsAreEqual(expected, actual) {\n\t\treturn\n\t}\n\tt.Helper()\n\tmsg := formatMsgAndArgs(\"Expected values to not be equal but both were:\", msgAndArgs...)\n\tt.Fatalf(\"%s\\n%s\", msg, repr.String(expected, repr.Indent(\"  \")))\n}", "id": 11314, "concepts": ["type parameters", "type assertions", "type equality", "testing.TB", "testing.T", "testing.B", "testing.Fail", "testing.Helper", "testing.Fatalf", "testing.Helper", "testing.TB", "testing.T", "testing.B", "testing.Fail", "testing.Helper", "testing.Fatalf", "testing.Helper", "testing.TB", "testing.T", "testing.B", "testing.Fail", "testing.Helper", "testing.Fatalf", "testing.Helper", "testing.TB", "testing.T", "testing.B", "testing.Fail", "testing.Helper", "testing.Fatalf", "testing.Helper", "testing.TB", "testing.T", "testing.B", "testing.Fail", "testing.Helper", "testing.Fatalf", "testing.Helper", "testing.TB", "testing.T", "testing.B", "testing.Fail", "testing.Helper", "testing.Fatalf", "testing.Helper", "testing.TB", "testing.T", "testing.B", "testing.Fail", "testing.Helper", "testing.Fatalf", "testing.Helper", "testing.TB", "testing.T", "testing.B", "testing.Fail", "testing.Helper", "testing.Fatalf", "testing.Helper", "testing.TB", "testing.T", "testing.B", "testing.Fail", "testing.Helper", "testing."], "_raw_llm_output": "type parameters, type assertions, type equality, testing.TB, testing.T, testing.B, testing.Fail, testing.Helper, testing.Fatalf, testing.Helper, testing.TB, testing.T, testing.B, testing.Fail, testing.Helper, testing.Fatalf, testing.Helper, testing.TB, testing.T, testing.B, testing.Fail, testing.Helper, testing.Fatalf, testing.Helper, testing.TB, testing.T, testing.B, testing.Fail, testing.Helper, testing.Fatalf, testing.Helper, testing.TB, testing.T, testing.B, testing.Fail, testing.Helper, testing.Fatalf, testing.Helper, testing.TB, testing.T, testing.B, testing.Fail, testing.Helper, testing.Fatalf, testing.Helper, testing.TB, testing.T, testing.B, testing.Fail, testing.Helper, testing.Fatalf, testing.Helper, testing.TB, testing.T, testing.B, testing.Fail, testing.Helper, testing.Fatalf, testing.Helper, testing.TB, testing.T, testing.B, testing.Fail, testing.Helper, testing."}
{"seed": "// WithTimeout specifies a time limit for requests made by this [Client]. Defaults to 5 seconds.\nfunc WithTimeout(timeout time.Duration) ClientOption {\n\treturn func(client *Client) {\n\t\tclient.timeout = timeout\n\t}\n}", "id": 11316, "concepts": ["function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", ""], "_raw_llm_output": "function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition,"}
{"seed": "// buildSteps builds the meta pipeline steps.\n// The tasks of the meta pipeline are:\n// 1) make sure the right commits are merged\n// 2) create the effective pipeline and write it to disk\n// 3) one step for each extending app\n// 4) create Tekton CRDs for the meta pipeline\nfunc buildSteps(params CRDCreationParameters) ([]syntax.Step, error) {\n\tvar steps []syntax.Step\n\n\t// 1)\n\tstep := stepMergePullRefs(params.PullRef)\n\tsteps = append(steps, step)\n\n\t// 2)\n\tstep = stepEffectivePipeline(params)\n\tsteps = append(steps, step)\n\n\tlog.Logger().Debugf(\"creating pipeline steps for extending apps\")\n\t// 3)\n\tfor _, app := range params.Apps {\n\t\tif app.Spec.PipelineExtension == nil {\n\t\t\tlog.Logger().Warnf(\"Skipping app %s in meta pipeline. It contains label %s with value %s, but does not contain PipelineExtension fields.\", app.Name, apps.AppTypeLabel, apps.PipelineExtension)\n\t\t\tcontinue\n\t\t}\n\n\t\textension := app.Spec.PipelineExtension\n\t\tstep := syntax.Step{\n\t\t\tName:      extension.Name,\n\t\t\tImage:     extension.Image,\n\t\t\tCommand:   extension.Command,\n\t\t\tArguments: extension.Args,\n\t\t}\n\n\t\tlog.Logger().Debugf(\"App %s contributes with step %s\", app.Name, util.PrettyPrint(step))\n\t\tsteps = append(steps, step)\n\t}\n\n\t// 4)\n\tstep = stepCreateTektonCRDs(params)\n\tsteps = append(steps, step)\n\n\treturn steps, nil\n}", "id": 11323, "concepts": ["slice definition", "slice append", "map definition", "map iteration (range loop)", "string formatting", "function definition", "function return", "function call", "function parameter", "function parameter default value", "function parameter type", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function parameter type assertion", "function"], "_raw_llm_output": "slice definition, slice append, map definition, map iteration (range loop), string formatting, function definition, function return, function call, function parameter, function parameter default value, function parameter type, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function parameter type assertion, function"}
{"seed": "// NoContent is a convenience function for building HTTP 204 No Content\n// responses.\nfunc NoContent(logging ...interface{}) Response {\n\treturn Response{\n\t\tStatus:  http.StatusNoContent,\n\t\tData:    Bytes(nil),\n\t\tLogging: logging,\n\t}\n}", "id": 11329, "concepts": ["HTTP 204 response", "Response struct", "Bytes function"], "_raw_llm_output": "HTTP 204 response, Response struct, Bytes function"}
{"seed": "// NewHandler injects log into requests context.\nfunc NewHandler(log zerolog.Logger) func(httpserver.Handler) httpserver.Handler {\n\treturn func(next httpserver.Handler) httpserver.Handler {\n\t\treturn httpserver.HandlerFunc(func(w http.ResponseWriter, r *http.Request) (int, error) {\n\t\t\t// Create a copy of the logger (including internal context slice)\n\t\t\t// to prevent data race when using UpdateContext.\n\t\t\tl := log.With().Logger()\n\t\t\tr = r.WithContext(l.WithContext(r.Context()))\n\t\t\treturn next.ServeHTTP(w, r)\n\t\t})\n\t}\n}", "id": 11330, "concepts": ["httpserver package usage", "context usage", "zerolog package usage"], "_raw_llm_output": "httpserver package usage, context usage, zerolog package usage"}
{"seed": "// _escFSByte returns the named file from the embedded assets. If useLocal is\n// true, the filesystem's contents are instead used.\nfunc _escFSByte(useLocal bool, name string) ([]byte, error) {\n\tif useLocal {\n\t\tf, err := _escLocal.Open(name)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tb, err := ioutil.ReadAll(f)\n\t\t_ = f.Close()\n\t\treturn b, err\n\t}\n\tf, err := _escStatic.prepare(name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn f.data, nil\n}", "id": 11345, "concepts": ["embedded assets", "file system usage", "ioutil.ReadAll"], "_raw_llm_output": "embedded assets, file system usage, ioutil.ReadAll"}
{"seed": "// Noscript_ is a convenience wrapper for Noscript without the attrs argument.\nfunc Noscript_(children ...HTML) HTML {\n  return Noscript(nil, children...)\n}", "id": 11375, "concepts": ["HTML", "HTML tag", "HTML attribute", "function definition", "function argument", "function return value", "function call"], "_raw_llm_output": "HTML, HTML tag, HTML attribute, function definition, function argument, function return value, function call"}
{"seed": "// NewSignalFromPointer will return a Signal from the\n// given unsafe pointer. This is primarily used in conjunction with MethodBindPtrCall.\nfunc NewSignalFromPointer(ptr Pointer) Signal {\n\n\treturn Signal{base: (*C.godot_signal)(ptr.getBase())}\n}", "id": 11384, "concepts": ["unsafe pointer usage", "CGO", "MethodBindPtrCall"], "_raw_llm_output": "unsafe pointer usage, CGO, MethodBindPtrCall"}
{"seed": "// NewKubernetesEthernetMatcher instantiates a new KubernetesEthernetMatcher object\n// This constructor will assign default values to properties that have it defined,\n// and makes sure properties required by API are set, but the set of arguments\n// will change when the set of required properties is changed\nfunc NewKubernetesEthernetMatcher(classId string, objectType string) *KubernetesEthernetMatcher {\n\tthis := KubernetesEthernetMatcher{}\n\tthis.ClassId = classId\n\tthis.ObjectType = objectType\n\tvar type_ string = \"Name\"\n\tthis.Type = &type_\n\treturn &this\n}", "id": 11388, "concepts": ["constructor", "pointer", "struct", "basic function definition"], "_raw_llm_output": "constructor, pointer, struct, basic function definition"}
{"seed": "// ParseUpdateDNSZoneResponse parses an HTTP response from a UpdateDNSZoneWithResponse call\nfunc ParseUpdateDNSZoneResponse(rsp *http.Response) (*UpdateDNSZoneResponse, error) {\n\tbodyBytes, err := ioutil.ReadAll(rsp.Body)\n\tdefer rsp.Body.Close()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse := &UpdateDNSZoneResponse{\n\t\tBody:         bodyBytes,\n\t\tHTTPResponse: rsp,\n\t}\n\n\tswitch {\n\tcase strings.Contains(rsp.Header.Get(\"Content-Type\"), \"json\") && rsp.StatusCode == 200:\n\t\tvar dest ScalewayDomainV2alpha2DNSZone\n\t\tif err := json.Unmarshal(bodyBytes, &dest); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresponse.JSON200 = &dest\n\n\t}\n\n\treturn response, nil\n}", "id": 11390, "concepts": ["http response parsing", "json parsing", "http client usage", "error handling", "switch statement"], "_raw_llm_output": "http response parsing, json parsing, http client usage, error handling, switch statement"}
{"seed": "// tag returns the git tag for the current branch or \"\" if none.\nfunc tag() string {\n\ts, _ := sh.Output(\"bash\", \"-c\", \"git describe --abbrev=0 --tags 2> /dev/null\")\n\tif s == \"\" {\n\t\treturn \"0.0.0\"\n\t}\n\treturn s\n}", "id": 11401, "concepts": ["shell scripting", "git usage"], "_raw_llm_output": "shell scripting, git usage"}
{"seed": "// NewHttpSyntheticMonitorUpdate instantiates a new HttpSyntheticMonitorUpdate object\n// This constructor will assign default values to properties that have it defined,\n// and makes sure properties required by API are set, but the set of arguments\n// will change when the set of required properties is changed\nfunc NewHttpSyntheticMonitorUpdate(frequencyMin int32, type_ string, name string, locations []string, enabled bool, script map[string]interface{}, tags []TagWithSourceInfo, manuallyAssignedApps []string) *HttpSyntheticMonitorUpdate {\n\tthis := HttpSyntheticMonitorUpdate{}\n\tthis.FrequencyMin = frequencyMin\n\tthis.Type = type_\n\tthis.Name = name\n\tthis.Locations = locations\n\tthis.Enabled = enabled\n\tthis.Script = script\n\tthis.Tags = tags\n\tthis.ManuallyAssignedApps = manuallyAssignedApps\n\treturn &this\n}", "id": 11402, "concepts": ["constructor", "map", "slice", "struct", "basic function definition"], "_raw_llm_output": "constructor, map, slice, struct, basic function definition"}
{"seed": "// PodSpecApplyConfiguration constructs an declarative configuration of the PodSpec type for use with\n// apply.\nfunc PodSpec() *PodSpecApplyConfiguration {\n\treturn &PodSpecApplyConfiguration{}\n}", "id": 11420, "concepts": ["struct definition", "method definition", "anonymous function", "pointer usage"], "_raw_llm_output": "struct definition, method definition, anonymous function, pointer usage"}
{"seed": "// AsSeason_Uc_Ta parses a string to find the corresponding Season_Uc_Ta, accepting either one of the string values or\n// a number. The input representation is determined by season_uc_taMarshalTextRep. It wraps Parse.\nfunc AsSeason_Uc_Ta(s string) (Season_Uc_Ta, error) {\n\tvar v = new(Season_Uc_Ta)\n\terr := v.Parse(s)\n\treturn *v, err\n}", "id": 11442, "concepts": ["parsing", "string representation", "basic function definition"], "_raw_llm_output": "parsing, string representation, basic function definition"}
{"seed": "// NetworkInterface_Spec_ARMGenerator returns a generator of NetworkInterface_Spec_ARM instances for property testing.\n// We first initialize networkInterface_Spec_ARMGenerator with a simplified generator based on the\n// fields with primitive types then replacing it with a more complex one that also handles complex fields\n// to ensure any cycles in the object graph properly terminate.\nfunc NetworkInterface_Spec_ARMGenerator() gopter.Gen {\n\tif networkInterface_Spec_ARMGenerator != nil {\n\t\treturn networkInterface_Spec_ARMGenerator\n\t}\n\n\tgenerators := make(map[string]gopter.Gen)\n\tAddIndependentPropertyGeneratorsForNetworkInterface_Spec_ARM(generators)\n\tnetworkInterface_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterface_Spec_ARM{}), generators)\n\n\t// The above call to gen.Struct() captures the map, so create a new one\n\tgenerators = make(map[string]gopter.Gen)\n\tAddIndependentPropertyGeneratorsForNetworkInterface_Spec_ARM(generators)\n\tAddRelatedPropertyGeneratorsForNetworkInterface_Spec_ARM(generators)\n\tnetworkInterface_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterface_Spec_ARM{}), generators)\n\n\treturn networkInterface_Spec_ARMGenerator\n}", "id": 11450, "concepts": ["struct definition", "anonymous function", "property testing", "property generator", "complex object graph"], "_raw_llm_output": "struct definition, anonymous function, property testing, property generator, complex object graph"}
{"seed": "// ignoreResult is a convenience function for creating an ignore objectResult\nfunc ignoreResult(namespacedName string, reason string) objectResult {\n\treturn objectResult{NamespacedName: namespacedName, Ignored: true, Reason: reason}\n}", "id": 11458, "concepts": ["struct definition", "anonymous function", "function definition", "object definition"], "_raw_llm_output": "struct definition, anonymous function, function definition, object definition"}
{"seed": "// Optgroup represents the HTML element 'optgroup'.\n// For more information visit https://www.w3schools.com/tags/tag_optgroup.asp.\nfunc Optgroup(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"optgroup\", Attributes: attrs, Children: children}\n}", "id": 11469, "concepts": ["HTML generation", "HTML element definition", "HTML attribute definition", "HTML tree definition", "HTML element usage"], "_raw_llm_output": "HTML generation, HTML element definition, HTML attribute definition, HTML tree definition, HTML element usage"}
{"seed": "// CommentMarker sets the rune character of comment lines in the message.\nfunc CommentMarker(char rune) CommitOption {\n\treturn func(c *commitConfig) {\n\t\tc.commentMarker = char\n\t}\n}", "id": 11482, "concepts": ["function composition", "function options"], "_raw_llm_output": "function composition, function options"}
{"seed": "// DB is an alias to Default.\nfunc DB() *Connection {\n\treturn defaultConnection\n}", "id": 11487, "concepts": ["aliasing", "connection management"], "_raw_llm_output": "aliasing, connection management"}
{"seed": "// WorkplaceLT applies the LT predicate on the \"workplace\" field.\nfunc WorkplaceLT(v string) predicate.User {\n\treturn predicate.User(sql.FieldLT(FieldWorkplace, v))\n}", "id": 11492, "concepts": ["sql.FieldLT", "sql.FieldGT", "sql.FieldEQ", "sql.FieldNE", "sql.FieldIN", "sql.FieldNotIn", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldNull", "sql.FieldNotNull", "sql.FieldBetween", "sql.FieldNotBetween", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldNull", "sql.FieldNotNull", "sql.FieldBetween", "sql.FieldNotBetween", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldNull", "sql.FieldNotNull", "sql.FieldBetween", "sql.FieldNotBetween", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldNull", "sql.FieldNotNull", "sql.FieldBetween", "sql.FieldNotBetween", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldNull", "sql.FieldNotNull", "sql.FieldBetween", "sql.FieldNotBetween", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldNull"], "_raw_llm_output": "sql.FieldLT, sql.FieldGT, sql.FieldEQ, sql.FieldNE, sql.FieldIN, sql.FieldNotIn, sql.FieldLike, sql.FieldNotLike, sql.FieldNull, sql.FieldNotNull, sql.FieldBetween, sql.FieldNotBetween, sql.FieldIn, sql.FieldNotIn, sql.FieldLike, sql.FieldNotLike, sql.FieldNull, sql.FieldNotNull, sql.FieldBetween, sql.FieldNotBetween, sql.FieldIn, sql.FieldNotIn, sql.FieldLike, sql.FieldNotLike, sql.FieldNull, sql.FieldNotNull, sql.FieldBetween, sql.FieldNotBetween, sql.FieldIn, sql.FieldNotIn, sql.FieldLike, sql.FieldNotLike, sql.FieldNull, sql.FieldNotNull, sql.FieldBetween, sql.FieldNotBetween, sql.FieldIn, sql.FieldNotIn, sql.FieldLike, sql.FieldNotLike, sql.FieldNull, sql.FieldNotNull, sql.FieldBetween, sql.FieldNotBetween, sql.FieldIn, sql.FieldNotIn, sql.FieldLike, sql.FieldNotLike, sql.FieldNull"}
{"seed": "// Inspect traverses an AST in depth-first order: It starts by calling\n// f(node); node must not be nil. If f returns true, Inspect invokes f\n// recursively for each of the non-nil children of node, followed by a\n// call of f(nil).\n//\nfunc Inspect(node Node, f func(Node) bool) {\n\tif v := reflect.ValueOf(node); v.Kind() == reflect.Ptr && v.IsNil() {\n\t\treturn\n\t}\n\tWalk(inspector(f), node)\n}", "id": 11493, "concepts": ["reflection", "AST traversal", "function composition"], "_raw_llm_output": "reflection, AST traversal, function composition"}
{"seed": "// checkLabel checks that the given build label is not a pseudo-label.\n// These are disallowed in (nearly) all contexts.\nfunc checkLabel(s *scope, label core.BuildLabel) core.BuildLabel {\n\ts.NAssert(label.IsAllTargets(), \":all labels are not permitted here\")\n\ts.NAssert(label.IsAllSubpackages(), \"... labels are not permitted here\")\n\treturn label\n}", "id": 11495, "concepts": ["struct usage", "interface usage", "string manipulation", "control flow"], "_raw_llm_output": "struct usage, interface usage, string manipulation, control flow"}
{"seed": "// NewWaitdeploymentInformer constructs a new informer for Waitdeployment type.\n// Always prefer using an informer factory to get a shared informer instead of getting an independent\n// one. This reduces memory footprint and number of connections to the server.\nfunc NewWaitdeploymentInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers) cache.SharedIndexInformer {\n\treturn NewFilteredWaitdeploymentInformer(client, namespace, resyncPeriod, indexers, nil)\n}", "id": 11500, "concepts": ["cache.Indexers", "cache.SharedIndexInformer", "cache.NewSharedIndexInformer", "cache.NewFilterInformer", "cache.NewListWatchFromClient", "cache.NewListWatchFromClientFunc", "cache.NewListWatchFromServer", "cache.NewListWatchFromServerFunc", "cache.NewListWatch", "cache.NewListWatchFunc", "cache.NewListWatchFromObject", "cache.NewListWatchFromObjectFunc", "cache.NewListWatchFromNamespace", "cache.NewListWatchFromNamespaceFunc", "cache.NewListWatchFromCache", "cache.NewListWatchFromCacheFunc", "cache.NewListWatchFromCacheFunc", "cache.NewListWatchFromCacheFunc", "cache.NewListWatchFromCacheFunc", "cache.NewListWatchFromCacheFunc", "cache.NewListWatchFromCacheFunc", "cache.NewListWatchFromCacheFunc", "cache.NewListWatchFromCacheFunc", "cache.NewListWatchFromCacheFunc", "cache.NewListWatchFromCacheFunc", "cache.NewListWatchFromCacheFunc", "cache.NewListWatchFromCacheFunc", "cache.NewListWatchFromCacheFunc", "cache.NewListWatchFromCacheFunc", "cache.NewListWatchFromCacheFunc", "cache.NewList"], "_raw_llm_output": "cache.Indexers, cache.SharedIndexInformer, cache.NewSharedIndexInformer, cache.NewFilterInformer, cache.NewListWatchFromClient, cache.NewListWatchFromClientFunc, cache.NewListWatchFromServer, cache.NewListWatchFromServerFunc, cache.NewListWatch, cache.NewListWatchFunc, cache.NewListWatchFromObject, cache.NewListWatchFromObjectFunc, cache.NewListWatchFromNamespace, cache.NewListWatchFromNamespaceFunc, cache.NewListWatchFromCache, cache.NewListWatchFromCacheFunc, cache.NewListWatchFromCacheFunc, cache.NewListWatchFromCacheFunc, cache.NewListWatchFromCacheFunc, cache.NewListWatchFromCacheFunc, cache.NewListWatchFromCacheFunc, cache.NewListWatchFromCacheFunc, cache.NewListWatchFromCacheFunc, cache.NewListWatchFromCacheFunc, cache.NewListWatchFromCacheFunc, cache.NewListWatchFromCacheFunc, cache.NewListWatchFromCacheFunc, cache.NewListWatchFromCacheFunc, cache.NewListWatchFromCacheFunc, cache.NewListWatchFromCacheFunc, cache.NewList"}
{"seed": "// PingServer uses a passed database handle to check if the database server works\nfunc PingServer(db *sql.DB) string {\n\n\terr := db.Ping()\n\tif err != nil {\n\t\treturn (\"From Ping() Attempt: \" + err.Error())\n\t}\n\n\treturn (\"Database Ping Worked...\")\n\n}", "id": 11507, "concepts": ["sql package usage", "database connection", "error handling", "sql.DB.Ping()"], "_raw_llm_output": "sql package usage, database connection, error handling, sql.DB.Ping()"}
{"seed": "// DefaultConfig creates a default config object used by CF client\nfunc DefaultConfig() *Config {\n\treturn &Config{\n\t\tApiAddress:        \"http://api.bosh-lite.com\",\n\t\tUsername:          \"admin\",\n\t\tPassword:          \"admin\",\n\t\tToken:             \"\",\n\t\tSkipSslValidation: false,\n\t\tHttpClient:        http.DefaultClient,\n\t\tUserAgent:         \"SM-CF-client/1.0\",\n\t}\n}", "id": 11509, "concepts": ["struct definition", "default value assignment", "struct field initialization", "struct field access"], "_raw_llm_output": "struct definition, default value assignment, struct field initialization, struct field access"}
{"seed": "// Wrap takes existing go-logging Logger and returns logging.Logger. It can then\n// be put into a context with logging.Set(...).\nfunc Wrap(l *gol.Logger) logging.Logger {\n\tl.ExtraCalldepth += 1 // one layer of wrapping in loggerImpl struct above\n\treturn &loggerImpl{l}\n}", "id": 11531, "concepts": ["logging package usage", "struct composition", "method composition", "method overriding", "method chaining"], "_raw_llm_output": "logging package usage, struct composition, method composition, method overriding, method chaining"}
{"seed": "// MakeFullGroupFromName returns everything but the first element of a CRD name,\n// which by definition is <resource>.<full group>.\nfunc MakeFullGroupFromName(name string) string {\n\treturn getHalfBySep(name, \".\", 1)\n}", "id": 11537, "concepts": ["string manipulation", "string splitting"], "_raw_llm_output": "string manipulation, string splitting"}
{"seed": "// Title applies equality check predicate on the \"title\" field. It's identical to TitleEQ.\nfunc Title(v string) predicate.User {\n\treturn predicate.User(sql.FieldEQ(FieldTitle, v))\n}", "id": 11550, "concepts": ["equality check predicate", "sql.FieldEQ", "sql.Field", "sql.Field", "sql.Field"], "_raw_llm_output": "equality check predicate, sql.FieldEQ, sql.Field, sql.Field, sql.Field"}
{"seed": "// allEq checks if every rune in a given string is equal.\nfunc allEq(doc string) bool {\n\n\tbase := doc[0]\n\tfor i := 1; i < len(doc); i++ {\n\t\tif base != doc[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}", "id": 11552, "concepts": ["string manipulation", "rune handling", "character comparison"], "_raw_llm_output": "string manipulation, rune handling, character comparison"}
{"seed": "// Visited specifies a graph.Bits value to record visited nodes.\n//\n// For each node visited, the corresponding bit is set to 1.  Other bits\n// are not modified.\n//\n// The search algorithm controls the search using a graph.Bits.  If this\n// function is used, argument b will be used as the controlling value.\n//\n// Bits are not zeroed at the start of a search, so the initial Bits value\n// passed in should generally be zero.  Non-zero bits will limit the search.\nfunc Visited(b *graph.Bits) func(*config) {\n\treturn func(c *config) { c.visited = b }\n}", "id": 11571, "concepts": ["function composition", "function closure", "function definition", "function signature", "function usage", "function value", "function with closure", "function with multiple return values", "function with named return values", "function with named return values and multiple return values", "function with named return values and multiple return values and named return values", "function with named return values and multiple return values and named return values and named return values", "function with named return values and multiple return values and named return values and named return values and named return values", "function with named return values and multiple return values and named return values and named return values and named return values and named return values", "function with named return values and multiple return values and named return values and named return values and named return values and named return values and named return values", "function with named return values and multiple return values and named return values and named return values and named return values and named return values and named return values and named return values", "function with named return values and multiple return values and named return values and named return values and named return values and named return values and named return values and named return values and named return values", "function with named return values and multiple return values and named return values and named return values and named return values and named return values and named return values"], "_raw_llm_output": "function composition, function closure, function definition, function signature, function usage, function value, function with closure, function with multiple return values, function with named return values, function with named return values and multiple return values, function with named return values and multiple return values and named return values, function with named return values and multiple return values and named return values and named return values, function with named return values and multiple return values and named return values and named return values and named return values, function with named return values and multiple return values and named return values and named return values and named return values and named return values, function with named return values and multiple return values and named return values and named return values and named return values and named return values and named return values, function with named return values and multiple return values and named return values and named return values and named return values and named return values and named return values and named return values, function with named return values and multiple return values and named return values and named return values and named return values and named return values and named return values and named return values and named return values, function with named return values and multiple return values and named return values and named return values and named return values and named return values and named return values"}
{"seed": "// NewThreatIntelligenceIndicatorClientWithBaseURI creates an instance of the ThreatIntelligenceIndicatorClient client\n// using a custom endpoint.  Use this when interacting with an Azure cloud that uses a non-standard base URI (sovereign\n// clouds, Azure stack).\nfunc NewThreatIntelligenceIndicatorClientWithBaseURI(baseURI string, subscriptionID string) ThreatIntelligenceIndicatorClient {\n\treturn ThreatIntelligenceIndicatorClient{NewWithBaseURI(baseURI, subscriptionID)}\n}", "id": 11577, "concepts": ["client creation", "base URI handling"], "_raw_llm_output": "client creation, base URI handling"}
{"seed": "// NewSensorefficiencyWithDefaults instantiates a new Sensorefficiency object\n// This constructor will only assign default values to properties that have it defined,\n// but it doesn't guarantee that properties required by API are set\nfunc NewSensorefficiencyWithDefaults() *Sensorefficiency {\n\tthis := Sensorefficiency{}\n\treturn &this\n}", "id": 11599, "concepts": ["struct definition", "struct initialization", "struct property assignment"], "_raw_llm_output": "struct definition, struct initialization, struct property assignment"}
{"seed": "// PossibleResourceProviderManagementResourceAccessPolicyValues returns the possible values for the ResourceProviderManagementResourceAccessPolicy const type.\nfunc PossibleResourceProviderManagementResourceAccessPolicyValues() []ResourceProviderManagementResourceAccessPolicy {\n\treturn []ResourceProviderManagementResourceAccessPolicy{\n\t\tResourceProviderManagementResourceAccessPolicyAcisActionAllowed,\n\t\tResourceProviderManagementResourceAccessPolicyAcisReadAllowed,\n\t\tResourceProviderManagementResourceAccessPolicyNotSpecified,\n\t}\n}", "id": 11603, "concepts": ["enumerations", "constants", "type definition"], "_raw_llm_output": "enumerations, constants, type definition"}
{"seed": "// Bytes produces a human readable representation of an SI size.\n//\n// Bytes(82854982) -> 79 MB\n// NOTE: Originally copied from package go-humanize (https://github.com/dustin/go-humanize)\nfunc Bytes(s uint64) string {\n\tsizes := []string{\"B\", \"kB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\"}\n\treturn humanateBytes(s, 1024, sizes)\n}", "id": 11607, "concepts": ["integer division", "string formatting", "human-readable representation"], "_raw_llm_output": "integer division, string formatting, human-readable representation"}
{"seed": "// NewWireUnmarshaler returns a new Unmarshaler for wire.\n//\n// resolver can be nil if unknown and are only needed for extensions.\nfunc NewWireUnmarshaler(resolver Resolver) Unmarshaler {\n\treturn newWireUnmarshaler(resolver)\n}", "id": 11610, "concepts": ["interface", "function definition", "function composition", "function composition with anonymous function", "function composition with function composition"], "_raw_llm_output": "interface, function definition, function composition, function composition with anonymous function, function composition with function composition"}
{"seed": "// NewDeleteSiteDeployParamsWithContext creates a new DeleteSiteDeployParams object\n// with the default values initialized, and the ability to set a context for a request\nfunc NewDeleteSiteDeployParamsWithContext(ctx context.Context) *DeleteSiteDeployParams {\n\tvar ()\n\treturn &DeleteSiteDeployParams{\n\n\t\tContext: ctx,\n\t}\n}", "id": 11611, "concepts": ["context package usage", "function definition", "basic struct definition"], "_raw_llm_output": "context package usage, function definition, basic struct definition"}
{"seed": "// PromptPaperPhrase asks the user to enter a paper key phrase.\n// Used in `rekey paper` command.\nfunc PromptPaperPhrase(g *libkb.GlobalContext) (string, error) {\n\tm := libkb.NewMetaContextTODO(g)\n\targ := libkb.DefaultPassphraseArg(m)\n\targ.WindowTitle = \"Enter a paper key\"\n\targ.Prompt = \"Enter a paper key\"\n\targ.Type = keybase1.PassphraseType_PAPER_KEY\n\targ.Features.ShowTyping.Allow = true\n\targ.Features.ShowTyping.DefaultValue = true\n\n\tprompter := newClientPrompter(g)\n\tres, err := libkb.GetPassphraseUntilCheck(m, arg, prompter, &libkb.PaperChecker{})\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn res.Passphrase, nil\n}", "id": 11618, "concepts": ["keybase1.PassphraseType_PAPER_KEY", "libkb.GetPassphraseUntilCheck", "libkb.PaperChecker", "libkb.DefaultPassphraseArg", "libkb.NewMetaContextTODO", "libkb.NewMetaContext", "libkb.GetPassphraseUntilCheck", "libkb.PromptPassphrase", "libkb.PromptPassphrase", "libkb.PromptPassphrase", "libkb.PromptPassphrase", "libkb.PromptPassphrase", "libkb.PromptPassphrase", "libkb.PromptPassphrase", "libkb.PromptPassphrase", "libkb.PromptPassphrase", "libkb.PromptPassphrase", "libkb.PromptPassphrase", "libkb.PromptPassphrase", "libkb.PromptPassphrase", "libkb.PromptPassphrase", "libkb.PromptPassphrase", "libkb.PromptPassphrase", "libkb.PromptPassphrase", "libkb.PromptPassphrase", "libkb.PromptPassphrase", "libkb.PromptPassphrase", "libkb.PromptPassphrase", "libkb.PromptPassphrase", "libkb.PromptPassphrase", "libkb.PromptPassphrase", "libkb.PromptPassphrase", "libkb.PromptPassphrase", "libkb.PromptPassphrase", "libkb.PromptPass"], "_raw_llm_output": "keybase1.PassphraseType_PAPER_KEY, libkb.GetPassphraseUntilCheck, libkb.PaperChecker, libkb.DefaultPassphraseArg, libkb.NewMetaContextTODO, libkb.NewMetaContext, libkb.GetPassphraseUntilCheck, libkb.PromptPassphrase, libkb.PromptPassphrase, libkb.PromptPassphrase, libkb.PromptPassphrase, libkb.PromptPassphrase, libkb.PromptPassphrase, libkb.PromptPassphrase, libkb.PromptPassphrase, libkb.PromptPassphrase, libkb.PromptPassphrase, libkb.PromptPassphrase, libkb.PromptPassphrase, libkb.PromptPassphrase, libkb.PromptPassphrase, libkb.PromptPassphrase, libkb.PromptPassphrase, libkb.PromptPassphrase, libkb.PromptPassphrase, libkb.PromptPassphrase, libkb.PromptPassphrase, libkb.PromptPassphrase, libkb.PromptPassphrase, libkb.PromptPassphrase, libkb.PromptPassphrase, libkb.PromptPassphrase, libkb.PromptPassphrase, libkb.PromptPassphrase, libkb.PromptPass"}
{"seed": "// SocialEmailNotIn applies the NotIn predicate on the \"social_email\" field.\nfunc SocialEmailNotIn(vs ...string) predicate.User {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.User(func(s *sql.Selector) {\n\t\t// if not arguments were provided, append the FALSE constants,\n\t\t// since we can't apply \"IN ()\". This will make this predicate falsy.\n\t\tif len(vs) == 0 {\n\t\t\ts.Where(sql.False())\n\t\t\treturn\n\t\t}\n\t\ts.Where(sql.NotIn(s.C(FieldSocialEmail), v...))\n\t})\n}", "id": 11620, "concepts": ["sql.Selector", "sql.NotIn", "sql.False", "sql.C", "predicate.User", "function definition"], "_raw_llm_output": "sql.Selector, sql.NotIn, sql.False, sql.C, predicate.User, function definition"}
{"seed": "// builderScript is a convenience function which is used in the tests.  It\n// allows access to the script from a known good script built with the builder.\n// Any errors are converted to a panic since it is only, and must only, be used\n// with hard coded, and therefore, known good, scripts.\nfunc builderScript(builder *txscript.ScriptBuilder) []byte {\n\tscript, err := builder.Script()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn script\n}", "id": 11621, "concepts": ["txscript package usage", "script builder"], "_raw_llm_output": "txscript package usage, script builder"}
{"seed": "// SocialUserIDNotIn applies the NotIn predicate on the \"social_user_id\" field.\nfunc SocialUserIDNotIn(vs ...string) predicate.User {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.User(func(s *sql.Selector) {\n\t\t// if not arguments were provided, append the FALSE constants,\n\t\t// since we can't apply \"IN ()\". This will make this predicate falsy.\n\t\tif len(vs) == 0 {\n\t\t\ts.Where(sql.False())\n\t\t\treturn\n\t\t}\n\t\ts.Where(sql.NotIn(s.C(FieldSocialUserID), v...))\n\t})\n}", "id": 11629, "concepts": ["predicate.User", "sql.Selector", "sql.NotIn", "sql.False", "sql.C", "predicate.FieldSocialUserID"], "_raw_llm_output": "predicate.User, sql.Selector, sql.NotIn, sql.False, sql.C, predicate.FieldSocialUserID"}
{"seed": "// NewDeleteCoreV1NamespacedServiceUnauthorized creates a DeleteCoreV1NamespacedServiceUnauthorized with default headers values\nfunc NewDeleteCoreV1NamespacedServiceUnauthorized() *DeleteCoreV1NamespacedServiceUnauthorized {\n\treturn &DeleteCoreV1NamespacedServiceUnauthorized{}\n}", "id": 11630, "concepts": ["struct definition", "struct field definition", "struct initialization", "struct method definition", "struct method invocation", "struct method return value"], "_raw_llm_output": "struct definition, struct field definition, struct initialization, struct method definition, struct method invocation, struct method return value"}
{"seed": "// WithSimulation enables simulation of txn operations, which is triggered before\n// execution to obtain the sequence of intended operations without actually\n// calling any CRUD operations and assuming no failures.\n// By default, simulation is disabled.\nfunc WithSimulation(ctx context.Context) context.Context {\n\treturn context.WithValue(ctx, txnSimulationCtxKey, &txnSimulationOpt{})\n}", "id": 11641, "concepts": ["context", "context.WithValue", "context.Context", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", ""], "_raw_llm_output": "context, context.WithValue, context.Context, context.Context interface, context.Context interface, context.Context interface, context.Context interface, context.Context interface, context.Context interface, context.Context interface, context.Context interface, context.Context interface, context.Context interface, context.Context interface, context.Context interface, context.Context interface, context.Context interface, context.Context interface, context.Context interface, context.Context interface, context.Context interface, context.Context interface, context.Context interface, context.Context interface, context.Context interface, context.Context interface, context.Context interface, context.Context interface, context.Context interface, context.Context interface, context.Context interface, context.Context interface, context.Context interface, context.Context interface, context.Context interface, context.Context interface, context.Context interface, context.Context interface, context.Context interface, context.Context interface, context.Context interface, context.Context interface, context.Context interface, context.Context interface, context.Context interface, context.Context interface, context.Context interface, context.Context interface, context.Context interface, context.Context interface, context.Context interface, context.Context interface,"}
{"seed": "// WithCommander middleware sets the commander corresponding to the :commanderID URL parameter into\n// ctx.Locals under the key \"commander\"\nfunc WithCommander(r commanders.Reader) func(*fiber.Ctx) error {\n\treturn func(ctx *fiber.Ctx) error {\n\t\tid, err := uuid.FromString(ctx.Params(\"commanderID\"))\n\t\tif err != nil {\n\t\t\treturn newErrBadRequest(\"Invalid CommanderID\")\n\t\t}\n\t\tcommander, err := r.FindOne(commanders.FindOneQuery{ID: id})\n\t\tif err != nil {\n\t\t\treturn handleFindOneError(err, \"Commander\")\n\t\t}\n\t\tctx.Locals(\"commander\", commander)\n\t\treturn ctx.Next()\n\t}\n}", "id": 11646, "concepts": ["uuid package usage", "fiber package usage", "middleware", "context", "context.Next()"], "_raw_llm_output": "uuid package usage, fiber package usage, middleware, context, context.Next()"}
{"seed": "// FinishExecutionFn is the implementation of distributor.FinishExecutionFn.\n// It's defined here to avoid a circular dependency.\nfunc FinishExecutionFn(c context.Context, eid *dm.Execution_ID, rslt *dm.Result) ([]tumble.Mutation, error) {\n\tif rslt.Data != nil {\n\t\tif normErr := rslt.Data.Normalize(); normErr != nil {\n\t\t\tlogging.WithError(normErr).Errorf(c, \"Could not normalize distributor Result!\")\n\t\t\trslt = &dm.Result{\n\t\t\t\tAbnormalFinish: &dm.AbnormalFinish{\n\t\t\t\t\tStatus: dm.AbnormalFinish_RESULT_MALFORMED,\n\t\t\t\t\tReason: fmt.Sprintf(\"distributor result malformed: %q in %q\", normErr, rslt.Data.Object),\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}\n\n\treturn []tumble.Mutation{&FinishExecution{EID: eid, Result: rslt}}, nil\n}", "id": 11648, "concepts": ["struct definition", "anonymous function", "context", "pointer usage", "error handling"], "_raw_llm_output": "struct definition, anonymous function, context, pointer usage, error handling"}
{"seed": "// NewSourceSettings return a new config.SourceSettings struct with the given ComponentID.\nfunc NewSourceSettings(id config.ComponentID) SourceSettings {\n\treturn SourceSettings{id}\n}", "id": 11651, "concepts": ["struct definition", "struct field definition", "struct field initialization"], "_raw_llm_output": "struct definition, struct field definition, struct field initialization"}
{"seed": "// RiskDetailPAdminDismissedAllRiskForUser returns a pointer to RiskDetailVAdminDismissedAllRiskForUser\nfunc RiskDetailPAdminDismissedAllRiskForUser() *RiskDetail {\n\tv := RiskDetailVAdminDismissedAllRiskForUser\n\treturn &v\n}", "id": 11652, "concepts": ["pointer", "struct", "pointer dereference"], "_raw_llm_output": "pointer, struct, pointer dereference"}
{"seed": "// WithAcceptableAudiences specifies acceptable values for 'aud' claim in JWTs. A JWT must\n// contain at least one of these values in its 'aud' claim. Must not be empty.\nfunc WithAcceptableAudiences(acceptableAudiences []string) JwtHandlerConfigOption {\n\treturn func(cache *JwtAuthenticationHandler) error {\n\t\tif len(acceptableAudiences) == 0 {\n\t\t\treturn fmt.Errorf(\"acceptable audiences must contain at least one value\")\n\t\t}\n\t\tcache.acceptableAudiences = acceptableAudiences\n\t\treturn nil\n\t}\n}", "id": 11667, "concepts": ["interface", "function composition", "function options", "error handling"], "_raw_llm_output": "interface, function composition, function options, error handling"}
{"seed": "// NewBinaryTree returns a pointer to a new Binary Tree\nfunc NewBinaryTree() *BinaryTree {\n\treturn &BinaryTree{}\n}", "id": 11668, "concepts": ["binary tree", "pointer", "struct"], "_raw_llm_output": "binary tree, pointer, struct"}
{"seed": "// NewGetIPAMsubnetsParams creates a new GetIPAMsubnetsParams object\n// with the default values initialized.\nfunc NewGetIPAMsubnetsParams() *GetIPAMsubnetsParams {\n\tvar ()\n\treturn &GetIPAMsubnetsParams{\n\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 11671, "concepts": ["struct definition", "struct initialization", "pointer usage"], "_raw_llm_output": "struct definition, struct initialization, pointer usage"}
{"seed": "// WithDependentWatchesEnabled is an Option that configures whether the\n// Reconciler will register watches for dependent objects in releases and\n// trigger reconciliations when they change.\n//\n// By default, dependent watches are enabled.\nfunc SkipDependentWatches(skip bool) Option {\n\treturn func(r *Reconciler) error {\n\t\tr.skipDependentWatches = skip\n\t\treturn nil\n\t}\n}", "id": 11676, "concepts": ["struct definition", "function definition", "function call", "boolean handling", "boolean comparison", "boolean negation", "boolean logic", "boolean short-circuiting", "boolean short-circuiting", "boolean short-circuiting", "boolean short-circuiting", "boolean short-circuiting", "boolean short-circuiting", "boolean short-circuiting", "boolean short-circuiting", "boolean short-circuiting", "boolean short-circuiting", "boolean short-circuiting", "boolean short-circuiting", "boolean short-circuiting", "boolean short-circuiting", "boolean short-circuiting", "boolean short-circuiting", "boolean short-circuiting", "boolean short-circuiting", "boolean short-circuiting", "boolean short-circuiting", "boolean short-circuiting", "boolean short-circuiting", "boolean short-circuiting", "boolean short-circuiting", "boolean short-circuiting", "boolean short-circuiting", "boolean short-circuiting", "boolean short-circuiting", "boolean short-circuiting", "boolean short-circuiting", "boolean short-circuiting", "boolean short-circuiting", "boolean short-circuiting", "boolean short-circuiting", "boolean short-circuiting", "boolean short-circuiting", "boolean short-circuiting", "boolean short-circuiting", "boolean short-circuiting"], "_raw_llm_output": "struct definition, function definition, function call, boolean handling, boolean comparison, boolean negation, boolean logic, boolean short-circuiting, boolean short-circuiting, boolean short-circuiting, boolean short-circuiting, boolean short-circuiting, boolean short-circuiting, boolean short-circuiting, boolean short-circuiting, boolean short-circuiting, boolean short-circuiting, boolean short-circuiting, boolean short-circuiting, boolean short-circuiting, boolean short-circuiting, boolean short-circuiting, boolean short-circuiting, boolean short-circuiting, boolean short-circuiting, boolean short-circuiting, boolean short-circuiting, boolean short-circuiting, boolean short-circuiting, boolean short-circuiting, boolean short-circuiting, boolean short-circuiting, boolean short-circuiting, boolean short-circuiting, boolean short-circuiting, boolean short-circuiting, boolean short-circuiting, boolean short-circuiting, boolean short-circuiting, boolean short-circuiting, boolean short-circuiting, boolean short-circuiting, boolean short-circuiting, boolean short-circuiting, boolean short-circuiting, boolean short-circuiting"}
{"seed": "// NewAnalysisArchiveSummaryWithDefaults instantiates a new AnalysisArchiveSummary object\n// This constructor will only assign default values to properties that have it defined,\n// but it doesn't guarantee that properties required by API are set\nfunc NewAnalysisArchiveSummaryWithDefaults() *AnalysisArchiveSummary {\n\tthis := AnalysisArchiveSummary{}\n\treturn &this\n}", "id": 11680, "concepts": ["struct instantiation", "default value assignment"], "_raw_llm_output": "struct instantiation, default value assignment"}
{"seed": "// SetHandshakeInfo returns a copy of addr in which the Attributes field is\n// updated with hInfo.\nfunc SetHandshakeInfo(addr resolver.Address, hInfo *HandshakeInfo) resolver.Address {\n\taddr.Attributes = addr.Attributes.WithValues(handshakeAttrKey{}, hInfo)\n\treturn addr\n}", "id": 11685, "concepts": ["resolver.Address", "resolver.Address.Attributes", "handshakeAttrKey", "handshakeAttrKey.String", "handshakeAttrKey.Equal", "handshakeAttrKey.Value", "handshakeAttrKey.MarshalJSON", "handshakeAttrKey.UnmarshalJSON", "handshakeAttrKey.MarshalText", "handshakeAttrKey.UnmarshalText", "handshakeAttrKey.String", "handshakeAttrKey.Equal", "handshakeAttrKey.Value", "handshakeAttrKey.MarshalJSON", "handshakeAttrKey.UnmarshalJSON", "handshakeAttrKey.MarshalText", "handshakeAttrKey.UnmarshalText", "handshakeAttrKey.String", "handshakeAttrKey.Equal", "handshakeAttrKey.Value", "handshakeAttrKey.MarshalJSON", "handshakeAttrKey.UnmarshalJSON", "handshakeAttrKey.MarshalText", "handshakeAttrKey.UnmarshalText", "handshakeAttrKey.String", "handshakeAttrKey.Equal", "handshakeAttrKey.Value", "handshakeAttrKey.MarshalJSON", "handshakeAttrKey.UnmarshalJSON", "handshakeAttrKey.MarshalText", "handshakeAttrKey.UnmarshalText", "handshakeAttrKey.String", "handshakeAttrKey.Equal", "handshakeAttrKey.Value", "handshakeAttrKey.MarshalJSON", "handshakeAttrKey.UnmarshalJSON", "handshakeAttrKey.MarshalText", "handshakeAttrKey.UnmarshalText", "handshakeAttrKey.String", "handshakeAttrKey.Equal"], "_raw_llm_output": "resolver.Address, resolver.Address.Attributes, handshakeAttrKey, handshakeAttrKey.String, handshakeAttrKey.Equal, handshakeAttrKey.Value, handshakeAttrKey.MarshalJSON, handshakeAttrKey.UnmarshalJSON, handshakeAttrKey.MarshalText, handshakeAttrKey.UnmarshalText, handshakeAttrKey.String, handshakeAttrKey.Equal, handshakeAttrKey.Value, handshakeAttrKey.MarshalJSON, handshakeAttrKey.UnmarshalJSON, handshakeAttrKey.MarshalText, handshakeAttrKey.UnmarshalText, handshakeAttrKey.String, handshakeAttrKey.Equal, handshakeAttrKey.Value, handshakeAttrKey.MarshalJSON, handshakeAttrKey.UnmarshalJSON, handshakeAttrKey.MarshalText, handshakeAttrKey.UnmarshalText, handshakeAttrKey.String, handshakeAttrKey.Equal, handshakeAttrKey.Value, handshakeAttrKey.MarshalJSON, handshakeAttrKey.UnmarshalJSON, handshakeAttrKey.MarshalText, handshakeAttrKey.UnmarshalText, handshakeAttrKey.String, handshakeAttrKey.Equal, handshakeAttrKey.Value, handshakeAttrKey.MarshalJSON, handshakeAttrKey.UnmarshalJSON, handshakeAttrKey.MarshalText, handshakeAttrKey.UnmarshalText, handshakeAttrKey.String, handshakeAttrKey.Equal"}
{"seed": "// Textarea represents the HTML element 'textarea'.\n// For more information visit https://www.w3schools.com/tags/tag_textarea.asp.\nfunc Textarea(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"textarea\", Attributes: attrs, Children: children}\n}", "id": 11689, "concepts": ["HTML tree", "HTML element definition", "HTML element attributes", "HTML element children"], "_raw_llm_output": "HTML tree, HTML element definition, HTML element attributes, HTML element children"}
{"seed": "// isQuestion will return true if the given value ends with a question mark.\nfunc isQuestion(s string) bool {\n\treturn strings.HasSuffix(s, \"?\")\n}", "id": 11694, "concepts": ["string manipulation", "string comparison"], "_raw_llm_output": "string manipulation, string comparison"}
{"seed": "// NewGetMarketsRegionIDHistoryParamsWithTimeout creates a new GetMarketsRegionIDHistoryParams object\n// with the default values initialized, and the ability to set a timeout on a request\nfunc NewGetMarketsRegionIDHistoryParamsWithTimeout(timeout time.Duration) *GetMarketsRegionIDHistoryParams {\n\tvar (\n\t\tdatasourceDefault = string(\"tranquility\")\n\t)\n\treturn &GetMarketsRegionIDHistoryParams{\n\t\tDatasource: &datasourceDefault,\n\n\t\ttimeout: timeout,\n\t}\n}", "id": 11702, "concepts": ["struct initialization", "pointer usage", "timeout handling"], "_raw_llm_output": "struct initialization, pointer usage, timeout handling"}
{"seed": "// DisableThrottlerOptions suppresses the presence of throttler-related flags,\n// effectively disallowing external users to parametrize default throttling\n// behavior. This is useful mostly when a program creates multiple GH clients\n// with different behavior.\nfunc DisableThrottlerOptions() FlagParameter {\n\treturn func(o *flagParams) {\n\t\to.disableThrottlerOptions = true\n\t}\n}", "id": 11711, "concepts": ["function composition", "function definition", "function parameter", "function return value", "function type", "function type assertion"], "_raw_llm_output": "function composition, function definition, function parameter, function return value, function type, function type assertion"}
{"seed": "// NewMultipleMetricsParams creates a new MultipleMetricsParams object\n// with the default values initialized.\nfunc NewMultipleMetricsParams() *MultipleMetricsParams {\n\tvar ()\n\treturn &MultipleMetricsParams{\n\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 11721, "concepts": ["struct initialization", "struct field initialization", "struct field access", "struct method definition", "struct method call"], "_raw_llm_output": "struct initialization, struct field initialization, struct field access, struct method definition, struct method call"}
{"seed": "// NewAtomicSwapRefundFulfillment creates an unsigned atomic swap fulfillment,\n// as to get a refund (meaning redeeming the money as the sender).\n//\n// Returned fulfillment still has to be signed, as to add the signature,\n// with the parent transaction as the input as well as the matching private key.\n//\n// Note that this fulfillment will fail if the current time is\n// prior to the timestamp specified as time lock in the parent output.\nfunc NewAtomicSwapRefundFulfillment(pk PublicKey) *AtomicSwapFulfillment {\n\treturn &AtomicSwapFulfillment{PublicKey: pk}\n}", "id": 11724, "concepts": ["struct definition", "pointer usage", "method definition", "anonymous struct usage"], "_raw_llm_output": "struct definition, pointer usage, method definition, anonymous struct usage"}
{"seed": "// Option_ is a convenience wrapper for Option without the attrs argument.\nfunc Option_(children ...HTML) HTML {\n  return Option(nil, children...)\n}", "id": 11727, "concepts": ["function definition", "function argument", "function return value", "function call"], "_raw_llm_output": "function definition, function argument, function return value, function call"}
{"seed": "// NewJwtAuthenticationHandler factory method creating JwtAuthenticationHandler.\n// If the supplied VerificationKeyProvider is also a VerificationKeyCache,\n// the created JwtAuthenticationHandler is able to handle change of verification\n// keys - if the signature of a JWT cannot be verified with the keys returned by\n// VerificationKeyCache#Get, will refresh the key provider via\n// VerificationKeyCache#Refresh and will retry signature verification. Retry is done only\n// once.\n// parameters\n//  keyProvider  VerificationKeyProvider used for retrieving signing keys during\n//               JWT validation. Must not be nil.\n//  configOptions  a set of optional JwtHandlerConfigOption\n// returns\n//  By default the handler is created with a:\n//    - maximum clock skew value of 10 minutes\n//    - acceptable audiences containing a single element - \"vmware-tes:vapi\"\n//  values above are configurable via the configOptions parameter.\nfunc NewJwtAuthenticationHandler(keyProvider VerificationKeyProvider, configOptions ...JwtHandlerConfigOption) (*JwtAuthenticationHandler, error) {\n\tif keyProvider == nil {\n\t\treturn nil, fmt.Errorf(\"key provider must not be nil\")\n\t}\n\n\tjwtHandler := &JwtAuthenticationHandler{\n\t\tkeyProvider:         keyProvider,\n\t\tmaxClockSkew:        10 * 60,\n\t\tacceptableAudiences: []string{\"vmware-tes:vapi\"},\n\t}\n\n\tfor _, fn := range configOptions {\n\t\terr := fn(jwtHandler)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn jwtHandler, nil\n}", "id": 11732, "concepts": ["function definition", "function parameter", "function return value", "function call", "function call with parameters", "function call with return value", "function call with multiple return values", "function call with multiple return values and error handling", "function call with multiple return values and error handling", "function call with multiple return values and error handling", "function call with multiple return values and error handling", "function call with multiple return values and error handling", "function call with multiple return values and error handling", "function call with multiple return values and error handling", "function call with multiple return values and error handling", "function call with multiple return values and error handling", "function call with multiple return values and error handling", "function call with multiple return values and error handling", "function call with multiple return values and error handling", "function call with multiple return values and error handling", "function call with multiple return values and error handling", "function call with multiple return values and error handling", "function call with multiple return values and error handling", "function call with multiple return values and error handling", "function call with multiple return values and error handling", "function call with multiple return values and error handling", "function call with multiple return values and error handling", "function call with multiple return values and error handling", "function call with multiple return values and error handling", "function call with multiple"], "_raw_llm_output": "function definition, function parameter, function return value, function call, function call with parameters, function call with return value, function call with multiple return values, function call with multiple return values and error handling, function call with multiple return values and error handling, function call with multiple return values and error handling, function call with multiple return values and error handling, function call with multiple return values and error handling, function call with multiple return values and error handling, function call with multiple return values and error handling, function call with multiple return values and error handling, function call with multiple return values and error handling, function call with multiple return values and error handling, function call with multiple return values and error handling, function call with multiple return values and error handling, function call with multiple return values and error handling, function call with multiple return values and error handling, function call with multiple return values and error handling, function call with multiple return values and error handling, function call with multiple return values and error handling, function call with multiple return values and error handling, function call with multiple return values and error handling, function call with multiple return values and error handling, function call with multiple return values and error handling, function call with multiple return values and error handling, function call with multiple"}
{"seed": "// PhoneEQ applies the EQ predicate on the \"phone\" field.\nfunc PhoneEQ(v string) predicate.User {\n\treturn predicate.User(sql.FieldEQ(FieldPhone, v))\n}", "id": 11739, "concepts": ["sql.FieldEQ", "sql.FieldNE", "sql.FieldGT", "sql.FieldGTE", "sql.FieldLT", "sql.FieldLTE", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldIsNull", "sql.FieldIsNotNull", "sql.FieldBetween", "sql.FieldNotBetween", "sql.FieldExists", "sql.FieldNotExists", "sql.FieldRaw", "sql.FieldRawEQ", "sql.FieldRawNE", "sql.FieldRawGT", "sql.FieldRawGTE", "sql.FieldRawLT", "sql.FieldRawLTE", "sql.FieldRawLike", "sql.FieldRawNotLike", "sql.FieldRawIn", "sql.FieldRawNotIn", "sql.FieldRawIsNull", "sql.FieldRawIsNotNull", "sql.FieldRawBetween", "sql.FieldRawNotBetween", "sql.FieldRawExists", "sql.FieldRawNotExists"], "_raw_llm_output": "sql.FieldEQ, sql.FieldNE, sql.FieldGT, sql.FieldGTE, sql.FieldLT, sql.FieldLTE, sql.FieldLike, sql.FieldNotLike, sql.FieldIn, sql.FieldNotIn, sql.FieldIsNull, sql.FieldIsNotNull, sql.FieldBetween, sql.FieldNotBetween, sql.FieldExists, sql.FieldNotExists, sql.FieldRaw, sql.FieldRawEQ, sql.FieldRawNE, sql.FieldRawGT, sql.FieldRawGTE, sql.FieldRawLT, sql.FieldRawLTE, sql.FieldRawLike, sql.FieldRawNotLike, sql.FieldRawIn, sql.FieldRawNotIn, sql.FieldRawIsNull, sql.FieldRawIsNotNull, sql.FieldRawBetween, sql.FieldRawNotBetween, sql.FieldRawExists, sql.FieldRawNotExists"}
{"seed": "// NewAtomicSwapSecret creates a new cryptographically secure\n// atomic swap secret\nfunc NewAtomicSwapSecret() (ass AtomicSwapSecret, err error) {\n\t_, err = rand.Read(ass[:])\n\treturn\n}", "id": 11744, "concepts": ["cryptography", "crypto/rand package usage", "byte slice initialization"], "_raw_llm_output": "cryptography, crypto/rand package usage, byte slice initialization"}
{"seed": "// NewTelemetryPolicyFactory creates a factory that can create telemetry policy objects\n// which add telemetry information to outgoing HTTP requests.\nfunc NewTelemetryPolicyFactory(o TelemetryOptions) pipeline.Factory {\n\tb := &bytes.Buffer{}\n\tb.WriteString(o.Value)\n\tif b.Len() > 0 {\n\t\tb.WriteRune(' ')\n\t}\n\tfmt.Fprintf(b, \"Azure-Storage/%s %s\", serviceLibVersion, platformInfo)\n\treturn &telemetryPolicyFactory{telemetryValue: b.String()}\n}", "id": 11748, "concepts": ["function definition", "function return value", "function argument", "function call", "function scope", "function closure", "function composition", "function composition with anonymous functions", "function composition with named functions", "function composition with named functions and anonymous functions", "function composition with named functions and anonymous functions and named functions", "function composition with named functions and anonymous functions and named functions and anonymous functions", "function composition with named functions and anonymous functions and named functions and anonymous functions and anonymous functions", "function composition with named functions and anonymous functions and named functions and anonymous functions and anonymous functions and anonymous functions", "function composition with named functions and anonymous functions and named functions and anonymous functions and anonymous functions and anonymous functions and anonymous functions", "function composition with named functions and anonymous functions and named functions and anonymous functions and anonymous functions and anonymous functions and anonymous functions and anonymous functions", "function composition with named functions and anonymous functions and named functions and anonymous functions and anonymous functions and anonymous functions and anonymous functions and anonymous functions and anonymous functions", "function composition with named functions and anonymous functions and named functions and anonymous functions and anonymous functions and anonymous functions and anonymous functions and anonymous functions and anonymous functions and anonymous functions", "function composition with named functions and anonymous functions and named functions and anonymous functions and anonymous functions and anonymous functions and anonymous functions and anonymous functions and anonymous functions and anonymous functions"], "_raw_llm_output": "function definition, function return value, function argument, function call, function scope, function closure, function composition, function composition with anonymous functions, function composition with named functions, function composition with named functions and anonymous functions, function composition with named functions and anonymous functions and named functions, function composition with named functions and anonymous functions and named functions and anonymous functions, function composition with named functions and anonymous functions and named functions and anonymous functions and anonymous functions, function composition with named functions and anonymous functions and named functions and anonymous functions and anonymous functions and anonymous functions, function composition with named functions and anonymous functions and named functions and anonymous functions and anonymous functions and anonymous functions and anonymous functions, function composition with named functions and anonymous functions and named functions and anonymous functions and anonymous functions and anonymous functions and anonymous functions and anonymous functions, function composition with named functions and anonymous functions and named functions and anonymous functions and anonymous functions and anonymous functions and anonymous functions and anonymous functions and anonymous functions, function composition with named functions and anonymous functions and named functions and anonymous functions and anonymous functions and anonymous functions and anonymous functions and anonymous functions and anonymous functions and anonymous functions, function composition with named functions and anonymous functions and named functions and anonymous functions and anonymous functions and anonymous functions and anonymous functions and anonymous functions and anonymous functions and anonymous functions"}
{"seed": "// extrapolatedRate function is taken from prometheus code promql/functions.go:59\n// extrapolatedRate is a utility function for rate/increase/delta.\n// It calculates the rate (allowing for counter resets if isCounter is true),\n// extrapolates if the first/last sample is close to the boundary, and returns\n// the result as either per-second (if isRate is true) or overall.\nfunc extrapolatedRate(samples []promql.Point, selRange time.Duration, isCounter, isRate bool) float64 {\n\t// No sense in trying to compute a rate without at least two points. Drop\n\t// this Vector element.\n\tif len(samples) < 2 {\n\t\treturn 0\n\t}\n\tvar (\n\t\trangeStart = samples[0].T - durationMilliseconds(selRange)\n\t\trangeEnd   = samples[len(samples)-1].T\n\t)\n\n\tresultValue := samples[len(samples)-1].V - samples[0].V\n\tif isCounter {\n\t\tvar lastValue float64\n\t\tfor _, sample := range samples {\n\t\t\tif sample.V < lastValue {\n\t\t\t\tresultValue += lastValue\n\t\t\t}\n\t\t\tlastValue = sample.V\n\t\t}\n\t}\n\n\t// Duration between first/last samples and boundary of range.\n\tdurationToStart := float64(samples[0].T-rangeStart) / 1000\n\tdurationToEnd := float64(rangeEnd-samples[len(samples)-1].T) / 1000\n\n\tsampledInterval := float64(samples[len(samples)-1].T-samples[0].T) / 1000\n\taverageDurationBetweenSamples := sampledInterval / float64(len(samples)-1)\n\n\tif isCounter && resultValue > 0 && samples[0].V >= 0 {\n\t\t// Counters cannot be negative. If we have any slope at\n\t\t// all (i.e. resultValue went up), we can extrapolate\n\t\t// the zero point of the counter. If the duration to the\n\t\t// zero point is shorter than the durationToStart, we\n\t\t// take the zero point as the start of the series,\n\t\t// thereby avoiding extrapolation to negative counter\n\t\t// values.\n\t\tdurationToZero := sampledInterval * (samples[0].V / resultValue)\n\t\tif durationToZero < durationToStart {\n\t\t\tdurationToStart = durationToZero\n\t\t}\n\t}\n\n\t// If the first/last samples are close to the boundaries of the range,\n\t// extrapolate the result. This is as we expect that another sample\n\t// will exist given the spacing between samples we've seen thus far,\n\t// with an allowance for noise.\n\textrapolationThreshold := averageDurationBetweenSamples * 1.1\n\textrapolateToInterval := sampledInterval\n\n\tif durationToStart < extrapolationThreshold {\n\t\textrapolateToInterval += durationToStart\n\t} else {\n\t\textrapolateToInterval += averageDurationBetweenSamples / 2\n\t}\n\tif durationToEnd < extrapolationThreshold {\n\t\textrapolateToInterval += durationToEnd\n\t} else {\n\t\textrapolateToInterval += averageDurationBetweenSamples / 2\n\t}\n\tresultValue = resultValue * (extrapolateToInterval / sampledInterval)\n\tif isRate {\n\t\tseconds := selRange.Seconds()\n\t\tresultValue = resultValue / seconds\n\t}\n\n\treturn resultValue\n}", "id": 11761, "concepts": ["time handling", "duration handling", "float handling", "function definition", "function return value", "function parameter", "function parameter type", "function parameter default value", "function parameter type conversion", "function parameter type conversion", "function parameter type conversion", "function parameter type conversion", "function parameter type conversion", "function parameter type conversion", "function parameter type conversion", "function parameter type conversion", "function parameter type conversion", "function parameter type conversion", "function parameter type conversion", "function parameter type conversion", "function parameter type conversion", "function parameter type conversion", "function parameter type conversion", "function parameter type conversion", "function parameter type conversion", "function parameter type conversion", "function parameter type conversion", "function parameter type conversion", "function parameter type conversion", "function parameter type conversion", "function parameter type conversion", "function parameter type conversion", "function parameter type conversion", "function parameter type conversion", "function parameter type conversion", "function parameter type conversion", "function parameter type conversion", "function parameter type conversion", "function parameter type conversion", "function parameter type conversion", "function parameter type conversion", "function parameter type conversion", "function parameter type conversion", "function parameter type conversion", "function parameter type conversion", "function parameter type conversion", "function parameter type conversion", "function parameter type conversion", "function parameter type conversion", "function parameter type conversion", "function parameter type conversion", "function parameter type conversion", "function parameter type conversion", "function parameter"], "_raw_llm_output": "time handling, duration handling, float handling, function definition, function return value, function parameter, function parameter type, function parameter default value, function parameter type conversion, function parameter type conversion, function parameter type conversion, function parameter type conversion, function parameter type conversion, function parameter type conversion, function parameter type conversion, function parameter type conversion, function parameter type conversion, function parameter type conversion, function parameter type conversion, function parameter type conversion, function parameter type conversion, function parameter type conversion, function parameter type conversion, function parameter type conversion, function parameter type conversion, function parameter type conversion, function parameter type conversion, function parameter type conversion, function parameter type conversion, function parameter type conversion, function parameter type conversion, function parameter type conversion, function parameter type conversion, function parameter type conversion, function parameter type conversion, function parameter type conversion, function parameter type conversion, function parameter type conversion, function parameter type conversion, function parameter type conversion, function parameter type conversion, function parameter type conversion, function parameter type conversion, function parameter type conversion, function parameter type conversion, function parameter type conversion, function parameter type conversion, function parameter type conversion, function parameter type conversion, function parameter type conversion, function parameter type conversion, function parameter type conversion, function parameter type conversion, function parameter"}
{"seed": "// Void Elements\n\n// Area represents the HTML void element 'area'.\n// For more information visit https://www.w3schools.com/tags/tag_area.asp.\nfunc Area(attrs []htmlgo.Attribute) HTML {\n\treturn &htmlgo.Tree{Tag: \"area\", Attributes: attrs, SelfClosing: true}\n}", "id": 11764, "concepts": ["HTML generation", "HTML void element", "HTML attribute"], "_raw_llm_output": "HTML generation, HTML void element, HTML attribute"}
{"seed": "// DecodeUserAuth implements binary de-serialization for UserAuthClass.\nfunc DecodeUserAuth(buf *bin.Buffer) (UserAuthClass, error) {\n\tid, err := buf.PeekID()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tswitch id {\n\tcase UserAuthTypeID:\n\t\t// Decoding user.auth#f4815592.\n\t\tv := UserAuth{}\n\t\tif err := v.Decode(buf); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to decode UserAuthClass: %w\", err)\n\t\t}\n\t\treturn &v, nil\n\tcase UserAuthPasswordTypeID:\n\t\t// Decoding user.authPassword#5981e317.\n\t\tv := UserAuthPassword{}\n\t\tif err := v.Decode(buf); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to decode UserAuthClass: %w\", err)\n\t\t}\n\t\treturn &v, nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unable to decode UserAuthClass: %w\", bin.NewUnexpectedID(id))\n\t}\n}", "id": 11770, "concepts": ["binary serialization", "switch statement", "interface", "error handling"], "_raw_llm_output": "binary serialization, switch statement, interface, error handling"}
{"seed": "// Takes in a string that describes the permissions for an object. Returns an ACL with\n// a method for checking permissions. An entity is a user with the following attributes:\n// - name\n// - list of groups\n//\n// When describing permissions use the following (glftpd) syntax:\n// - `-` prefix describes a user, i.e. `-userName`\n// - `=` prefix describes a group, i.e. `=groupName`\n// - no prefix describes a flag, i.e. `1` (currently no restrictions on legnth)\n// - `!` prefix denotes that the preceding permission is blocked, i.e. `!-userName` would\n// not be allowed\n//\n// Currently the order of checking is:\n// - blocked users\n// - blocked groups\n// - allowed users\n// - allowed groups\n// - blocked all (!*)\n// - allowed all (*)\n//\n// The default is to block permission\nfunc NewFromString(s string) (*ACL, error) {\n\tif len(s) == 0 {\n\t\treturn nil, ErrACLBadInput\n\t}\n\n\tvar a ACL\n\n\tfields := strings.Fields(strings.ToLower(s))\n\n\tvar c *collection\n\n\tfor _, f := range fields {\n\t\tc = &a.allowed\n\n\t\tif f[0] == '!' {\n\t\t\tif len(f) <= 1 {\n\t\t\t\treturn nil, ErrACLMalformedNegative\n\t\t\t}\n\n\t\t\tc = &a.blocked\n\n\t\t\tf = f[1:]\n\t\t}\n\n\t\tswitch f[0] {\n\t\tcase '-':\n\t\t\t// user specific acl\n\t\t\tif len(f) <= 1 {\n\t\t\t\treturn nil, ErrACLMalformedUser\n\t\t\t}\n\n\t\t\tf = f[1:]\n\n\t\t\tif f == \"*\" {\n\t\t\t\treturn nil, ErrACLBadUser\n\t\t\t}\n\n\t\t\tif !AllowedUserAndGroupCharsRE.MatchString(f) {\n\t\t\t\treturn nil, ErrACLInvalidCharacters\n\t\t\t}\n\n\t\t\tc.users = append(c.users, f)\n\n\t\tcase '=':\n\t\t\t// group specific acl\n\t\t\tif len(f) <= 1 {\n\t\t\t\treturn nil, ErrACLMalformedGroup\n\t\t\t}\n\n\t\t\tf = f[1:]\n\n\t\t\tif f == \"*\" {\n\t\t\t\treturn nil, ErrACLBadGroup\n\t\t\t}\n\n\t\t\tif !AllowedUserAndGroupCharsRE.MatchString(f) {\n\t\t\t\treturn nil, ErrACLInvalidCharacters\n\t\t\t}\n\n\t\t\tc.groups = append(c.groups, f)\n\n\t\tdefault:\n\n\t\t\t// special acl keywords\n\t\t\tswitch f {\n\t\t\tcase \"self\":\n\t\t\t\tc.self = true\n\t\t\tcase \"gadmin\":\n\t\t\t\tc.gadmin = true\n\t\t\tcase \"*\":\n\t\t\t\tc.all = true\n\n\t\t\tdefault:\n\t\t\t\treturn nil, ErrACLInvalidCharacters\n\t\t\t}\n\t\t}\n\t}\n\n\treturn &a, nil\n}", "id": 11774, "concepts": ["string manipulation", "regular expressions", "string parsing", "string comparison", "string formatting", "string iteration", "string concatenation", "string length", "string indexing", "string slicing", "string replacement", "string splitting", "string concatenation", "string length", "string indexing", "string slicing", "string replacement", "string splitting", "string concatenation", "string length", "string indexing", "string slicing", "string replacement", "string splitting", "string concatenation", "string length", "string indexing", "string slicing", "string replacement", "string splitting", "string concatenation", "string length", "string indexing", "string slicing", "string replacement", "string splitting", "string concatenation", "string length", "string indexing", "string slicing", "string replacement", "string splitting", "string concatenation", "string length", "string indexing", "string slicing", "string replacement", "string splitting", "string concatenation", "string length", "string indexing", "string slicing", "string replacement", "string splitting", "string concatenation", "string length", "string indexing", "string slicing", "string replacement", "string splitting", "string concatenation", "string length", "string indexing", "string slicing", "string replacement", "string splitting", "string concatenation", "string length", "string indexing", "string slicing", "string replacement", "string splitting", "string concatenation", "string length", "string indexing", "string slicing", "string replacement", ""], "_raw_llm_output": "string manipulation, regular expressions, string parsing, string comparison, string formatting, string iteration, string concatenation, string length, string indexing, string slicing, string replacement, string splitting, string concatenation, string length, string indexing, string slicing, string replacement, string splitting, string concatenation, string length, string indexing, string slicing, string replacement, string splitting, string concatenation, string length, string indexing, string slicing, string replacement, string splitting, string concatenation, string length, string indexing, string slicing, string replacement, string splitting, string concatenation, string length, string indexing, string slicing, string replacement, string splitting, string concatenation, string length, string indexing, string slicing, string replacement, string splitting, string concatenation, string length, string indexing, string slicing, string replacement, string splitting, string concatenation, string length, string indexing, string slicing, string replacement, string splitting, string concatenation, string length, string indexing, string slicing, string replacement, string splitting, string concatenation, string length, string indexing, string slicing, string replacement, string splitting, string concatenation, string length, string indexing, string slicing, string replacement,"}
{"seed": "// PossibleResourceTypeValues returns an array of possible values for the ResourceType const type.\nfunc PossibleResourceTypeValues() []ResourceType {\n\treturn []ResourceType{ResourceTypeMicrosoftNetworkfrontDoors, ResourceTypeMicrosoftNetworkfrontDoorsfrontendEndpoints}\n}", "id": 11782, "concepts": ["constant definition", "array definition", "return statement"], "_raw_llm_output": "constant definition, array definition, return statement"}
{"seed": "// EncodeResendConfirmationRequest encodes internal request into grpc request type\nfunc EncodeResendConfirmationRequest(_ context.Context, r interface{}) (interface{}, error) {\n\treq := r.(ResendConfirmationRequest)\n\treturn &pb.ResendConfirmationRequest{\n\t\tUsername: req.Username,\n\t}, nil\n}", "id": 11787, "concepts": ["interface", "function definition", "function return type", "function parameter type"], "_raw_llm_output": "interface, function definition, function return type, function parameter type"}
{"seed": "// WithServer allows to customize the underlying http.Server\n// Note: when using Run() the handler and the address will change\nfunc WithServer(server *http.Server) RouterOption {\n\treturn func(router *Router) {\n\t\trouter.server = server\n\t}\n}", "id": 11790, "concepts": ["http.Server", "http.ListenAndServe", "http.HandleFunc", "http.Handler"], "_raw_llm_output": "http.Server, http.ListenAndServe, http.HandleFunc, http.Handler"}
{"seed": "// ParseAddServiceToLoadBalancerResponse parses an HTTP response from a AddServiceToLoadBalancerWithResponse call\nfunc ParseAddServiceToLoadBalancerResponse(rsp *http.Response) (*AddServiceToLoadBalancerResponse, error) {\n\tbodyBytes, err := ioutil.ReadAll(rsp.Body)\n\tdefer rsp.Body.Close()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse := &AddServiceToLoadBalancerResponse{\n\t\tBody:         bodyBytes,\n\t\tHTTPResponse: rsp,\n\t}\n\n\tswitch {\n\tcase strings.Contains(rsp.Header.Get(\"Content-Type\"), \"json\") && rsp.StatusCode == 200:\n\t\tvar dest Operation\n\t\tif err := json.Unmarshal(bodyBytes, &dest); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresponse.JSON200 = &dest\n\n\t}\n\n\treturn response, nil\n}", "id": 11791, "concepts": ["http.Response", "json.Unmarshal", "string manipulation", "http.Client usage"], "_raw_llm_output": "http.Response, json.Unmarshal, string manipulation, http.Client usage"}
{"seed": "// Given the root of a Binary Search Tree (BST), convert it to a Greater Tree\n// such that every key of the original BST is changed to the original key plus\n// sum of all keys greater than the original key in BST.\n// As a reminder, a binary search tree is a tree that satisfies these constraints:\n//\tThe left subtree of a node contains only nodes with keys less than the node's key.\n//\tThe right subtree of a node contains only nodes with keys greater than the node's key.\n//\tBoth the left and right subtrees must also be binary search trees.\n// Note: This question is the same as 1038: https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/\n//\tExample 1:\n//\t\tInput: root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]\n//\t\tOutput: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]\n//\tExample 2:\n//\t\tInput: root = [0,null,1]\n//\t\tOutput: [1,null,1]\n//\tExample 3:\n//\t\tInput: root = [1,0,2]\n//\t\tOutput: [3,3,2]\n//\tExample 4:\n//\t\tInput: root = [3,2,4,1]\n//\t\tOutput: [7,9,4,10]\n//\tConstraints:\n//\t\tThe number of nodes in the tree is in the range [0, 104].\n//\t\t-104 <= Node.val <= 104\n//\t\tAll the values in the tree are unique.\n//\t\troot is guaranteed to be a valid binary search tree.\n\nfunc convertBST(root *data.TreeNode) *data.TreeNode {\n\tsum := 0\n\tdfs538(root, &sum)\n\treturn root\n}", "id": 11809, "concepts": ["binary search tree", "tree traversal", "depth-first search"], "_raw_llm_output": "binary search tree, tree traversal, depth-first search"}
{"seed": "/*simple check if username from query is a existing user. Does not check password.\nrespond sucess if user exists, else respond error\nLocks usermap*/\nfunc does_user_exist(uname string) (string, bool) {\n\tuser_map_lock.Lock()\n\tdefer user_map_lock.Unlock()\n\tif _, is_exist := user_map[uname]; is_exist {\n\t\treturn fmt.Sprintf(\"success: user exists %s\\n\", END_TAG), false\n\t} else {\n\t\treturn fmt.Sprintf(\"error: no such user %s\\n\", END_TAG), false\n\t}\n}", "id": 11822, "concepts": ["map iteration (range loop)", "locking", "basic function definition"], "_raw_llm_output": "map iteration (range loop), locking, basic function definition"}
{"seed": "// NewDockerBlockIOStatsDelta sums up block I/O reads and writes and calculates the difference between two stat snapshots.\n// It returns nil if aggregated stats are equal.\nfunc NewDockerBlockIOStatsDelta(prev, next docker.ContainerBlockIOStats) *DockerBlockIOStatsDelta {\n\tvar delta DockerBlockIOStatsDelta\n\n\tfor _, stat := range next.ServiceBytes {\n\t\tswitch stat.Operation {\n\t\tcase docker.BlockIOReadOp:\n\t\t\tdelta.Read += stat.Value\n\t\tcase docker.BlockIOWriteOp:\n\t\t\tdelta.Write += stat.Value\n\t\t}\n\t}\n\n\tfor _, stat := range prev.ServiceBytes {\n\t\tswitch stat.Operation {\n\t\tcase docker.BlockIOReadOp:\n\t\t\tdelta.Read -= stat.Value\n\t\tcase docker.BlockIOWriteOp:\n\t\t\tdelta.Write -= stat.Value\n\t\t}\n\t}\n\n\tif delta.IsZero() {\n\t\treturn nil\n\t}\n\n\treturn &delta\n}", "id": 11824, "concepts": ["struct definition", "struct field access", "struct field assignment", "struct field comparison", "struct field initialization", "struct field iteration (range loop)", "struct field modification", "struct field summation", "struct field type definition", "struct field type conversion", "struct field type definition", "struct field type conversion", "struct field type definition", "struct field type conversion", "struct field type definition", "struct field type conversion", "struct field type definition", "struct field type conversion", "struct field type definition", "struct field type conversion", "struct field type definition", "struct field type conversion", "struct field type definition", "struct field type conversion", "struct field type definition", "struct field type conversion", "struct field type definition", "struct field type conversion", "struct field type definition", "struct field type conversion", "struct field type definition", "struct field type conversion", "struct field type definition", "struct field type conversion", "struct field type definition", "struct field type conversion", "struct field type definition", "struct field type conversion", "struct field type definition", "struct field type conversion", "struct field type definition", "struct field type conversion", "struct field type definition", "struct field type conversion", "struct field type definition", "struct field type conversion", "struct field type definition", "struct field type conversion", "struct field type definition", "struct field type conversion", "struct field type definition", "struct field type conversion"], "_raw_llm_output": "struct definition, struct field access, struct field assignment, struct field comparison, struct field initialization, struct field iteration (range loop), struct field modification, struct field summation, struct field type definition, struct field type conversion, struct field type definition, struct field type conversion, struct field type definition, struct field type conversion, struct field type definition, struct field type conversion, struct field type definition, struct field type conversion, struct field type definition, struct field type conversion, struct field type definition, struct field type conversion, struct field type definition, struct field type conversion, struct field type definition, struct field type conversion, struct field type definition, struct field type conversion, struct field type definition, struct field type conversion, struct field type definition, struct field type conversion, struct field type definition, struct field type conversion, struct field type definition, struct field type conversion, struct field type definition, struct field type conversion, struct field type definition, struct field type conversion, struct field type definition, struct field type conversion, struct field type definition, struct field type conversion, struct field type definition, struct field type conversion, struct field type definition, struct field type conversion, struct field type definition, struct field type conversion, struct field type definition, struct field type conversion"}
{"seed": "// AssertMulticastGroupFCntDown assert the multicast-group downlink frame-counter.\nfunc AssertMulticastGroupFCntDown(fCntDown uint32) Assertion {\n\treturn func(assert *require.Assertions, ts *IntegrationTestSuite) {\n\t\tmg, err := storage.GetMulticastGroup(context.Background(), storage.DB(), ts.MulticastGroup.ID, false)\n\t\tassert.NoError(err)\n\t\tassert.Equal(fCntDown, mg.FCnt)\n\t}\n}", "id": 11825, "concepts": ["storage package usage", "context package usage", "storage.GetMulticastGroup", "storage.DB", "storage.MulticastGroup", "storage.MulticastGroup.ID", "storage.MulticastGroup.FCnt", "require.Assertions", "require.Equal"], "_raw_llm_output": "storage package usage, context package usage, storage.GetMulticastGroup, storage.DB, storage.MulticastGroup, storage.MulticastGroup.ID, storage.MulticastGroup.FCnt, require.Assertions, require.Equal"}
{"seed": "// DropOptionalLT applies the LT predicate on the \"drop_optional\" field.\nfunc DropOptionalLT(v string) predicate.User {\n\treturn predicate.User(sql.FieldLT(FieldDropOptional, v))\n}", "id": 11827, "concepts": ["sql.FieldLT", "sql.FieldGT", "sql.FieldEQ", "sql.FieldNEQ", "sql.FieldIsNull", "sql.FieldIsNotNull", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldContains", "sql.FieldNotContains", "sql.FieldStartsWith", "sql.FieldNotStartsWith", "sql.FieldEndsWith", "sql.FieldNotEndsWith", "sql.FieldContainsAny", "sql.FieldNotContainsAny", "sql.FieldContainsAll", "sql.FieldNotContainsAll", "sql.FieldContainsRegex", "sql.FieldNotContainsRegex", "sql.FieldContainsRegexAny", "sql.FieldNotContainsRegexAny", "sql.FieldContainsRegexAll", "sql.FieldNotContainsRegexAll", "sql.FieldContainsI", "sql.FieldNotContainsI", "sql.FieldContainsAnyI", "sql.FieldNotContainsAnyI", "sql.FieldContainsAllI", "sql.FieldNotContainsAllI", "sql.FieldContainsRegexI", "sql.FieldNotContainsRegexI", "sql.FieldContainsRegexAnyI", "sql.FieldNotContainsRegexAnyI", "sql.FieldContainsRegexAllI", "sql.FieldNotContainsRegexAllI", "sql.FieldContainsRegexI", "sql.FieldNotContainsRegexI", "sql.FieldContainsRegex"], "_raw_llm_output": "sql.FieldLT, sql.FieldGT, sql.FieldEQ, sql.FieldNEQ, sql.FieldIsNull, sql.FieldIsNotNull, sql.FieldIn, sql.FieldNotIn, sql.FieldContains, sql.FieldNotContains, sql.FieldStartsWith, sql.FieldNotStartsWith, sql.FieldEndsWith, sql.FieldNotEndsWith, sql.FieldContainsAny, sql.FieldNotContainsAny, sql.FieldContainsAll, sql.FieldNotContainsAll, sql.FieldContainsRegex, sql.FieldNotContainsRegex, sql.FieldContainsRegexAny, sql.FieldNotContainsRegexAny, sql.FieldContainsRegexAll, sql.FieldNotContainsRegexAll, sql.FieldContainsI, sql.FieldNotContainsI, sql.FieldContainsAnyI, sql.FieldNotContainsAnyI, sql.FieldContainsAllI, sql.FieldNotContainsAllI, sql.FieldContainsRegexI, sql.FieldNotContainsRegexI, sql.FieldContainsRegexAnyI, sql.FieldNotContainsRegexAnyI, sql.FieldContainsRegexAllI, sql.FieldNotContainsRegexAllI, sql.FieldContainsRegexI, sql.FieldNotContainsRegexI, sql.FieldContainsRegex"}
{"seed": "// NewCreateScopedUserRoleSpacesParamsWithTimeout creates a new CreateScopedUserRoleSpacesParams object\n// with the default values initialized, and the ability to set a timeout on a request\nfunc NewCreateScopedUserRoleSpacesParamsWithTimeout(timeout time.Duration) *CreateScopedUserRoleSpacesParams {\n\tvar ()\n\treturn &CreateScopedUserRoleSpacesParams{\n\n\t\ttimeout: timeout,\n\t}\n}", "id": 11832, "concepts": ["function definition", "default value initialization", "timeout handling"], "_raw_llm_output": "function definition, default value initialization, timeout handling"}
{"seed": "// SocialNameGT applies the GT predicate on the \"social_name\" field.\nfunc SocialNameGT(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.GT(s.C(FieldSocialName), v))\n\t})\n}", "id": 11842, "concepts": ["sql.Selector", "sql.C", "sql.GT", "predicate.User", "function definition"], "_raw_llm_output": "sql.Selector, sql.C, sql.GT, predicate.User, function definition"}
{"seed": "// DefaultGenesisState returns the evidence module's default genesis state.\nfunc DefaultGenesisState() GenesisState {\n\treturn GenesisState{\n\t\tEvidence: []exported.Evidence{},\n\t}\n}", "id": 11861, "concepts": ["struct definition", "struct field initialization", "exported vs. unexported fields"], "_raw_llm_output": "struct definition, struct field initialization, exported vs. unexported fields"}
{"seed": "// We've gotten an *http.Response (maybe) and an error (maybe) back after\n// performing some HTTP operation; this function takes care of figuring\n// out if the operation succeeded, refreshes OAuth2 tokens if expiration\n// was the cause of the failure, takes care of exponential back-off for\n// transient errors, etc.  It then returns a HTTPResponseResult to the\n// caller, indicating how it should proceed.\nfunc handleHTTPResponse(resp *http.Response, err error, ntries int) HTTPResponseResult {\n\tif err == nil && resp != nil && resp.StatusCode >= 200 && resp.StatusCode <= 299 {\n\t\treturn Success\n\t}\n\n\tif ntries == maxHTTPRetries {\n\t\treturn Fail\n\t}\n\n\tif resp != nil && resp.StatusCode == 401 {\n\t\t// After an hour, the OAuth2 token expires and needs to\n\t\t// be refreshed.\n\t\tdebug.Printf(\"Trying OAuth2 token refresh.\")\n\t\tif err = oAuthTransport.Refresh(); err == nil {\n\t\t\t// Success\n\t\t\treturn Retry\n\t\t}\n\t\t// Otherwise fall through to sleep\n\t}\n\n\t// 403, 500, and 503 error codes come up for transient issues like\n\t// hitting the rate limit for Drive SDK API calls, but sometimes we get\n\t// other timeouts/connection resets here. Therefore, for all errors, we\n\t// sleep (with exponential  backoff) and try again a few times before\n\t// giving up.\n\texponentialBackoff(ntries, resp, err)\n\treturn Retry\n}", "id": 11870, "concepts": ["error handling", "retry logic", "exponential backoff", "HTTP client usage"], "_raw_llm_output": "error handling, retry logic, exponential backoff, HTTP client usage"}
{"seed": "// Marquee_ is a convenience wrapper for Marquee without the attrs argument.\nfunc Marquee_(children ...HTML) HTML {\n  return Marquee(nil, children...)\n}", "id": 11873, "concepts": ["HTML tag definition", "HTML tag attribute definition", "HTML tag attribute value definition", "HTML tag attribute value interpolation", "HTML tag attribute value interpolation with string concatenation", "HTML tag attribute value interpolation with string concatenation and interpolation", "HTML tag attribute value interpolation with string concatenation and interpolation and interpolation", "HTML tag attribute value interpolation with string concatenation and interpolation and interpolation and interpolation", "HTML tag attribute value interpolation with string concatenation and interpolation and interpolation and interpolation and interpolation", "HTML tag attribute value interpolation with string concatenation and interpolation and interpolation and interpolation and interpolation and interpolation", "HTML tag attribute value interpolation with string concatenation and interpolation and interpolation and interpolation and interpolation and interpolation and interpolation", "HTML tag attribute value interpolation with string concatenation and interpolation and interpolation and interpolation and interpolation and interpolation and interpolation and interpolation", "HTML tag attribute value interpolation with string concatenation and interpolation and interpolation and interpolation and interpolation and interpolation and interpolation and interpolation and interpolation", "HTML tag attribute value interpolation with string concatenation and interpolation and interpolation and interpolation and interpolation and interpolation and interpolation and interpolation and interpolation and interpolation", "HTML tag attribute value interpolation with string concatenation and interpolation and interpolation and interpolation and interpolation and interpolation and interpolation and interpolation and interpolation and interpolation and interpolation", "HTML tag attribute value interpolation with string concatenation and interpolation and interpolation and"], "_raw_llm_output": "HTML tag definition, HTML tag attribute definition, HTML tag attribute value definition, HTML tag attribute value interpolation, HTML tag attribute value interpolation with string concatenation, HTML tag attribute value interpolation with string concatenation and interpolation, HTML tag attribute value interpolation with string concatenation and interpolation and interpolation, HTML tag attribute value interpolation with string concatenation and interpolation and interpolation and interpolation, HTML tag attribute value interpolation with string concatenation and interpolation and interpolation and interpolation and interpolation, HTML tag attribute value interpolation with string concatenation and interpolation and interpolation and interpolation and interpolation and interpolation, HTML tag attribute value interpolation with string concatenation and interpolation and interpolation and interpolation and interpolation and interpolation and interpolation, HTML tag attribute value interpolation with string concatenation and interpolation and interpolation and interpolation and interpolation and interpolation and interpolation and interpolation, HTML tag attribute value interpolation with string concatenation and interpolation and interpolation and interpolation and interpolation and interpolation and interpolation and interpolation and interpolation, HTML tag attribute value interpolation with string concatenation and interpolation and interpolation and interpolation and interpolation and interpolation and interpolation and interpolation and interpolation and interpolation, HTML tag attribute value interpolation with string concatenation and interpolation and interpolation and interpolation and interpolation and interpolation and interpolation and interpolation and interpolation and interpolation and interpolation, HTML tag attribute value interpolation with string concatenation and interpolation and interpolation and"}
{"seed": "// WithEventRecorder is an Option that configures a Reconciler's EventRecorder.\n//\n// By default, manager.GetEventRecorderFor() is used if this option is not\n// configured.\nfunc WithEventRecorder(er record.EventRecorder) Option {\n\treturn func(r *Reconciler) error {\n\t\tr.eventRecorder = er\n\t\treturn nil\n\t}\n}", "id": 11876, "concepts": ["Option pattern", "record.EventRecorder usage"], "_raw_llm_output": "Option pattern, record.EventRecorder usage"}
{"seed": "// NewHyperflexVmSnapshotInfoAllOfWithDefaults instantiates a new HyperflexVmSnapshotInfoAllOf object\n// This constructor will only assign default values to properties that have it defined,\n// but it doesn't guarantee that properties required by API are set\nfunc NewHyperflexVmSnapshotInfoAllOfWithDefaults() *HyperflexVmSnapshotInfoAllOf {\n\tthis := HyperflexVmSnapshotInfoAllOf{}\n\tvar classId string = \"hyperflex.VmSnapshotInfo\"\n\tthis.ClassId = classId\n\tvar objectType string = \"hyperflex.VmSnapshotInfo\"\n\tthis.ObjectType = objectType\n\treturn &this\n}", "id": 11883, "concepts": ["struct definition", "struct field definition", "struct field initialization", "struct field assignment", "struct field initialization", "struct field assignment", "struct field initialization", "struct field assignment", "struct field initialization", "struct field assignment", "struct field initialization", "struct field assignment", "struct field initialization", "struct field assignment", "struct field initialization", "struct field assignment", "struct field initialization", "struct field assignment", "struct field initialization", "struct field assignment", "struct field initialization", "struct field assignment", "struct field initialization", "struct field assignment", "struct field initialization", "struct field assignment", "struct field initialization", "struct field assignment", "struct field initialization", "struct field assignment", "struct field initialization", "struct field assignment", "struct field initialization", "struct field assignment", "struct field initialization", "struct field assignment", "struct field initialization", "struct field assignment", "struct field initialization", "struct field assignment", "struct field initialization", "struct field assignment", "struct field initialization", "struct field assignment", "struct field initialization", "struct field assignment", "struct field initialization", "struct field assignment", "struct field initialization", "struct field assignment", "struct field initialization", "struct field assignment", "struct field initialization", "struct field assignment", "struct field initialization", "struct field assignment", "struct field initialization", "struct field assignment", "struct field initialization", "struct field assignment", "struct field initialization", "struct field assignment", "struct field initialization", "struct field assignment", ""], "_raw_llm_output": "struct definition, struct field definition, struct field initialization, struct field assignment, struct field initialization, struct field assignment, struct field initialization, struct field assignment, struct field initialization, struct field assignment, struct field initialization, struct field assignment, struct field initialization, struct field assignment, struct field initialization, struct field assignment, struct field initialization, struct field assignment, struct field initialization, struct field assignment, struct field initialization, struct field assignment, struct field initialization, struct field assignment, struct field initialization, struct field assignment, struct field initialization, struct field assignment, struct field initialization, struct field assignment, struct field initialization, struct field assignment, struct field initialization, struct field assignment, struct field initialization, struct field assignment, struct field initialization, struct field assignment, struct field initialization, struct field assignment, struct field initialization, struct field assignment, struct field initialization, struct field assignment, struct field initialization, struct field assignment, struct field initialization, struct field assignment, struct field initialization, struct field assignment, struct field initialization, struct field assignment, struct field initialization, struct field assignment, struct field initialization, struct field assignment, struct field initialization, struct field assignment, struct field initialization, struct field assignment, struct field initialization, struct field assignment, struct field initialization, struct field assignment,"}
{"seed": "// NewCancelWorkflowExecutionParamsWithTimeout creates a new CancelWorkflowExecutionParams object\n// with the default values initialized, and the ability to set a timeout on a request\nfunc NewCancelWorkflowExecutionParamsWithTimeout(timeout time.Duration) *CancelWorkflowExecutionParams {\n\tvar ()\n\treturn &CancelWorkflowExecutionParams{\n\n\t\ttimeout: timeout,\n\t}\n}", "id": 11885, "concepts": ["function definition", "timeout handling", "struct definition", "pointer usage"], "_raw_llm_output": "function definition, timeout handling, struct definition, pointer usage"}
{"seed": "// IsDuplicateError checks if an error is the `DuplicateError` type.\nfunc IsDuplicateError(e error) bool {\n\t_, ok := e.(DuplicateError)\n\treturn ok\n}", "id": 11899, "concepts": ["type assertion", "error handling", "error wrapping"], "_raw_llm_output": "type assertion, error handling, error wrapping"}
{"seed": "// URIToString creates a binding that connects a URI data item to a String.\n// Changes to the URI will be pushed to the String and setting the string will parse and set the\n// URI if the parse was successful.\n//\n// Since: 2.1\nfunc URIToString(v URI) String {\n\tstr := &stringFromURI{from: v}\n\tv.AddListener(str)\n\treturn str\n}", "id": 11902, "concepts": ["interface", "struct", "method", "pointer", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method receiver", "method"], "_raw_llm_output": "interface, struct, method, pointer, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method receiver, method"}
{"seed": "// NewHandler creates a new build server wrapping a (also newly\n// created) Go language server. I.e., it creates a BuildHandler\n// wrapping a LangHandler. The two handlers share a file system (in\n// memory).\n//\n// The build server is responsible for things such as fetching\n// dependencies, setting up the right file system structure and paths,\n// and mapping local file system paths to logical URIs (e.g.,\n// /goroot/src/fmt/print.go ->\n// git://github.com/golang/go?go1.7.1#src/fmt/print.go).\nfunc NewHandler(defaultCfg langserver.Config) *BuildHandler {\n\tif defaultCfg.MaxParallelism <= 0 {\n\t\tpanic(fmt.Sprintf(\"langserver.Config.MaxParallelism must be at least 1 (got %d)\", defaultCfg.MaxParallelism))\n\t}\n\tshared := &langserver.HandlerShared{Shared: true}\n\th := &BuildHandler{\n\t\tHandlerShared: shared,\n\t\tlang: &langserver.LangHandler{\n\t\t\tHandlerShared: shared,\n\t\t\tDefaultConfig: defaultCfg,\n\t\t},\n\t}\n\tshared.FindPackage = h.findPackageCached\n\treturn h\n}", "id": 11917, "concepts": ["function definition", "function composition", "function composition with anonymous function", "function composition with function composition", "function composition with function composition with function composition", "function composition with function composition with function composition with function composition", "function composition with function composition with function composition with function composition with function composition", "function composition with function composition with function composition with function composition with function composition with function composition", "function composition with function composition with function composition with function composition with function composition with function composition with function composition", "function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition", "function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition", "function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition", "function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition", "function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition", "function composition with function composition with function composition with function composition with"], "_raw_llm_output": "function definition, function composition, function composition with anonymous function, function composition with function composition, function composition with function composition with function composition, function composition with function composition with function composition with function composition, function composition with function composition with function composition with function composition with function composition, function composition with function composition with function composition with function composition with function composition with function composition, function composition with function composition with function composition with function composition with function composition with function composition with function composition, function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition, function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition, function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition, function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition, function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition, function composition with function composition with function composition with function composition with"}
{"seed": "// IDIn applies the In predicate on the ID field.\nfunc IDIn(ids ...string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\t// if not arguments were provided, append the FALSE constants,\n\t\t// since we can't apply \"IN ()\". This will make this predicate falsy.\n\t\tif len(ids) == 0 {\n\t\t\ts.Where(sql.False())\n\t\t\treturn\n\t\t}\n\t\tv := make([]interface{}, len(ids))\n\t\tfor i := range v {\n\t\t\tv[i] = ids[i]\n\t\t}\n\t\ts.Where(sql.In(s.C(FieldID), v...))\n\t})\n}", "id": 11925, "concepts": ["sql package usage", "sql.Selector", "sql.In", "sql.False", "sql.C", "predicate.User", "function definition"], "_raw_llm_output": "sql package usage, sql.Selector, sql.In, sql.False, sql.C, predicate.User, function definition"}
{"seed": "// RemoveMappingQualityLessThan is a filter for removing reads\n// that do not match or exceed the given mapping quality.\nfunc RemoveMappingQualityLessThan(mq int) sam.Filter {\n\tif mq == 0 {\n\t\treturn nil // no need to add any filter because aln.MAPQ is always >= 0\n\t}\n\tif mq > math.MaxUint8 {\n\t\treturn func(_ *sam.Header) sam.AlignmentFilter {\n\t\t\treturn func(_ *sam.Alignment) bool {\n\t\t\t\treturn false // no aln.MAPQ can be > math.MaxUint8\n\t\t\t}\n\t\t}\n\t}\n\tmapq := byte(mq)\n\treturn func(_ *sam.Header) sam.AlignmentFilter {\n\t\treturn func(aln *sam.Alignment) bool { return aln.MAPQ >= mapq }\n\t}\n}", "id": 11929, "concepts": ["filter", "filter function", "filter function definition", "filter function usage", "filter function application", "filter function composition", "filter function composition application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter function application", "filter"], "_raw_llm_output": "filter, filter function, filter function definition, filter function usage, filter function application, filter function composition, filter function composition application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter function application, filter"}
{"seed": "/*\nStatusCode returns the HTTP status code carried by the given error.\nReturns 0 if the error is not produced by a body parser function.\n*/\nfunc StatusCode(err error) int {\n\tif e := getResponseError(err); e != nil {\n\t\treturn e.StatusCode\n\t} else {\n\t\treturn 0\n\t}\n}", "id": 11933, "concepts": ["error handling (error wrapping)", "error handling (error unwrapping)", "error handling (error type assertion)", "error handling (error interface)", "error handling (error interface conversion)", "error handling (error interface assertion)", "error handling (error interface type assertion)", "error handling (error interface type assertion)", "error handling (error interface type assertion)", "error handling (error interface type assertion)", "error handling (error interface type assertion)", "error handling (error interface type assertion)", "error handling (error interface type assertion)", "error handling (error interface type assertion)", "error handling (error interface type assertion)", "error handling (error interface type assertion)", "error handling (error interface type assertion)", "error handling (error interface type assertion)", "error handling (error interface type assertion)", "error handling (error interface type assertion)", "error handling (error interface type assertion)", "error handling (error interface type assertion)", "error handling (error interface type assertion)", "error handling (error interface type assertion)", "error handling (error interface type assertion)", "error handling (error interface type assertion)", "error handling (error interface type assertion)", "error handling (error interface type assertion)", "error handling (error interface type assertion)", "error handling (error interface type assertion)", "error handling (error interface type assertion)", "error handling (error interface type assertion)", "error handling (error interface type assertion"], "_raw_llm_output": "error handling (error wrapping), error handling (error unwrapping), error handling (error type assertion), error handling (error interface), error handling (error interface conversion), error handling (error interface assertion), error handling (error interface type assertion), error handling (error interface type assertion), error handling (error interface type assertion), error handling (error interface type assertion), error handling (error interface type assertion), error handling (error interface type assertion), error handling (error interface type assertion), error handling (error interface type assertion), error handling (error interface type assertion), error handling (error interface type assertion), error handling (error interface type assertion), error handling (error interface type assertion), error handling (error interface type assertion), error handling (error interface type assertion), error handling (error interface type assertion), error handling (error interface type assertion), error handling (error interface type assertion), error handling (error interface type assertion), error handling (error interface type assertion), error handling (error interface type assertion), error handling (error interface type assertion), error handling (error interface type assertion), error handling (error interface type assertion), error handling (error interface type assertion), error handling (error interface type assertion), error handling (error interface type assertion), error handling (error interface type assertion"}
{"seed": "// SocialPayloadGT applies the GT predicate on the \"social_payload\" field.\nfunc SocialPayloadGT(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.GT(s.C(FieldSocialPayload), v))\n\t})\n}", "id": 11950, "concepts": ["sql.Selector", "sql.GT", "sql.C", "predicate.User", "function definition"], "_raw_llm_output": "sql.Selector, sql.GT, sql.C, predicate.User, function definition"}
{"seed": "// GenerateVcode creates a unique token that maps back to the specified email\n// address.  Send this token as part of a link in a confirmation email, and\n// use GetVerifiedEmail to change it back into a (now verified) email address.\nfunc GenerateVcode(email string) (string, error) {\n\n\t// Check only the very basic email format. The real validation happens when\n\t// we actually send to the email address. This will allow  unconventional\n\t// email addresses to still be used.\n\tif strings.Count(email, \"@\") != 1 || email[0] == '@' || email[len(email)-1] == '@' {\n\t\treturn \"\", ErrInvalidEmail\n\t}\n\n  // Have the verify code be valid for 24 hours.\n\texpiry := timestamp() + 86400\n\n\tfor {\n\t\tvcode := RandomToken(32)\n\t\tif _, err := db.Exec(\n\t\t\t\"INSERT INTO \"+emailVerifyTable+\" (vtoken, email, expires_at) VALUES (?,?,?)\",\n\t\t\tvcode, email, expiry); err != nil {\n\t\t\tif isDuplicate(err) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn \"\", err\n\t\t}\n\t\treturn vcode, nil\n\t}\n}", "id": 11958, "concepts": ["string manipulation", "string comparison", "string concatenation", "string length", "string index access", "string iteration", "string formatting", "string concatenation", "string comparison", "string length", "string index access", "string iteration", "string formatting", "string concatenation", "string comparison", "string length", "string index access", "string iteration", "string formatting", "string concatenation", "string comparison", "string length", "string index access", "string iteration", "string formatting", "string concatenation", "string comparison", "string length", "string index access", "string iteration", "string formatting", "string concatenation", "string comparison", "string length", "string index access", "string iteration", "string formatting", "string concatenation", "string comparison", "string length", "string index access", "string iteration", "string formatting", "string concatenation", "string comparison", "string length", "string index access", "string iteration", "string formatting", "string concatenation", "string comparison", "string length", "string index access", "string iteration", "string formatting", "string concatenation", "string comparison", "string length", "string index access", "string iteration", "string formatting", "string concatenation", "string comparison", "string length", "string index access", "string iteration", "string formatting", "string concatenation", "string comparison", "string length", "string index access", "string iteration", "string formatting", "string concatenation", "string comparison", "string length", "string index"], "_raw_llm_output": "string manipulation, string comparison, string concatenation, string length, string index access, string iteration, string formatting, string concatenation, string comparison, string length, string index access, string iteration, string formatting, string concatenation, string comparison, string length, string index access, string iteration, string formatting, string concatenation, string comparison, string length, string index access, string iteration, string formatting, string concatenation, string comparison, string length, string index access, string iteration, string formatting, string concatenation, string comparison, string length, string index access, string iteration, string formatting, string concatenation, string comparison, string length, string index access, string iteration, string formatting, string concatenation, string comparison, string length, string index access, string iteration, string formatting, string concatenation, string comparison, string length, string index access, string iteration, string formatting, string concatenation, string comparison, string length, string index access, string iteration, string formatting, string concatenation, string comparison, string length, string index access, string iteration, string formatting, string concatenation, string comparison, string length, string index access, string iteration, string formatting, string concatenation, string comparison, string length, string index"}
{"seed": "// CredentialCreationResponseFromProto converts a CredentialCreationResponse\n// proto to its lib counterpart.\nfunc CredentialCreationResponseFromProto(ccr *wantypes.CredentialCreationResponse) *CredentialCreationResponse {\n\tif ccr == nil {\n\t\treturn nil\n\t}\n\treturn &CredentialCreationResponse{\n\t\tPublicKeyCredential: PublicKeyCredential{\n\t\t\tCredential: Credential{\n\t\t\t\tID:   base64.RawURLEncoding.EncodeToString(ccr.RawId),\n\t\t\t\tType: ccr.Type,\n\t\t\t},\n\t\t\tRawID:      ccr.RawId,\n\t\t\tExtensions: outputExtensionsFromProto(ccr.Extensions),\n\t\t},\n\t\tAttestationResponse: authenticatorAttestationResponseFromProto(ccr.Response),\n\t}\n}", "id": 11978, "concepts": ["conversion", "struct field access", "pointer dereference", "pointer handling", "interface conversion"], "_raw_llm_output": "conversion, struct field access, pointer dereference, pointer handling, interface conversion"}
{"seed": "// JoinTableValues concatenates the elements of values to :value1, :value2, ...\n// query := JoinTableValues(\"foo\", \"bar\")\n// // \"?,?\"\n// query := JoinTableValues()\n// // \"\"\nfunc JoinTableValues(cols ...string) string {\n\tcols = strings_.SliceTrimEmpty(cols...)\n\tif len(cols) == 0 {\n\t\t// https://dev.mysql.com/doc/refman/5.7/en/data-type-defaults.html\n\t\t// DEFAULT\n\t\treturn \"\"\n\t}\n\treturn strings.Join(TableValues(cols...), \",\")\n}", "id": 11983, "concepts": ["string manipulation", "string formatting", "string concatenation", "string trimming", "slice manipulation", "slice iteration (range loop)", "slice concatenation", "slice trimming", "string formatting", "string concatenation", "string trimming", "string formatting", "string concatenation", "string trimming", "string formatting", "string concatenation", "string trimming", "string formatting", "string concatenation", "string trimming", "string formatting", "string concatenation", "string trimming", "string formatting", "string concatenation", "string trimming", "string formatting", "string concatenation", "string trimming", "string formatting", "string concatenation", "string trimming", "string formatting", "string concatenation", "string trimming", "string formatting", "string concatenation", "string trimming", "string formatting", "string concatenation", "string trimming", "string formatting", "string concatenation", "string trimming", "string formatting", "string concatenation", "string trimming", "string formatting", "string concatenation", "string trimming", "string formatting", "string concatenation", "string trimming", "string formatting", "string concatenation", "string trimming", "string formatting", "string concatenation", "string trimming", "string formatting", "string concatenation", "string trimming", "string formatting", "string concatenation"], "_raw_llm_output": "string manipulation, string formatting, string concatenation, string trimming, slice manipulation, slice iteration (range loop), slice concatenation, slice trimming, string formatting, string concatenation, string trimming, string formatting, string concatenation, string trimming, string formatting, string concatenation, string trimming, string formatting, string concatenation, string trimming, string formatting, string concatenation, string trimming, string formatting, string concatenation, string trimming, string formatting, string concatenation, string trimming, string formatting, string concatenation, string trimming, string formatting, string concatenation, string trimming, string formatting, string concatenation, string trimming, string formatting, string concatenation, string trimming, string formatting, string concatenation, string trimming, string formatting, string concatenation, string trimming, string formatting, string concatenation, string trimming, string formatting, string concatenation, string trimming, string formatting, string concatenation, string trimming, string formatting, string concatenation, string trimming, string formatting, string concatenation, string trimming, string formatting, string concatenation"}
{"seed": "// BuildRequestSignature builds the signature required by the Coinbase Pro API for the CB-ACCESS-SIGN\n// header, using the request's method, path, and JSON body (if provided).\n// The generated signature, as well as the timestamp (in seconds) used for the signature (for use with the\n// CB-ACCESS-TIMESTAMP header) are returned.\nfunc BuildRequestSignature(requestMethod, requestPath string, requestBody []byte) (string, string) {\n\tsecret, err := base64.StdEncoding.DecodeString(secrets.CoinbaseAPISecret())\n\tif err != nil {\n\t\tpanic(errors.Wrap(err, \"base64 decoding error\"))\n\t}\n\n\ttimestamp := time.Now().Unix()\n\ttimestampStr := fmt.Sprintf(\"%d\", timestamp)\n\n\tprehashStr := timestampStr + strings.ToUpper(requestMethod) + requestPath\n\tif requestBody != nil {\n\t\tprehashStr += string(requestBody)\n\t}\n\n\tprehashBytes := []byte(prehashStr)\n\n\tmac := hmac.New(sha256.New, secret)\n\t_, err = mac.Write(prehashBytes)\n\tif err != nil {\n\t\tpanic(errors.Wrap(err, \"error attempting to write prehash bytes to hmac\"))\n\t}\n\n\tsigBytes := mac.Sum(nil)\n\n\tsigEncoded := base64.StdEncoding.EncodeToString(sigBytes)\n\n\treturn sigEncoded, timestampStr\n}", "id": 12000, "concepts": ["hmac", "sha256", "base64", "time.Now", "string manipulation", "string formatting", "error handling", "panic", "crypto/hmac", "crypto/sha256", "crypto/base64"], "_raw_llm_output": "hmac, sha256, base64, time.Now, string manipulation, string formatting, error handling, panic, crypto/hmac, crypto/sha256, crypto/base64"}
{"seed": "// middlewareInterceptionTest tests that unary and streaming requests can be\n// intercepted. It also makes sure that depending on the mode (read-only or\n// custom macaroon caveat) a middleware only gets access to the requests it\n// should be allowed access to.\nfunc middlewareInterceptionTest(t *testing.T, node *lntest.HarnessNode,\n\tpeer *lntest.HarnessNode, registration *middlewareHarness,\n\tuserMac *macaroon.Macaroon, disallowedMac *macaroon.Macaroon,\n\treadOnly bool) {\n\n\t// Everything we test here should be executed in a matter of\n\t// milliseconds, so we can use one single timeout context for all calls.\n\tctxb := context.Background()\n\tctxc, cancel := context.WithTimeout(ctxb, defaultTimeout)\n\tdefer cancel()\n\n\t// Create a client connection that we'll use to simulate user requests\n\t// to lnd with.\n\tcleanup, client := macaroonClient(t, node, userMac)\n\tdefer cleanup()\n\n\t// We're going to send a simple RPC request to list all channels.\n\t// We need to invoke the intercept logic in a goroutine because we'd\n\t// block the execution of the main task otherwise.\n\treq := &lnrpc.ListChannelsRequest{ActiveOnly: true}\n\tgo registration.interceptUnary(\n\t\t\"/lnrpc.Lightning/ListChannels\", req, nil, readOnly,\n\t)\n\n\t// Do the actual call now and wait for the interceptor to do its thing.\n\tresp, err := client.ListChannels(ctxc, req)\n\trequire.NoError(t, err)\n\n\t// Did we receive the correct intercept message?\n\tassertInterceptedType(t, resp, <-registration.responsesChan)\n\n\t// Let's test the same for a streaming endpoint.\n\treq2 := &lnrpc.PeerEventSubscription{}\n\tgo registration.interceptStream(\n\t\t\"/lnrpc.Lightning/SubscribePeerEvents\", req2, nil, readOnly,\n\t)\n\n\t// Do the actual call now and wait for the interceptor to do its thing.\n\tpeerCtx, peerCancel := context.WithCancel(ctxb)\n\tresp2, err := client.SubscribePeerEvents(peerCtx, req2)\n\trequire.NoError(t, err)\n\n\t// Disconnect Bob to trigger a peer event without using Alice's RPC\n\t// interface itself.\n\t_, err = peer.DisconnectPeer(ctxc, &lnrpc.DisconnectPeerRequest{\n\t\tPubKey: node.PubKeyStr,\n\t})\n\trequire.NoError(t, err)\n\tpeerEvent, err := resp2.Recv()\n\trequire.NoError(t, err)\n\trequire.Equal(t, lnrpc.PeerEvent_PEER_OFFLINE, peerEvent.GetType())\n\n\t// Stop the peer stream again, otherwise we'll produce more events.\n\tpeerCancel()\n\n\t// Did we receive the correct intercept message?\n\tassertInterceptedType(t, peerEvent, <-registration.responsesChan)\n\n\t// Make sure that with the other macaroon we aren't allowed to access\n\t// the interceptor. If we registered for read-only access then there is\n\t// no middleware that handles the custom macaroon caveat. If we\n\t// registered for a custom caveat then there is no middleware that\n\t// handles unencumbered read-only access.\n\tcleanup, client = macaroonClient(t, node, disallowedMac)\n\tdefer cleanup()\n\n\t// We need to make sure we don't get any interception messages for\n\t// requests made with the disallowed macaroon.\n\tvar (\n\t\terrChan = make(chan error, 1)\n\t\tmsgChan = make(chan *lnrpc.RPCMiddlewareRequest, 1)\n\t)\n\tgo func() {\n\t\treq, err := registration.stream.Recv()\n\t\tif err != nil {\n\t\t\terrChan <- err\n\t\t\treturn\n\t\t}\n\n\t\tmsgChan <- req\n\t}()\n\n\t// Let's invoke the same request again but with the other macaroon.\n\tresp, err = client.ListChannels(ctxc, req)\n\n\t// Depending on what mode we're in, we expect something different. If we\n\t// are in read-only mode then an encumbered macaroon cannot be used\n\t// since there is no middleware registered for it. If we registered for\n\t// a custom macaroon caveat and a request with anon-encumbered macaroon\n\t// comes in, we expect to just not get any intercept messages.\n\tif readOnly {\n\t\trequire.Error(t, err)\n\t\trequire.Contains(\n\t\t\tt, err.Error(), \"cannot accept macaroon with custom \"+\n\t\t\t\t\"caveat 'itest-caveat', no middleware \"+\n\t\t\t\t\"registered\",\n\t\t)\n\t} else {\n\t\trequire.NoError(t, err)\n\n\t\t// We disconnected Bob so there should be no active channels.\n\t\trequire.Len(t, resp.Channels, 0)\n\t}\n\n\t// There should be neither an error nor any interception messages in the\n\t// channels.\n\tselect {\n\tcase err := <-errChan:\n\t\tt.Fatalf(\"Unexpected error, not expecting messages: %v\", err)\n\n\tcase msg := <-msgChan:\n\t\tt.Fatalf(\"Unexpected intercept message: %v\", msg)\n\n\tcase <-time.After(time.Second):\n\t\t// Nothing came in for a second, we're fine.\n\t}\n}", "id": 12001, "concepts": ["middleware", "macaroon", "macaroon caveat", "macaroon caveat handling", "macaroon caveat registration", "macaroon caveat usage", "macaroon caveat access", "macaroon caveat access handling", "macaroon caveat access registration", "macaroon caveat access usage", "macaroon caveat access handling", "macaroon caveat access registration", "macaroon caveat access usage", "macaroon caveat access handling", "macaroon caveat access registration", "macaroon caveat access usage", "macaroon caveat access handling", "macaroon caveat access registration", "macaroon caveat access usage", "macaroon caveat access handling", "macaroon caveat access registration", "macaroon caveat access usage", "macaroon caveat access handling", "macaroon caveat access registration", "macaroon caveat access usage", "macaroon caveat access handling", "macaroon caveat access registration", "macaroon caveat access usage", "macaroon caveat access handling", "macaroon caveat access registration", "macaroon caveat access usage", "macaroon caveat access handling", "macaroon caveat access registration", "macaroon caveat access usage"], "_raw_llm_output": "middleware, macaroon, macaroon caveat, macaroon caveat handling, macaroon caveat registration, macaroon caveat usage, macaroon caveat access, macaroon caveat access handling, macaroon caveat access registration, macaroon caveat access usage, macaroon caveat access handling, macaroon caveat access registration, macaroon caveat access usage, macaroon caveat access handling, macaroon caveat access registration, macaroon caveat access usage, macaroon caveat access handling, macaroon caveat access registration, macaroon caveat access usage, macaroon caveat access handling, macaroon caveat access registration, macaroon caveat access usage, macaroon caveat access handling, macaroon caveat access registration, macaroon caveat access usage, macaroon caveat access handling, macaroon caveat access registration, macaroon caveat access usage, macaroon caveat access handling, macaroon caveat access registration, macaroon caveat access usage, macaroon caveat access handling, macaroon caveat access registration, macaroon caveat access usage"}
{"seed": "// Calculate the Geom Mean Long Sun in degrees based on the formula: 280.46646 + julianCentury * (36000.76983 + julianCentury * 0.0003032)\n// julianCentury - Julian century calculated by the calcJulianCentury function\n// Return The Geom Mean Long Sun slice\nfunc calcGeomMeanLongSun(julianCentury []float64) (geomMeanLongSun []float64) {\n\tfor index := 0; index < len(julianCentury); index++ {\n\t\ta := 280.46646 + julianCentury[index]*(36000.76983+julianCentury[index]*0.0003032)\n\t\ttemp := math.Mod(a, 360.0)\n\t\tgeomMeanLongSun = append(geomMeanLongSun, temp)\n\t}\n\treturn\n}", "id": 12005, "concepts": ["slice iteration (range loop)", "slice manipulation", "slice creation", "slice appending", "mathematical operations", "mathematical constants", "mathematical functions", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants", "mathematical constants"], "_raw_llm_output": "slice iteration (range loop), slice manipulation, slice creation, slice appending, mathematical operations, mathematical constants, mathematical functions, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants, mathematical constants"}
{"seed": "// Trace returns the filename, line and function name of its caller.\n// Ref: http://stackoverflow.com/questions/25927660/golang-get-current-scope-of-function-name\nfunc Trace() (string) {\n  // At least one entry needed\n  pc := make([]uintptr, 10)\n  runtime.Callers(3, pc)\n  f := runtime.FuncForPC(pc[0])\n  file, line := f.FileLine(pc[0])\n  return filepath.Base(file) + \":\" + strconv.Itoa(line) + \" \" + f.Name()\n}", "id": 12015, "concepts": ["runtime.Callers", "runtime.FuncForPC", "runtime.Func.FileLine", "runtime.Func.Name", "filepath.Base", "strconv.Itoa"], "_raw_llm_output": "runtime.Callers, runtime.FuncForPC, runtime.Func.FileLine, runtime.Func.Name, filepath.Base, strconv.Itoa"}
{"seed": "// Eval takes an ast.Node (starting with the RootNode) and traverses the AST.\n// It switches on the node's type and recursively evaluates them appropriately\nfunc Eval(node ast.Node, env *object.Environment) object.Object {\n\tswitch node := node.(type) {\n\n\t// Statements\n\tcase *ast.RootNode:\n\t\treturn evalRootNode(node, env)\n\n\tcase *ast.BlockStatement:\n\t\treturn evalBlockStmt(node, env)\n\n\tcase *ast.ExpressionStatement:\n\t\treturn Eval(node.Expression, env)\n\n\tcase *ast.ReturnStatement:\n\t\tval := Eval(node.ReturnValue, env)\n\t\tif isError(val) {\n\t\t\treturn val\n\t\t}\n\t\treturn &object.ReturnValue{Value: val}\n\n\tcase *ast.LetStatement:\n\t\tval := Eval(node.Value, env)\n\t\tif isError(val) {\n\t\t\treturn val\n\t\t}\n\t\tenv.Set(node.Name.Value, val)\n\n\tcase *ast.ConstStatement:\n\t\tval := Eval(node.Value, env)\n\t\tif isError(val) {\n\t\t\treturn val\n\t\t}\n\t\tenv.Set(node.Name.Value, val)\n\n\t// Expressions\n\tcase *ast.IntegerLiteral:\n\t\treturn &object.Integer{Value: node.Value}\n\n\tcase *ast.StringLiteral:\n\t\treturn &object.String{Value: node.Value}\n\n\tcase *ast.Boolean:\n\t\treturn nativeBoolToBooleanObj(node.Value)\n\n\tcase *ast.PrefixExpression:\n\t\tright := Eval(node.Right, env)\n\t\tif isError(right) {\n\t\t\treturn right\n\t\t}\n\t\treturn evalPrefixExpr(node.Operator, right, node.Token.Line)\n\n\tcase *ast.InfixExpression:\n\t\tleft := Eval(node.Left, env)\n\t\tif isError(left) {\n\t\t\treturn left\n\t\t}\n\t\tright := Eval(node.Right, env)\n\t\tif isError(right) {\n\t\t\treturn right\n\t\t}\n\t\treturn evalInfixExpr(node.Operator, left, right, node.Token.Line)\n\n\tcase *ast.PostfixExpression:\n\t\treturn evalPostfixExpr(env, node.Operator, node)\n\n\tcase *ast.IfExpression:\n\t\treturn evalIfExpr(node, env)\n\n\tcase *ast.Identifier:\n\t\treturn evalIdentifier(node, env)\n\n\tcase *ast.FunctionLiteral:\n\t\tparams := node.Parameters\n\t\tbody := node.Body\n\t\treturn &object.Function{\n\t\t\tParameters: params,\n\t\t\tBody:       body,\n\t\t\tEnv:        env,\n\t\t}\n\n\tcase *ast.CallExpression:\n\t\tfn := Eval(node.Function, env)\n\t\tif isError(fn) {\n\t\t\treturn fn\n\t\t}\n\t\targs := evalExprs(node.Arguments, env)\n\t\tif len(args) == 1 && isError(args[0]) {\n\t\t\treturn args[0]\n\t\t}\n\t\treturn applyFunction(fn, args, node.Token.Line)\n\n\tcase *ast.ArrayLiteral:\n\t\telements := evalExprs(node.Elements, env)\n\t\tif len(elements) == 1 && isError(elements[0]) {\n\t\t\treturn elements[0]\n\t\t}\n\t\treturn &object.Array{Elements: elements}\n\n\tcase *ast.IndexExpression:\n\t\tleft := Eval(node.Left, env)\n\t\tif isError(left) {\n\t\t\treturn left\n\t\t}\n\t\tindex := Eval(node.Index, env)\n\t\tif isError(index) {\n\t\t\treturn index\n\t\t}\n\t\treturn evalIndexExpr(left, index, node.Token.Line)\n\n\tcase *ast.HashLiteral:\n\t\treturn evalHashLiteral(node, env)\n\t}\n\n\treturn nil\n}", "id": 12019, "concepts": ["ast traversal", "AST node types", "AST node switch statement", "AST node evaluation", "AST node evaluation switch statement", "AST node evaluation switch statement cases", "AST node evaluation switch statement cases", "AST node evaluation switch statement cases", "AST node evaluation switch statement cases", "AST node evaluation switch statement cases", "AST node evaluation switch statement cases", "AST node evaluation switch statement cases", "AST node evaluation switch statement cases", "AST node evaluation switch statement cases", "AST node evaluation switch statement cases", "AST node evaluation switch statement cases", "AST node evaluation switch statement cases", "AST node evaluation switch statement cases", "AST node evaluation switch statement cases", "AST node evaluation switch statement cases", "AST node evaluation switch statement cases", "AST node evaluation switch statement cases", "AST node evaluation switch statement cases", "AST node evaluation switch statement cases", "AST node evaluation switch statement cases", "AST node evaluation switch statement cases", "AST node evaluation switch statement cases", "AST node evaluation switch statement cases", "AST node evaluation switch statement cases", "AST node evaluation switch statement cases", "AST node evaluation switch statement cases", "AST node evaluation switch statement cases", "AST node evaluation switch statement cases", "AST node evaluation switch statement cases", "AST node evaluation switch statement cases", "AST node evaluation switch statement cases", "AST node evaluation switch statement cases", "AST node evaluation switch statement cases", "AST node"], "_raw_llm_output": "ast traversal, AST node types, AST node switch statement, AST node evaluation, AST node evaluation switch statement, AST node evaluation switch statement cases, AST node evaluation switch statement cases, AST node evaluation switch statement cases, AST node evaluation switch statement cases, AST node evaluation switch statement cases, AST node evaluation switch statement cases, AST node evaluation switch statement cases, AST node evaluation switch statement cases, AST node evaluation switch statement cases, AST node evaluation switch statement cases, AST node evaluation switch statement cases, AST node evaluation switch statement cases, AST node evaluation switch statement cases, AST node evaluation switch statement cases, AST node evaluation switch statement cases, AST node evaluation switch statement cases, AST node evaluation switch statement cases, AST node evaluation switch statement cases, AST node evaluation switch statement cases, AST node evaluation switch statement cases, AST node evaluation switch statement cases, AST node evaluation switch statement cases, AST node evaluation switch statement cases, AST node evaluation switch statement cases, AST node evaluation switch statement cases, AST node evaluation switch statement cases, AST node evaluation switch statement cases, AST node evaluation switch statement cases, AST node evaluation switch statement cases, AST node evaluation switch statement cases, AST node evaluation switch statement cases, AST node evaluation switch statement cases, AST node evaluation switch statement cases, AST node"}
{"seed": "// DateTimeNotIn applies the NotIn predicate on the \"dateTime\" field.\nfunc DateTimeNotIn(vs ...time.Time) predicate.Bulk {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.Bulk(func(s *sql.Selector) {\n\t\t// if not arguments were provided, append the FALSE constants,\n\t\t// since we can't apply \"IN ()\". This will make this predicate falsy.\n\t\tif len(v) == 0 {\n\t\t\ts.Where(sql.False())\n\t\t\treturn\n\t\t}\n\t\ts.Where(sql.NotIn(s.C(FieldDateTime), v...))\n\t})\n}", "id": 12020, "concepts": ["sql.Selector", "sql.NotIn", "sql.False", "sql.Bulk", "predicate.Bulk", "predicate.Bulk function definition"], "_raw_llm_output": "sql.Selector, sql.NotIn, sql.False, sql.Bulk, predicate.Bulk, predicate.Bulk function definition"}
{"seed": "// SocialUserIDEQ applies the EQ predicate on the \"social_user_id\" field.\nfunc SocialUserIDEQ(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldSocialUserID), v))\n\t})\n}", "id": 12040, "concepts": ["sql.Selector", "sql.EQ", "sql.Field", "predicate.User"], "_raw_llm_output": "sql.Selector, sql.EQ, sql.Field, predicate.User"}
{"seed": "// NewEditParamsWithHTTPClient creates a new EditParams object\n// with the ability to set a custom HTTPClient for a request.\nfunc NewEditParamsWithHTTPClient(client *http.Client) *EditParams {\n\treturn &EditParams{\n\t\tHTTPClient: client,\n\t}\n}", "id": 12087, "concepts": ["struct definition", "pointer usage", "method definition", "method receiver"], "_raw_llm_output": "struct definition, pointer usage, method definition, method receiver"}
{"seed": "// FloatToStringWithFormat creates a binding that connects a Float data item to a String and is\n// presented using the specified format. Changes to the Float will be pushed to the String and setting\n// the string will parse and set the Float if the string matches the format and its parse was successful.\n//\n// Since: 2.0\nfunc FloatToStringWithFormat(v Float, format string) String {\n\tif format == \"%f\" { // Same as not using custom formatting.\n\t\treturn FloatToString(v)\n\t}\n\n\tstr := &stringFromFloat{from: v, format: format}\n\tv.AddListener(str)\n\treturn str\n}", "id": 12135, "concepts": ["string formatting", "fmt package usage", "custom formatting", "String type", "Float type", "Float.AddListener"], "_raw_llm_output": "string formatting, fmt package usage, custom formatting, String type, Float type, Float.AddListener"}
{"seed": "// Ins_ is a convenience wrapper for Ins without the attrs argument.\nfunc Ins_(children ...HTML) HTML {\n  return Ins(nil, children...)\n}", "id": 12136, "concepts": ["HTML struct definition", "HTML struct field definition", "HTML struct field initialization", "HTML struct field usage", "HTML struct method definition", "HTML struct method usage"], "_raw_llm_output": "HTML struct definition, HTML struct field definition, HTML struct field initialization, HTML struct field usage, HTML struct method definition, HTML struct method usage"}
{"seed": "// NewOf3Or5 gives a slice of numbers below\n// the desried maximum that are multiples of\n// either 3 or 5\nfunc NewOf3Or5(max int) Multiples {\n\tvar m Multiples\n\n\tfor i := 1; i < max; i++ {\n\t\tif i%3 == 0 || i%5 == 0 {\n\t\t\tm = append(m, i)\n\t\t}\n\t}\n\n\treturn m\n}", "id": 12149, "concepts": ["slice", "for loop", "if statement", "basic function definition"], "_raw_llm_output": "slice, for loop, if statement, basic function definition"}
{"seed": "/*\n\t\u627e\u5230  \u5927\u4e8e s\u7684\u6700\u5c0f\u7ec4\u5408\n\t\u5982 7,\u5e76\u4e14\u63d0\u4f9b\u4e86[2,3,1,2,4,3] ,\u5219 4+3 >=7  2+3+2>=7 \u4f46\u662f 3>2 \u6240\u4ee5 4,3\u4e3a\u7ec4\u5408\n\t\u6ed1\u52a8\u7a97\u53e3(\u53cc\u6307\u9488\u89e3\u51b3)\n */\nfunc minSubArrayLen(s int, nums []int) int {\n\tif len(nums) == 0 {\n\t\treturn 0\n\t}\n\tl, r, min := 0, 0, math.MaxInt32\n\tsum := 0\n\tfor r < len(nums) {\n\t\tsum += nums[r]\n\t\tfor sum >= s {\n\t\t\t//  \u5f00\u59cb\u7f29\u5c0f\u7a97\u53e3\n\t\t\tmin = minIn11(r - l + 1, min)\n\t\t\tsum-=nums[l]\n\t\t\tl++\n\t\t}\n\t\tr++\n\t}\n\tif min==math.MaxInt32{\n\t\treturn 0\n\t}\n\treturn min\n}", "id": 12161, "concepts": ["\u6ed1\u52a8\u7a97\u53e3(\u53cc\u6307\u9488\u89e3\u51b3)", "\u53cc\u6307\u9488", "\u6570\u7ec4", "\u53cc\u6307\u9488", "\u6570\u7ec4"], "_raw_llm_output": "\u6ed1\u52a8\u7a97\u53e3(\u53cc\u6307\u9488\u89e3\u51b3), \u53cc\u6307\u9488, \u6570\u7ec4, \u53cc\u6307\u9488, \u6570\u7ec4"}
{"seed": "// EncodeVariantKey returns a Genetic Variant Key based on pre-encoded CHROM, POS (0-base), REF+ALT.\nfunc EncodeVariantKey(chrom uint8, pos, refalt uint32) uint64 {\n\treturn uint64(C.encode_variantkey(C.uint8_t(chrom), C.uint32_t(pos), C.uint32_t(refalt)))\n}", "id": 12181, "concepts": ["C interop", "CGO", "C.uint8_t", "C.uint32_t", "C.encode_variantkey"], "_raw_llm_output": "C interop, CGO, C.uint8_t, C.uint32_t, C.encode_variantkey"}
{"seed": "// LinesByParagraph takes a slice of strings, and returns a slice of slices of\n// strings: it separates paragraphs (multiple newlines).\nfunc LinesByParagraph(lines []string) [][]string {\n\tvar result [][]string\n\tvar chunk []string\n\n\tfor _, line := range lines {\n\t\tif line == \"\" {\n\t\t\tif chunk != nil {\n\t\t\t\tresult = append(result, chunk)\n\t\t\t\tchunk = nil\n\t\t\t}\n\t\t} else {\n\t\t\tchunk = append(chunk, line)\n\t\t}\n\t}\n\tif chunk != nil {\n\t\tresult = append(result, chunk)\n\t}\n\treturn result\n}", "id": 12207, "concepts": ["slice iteration (range loop)", "slice manipulation", "string manipulation"], "_raw_llm_output": "slice iteration (range loop), slice manipulation, string manipulation"}
{"seed": "// NewFxKeyValueYARPCClient provides a KeyValueYARPCClient\n// to an Fx application using the given name for routing.\n//\n//  fx.Provide(\n//    examplepb.NewFxKeyValueYARPCClient(\"service-name\"),\n//    ...\n//  )\nfunc NewFxKeyValueYARPCClient(name string, options ...protobuf.ClientOption) interface{} {\n\treturn func(params FxKeyValueYARPCClientParams) FxKeyValueYARPCClientResult {\n\t\tcc := params.Provider.ClientConfig(name)\n\n\t\tif params.Restriction != nil {\n\t\t\tif namer, ok := cc.GetUnaryOutbound().(transport.Namer); ok {\n\t\t\t\tif err := params.Restriction.Check(protobuf.Encoding, namer.TransportName()); err != nil {\n\t\t\t\t\tpanic(err.Error())\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn FxKeyValueYARPCClientResult{\n\t\t\tClient: newKeyValueYARPCClient(cc, params.AnyResolver, options...),\n\t\t}\n\t}\n}", "id": 12215, "concepts": ["interface", "function composition", "function composition with anonymous function", "function composition with anonymous function and return value", "function composition with anonymous function and return value with error handling", "function composition with anonymous function and return value with error handling and interface", "function composition with anonymous function and return value with error handling and interface and function composition with anonymous function and return value with error handling and interface and function composition with anonymous function and return value with error handling and interface and function composition with anonymous function and return value with error handling and interface and function composition with anonymous function and return value with error handling and interface and function composition with anonymous function and return value with error handling and interface and function composition with anonymous function and return value with error handling and interface and function composition with anonymous function and return value with error handling and interface and function composition with anonymous function and return value with error handling and interface and function composition with anonymous function and return value with error handling and interface and function composition with anonymous function and return value with error handling and interface and function composition with anonymous function and return value with error handling and interface and function composition with anonymous function and return value with error handling and interface and function composition with anonymous function and return value with error handling and interface and function composition with anonymous function and return value with error handling and interface"], "_raw_llm_output": "interface, function composition, function composition with anonymous function, function composition with anonymous function and return value, function composition with anonymous function and return value with error handling, function composition with anonymous function and return value with error handling and interface, function composition with anonymous function and return value with error handling and interface and function composition with anonymous function and return value with error handling and interface and function composition with anonymous function and return value with error handling and interface and function composition with anonymous function and return value with error handling and interface and function composition with anonymous function and return value with error handling and interface and function composition with anonymous function and return value with error handling and interface and function composition with anonymous function and return value with error handling and interface and function composition with anonymous function and return value with error handling and interface and function composition with anonymous function and return value with error handling and interface and function composition with anonymous function and return value with error handling and interface and function composition with anonymous function and return value with error handling and interface and function composition with anonymous function and return value with error handling and interface and function composition with anonymous function and return value with error handling and interface and function composition with anonymous function and return value with error handling and interface and function composition with anonymous function and return value with error handling and interface"}
{"seed": "// DefaultCompareFn is a default function to use for comparisons.\n// Handles identity, nils, strings, numerics, and things implementing the iseq.Comparer interface.\nfunc DefaultCompareFn(k1 interface{}, k2 interface{}) int {\n\tif k1 == k2 {\n\t\treturn 0\n\t}\n\tif k1 != nil {\n\t\tif k2 == nil {\n\t\t\treturn 1\n\t\t}\n\t\tif c, ok := k1.(iseq.Comparer); ok {\n\t\t\treturn c.Compare(k2)\n\t\t}\n\t\tif c, ok := k2.(iseq.Comparer); ok {\n\t\t\treturn -c.Compare(k1)\n\t\t}\n\t\tif s, ok := k1.(string); ok {\n\t\t\treturn CompareString(s, k2)\n\t\t}\n\t\tif IsComparableNumeric(k1) {\n\t\t\treturn CompareComparableNumeric(k1, k2)\n\t\t}\n\t\tpanic(\"Can't compare\")\n\t}\n\treturn -1\n}", "id": 12216, "concepts": ["interface", "type assertion", "comparison", "nil handling", "string comparison", "numeric comparison", "basic function definition"], "_raw_llm_output": "interface, type assertion, comparison, nil handling, string comparison, numeric comparison, basic function definition"}
{"seed": "// Use this data source to access information about an existing Management Group Template Deployment.\nfunc LookupGroupTemplateDeployment(ctx *pulumi.Context, args *LookupGroupTemplateDeploymentArgs, opts ...pulumi.InvokeOption) (*LookupGroupTemplateDeploymentResult, error) {\n\topts = internal.PkgInvokeDefaultOpts(opts)\n\tvar rv LookupGroupTemplateDeploymentResult\n\terr := ctx.Invoke(\"azure:management/getGroupTemplateDeployment:getGroupTemplateDeployment\", args, &rv, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &rv, nil\n}", "id": 12230, "concepts": ["pulumi.Context", "pulumi.InvokeOption", "pulumi.InvokeArgs", "pulumi.InvokeResult", "pulumi.Output", "pulumi.Input", "pulumi.Resource", "pulumi.ResourceState", "pulumi.Provider", "pulumi.ResourceOptions", "pulumi.InvokeArgs", "pulumi.InvokeResult", "pulumi.Output", "pulumi.Input", "pulumi.Resource", "pulumi.ResourceState", "pulumi.Provider", "pulumi.ResourceOptions", "pulumi.InvokeArgs", "pulumi.InvokeResult", "pulumi.Output", "pulumi.Input", "pulumi.Resource", "pulumi.ResourceState", "pulumi.Provider", "pulumi.ResourceOptions", "pulumi.InvokeArgs", "pulumi.InvokeResult", "pulumi.Output", "pulumi.Input", "pulumi.Resource", "pulumi.ResourceState", "pulumi.Provider", "pulumi.ResourceOptions", "pulumi.InvokeArgs", "pulumi.InvokeResult", "pulumi.Output", "pulumi.Input", "pulumi.Resource", "pulumi.ResourceState", "pulumi.Provider", "pulumi.ResourceOptions", "pulumi.InvokeArgs", "pulumi.InvokeResult", "pulumi.Output", "pulumi.Input", "pulumi.Resource", "pulumi.ResourceState", "pulumi.Provider", "pulumi.ResourceOptions", "pulumi.InvokeArgs", "pulumi.InvokeResult", "pulumi.Output", "pulumi.Input", "pulumi.Resource", "pulumi.ResourceState", "pulumi.Provider"], "_raw_llm_output": "pulumi.Context, pulumi.InvokeOption, pulumi.InvokeArgs, pulumi.InvokeResult, pulumi.Output, pulumi.Input, pulumi.Resource, pulumi.ResourceState, pulumi.Provider, pulumi.ResourceOptions, pulumi.InvokeArgs, pulumi.InvokeResult, pulumi.Output, pulumi.Input, pulumi.Resource, pulumi.ResourceState, pulumi.Provider, pulumi.ResourceOptions, pulumi.InvokeArgs, pulumi.InvokeResult, pulumi.Output, pulumi.Input, pulumi.Resource, pulumi.ResourceState, pulumi.Provider, pulumi.ResourceOptions, pulumi.InvokeArgs, pulumi.InvokeResult, pulumi.Output, pulumi.Input, pulumi.Resource, pulumi.ResourceState, pulumi.Provider, pulumi.ResourceOptions, pulumi.InvokeArgs, pulumi.InvokeResult, pulumi.Output, pulumi.Input, pulumi.Resource, pulumi.ResourceState, pulumi.Provider, pulumi.ResourceOptions, pulumi.InvokeArgs, pulumi.InvokeResult, pulumi.Output, pulumi.Input, pulumi.Resource, pulumi.ResourceState, pulumi.Provider, pulumi.ResourceOptions, pulumi.InvokeArgs, pulumi.InvokeResult, pulumi.Output, pulumi.Input, pulumi.Resource, pulumi.ResourceState, pulumi.Provider"}
{"seed": "// FindBranchProjectRef gets a project ref given the project identifier.\n// This returns only branch-level settings; to include repo settings, use FindMergedProjectRef.\nfunc FindBranchProjectRef(identifier string) (*ProjectRef, error) {\n\treturn findOneProjectRefQ(byId(identifier))\n}", "id": 12236, "concepts": ["querying", "query parameters", "query results", "query errors", "query results", "query results"], "_raw_llm_output": "querying, query parameters, query results, query errors, query results, query results"}
{"seed": "// getStack returns 10 closest stacktrace, included file paths and line numbers\n// it will ignore all system path, path which is vendor is striped to /vendor/\n// skip: number of stack ignored\nfunc getStack(skip int) string {\n\tstack := make([]uintptr, 10)\n\tvar sb strings.Builder\n\t// skip one system stack, the this current stack line\n\tlength := runtime.Callers(2+skip, stack[:])\n\tfor i := 0; i < length; i++ {\n\t\tpc := stack[i]\n\t\t// pc - 1 because the program counters we use are usually return addresses,\n\t\t// and we want to show the line that corresponds to the function call\n\t\tf := runtime.FuncForPC(pc)\n\t\tfile, line := f.FileLine(pc - 1)\n\t\t// dont report system path\n\t\tif isSystemPath(file) {\n\t\t\tcontinue\n\t\t}\n\n\t\tfile = trimToPrefix(file, \"/vendor/\")\n\n\t\t// trim out common provider since most of go projects are hosted\n\t\t// in single host, there is no need to include them in the call stack\n\t\t// remove them help keeping the call stack smaller, navigatiing easier\n\t\tif !strings.HasPrefix(file, \"/vendor\") {\n\t\t\tfile = trimOutPrefix(file, \"/git.subiz.net/\")\n\t\t\tfile = trimOutPrefix(file, \"/github.com/\")\n\t\t\tfile = trimOutPrefix(file, \"/gitlab.com/\")\n\t\t\tfile = trimOutPrefix(file, \"/bitbucket.org/\")\n\t\t\tfile = trimOutPrefix(file, \"/gopkg.in/\")\n\t\t}\n\n\t\tsb.WriteString(file)\n\t\tsb.WriteString(\":\")\n\t\tsb.WriteString(strconv.Itoa(line))\n\t\tsb.WriteString(\"\\n\")\n\t}\n\treturn sb.String()\n}", "id": 12240, "concepts": ["runtime.Callers", "runtime.FuncForPC", "runtime.Func.FileLine", "runtime.Func.Name", "strings.HasPrefix", "strings.TrimPrefix", "strings.TrimSuffix", "strings.Split", "strings.Join", "strings.Fields", "strings.TrimSpace", "strings.Replace", "strings.HasSuffix", "strconv.Itoa", "strings.Index", "strings.LastIndex", "strings.Contains", "strings.Count", "strings.Repeat", "strings.ToLower", "strings.ToUpper", "strings.Trim", "strings.SplitAfter", "strings.SplitAfterN", "strings.SplitN", "strings.TrimLeft", "strings.TrimRight", "strings.TrimPrefix", "strings.TrimSuffix", "strings.FieldsFunc", "strings.Map", "strings.IndexAny", "strings.LastIndexAny", "strings.IndexRune", "strings.LastIndexRune", "strings.Compare", "strings.EqualFold", "strings.ContainsAny", "strings.ContainsRune", "strings.Count", "strings.HasPrefix", "strings.HasSuffix", "strings.IndexByte", "strings.LastIndexByte", "strings.IndexFunc", "strings.LastIndexFunc", "strings.IndexRune", "strings.LastIndexRune", "strings.Map", "strings.Repeat", "strings.Replace", "strings.ToLower", "strings.ToUpper", "strings."], "_raw_llm_output": "runtime.Callers, runtime.FuncForPC, runtime.Func.FileLine, runtime.Func.Name, strings.HasPrefix, strings.TrimPrefix, strings.TrimSuffix, strings.Split, strings.Join, strings.Fields, strings.TrimSpace, strings.Replace, strings.HasSuffix, strconv.Itoa, strings.Index, strings.LastIndex, strings.Contains, strings.Count, strings.Repeat, strings.ToLower, strings.ToUpper, strings.Trim, strings.SplitAfter, strings.SplitAfterN, strings.SplitN, strings.TrimLeft, strings.TrimRight, strings.TrimPrefix, strings.TrimSuffix, strings.FieldsFunc, strings.Map, strings.IndexAny, strings.LastIndexAny, strings.IndexRune, strings.LastIndexRune, strings.Compare, strings.EqualFold, strings.ContainsAny, strings.ContainsRune, strings.Count, strings.HasPrefix, strings.HasSuffix, strings.IndexByte, strings.LastIndexByte, strings.IndexFunc, strings.LastIndexFunc, strings.IndexRune, strings.LastIndexRune, strings.Map, strings.Repeat, strings.Replace, strings.ToLower, strings.ToUpper, strings."}
{"seed": "// URLHandler adds the requested URL as a field to the context's logger\n// using fieldKey as field key.\nfunc URLHandler(fieldKey string) func(next httpserver.Handler) httpserver.Handler {\n\treturn func(next httpserver.Handler) httpserver.Handler {\n\t\treturn httpserver.HandlerFunc(func(w http.ResponseWriter, r *http.Request) (int, error) {\n\t\t\tlog := zerolog.Ctx(r.Context())\n\t\t\tlog.UpdateContext(func(c zerolog.Context) zerolog.Context {\n\t\t\t\treturn c.Str(fieldKey, r.URL.String())\n\t\t\t})\n\t\t\treturn next.ServeHTTP(w, r)\n\t\t})\n\t}\n}", "id": 12256, "concepts": ["http server", "http.ResponseWriter", "http.Request", "zerolog package usage", "context usage"], "_raw_llm_output": "http server, http.ResponseWriter, http.Request, zerolog package usage, context usage"}
{"seed": "// ResultFromError returns ResultSuccess if err is nil. Otherwise ResultFailure\n// is returned with the error message as the failure message.\nfunc ResultFromError(err error) Result {\n\tif err == nil {\n\t\treturn ResultSuccess\n\t}\n\treturn ResultFailure(err.Error())\n}", "id": 12263, "concepts": ["error handling (idiomatic if err != nil)", "error message extraction"], "_raw_llm_output": "error handling (idiomatic if err != nil), error message extraction"}
{"seed": "// wrapFn wraps an inner function into one suitable as a builtin function. It\n// generates argument checking and conversion code according to the signature\n// of the inner function. The inner function must accept evalCtx* as the first\n// argument and return an exitus.\nfunc wrapFn(inner interface{}) func(*EvalCtx, []Value) {\n\ttype_ := reflect.TypeOf(inner)\n\tif type_.In(0) != evalCtxType {\n\t\tpanic(\"bad func\")\n\t}\n\n\trequiredArgs := type_.NumIn() - 1\n\tisVariadic := type_.IsVariadic()\n\tvar variadicType reflect.Type\n\tif isVariadic {\n\t\trequiredArgs--\n\t\tvariadicType = type_.In(type_.NumIn() - 1).Elem()\n\t\tif !supportedIn(variadicType) {\n\t\t\tpanic(\"bad func argument\")\n\t\t}\n\t}\n\n\tfor i := 0; i < requiredArgs; i++ {\n\t\tif !supportedIn(type_.In(i + 1)) {\n\t\t\tpanic(\"bad func argument\")\n\t\t}\n\t}\n\n\treturn func(ec *EvalCtx, args []Value) {\n\t\tif len(args) < requiredArgs || (!isVariadic && len(args) > requiredArgs) {\n\t\t\tthrow(ErrArgs)\n\t\t}\n\t\tcallArgs := make([]reflect.Value, len(args)+1)\n\t\tcallArgs[0] = reflect.ValueOf(ec)\n\n\t\tok := convertArgs(args[:requiredArgs], callArgs[1:],\n\t\t\tfunc(i int) reflect.Type { return type_.In(i + 1) })\n\t\tif !ok {\n\t\t\tthrow(ErrArgs)\n\t\t}\n\t\tif isVariadic {\n\t\t\tok := convertArgs(args[requiredArgs:], callArgs[1+requiredArgs:],\n\t\t\t\tfunc(i int) reflect.Type { return variadicType })\n\t\t\tif !ok {\n\t\t\t\tthrow(ErrArgs)\n\t\t\t}\n\t\t}\n\t\treflect.ValueOf(inner).Call(callArgs)\n\t}\n}", "id": 12265, "concepts": ["reflection", "function wrapping", "function argument conversion"], "_raw_llm_output": "reflection, function wrapping, function argument conversion"}
{"seed": "// Legend represents the HTML element 'legend'.\n// For more information visit https://www.w3schools.com/tags/tag_legend.asp.\nfunc Legend(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"legend\", Attributes: attrs, Children: children}\n}", "id": 12266, "concepts": ["HTML generation", "HTML tree building", "HTML element definition", "HTML attribute definition"], "_raw_llm_output": "HTML generation, HTML tree building, HTML element definition, HTML attribute definition"}
{"seed": "// Ol_ is a convenience wrapper for Ol without the attrs argument.\nfunc Ol_(children ...HTML) HTML {\n  return Ol(nil, children...)\n}", "id": 12271, "concepts": ["HTML struct", "HTML struct field", "HTML struct field initialization", "HTML struct field usage", "HTML struct field type", "HTML struct field type conversion"], "_raw_llm_output": "HTML struct, HTML struct field, HTML struct field initialization, HTML struct field usage, HTML struct field type, HTML struct field type conversion"}
{"seed": "// GetSecDepBalance returns the amount of security deposit charge and the\n// amount that was assessed for the supplied Rental Agreement and RID\n//\n// PARAMS\n//\tbid  - business id\n//  rid  - the rentable for which the deposit was assessed\n//  raid - the Rental Agreement associated with the assessment\n//  d1   - start time; do not consider assessments prior to this date\n//  d2   - stop time; do not considder assessments on or after this date\n//\n// RETURNS\n// float64 - Amount of change in Security Deposit Balance between d1 and d2\n//   error - any error encountered\n//-----------------------------------------------------------------------------\nfunc GetSecDepBalance(ctx context.Context, bid, raid, rid int64, d1, d2 *time.Time) (float64, error) {\n\t//-------------------------------\n\t// first, check the cache...\n\t//-------------------------------\n\tb := getSecDepCachedBalanceEntry(bid, rid, raid, d1, d2)\n\tif b != nil {\n\t\treturn b.begin, nil\n\t}\n\n\tamt := float64(0)\n\tm, err := SecDepRules(bid)\n\tif err != nil {\n\t\treturn amt, fmt.Errorf(\"Error in SecDepRules: %s\", err.Error())\n\t}\n\tif len(m) == 0 {\n\t\treturn amt, fmt.Errorf(\"There are no account rules that credit a %s account\", LiabilitySecDep)\n\t}\n\t//-----------------------------------------------------------\n\t// What Assessments use the account rules found above?\n\t//-----------------------------------------------------------\n\tsa := []string{}\n\tfor i := 0; i < len(m); i++ {\n\t\tsa = append(sa, fmt.Sprintf(\"ARID=%d\", m[i]))\n\t}\n\tq := fmt.Sprintf(\"SELECT SUM(Amount) AS Amt FROM Assessments WHERE BID=%d AND RID=%d and RAID=%d AND %q<=Start AND Stop<%q AND (%s)\",\n\t\tbid, rid, raid, d1.Format(RRDATEFMTSQL), d2.Format(RRDATEFMTSQL), strings.Join(sa, \" OR \"))\n\t// Console(\"=======>>>>>>  q:  %s\\n\", q)\n\trows, err := RRdb.Dbrr.Query(q)\n\tfor rows.Next() {\n\t\tvar x NullFloat64\n\t\terr := rows.Scan(&x)\n\t\tif err != nil {\n\t\t\treturn amt, err\n\t\t}\n\t\tamt += x.Float64\n\t}\n\terr = rows.Err()\n\tif err != nil {\n\t\treturn amt, err\n\t}\n\tstoreSecDepBalanceInfoToCache(bid, rid, raid, d1, d2, amt /* this is the val we'll use */, amt /*placeholder*/) // cache this value, maybe we'll hit it again\n\treturn amt, nil\n\n}", "id": 12276, "concepts": ["string formatting", "fmt package usage", "SQL query", "SQL query execution", "SQL query result handling", "SQL query parameterization", "SQL query result scanning", "SQL query error handling", "SQL query result error handling", "SQL query result error handling", "SQL query result error handling", "SQL query result error handling", "SQL query result error handling", "SQL query result error handling", "SQL query result error handling", "SQL query result error handling", "SQL query result error handling", "SQL query result error handling", "SQL query result error handling", "SQL query result error handling", "SQL query result error handling", "SQL query result error handling", "SQL query result error handling", "SQL query result error handling", "SQL query result error handling", "SQL query result error handling", "SQL query result error handling", "SQL query result error handling", "SQL query result error handling", "SQL query result error handling", "SQL query result error handling", "SQL query result error handling", "SQL query result error handling", "SQL query result error handling", "SQL query result error handling", "SQL query result error handling", "SQL query result error handling", "SQL query result error handling", "SQL query result error handling", "SQL query result error handling", "SQL query result error handling", "SQL query result error handling", "SQL query result error handling", "SQL query result error handling", "SQL query result error handling"], "_raw_llm_output": "string formatting, fmt package usage, SQL query, SQL query execution, SQL query result handling, SQL query parameterization, SQL query result scanning, SQL query error handling, SQL query result error handling, SQL query result error handling, SQL query result error handling, SQL query result error handling, SQL query result error handling, SQL query result error handling, SQL query result error handling, SQL query result error handling, SQL query result error handling, SQL query result error handling, SQL query result error handling, SQL query result error handling, SQL query result error handling, SQL query result error handling, SQL query result error handling, SQL query result error handling, SQL query result error handling, SQL query result error handling, SQL query result error handling, SQL query result error handling, SQL query result error handling, SQL query result error handling, SQL query result error handling, SQL query result error handling, SQL query result error handling, SQL query result error handling, SQL query result error handling, SQL query result error handling, SQL query result error handling, SQL query result error handling, SQL query result error handling, SQL query result error handling, SQL query result error handling, SQL query result error handling, SQL query result error handling, SQL query result error handling, SQL query result error handling"}
{"seed": "// GzipAssetDir returns the file names below a certain\n// directory embedded in the file by bindata.\n// For example if you run bindata on data/... and data contains the\n// following hierarchy:\n//     data/\n//       foo.txt\n//       img/\n//         a.png\n//         b.png\n// then GzipAssetDir(\"data\") would return []string{\"foo.txt\", \"img\"}\n// GzipAssetDir(\"data/img\") would return []string{\"a.png\", \"b.png\"}\n// GzipAssetDir(\"foo.txt\") and GzipAssetDir(\"notexist\") would return an error\n// GzipAssetDir(\"\") will return []string{\"data\"}.\nfunc GzipAssetDir(name string) ([]string, error) {\n\tnode := _gzipbintree\n\tif len(name) != 0 {\n\t\tcannonicalName := strings.Replace(name, \"\\\\\", \"/\", -1)\n\t\tpathList := strings.Split(cannonicalName, \"/\")\n\t\tfor _, p := range pathList {\n\t\t\tnode = node.Children[p]\n\t\t\tif node == nil {\n\t\t\t\treturn nil, &os.PathError{\n\t\t\t\t\tOp:   \"open\",\n\t\t\t\t\tPath: name,\n\t\t\t\t\tErr:  os.ErrNotExist,\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif node.Func != nil {\n\t\treturn nil, &os.PathError{\n\t\t\tOp:   \"open\",\n\t\t\tPath: name,\n\t\t\tErr:  os.ErrNotExist,\n\t\t}\n\t}\n\trv := make([]string, 0, len(node.Children))\n\tfor childName := range node.Children {\n\t\trv = append(rv, childName)\n\t}\n\treturn rv, nil\n}", "id": 12294, "concepts": ["bindata usage", "string manipulation", "map iteration", "error handling", "standard library usage"], "_raw_llm_output": "bindata usage, string manipulation, map iteration, error handling, standard library usage"}
{"seed": "// RegisterFleaHandler registers the http handlers for service Flea to \"mux\".\n// The handlers forward requests to the grpc endpoint over \"conn\".\nfunc RegisterFleaHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {\n\treturn RegisterFleaHandlerClient(ctx, mux, NewFleaClient(conn))\n}", "id": 12295, "concepts": ["grpc", "runtime.ServeMux", "grpc.ClientConn", "grpc.NewClientConn", "context.Context", "client-side usage"], "_raw_llm_output": "grpc, runtime.ServeMux, grpc.ClientConn, grpc.NewClientConn, context.Context, client-side usage"}
{"seed": "// PossiblePolicyEnabledStateValues returns an array of possible values for the PolicyEnabledState const type.\nfunc PossiblePolicyEnabledStateValues() []PolicyEnabledState {\n\treturn []PolicyEnabledState{PolicyEnabledStateDisabled, PolicyEnabledStateEnabled}\n}", "id": 12299, "concepts": ["type definition", "const definition", "array definition", "type conversion"], "_raw_llm_output": "type definition, const definition, array definition, type conversion"}
{"seed": "// ParseMAC parses s as 12 hex digits, IEEE 802 MAC-48 or EUI-48,\n// using one of the folowing formats:\n//   0123456789ab\n//   0123.4567.89ab\n//   01-23.45.67.89ab\n//   01:23:45:67:89:ab\n// the EUI-64 format is not suported.\nfunc ParseMAC(s string) (m MAC, err error) {\n\tif len(s) == 12 {\n\t\ts = fmt.Sprintf(\"%s.%s.%s\", s[0:4], s[4:8], s[8:12])\n\t}\n\thw, err := net.ParseMAC(s)\n\tif len(hw) == 8 {\n\t\treturn nil, &net.AddrError{Err: \"EUI-64 not suported\", Addr: s}\n\t}\n\treturn MAC(hw), err\n}", "id": 12304, "concepts": ["net.ParseMAC", "string manipulation", "error handling (net.AddrError)", "error wrapping"], "_raw_llm_output": "net.ParseMAC, string manipulation, error handling (net.AddrError), error wrapping"}
{"seed": "// NewAPIResponseWithError returns a new APIResponse object with the provided error message.\nfunc NewAPIResponseWithError(errorMessage string) *APIResponse {\n\n\tresponse := &APIResponse{Message: errorMessage}\n\treturn response\n}", "id": 12338, "concepts": ["struct definition", "pointer usage", "error handling"], "_raw_llm_output": "struct definition, pointer usage, error handling"}
{"seed": "// Intersect returns every Value from a that is also in b.\nfunc Intersect(a, b Set) Set {\n\treturn a.Where(func(v Value) bool { return b.Has(v) })\n}", "id": 12341, "concepts": ["set intersection", "set definition", "set usage", "set iteration"], "_raw_llm_output": "set intersection, set definition, set usage, set iteration"}
{"seed": "// NewDockerVolumePlugin creates a DockerVolumePlugin which can be used to communicate with\n// a Docker Volume Plugin. The communication happens over http on Windows.\nfunc NewDockerVolumePlugin(options *Options) (*DockerVolumePlugin, error) {\n\thostUrl := GetHostURL(hostName, port)\n\tvar err error\n\n\tdvp := &DockerVolumePlugin{\n\t\tstripK8sOpts:                 options.StripK8sFromOptions,\n\t\tclient:                       connectivity.NewHTTPClientWithTimeout(hostUrl, dvpSocketTimeout),\n\t\tListOfStorageResourceOptions: options.ListOfStorageResourceOptions,\n\t\tFactorForConversion:          options.FactorForConversion,\n\t}\n\n\tif options.SupportsCapabilities {\n\t\t// test connectivity\n\t\t_, err = dvp.Capabilities()\n\t\tif err != nil {\n\t\t\treturn dvp, err\n\t\t}\n\t}\n\n\treturn dvp, nil\n\n}", "id": 12356, "concepts": ["http client", "http request", "http response", "error handling", "error handling (idiomatic if err != nil)", "error handling (errors.Is)", "error handling (errors.As)", "error handling (errors.New)", "error handling (errors.Wrap)", "error handling (errors.Wrapf)", "error handling (errors.WithMessage)", "error handling (errors.WithMessagef)", "error handling (errors.WithStack)", "error handling (errors.Errorf)", "error handling (errors.Wrapf)", "error handling (errors.Wrap)", "error handling (errors.Wrapf)", "error handling (errors.Wrap)", "error handling (errors.Wrapf)", "error handling (errors.Wrap)", "error handling (errors.Wrapf)", "error handling (errors.Wrap)", "error handling (errors.Wrapf)", "error handling (errors.Wrap)", "error handling (errors.Wrapf)", "error handling (errors.Wrap)", "error handling (errors.Wrapf)", "error handling (errors.Wrap)", "error handling (errors.Wrapf)", "error handling (errors.Wrap)", "error handling (errors.Wrapf)", "error handling (errors.Wrap)", "error handling (errors.Wrapf)", "error handling (errors.Wrap)", "error handling (errors.Wrapf)", "error handling (errors.Wrap"], "_raw_llm_output": "http client, http request, http response, error handling, error handling (idiomatic if err != nil), error handling (errors.Is), error handling (errors.As), error handling (errors.New), error handling (errors.Wrap), error handling (errors.Wrapf), error handling (errors.WithMessage), error handling (errors.WithMessagef), error handling (errors.WithStack), error handling (errors.Errorf), error handling (errors.Wrapf), error handling (errors.Wrap), error handling (errors.Wrapf), error handling (errors.Wrap), error handling (errors.Wrapf), error handling (errors.Wrap), error handling (errors.Wrapf), error handling (errors.Wrap), error handling (errors.Wrapf), error handling (errors.Wrap), error handling (errors.Wrapf), error handling (errors.Wrap), error handling (errors.Wrapf), error handling (errors.Wrap), error handling (errors.Wrapf), error handling (errors.Wrap), error handling (errors.Wrapf), error handling (errors.Wrap), error handling (errors.Wrapf), error handling (errors.Wrap), error handling (errors.Wrapf), error handling (errors.Wrap"}
{"seed": "// TransfertobankaccountGT applies the GT predicate on the \"transfertobankaccount\" field.\nfunc TransfertobankaccountGT(v float64) predicate.Bulk {\n\treturn predicate.Bulk(func(s *sql.Selector) {\n\t\ts.Where(sql.GT(s.C(FieldTransfertobankaccount), v))\n\t})\n}", "id": 12362, "concepts": ["sql.Selector", "sql.GT", "sql.C", "predicate.Bulk", "basic function definition"], "_raw_llm_output": "sql.Selector, sql.GT, sql.C, predicate.Bulk, basic function definition"}
{"seed": "// ParseDeleteSSLCertificateResponse parses an HTTP response from a DeleteSSLCertificateWithResponse call\nfunc ParseDeleteSSLCertificateResponse(rsp *http.Response) (*DeleteSSLCertificateResponse, error) {\n\tbodyBytes, err := ioutil.ReadAll(rsp.Body)\n\tdefer rsp.Body.Close()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse := &DeleteSSLCertificateResponse{\n\t\tBody:         bodyBytes,\n\t\tHTTPResponse: rsp,\n\t}\n\n\tswitch {\n\tcase strings.Contains(rsp.Header.Get(\"Content-Type\"), \"json\") && rsp.StatusCode == 200:\n\t\tvar dest ScalewayDomainV2alpha2DeleteSSLCertificateResponse\n\t\tif err := json.Unmarshal(bodyBytes, &dest); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresponse.JSON200 = &dest\n\n\t}\n\n\treturn response, nil\n}", "id": 12364, "concepts": ["HTTP response parsing", "JSON parsing", "HTTP status code handling", "error handling"], "_raw_llm_output": "HTTP response parsing, JSON parsing, HTTP status code handling, error handling"}
{"seed": "// CreatedAtIn applies the In predicate on the \"created_at\" field.\nfunc CreatedAtIn(vs ...time.Time) predicate.User {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.User(func(s *sql.Selector) {\n\t\t// if not arguments were provided, append the FALSE constants,\n\t\t// since we can't apply \"IN ()\". This will make this predicate falsy.\n\t\tif len(vs) == 0 {\n\t\t\ts.Where(sql.False())\n\t\t\treturn\n\t\t}\n\t\ts.Where(sql.In(s.C(FieldCreatedAt), v...))\n\t})\n}", "id": 12371, "concepts": ["sql.Selector", "sql.In", "sql.False", "predicate.User", "basic function definition"], "_raw_llm_output": "sql.Selector, sql.In, sql.False, predicate.User, basic function definition"}
{"seed": "// P_ is a convenience wrapper for P without the attrs argument.\nfunc P_(children ...HTML) HTML {\n  return P(nil, children...)\n}", "id": 12385, "concepts": ["function definition", "function argument handling", "function return value handling", "function call"], "_raw_llm_output": "function definition, function argument handling, function return value handling, function call"}
{"seed": "// VerifyJWSMessage verifies a signed message and returns its payload\n// The message is a JWS encoded string. The public key of the sender is\n// needed to verify the message.\n//  Intended for testing, as the application uses VerifySenderJWSSignature instead.\nfunc VerifyJWSMessage(message string, publicKey *ecdsa.PublicKey) (payload string, err error) {\n\tif publicKey == nil {\n\t\terr := errors.New(\"VerifyJWSMessage: public key is nil\")\n\t\treturn \"\", err\n\t}\n\tjwsSignature, err := jose.ParseSigned(message)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tpayloadB, err := jwsSignature.Verify(publicKey)\n\treturn string(payloadB), err\n}", "id": 12390, "concepts": ["JWS signature verification", "JWS decoding", "public key verification"], "_raw_llm_output": "JWS signature verification, JWS decoding, public key verification"}
{"seed": "// fsToTar writes the filesystem represented by fsys to w as a tar archive.\n// This function unsets user and group information in the tar archive so that readers\n// of archives produced by this function do not need to account for differences in\n// permissions between source and destination filesystems.\nfunc fsToTar(w io.Writer, fsys fs.FS, buf []byte) error {\n\tif buf == nil || len(buf) == 0 {\n\t\t// We are not sensitive to the size of this buffer, we just need it to be shared.\n\t\t// For simplicity, do the same as io.Copy() would.\n\t\tbuf = make([]byte, 32*1024)\n\t}\n\ttw := tar.NewWriter(w)\n\tif err := fs.WalkDir(fsys, \".\", func(path string, d fs.DirEntry, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif d.Type()&os.ModeSymlink != 0 {\n\t\t\treturn nil\n\t\t}\n\t\tinfo, err := d.Info()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"get file info for %q: %v\", path, err)\n\t\t}\n\n\t\th, err := tar.FileInfoHeader(info, \"\")\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"build tar file info header for %q: %v\", path, err)\n\t\t}\n\t\th.Uid = 0\n\t\th.Gid = 0\n\t\th.Uname = \"\"\n\t\th.Gname = \"\"\n\t\th.AccessTime = time.Time{}\n\t\th.ChangeTime = time.Time{}\n\t\th.ModTime = time.Time{}\n\t\th.Name = path\n\n\t\tif err := tw.WriteHeader(h); err != nil {\n\t\t\treturn fmt.Errorf(\"write tar header for %q: %v\", path, err)\n\t\t}\n\t\tif d.IsDir() {\n\t\t\treturn nil\n\t\t}\n\t\tf, err := fsys.Open(path)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"open file %q: %v\", path, err)\n\t\t}\n\t\tdefer f.Close()\n\t\tif _, err := io.CopyBuffer(tw, f, buf); err != nil {\n\t\t\treturn fmt.Errorf(\"write tar data for %q: %v\", path, err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\treturn fmt.Errorf(\"write tar: %w\", err)\n\t}\n\tif err := tw.Close(); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "id": 12400, "concepts": ["fs.WalkDir", "fs.Open", "io.CopyBuffer", "tar.FileInfoHeader", "tar.NewWriter", "io.Writer", "io.Closer", "fs.FS", "os.ModeSymlink", "os.ModeDir", "os.ModeType", "os.ModeDevice", "os.ModeNamedPipe", "os.ModeSocket", "os.ModeIrregular", "os.ModeTemporary", "os.ModeSymlink", "os.ModeDevice", "os.ModeNamedPipe", "os.ModeSocket", "os.ModeIrregular", "os.ModeTemporary", "os.ModeSetuid", "os.ModeSetgid", "os.ModeSticky", "os.ModeDir", "os.ModeSymlink", "os.ModeDevice", "os.ModeNamedPipe", "os.ModeSocket", "os.ModeIrregular", "os.ModeTemporary", "os.ModeSetuid", "os.ModeSetgid", "os.ModeSticky", "os.ModeDir", "os.ModeSymlink", "os.ModeDevice", "os.ModeNamedPipe", "os.ModeSocket", "os.ModeIrregular", "os.ModeTemporary", "os.ModeSetuid", "os.ModeSetgid", "os.ModeSticky", "os.ModeDir", "os.ModeSymlink", "os.ModeDevice", ""], "_raw_llm_output": "fs.WalkDir, fs.Open, io.CopyBuffer, tar.FileInfoHeader, tar.NewWriter, io.Writer, io.Closer, fs.FS, os.ModeSymlink, os.ModeDir, os.ModeType, os.ModeDevice, os.ModeNamedPipe, os.ModeSocket, os.ModeIrregular, os.ModeTemporary, os.ModeSymlink, os.ModeDevice, os.ModeNamedPipe, os.ModeSocket, os.ModeIrregular, os.ModeTemporary, os.ModeSetuid, os.ModeSetgid, os.ModeSticky, os.ModeDir, os.ModeSymlink, os.ModeDevice, os.ModeNamedPipe, os.ModeSocket, os.ModeIrregular, os.ModeTemporary, os.ModeSetuid, os.ModeSetgid, os.ModeSticky, os.ModeDir, os.ModeSymlink, os.ModeDevice, os.ModeNamedPipe, os.ModeSocket, os.ModeIrregular, os.ModeTemporary, os.ModeSetuid, os.ModeSetgid, os.ModeSticky, os.ModeDir, os.ModeSymlink, os.ModeDevice,"}
{"seed": "// NewCommand creates a *cobra.Command object with default parameters\nfunc NewCommand() *cobra.Command {\n\ts := options.NewOptions()\n\n\tcmd := &cobra.Command{\n\t\tUse:  \"loadbalancer-controller\",\n\t\tLong: `k8s loadbalancer resource controller`,\n\t\tRun: func(cmd *cobra.Command, args []string) {\n\t\t\tc, err := s.Config()\n\t\t\tif err != nil {\n\t\t\t\tklog.Exitln(err)\n\t\t\t}\n\t\t\tif err := Run(c, wait.NeverStop); err != nil {\n\t\t\t\tklog.Exitln(err)\n\t\t\t}\n\t\t},\n\t}\n\n\tfs := cmd.Flags()\n\tfs.AddFlagSet(s.Flags())\n\n\t_ = fs.Set(\"logtostderr\", \"true\")\n\n\treturn cmd\n}", "id": 12401, "concepts": ["cobra package usage", "command line flags", "standard library usage"], "_raw_llm_output": "cobra package usage, command line flags, standard library usage"}
{"seed": "// PhenotypepropExistsGP checks if the Phenotypeprop row exists. Panics on error.\nfunc PhenotypepropExistsGP(phenotypepropID int) bool {\n\te, err := PhenotypepropExists(boil.GetDB(), phenotypepropID)\n\tif err != nil {\n\t\tpanic(boil.WrapErr(err))\n\t}\n\n\treturn e\n}", "id": 12412, "concepts": ["database query", "panic", "boil package usage"], "_raw_llm_output": "database query, panic, boil package usage"}
{"seed": "// HeroPlayed applies equality check predicate on the \"hero_played\" field. It's identical to HeroPlayedEQ.\nfunc HeroPlayed(v uint) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldHeroPlayed), v))\n\t})\n}", "id": 12413, "concepts": ["predicate.User", "sql.Selector", "sql.EQ"], "_raw_llm_output": "predicate.User, sql.Selector, sql.EQ"}
{"seed": "// findItemInSequence returns the index of the child in sequenceNode which \"matches\" findVal. See sequenceItemMatch for\n// what is considered a \"match\". Returns -1 if there is no match found.\nfunc findItemInSequence(sequenceKey string, findVal *goyaml.Node, sequenceNode *goyaml.Node) int {\n\tchildren := sequenceNode.Content\n\tfor i, val := range children {\n\t\tif sequenceItemMatch(sequenceKey, val, findVal) {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}", "id": 12414, "concepts": ["slice iteration (range loop)", "map iteration (range loop)", "map key iteration (range loop)", "map value iteration (range loop)", "slice manipulation (append", "copy", "delete)", "map manipulation (delete)", "basic function definition", "basic function return"], "_raw_llm_output": "slice iteration (range loop), map iteration (range loop), map key iteration (range loop), map value iteration (range loop),\nslice manipulation (append, copy, delete), map manipulation (delete), basic function definition, basic function return"}
{"seed": "// IDNEQ applies the NEQ predicate on the ID field.\nfunc IDNEQ(id int) predicate.User {\n\treturn predicate.User(sql.FieldNEQ(FieldID, id))\n}", "id": 12420, "concepts": ["predicate.User", "sql.FieldNEQ", "sql.FieldEQ"], "_raw_llm_output": "predicate.User, sql.FieldNEQ, sql.FieldEQ"}
{"seed": "// NewV1SciNameAndIdsWithDefaults instantiates a new V1SciNameAndIds object\n// This constructor will only assign default values to properties that have it defined,\n// but it doesn't guarantee that properties required by API are set\nfunc NewV1SciNameAndIdsWithDefaults() *V1SciNameAndIds {\n\tthis := V1SciNameAndIds{}\n\treturn &this\n}", "id": 12442, "concepts": ["constructor", "default values", "API usage"], "_raw_llm_output": "constructor, default values, API usage"}
{"seed": "// NewLoggerWithField returns a logger that logs with the given fields.\n// It is derived from the internal logger instance of this package and uses the same log level and log file.\n//\n// If the internal logger instance is not initialized before this call, it is initialized to \"debug\" level\n// and logs to the standard output (stdout).\nfunc NewLoggerWithField(key string, value interface{}) Logger {\n\tif logger == nil {\n\t\tInitLogger(\"debug\", \"\") // nolint: errcheck, gosec\t// err will always be nil in this case.\n\t}\n\treturn logger.WithField(key, value)\n}", "id": 12456, "concepts": ["logger", "logger.WithField", "logger initialization"], "_raw_llm_output": "logger, logger.WithField, logger initialization"}
{"seed": "// NewMultipleMetricsParamsWithTimeout creates a new MultipleMetricsParams object\n// with the default values initialized, and the ability to set a timeout on a request\nfunc NewMultipleMetricsParamsWithTimeout(timeout time.Duration) *MultipleMetricsParams {\n\tvar ()\n\treturn &MultipleMetricsParams{\n\n\t\ttimeout: timeout,\n\t}\n}", "id": 12457, "concepts": ["struct initialization", "pointer receivers", "timeout handling"], "_raw_llm_output": "struct initialization, pointer receivers, timeout handling"}
{"seed": "// GenerateEvent is a utility function to be used by testing frameworks in order\n// to generate Stellar Asset Contract events.\n//\n// To provide a generic interface, there are more arguments than apply to the\n// type, but you should only expect the relevant ones to be set (for example,\n// transfer events have no admin, so it will be ignored). This means you can\n// always pass your set of testing parameters, modify the type, and get the\n// event filled out with the details you expect.\nfunc GenerateEvent(\n\ttype_ EventType,\n\tfrom, to, admin string,\n\tasset xdr.Asset,\n\tamount *big.Int,\n\tpassphrase string,\n) xdr.ContractEvent {\n\tvar topics []xdr.ScVal\n\tdata := makeBigAmount(amount)\n\n\tswitch type_ {\n\tcase EventTypeTransfer:\n\t\ttopics = []xdr.ScVal{\n\t\t\tmakeSymbol(\"transfer\"),\n\t\t\tmakeAddress(from),\n\t\t\tmakeAddress(to),\n\t\t\tmakeAsset(asset),\n\t\t}\n\n\tcase EventTypeMint:\n\t\ttopics = []xdr.ScVal{\n\t\t\tmakeSymbol(\"mint\"),\n\t\t\tmakeAddress(admin),\n\t\t\tmakeAddress(to),\n\t\t\tmakeAsset(asset),\n\t\t}\n\n\tcase EventTypeClawback:\n\t\ttopics = []xdr.ScVal{\n\t\t\tmakeSymbol(\"clawback\"),\n\t\t\tmakeAddress(admin),\n\t\t\tmakeAddress(from),\n\t\t\tmakeAsset(asset),\n\t\t}\n\n\tcase EventTypeBurn:\n\t\ttopics = []xdr.ScVal{\n\t\t\tmakeSymbol(\"burn\"),\n\t\t\tmakeAddress(from),\n\t\t\tmakeAsset(asset),\n\t\t}\n\n\tdefault:\n\t\tpanic(fmt.Errorf(\"event type %v unsupported\", type_))\n\t}\n\n\trawContractId, err := asset.ContractID(passphrase)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tcontractId := xdr.Hash(rawContractId)\n\n\tevent := xdr.ContractEvent{\n\t\tType:       xdr.ContractEventTypeContract,\n\t\tContractId: &contractId,\n\t\tBody: xdr.ContractEventBody{\n\t\t\tV: 0,\n\t\t\tV0: &xdr.ContractEventV0{\n\t\t\t\tTopics: xdr.ScVec(topics),\n\t\t\t\tData:   data,\n\t\t\t},\n\t\t},\n\t}\n\n\treturn event\n}", "id": 12467, "concepts": ["contract event generation", "contract event types", "contract event data", "contract event topics", "contract event contract ID", "contract event type", "contract event body", "contract event version", "contract event version 0", "contract event version 0 topics", "contract event version 0 data", "contract event version 0 contract ID", "contract event version 0 contract ID", "contract event version 0 contract ID", "contract event version 0 contract ID", "contract event version 0 contract ID", "contract event version 0 contract ID", "contract event version 0 contract ID", "contract event version 0 contract ID", "contract event version 0 contract ID", "contract event version 0 contract ID", "contract event version 0 contract ID", "contract event version 0 contract ID", "contract event version 0 contract ID", "contract event version 0 contract ID", "contract event version 0 contract ID", "contract event version 0 contract ID", "contract event version 0 contract ID", "contract event version 0 contract ID", "contract event version 0 contract ID", "contract event version 0 contract ID", "contract event version 0 contract ID", "contract event version 0 contract ID", "contract event version 0 contract ID", "contract event version 0 contract ID", "contract event version 0 contract ID", "contract event"], "_raw_llm_output": "contract event generation, contract event types, contract event data, contract event topics, contract event contract ID, contract event type, contract event body, contract event version, contract event version 0, contract event version 0 topics, contract event version 0 data, contract event version 0 contract ID, contract event version 0 contract ID, contract event version 0 contract ID, contract event version 0 contract ID, contract event version 0 contract ID, contract event version 0 contract ID, contract event version 0 contract ID, contract event version 0 contract ID, contract event version 0 contract ID, contract event version 0 contract ID, contract event version 0 contract ID, contract event version 0 contract ID, contract event version 0 contract ID, contract event version 0 contract ID, contract event version 0 contract ID, contract event version 0 contract ID, contract event version 0 contract ID, contract event version 0 contract ID, contract event version 0 contract ID, contract event version 0 contract ID, contract event version 0 contract ID, contract event version 0 contract ID, contract event version 0 contract ID, contract event version 0 contract ID, contract event version 0 contract ID, contract event"}
{"seed": "// YAMLHandler will parse the provided YAML and then return\n// an http.HandlerFunc (which also implements http.Handler)\n// that will attempt to map any paths to their corresponding\n// URL. If the path is not provided in the YAML, then the\n// fallback http.Handler will be called instead.\n//\n// YAML is expected to be in the format:\n//\n//     - path: /some-path\n//       url: https://www.some-url.com/demo\n//\n// The only errors that can be returned all relate to having\n// invalid YAML data.\nfunc YAMLHandler(yml []byte, fallback http.Handler) (http.HandlerFunc, error) {\n\t// parse yaml into a slice of maps, as appropriate for the expected\n\t// format\n\tmappings := make([]map[string]string, 0, 10)\n\tcombinedMapping := make(map[string]string)\n\terr := yaml.Unmarshal(yml, &mappings)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// combine the maps in the slice into a single map\n\tfor _, routingPair := range mappings {\n\t\tcombinedMapping[routingPair[\"path\"]] = routingPair[\"url\"]\n\t}\n\treturn MapHandler(combinedMapping, fallback), nil\n}", "id": 12468, "concepts": ["YAML parsing", "map iteration", "map creation", "map lookup", "map iteration", "map creation", "map lookup", "map iteration", "map creation", "map lookup", "map iteration", "map creation", "map lookup", "map iteration", "map creation", "map lookup", "map iteration", "map creation", "map lookup", "map iteration", "map creation", "map lookup", "map iteration", "map creation", "map lookup", "map iteration", "map creation", "map lookup", "map iteration", "map creation", "map lookup", "map iteration", "map creation", "map lookup", "map iteration", "map creation", "map lookup", "map iteration", "map creation", "map lookup", "map iteration", "map creation", "map lookup", "map iteration", "map creation", "map lookup", "map iteration", "map creation", "map lookup", "map iteration", "map creation", "map lookup", "map iteration", "map creation", "map lookup", "map iteration", "map creation", "map lookup", "map iteration", "map creation", "map lookup", "map iteration", "map creation", "map lookup", "map iteration", "map creation", "map lookup", "map iteration", "map creation", "map lookup", "map iteration", "map creation", "map lookup", "map iteration", "map creation", "map lookup", "map iteration", "map creation", "map lookup", "map iteration", "map creation", "map lookup", "map iteration", "map creation", "map lookup", ""], "_raw_llm_output": "YAML parsing, map iteration, map creation, map lookup, map iteration, map creation, map lookup, map iteration, map creation, map lookup, map iteration, map creation, map lookup, map iteration, map creation, map lookup, map iteration, map creation, map lookup, map iteration, map creation, map lookup, map iteration, map creation, map lookup, map iteration, map creation, map lookup, map iteration, map creation, map lookup, map iteration, map creation, map lookup, map iteration, map creation, map lookup, map iteration, map creation, map lookup, map iteration, map creation, map lookup, map iteration, map creation, map lookup, map iteration, map creation, map lookup, map iteration, map creation, map lookup, map iteration, map creation, map lookup, map iteration, map creation, map lookup, map iteration, map creation, map lookup, map iteration, map creation, map lookup, map iteration, map creation, map lookup, map iteration, map creation, map lookup, map iteration, map creation, map lookup, map iteration, map creation, map lookup, map iteration, map creation, map lookup, map iteration, map creation, map lookup, map iteration, map creation, map lookup,"}
{"seed": "// SocialNameHasSuffix applies the HasSuffix predicate on the \"social_name\" field.\nfunc SocialNameHasSuffix(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.HasSuffix(s.C(FieldSocialName), v))\n\t})\n}", "id": 12489, "concepts": ["sql.Selector", "sql.HasSuffix", "sql.C", "sql.Where", "sql.Predicate", "sql.Field", "sql.Selector.Where", "sql.Selector.C", "sql.Selector.HasSuffix", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql"], "_raw_llm_output": "sql.Selector, sql.HasSuffix, sql.C, sql.Where, sql.Predicate, sql.Field, sql.Selector.Where, sql.Selector.C, sql.Selector.HasSuffix, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql"}
{"seed": "// addUnrefToFinalResOp makes a resolutionOp at the end of opsList if\n// one doesn't exist yet, and then adds the given pointer as an unref\n// block to it.\nfunc addUnrefToFinalResOp(ops opsList, ptr data.BlockPointer,\n\tdoNotUnref map[data.BlockPointer]bool) opsList {\n\t// Make sure the block ID we want to unref isn't in the \"do not\n\t// unref\" list -- it could mean that block has already been GC'd\n\t// by the merged branch.  We can't compare pointers directly\n\t// because GC'd pointers contain no block context.\n\tfor noUnref := range doNotUnref {\n\t\tif ptr.ID == noUnref.ID {\n\t\t\treturn ops\n\t\t}\n\t}\n\n\tresOp, ok := ops[len(ops)-1].(*resolutionOp)\n\tif !ok {\n\t\tresOp = newResolutionOp()\n\t\tops = append(ops, resOp)\n\t}\n\tresOp.AddUncommittedUnrefBlock(ptr)\n\treturn ops\n}", "id": 12498, "concepts": ["slice manipulation", "map iteration (range loop)", "pointer comparison", "pointer handling", "basic function definition"], "_raw_llm_output": "slice manipulation, map iteration (range loop), pointer comparison, pointer handling, basic function definition"}
{"seed": "// NameHasPrefix applies the HasPrefix predicate on the \"name\" field.\nfunc NameHasPrefix(v string) predicate.User {\n\treturn predicate.User(sql.FieldHasPrefix(FieldName, v))\n}", "id": 12500, "concepts": ["predicate.User", "sql.FieldHasPrefix"], "_raw_llm_output": "predicate.User, sql.FieldHasPrefix"}
{"seed": "// stateE0 is the state after reading the mantissa, e, optional sign,\n// and at least one digit of the exponent in a number,\n// such as after reading `G314e-2` or `G0.314e+1` or `G3.14e0`.\nfunc stateE0(s *scanner, c byte) int {\n\tif '0' <= c && c <= '9' {\n\t\treturn scanContinue\n\t}\n\treturn stateEndValue(s, c)\n}", "id": 12509, "concepts": ["state machine", "scanner", "state transition", "integer parsing"], "_raw_llm_output": "state machine, scanner, state transition, integer parsing"}
{"seed": "// DefaultExprGTE applies the GTE predicate on the \"default_expr\" field.\nfunc DefaultExprGTE(v string) predicate.User {\n\treturn predicate.User(sql.FieldGTE(FieldDefaultExpr, v))\n}", "id": 12517, "concepts": ["sql package usage", "predicate.User", "sql.FieldGTE", "sql.FieldLTE"], "_raw_llm_output": "sql package usage, predicate.User, sql.FieldGTE, sql.FieldLTE"}
{"seed": "// Logger instances a Logger middleware that will write the logs to gin.DefaultWriter.\n// By default gin.DefaultWriter = os.Stdout.\nfunc Logger() HandlerFunc {\n\treturn gin.Logger()\n}", "id": 12520, "concepts": ["middleware", "gin.Logger()"], "_raw_llm_output": "middleware, gin.Logger()"}
{"seed": "// NicknameGTE applies the GTE predicate on the \"nickname\" field.\nfunc NicknameGTE(v string) predicate.User {\n\treturn predicate.User(sql.FieldGTE(FieldNickname, v))\n}", "id": 12539, "concepts": ["sql.FieldGTE", "predicate.User", "sql.Field", "sql.FieldGTE"], "_raw_llm_output": "sql.FieldGTE, predicate.User, sql.Field, sql.FieldGTE"}
{"seed": "// IsSandboxedMacOS reports whether this process is a sandboxed macOS\n// process. It is true for the Mac App Store and macsys (System\n// Extension) version on macOS, and false for tailscaled-on-macOS.\nfunc IsSandboxedMacOS() bool {\n\tif runtime.GOOS != \"darwin\" {\n\t\treturn false\n\t}\n\tif IsMacSysExt() {\n\t\treturn true\n\t}\n\texe, _ := os.Executable()\n\treturn strings.HasSuffix(exe, \"/Contents/MacOS/Tailscale\")\n}", "id": 12551, "concepts": ["runtime.GOOS", "os.Executable", "string manipulation", "runtime.GOOS", "runtime.GOOS", "runtime.GOOS", "runtime.GOOS", "runtime.GOOS", "runtime.GOOS", "runtime.GOOS", "runtime.GOOS", "runtime.GOOS", "runtime.GOOS", "runtime.GOOS", "runtime.GOOS", "runtime.GOOS", "runtime.GOOS", "runtime.GOOS", "runtime.GOOS", "runtime.GOOS", "runtime.GOOS", "runtime.GOOS", "runtime.GOOS", "runtime.GOOS", "runtime.GOOS", "runtime.GOOS", "runtime.GOOS", "runtime.GOOS", "runtime.GOOS", "runtime.GOOS", "runtime.GOOS", "runtime.GOOS", "runtime.GOOS", "runtime.GOOS", "runtime.GOOS", "runtime.GOOS", "runtime.GOOS", "runtime.GOOS", "runtime.GOOS", "runtime.GOOS", "runtime.GOOS", "runtime.GOOS", "runtime.GOOS", "runtime.GOOS", "runtime.GOOS", "runtime.GOOS", "runtime.GOOS", "runtime.GOOS", "runtime.GOOS", "runtime.GOOS", "runtime.GOOS", "runtime.GO"], "_raw_llm_output": "runtime.GOOS, os.Executable, string manipulation, runtime.GOOS, runtime.GOOS, runtime.GOOS, runtime.GOOS, runtime.GOOS, runtime.GOOS, runtime.GOOS, runtime.GOOS, runtime.GOOS, runtime.GOOS, runtime.GOOS, runtime.GOOS, runtime.GOOS, runtime.GOOS, runtime.GOOS, runtime.GOOS, runtime.GOOS, runtime.GOOS, runtime.GOOS, runtime.GOOS, runtime.GOOS, runtime.GOOS, runtime.GOOS, runtime.GOOS, runtime.GOOS, runtime.GOOS, runtime.GOOS, runtime.GOOS, runtime.GOOS, runtime.GOOS, runtime.GOOS, runtime.GOOS, runtime.GOOS, runtime.GOOS, runtime.GOOS, runtime.GOOS, runtime.GOOS, runtime.GOOS, runtime.GOOS, runtime.GOOS, runtime.GOOS, runtime.GOOS, runtime.GOOS, runtime.GOOS, runtime.GOOS, runtime.GOOS, runtime.GOOS, runtime.GOOS, runtime.GO"}
{"seed": "// NewPayRatesGetParams creates a new PayRatesGetParams object\n// with the default values initialized.\nfunc NewPayRatesGetParams() *PayRatesGetParams {\n\tvar ()\n\treturn &PayRatesGetParams{\n\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 12577, "concepts": ["struct definition", "struct initialization", "struct field access"], "_raw_llm_output": "struct definition, struct initialization, struct field access"}
{"seed": "// NewStorageNetAppSnapshotPolicyScheduleWithDefaults instantiates a new StorageNetAppSnapshotPolicySchedule object\n// This constructor will only assign default values to properties that have it defined,\n// but it doesn't guarantee that properties required by API are set\nfunc NewStorageNetAppSnapshotPolicyScheduleWithDefaults() *StorageNetAppSnapshotPolicySchedule {\n\tthis := StorageNetAppSnapshotPolicySchedule{}\n\tvar classId string = \"storage.NetAppSnapshotPolicySchedule\"\n\tthis.ClassId = classId\n\tvar objectType string = \"storage.NetAppSnapshotPolicySchedule\"\n\tthis.ObjectType = objectType\n\treturn &this\n}", "id": 12586, "concepts": ["constructor", "basic function definition", "class instantiation"], "_raw_llm_output": "constructor, basic function definition, class instantiation"}
{"seed": "// HeaderHandler adds the request's headerName from Header as a field to the\n// context's logger using headerName as field key.\nfunc HeaderHandler(headerName string) func(next httpserver.Handler) httpserver.Handler {\n\treturn func(next httpserver.Handler) httpserver.Handler {\n\t\treturn httpserver.HandlerFunc(func(w http.ResponseWriter, r *http.Request) (int, error) {\n\t\t\tif v := r.Header.Get(headerName); v != \"\" {\n\t\t\t\tlog := zerolog.Ctx(r.Context())\n\t\t\t\tlog.UpdateContext(func(c zerolog.Context) zerolog.Context {\n\t\t\t\t\treturn c.Str(headerName, v)\n\t\t\t\t})\n\t\t\t}\n\t\t\treturn next.ServeHTTP(w, r)\n\t\t})\n\t}\n}", "id": 12590, "concepts": ["http.ResponseWriter", "http.Request", "http.Header", "zerolog.Context", "zerolog.Context.Str", "httpserver.Handler", "httpserver.HandlerFunc", "httpserver.Handler.ServeHTTP", "httpserver.HandlerFunc.ServeHTTP", "function composition", "function composition with anonymous functions", "function composition with named functions", "function composition with named functions and anonymous functions"], "_raw_llm_output": "http.ResponseWriter, http.Request, http.Header, zerolog.Context, zerolog.Context.Str, httpserver.Handler, httpserver.HandlerFunc, httpserver.Handler.ServeHTTP, httpserver.HandlerFunc.ServeHTTP, function composition, function composition with anonymous functions, function composition with named functions, function composition with named functions and anonymous functions"}
{"seed": "// UpdatedAtNEQ applies the NEQ predicate on the \"updated_at\" field.\nfunc UpdatedAtNEQ(v time.Time) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldUpdatedAt), v))\n\t})\n}", "id": 12602, "concepts": ["sql package usage", "sql.Selector", "sql.NEQ", "sql.Where", "sql.C", "sql.Field", "sql.Predicate", "sql.Predicate.User", "sql.Predicate.Where", "sql.Predicate.NEQ", "sql.Predicate.C", "sql.Predicate.Field", "sql.Predicate.SQL", "sql.Predicate.SQL.Where", "sql.Predicate.SQL.NEQ", "sql.Predicate.SQL.C", "sql.Predicate.SQL.Field", "sql.Predicate.SQL.Value", "sql.Predicate.SQL.Value.NEQ", "sql.Predicate.SQL.Value.C", "sql.Predicate.SQL.Value.Field", "sql.Predicate.SQL.Value.Value", "sql.Predicate.SQL.Value.Value.NEQ", "sql.Predicate.SQL.Value.Value.C", "sql.Predicate.SQL.Value.Value.Field", "sql.Predicate.SQL.Value.Value.Value", "sql.Predicate.SQL.Value.Value.Value.NEQ", "sql.Predicate.SQL.Value.Value.Value.C", "sql.Predicate.SQL.Value.Value.Value.Field", "sql.Predicate.SQL.Value.Value.Value.Value", "sql"], "_raw_llm_output": "sql package usage, sql.Selector, sql.NEQ, sql.Where, sql.C, sql.Field, sql.Predicate, sql.Predicate.User, sql.Predicate.Where, sql.Predicate.NEQ, sql.Predicate.C, sql.Predicate.Field, sql.Predicate.SQL, sql.Predicate.SQL.Where, sql.Predicate.SQL.NEQ, sql.Predicate.SQL.C, sql.Predicate.SQL.Field, sql.Predicate.SQL.Value, sql.Predicate.SQL.Value.NEQ, sql.Predicate.SQL.Value.C, sql.Predicate.SQL.Value.Field, sql.Predicate.SQL.Value.Value, sql.Predicate.SQL.Value.Value.NEQ, sql.Predicate.SQL.Value.Value.C, sql.Predicate.SQL.Value.Value.Field, sql.Predicate.SQL.Value.Value.Value, sql.Predicate.SQL.Value.Value.Value.NEQ, sql.Predicate.SQL.Value.Value.Value.C, sql.Predicate.SQL.Value.Value.Value.Field, sql.Predicate.SQL.Value.Value.Value.Value, sql"}
{"seed": "// Extract recursively extracts the assets at src into the directory dst. If dst doesn't exist, the\n// directory is created including any missing parents.\n//\n// The assets are read either from data embedded in the binary or from the filesystem, depending on\n// whether the LOKOCTL_USE_FS_ASSETS environment variable is set.\nfunc Extract(src, dst string) error {\n\twalk := copyingWalker(dst, 0700)\n\tif err := get().WalkFiles(src, walk); err != nil {\n\t\treturn fmt.Errorf(\"failed to walk assets: %v\", err)\n\t}\n\n\treturn nil\n}", "id": 12615, "concepts": ["filesystem handling", "file copying", "file walking"], "_raw_llm_output": "filesystem handling, file copying, file walking"}
{"seed": "// StreamClientInterceptor returns a new stream client interceptor that performs rate limiting on the request on the\n// client side.\n// This can be helpful for clients that want to limit the number of requests they send in a given time, potentially\n// saving cost.\nfunc StreamClientInterceptor(limiter Limiter) grpc.StreamClientInterceptor {\n\treturn func(ctx context.Context, desc *grpc.StreamDesc, cc *grpc.ClientConn, method string, streamer grpc.Streamer, opts ...grpc.CallOption) (grpc.ClientStream, error) {\n\t\tif err := limiter.Limit(ctx); err != nil {\n\t\t\treturn nil, status.Errorf(codes.ResourceExhausted, \"%s is rejected by grpc_ratelimit middleware, please retry later. %s\", method, err)\n\t\t}\n\t\treturn streamer(ctx, desc, cc, method, opts...)\n\t}\n}", "id": 12629, "concepts": ["grpc.StreamClientInterceptor", "grpc.Streamer", "grpc.ClientStream", "grpc.ClientConn", "grpc.CallOption", "grpc.StreamDesc", "context.Context", "grpc.StreamDesc", "grpc.ClientConn", "grpc.Streamer", "grpc.CallOption", "grpc.StreamDesc", "context.Context", "grpc.StreamDesc", "grpc.ClientConn", "grpc.Streamer", "grpc.CallOption", "grpc.StreamDesc", "context.Context", "grpc.StreamDesc", "grpc.ClientConn", "grpc.Streamer", "grpc.CallOption", "grpc.StreamDesc", "context.Context", "grpc.StreamDesc", "grpc.ClientConn", "grpc.Streamer", "grpc.CallOption", "grpc.StreamDesc", "context.Context", "grpc.StreamDesc", "grpc.ClientConn", "grpc.Streamer", "grpc.CallOption", "grpc.StreamDesc", "context.Context", "grpc.StreamDesc", "grpc.ClientConn", "grpc.Streamer", "grpc.CallOption", "grpc.StreamDesc", "context.Context", "grpc.StreamDesc", "grpc.ClientConn", "grpc.Streamer", "grpc.CallOption", "grpc.StreamDesc", "context.Context", "grpc.StreamDesc", "grpc.ClientConn", "grpc.Streamer", "grpc.CallOption", "grpc.StreamDesc", "context"], "_raw_llm_output": "grpc.StreamClientInterceptor, grpc.Streamer, grpc.ClientStream, grpc.ClientConn, grpc.CallOption, grpc.StreamDesc, context.Context, grpc.StreamDesc, grpc.ClientConn, grpc.Streamer, grpc.CallOption, grpc.StreamDesc, context.Context, grpc.StreamDesc, grpc.ClientConn, grpc.Streamer, grpc.CallOption, grpc.StreamDesc, context.Context, grpc.StreamDesc, grpc.ClientConn, grpc.Streamer, grpc.CallOption, grpc.StreamDesc, context.Context, grpc.StreamDesc, grpc.ClientConn, grpc.Streamer, grpc.CallOption, grpc.StreamDesc, context.Context, grpc.StreamDesc, grpc.ClientConn, grpc.Streamer, grpc.CallOption, grpc.StreamDesc, context.Context, grpc.StreamDesc, grpc.ClientConn, grpc.Streamer, grpc.CallOption, grpc.StreamDesc, context.Context, grpc.StreamDesc, grpc.ClientConn, grpc.Streamer, grpc.CallOption, grpc.StreamDesc, context.Context, grpc.StreamDesc, grpc.ClientConn, grpc.Streamer, grpc.CallOption, grpc.StreamDesc, context"}
{"seed": "// findValInMap returns the child of mapNode which is value corresponding to the given key, and its index\nfunc findValInMap(key string, mapNode *goyaml.Node) (*goyaml.Node, int) {\n\tfindKey := &goyaml.Node{\n\t\tKind:  goyaml.ScalarNode,\n\t\tValue: key,\n\t\tTag:   strTag,\n\t}\n\n\tkeyIndex := findKeyInMap(findKey, mapNode)\n\tif keyIndex == -1 {\n\t\treturn nil, -1\n\t}\n\n\tvalIndex := keyIndex + 1\n\treturn mapNode.Content[valIndex], valIndex\n}", "id": 12651, "concepts": ["map iteration (range loop)", "map lookup", "map traversal", "map indexing"], "_raw_llm_output": "map iteration (range loop), map lookup, map traversal, map indexing"}
{"seed": "// Uint8 converts an uint8 to a pointer\nfunc Uint8(v uint8) *uint8 {\n\treturn &v\n}", "id": 12661, "concepts": ["pointer", "basic function definition"], "_raw_llm_output": "pointer, basic function definition"}
{"seed": "// ActorNameByCode returns the (string) name of the actor given a cid code.\nfunc ActorNameByCode(code cid.Cid) string {\n\tif !code.Defined() {\n\t\treturn \"<undefined>\"\n\t}\n\n\tinfo, ok := builtinActors[code]\n\tif !ok {\n\t\treturn \"<unknown>\"\n\t}\n\treturn info.name\n}", "id": 12663, "concepts": ["map iteration (range loop)", "map lookup", "string formatting", "string concatenation"], "_raw_llm_output": "map iteration (range loop), map lookup, string formatting, string concatenation"}
{"seed": "// EnsureFinalizer ensures that a finalizer of the given name is set on the given object with exponential backoff.\n// If the finalizer is not set, it adds it to the list of finalizers and patches the remote object.\n// Use PatchAddFinalizers instead, if the controller is able to tolerate conflict errors caused by stale reads.\nfunc EnsureFinalizer(ctx context.Context, reader client.Reader, writer client.Writer, obj client.Object, finalizer string) error {\n\treturn tryPatchFinalizers(ctx, reader, writer, obj, controllerutil.AddFinalizer, finalizer)\n}", "id": 12670, "concepts": ["client-go", "context", "client.Reader", "client.Writer", "client.Object", "controllerutil.AddFinalizer", "exponential backoff", "retry"], "_raw_llm_output": "client-go, context, client.Reader, client.Writer, client.Object, controllerutil.AddFinalizer, exponential backoff, retry"}
{"seed": "// boolGoToPy converts a Go bool to python-compatible C.char\nfunc boolGoToPy(b bool) C.char {\n\tif b {\n\t\treturn 1\n\t}\n\treturn 0\n}", "id": 12679, "concepts": ["C.char", "C.bool", "C.int", "C.char", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int", "C.int"], "_raw_llm_output": "C.char, C.bool, C.int, C.char, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int, C.int"}
{"seed": "// NewServiceStatusWithDefaults instantiates a new ServiceStatus object\n// This constructor will only assign default values to properties that have it defined,\n// but it doesn't guarantee that properties required by API are set\nfunc NewServiceStatusWithDefaults() *ServiceStatus {\n\tthis := ServiceStatus{}\n\n\n\treturn &this\n}", "id": 12680, "concepts": ["struct definition", "struct initialization", "default value assignment"], "_raw_llm_output": "struct definition, struct initialization, default value assignment"}
{"seed": "// NewNameEqualFold applies the EqualFold predicate on the \"new_name\" field.\nfunc NewNameEqualFold(v string) predicate.User {\n\treturn predicate.User(sql.FieldEqualFold(FieldNewName, v))\n}", "id": 12687, "concepts": ["predicate.User", "sql.FieldEqualFold"], "_raw_llm_output": "predicate.User, sql.FieldEqualFold"}
{"seed": "// generateMongoQuery takes in a number of parameters and constructs a mongo query\n// to retrieve objects from the Tidepool database. It is used by the router.Add(\"GET\", \"/{userID}\"\n// endpoint, which implements the Tide-whisperer API. See that function for further documentation\n// on parameters\nfunc generateMongoQuery(p *Params) bson.M {\n\n\tgroupDataQuery := bson.M{\n\t\t\"_userId\": p.UserID,\n\t\t\"_active\": true}\n\n\t//if optional parameters are present, then add them to the query\n\tif len(p.Types) > 0 && p.Types[0] != \"\" {\n\t\tgroupDataQuery[\"type\"] = bson.M{\"$in\": p.Types}\n\t}\n\n\tif len(p.SubTypes) > 0 && p.SubTypes[0] != \"\" {\n\t\tgroupDataQuery[\"subType\"] = bson.M{\"$in\": p.SubTypes}\n\t}\n\n\t// The Golang implementation of time.RFC3339Nano does not use a fixed number of digits after the\n\t// decimal point and therefore is not reliably sortable. And so we use our own custom format for\n\t// database range queries that will properly sort any data with time stored as an ISO string.\n\t// See https://github.com/golang/go/issues/19635\n\tif !p.Date.Start.IsZero() && !p.Date.End.IsZero() {\n\t\tgroupDataQuery[\"time\"] = bson.M{\"$gte\": p.Date.Start, \"$lte\": p.Date.End}\n\t} else if !p.Date.Start.IsZero() {\n\t\tgroupDataQuery[\"time\"] = bson.M{\"$gte\": p.Date.Start}\n\t} else if !p.Date.End.IsZero() {\n\t\tgroupDataQuery[\"time\"] = bson.M{\"$lte\": p.Date.End}\n\t}\n\n\tif !p.Carelink {\n\t\tgroupDataQuery[\"source\"] = bson.M{\"$ne\": \"carelink\"}\n\t}\n\n\tif p.DeviceID != \"\" {\n\t\tgroupDataQuery[\"deviceId\"] = p.DeviceID\n\t}\n\n\t// If we have an explicit upload ID to filter by, we don't need or want to apply any further\n\t// data source-based filtering\n\tif p.UploadID != \"\" {\n\t\tgroupDataQuery[\"uploadId\"] = p.UploadID\n\t} else {\n\t\tandQuery := []bson.M{}\n\t\tif !p.Dexcom && p.DexcomDataSource != nil {\n\t\t\tdexcomQuery := []bson.M{\n\t\t\t\t{\"type\": bson.M{\"$ne\": \"cbg\"}},\n\t\t\t\t{\"uploadId\": bson.M{\"$in\": p.DexcomDataSource[\"dataSetIds\"]}},\n\t\t\t}\n\n\t\t\t// more redundant OR query for multiple date field types\n\t\t\tearliestDataTime := p.DexcomDataSource[\"earliestDataTime\"].(primitive.DateTime).Time().UTC()\n\t\t\tdexcomQuery = append(dexcomQuery,\n\t\t\t\tbson.M{\"time\": bson.M{\"$lt\": earliestDataTime}},\n\t\t\t)\n\n\t\t\tlatestDataTime := p.DexcomDataSource[\"latestDataTime\"].(primitive.DateTime).Time().UTC()\n\t\t\tdexcomQuery = append(dexcomQuery,\n\t\t\t\tbson.M{\"time\": bson.M{\"$gt\": latestDataTime}},\n\t\t\t)\n\n\t\t\tandQuery = append(andQuery, bson.M{\"$or\": dexcomQuery})\n\t\t}\n\n\t\tif !p.Medtronic && len(p.MedtronicUploadIds) > 0 {\n\t\t\tmedtronicDateTime, err := time.Parse(medtronicDateFormat, p.MedtronicDate)\n\t\t\tif err != nil {\n\t\t\t\tmedtronicDateTime, _ = time.Parse(time.RFC3339, p.MedtronicDate)\n\t\t\t}\n\t\t\tmedtronicQuery := []bson.M{\n\t\t\t\t{\"time\": bson.M{\"$lt\": medtronicDateTime}},\n\t\t\t\t{\"type\": bson.M{\"$nin\": []string{\"basal\", \"bolus\", \"cbg\"}}},\n\t\t\t\t{\"uploadId\": bson.M{\"$nin\": p.MedtronicUploadIds}},\n\t\t\t}\n\t\t\tandQuery = append(andQuery, bson.M{\"$or\": medtronicQuery})\n\t\t}\n\n\t\tif len(andQuery) > 0 {\n\t\t\tgroupDataQuery[\"$and\"] = andQuery\n\t\t}\n\t}\n\n\treturn groupDataQuery\n}", "id": 12689, "concepts": ["date handling", "time formatting", "bson package usage", "string manipulation", "basic function definition", "time.Parse", "time.ParseInLocation", "time.Time.UTC", "time.Time.Format", "time.Time.Parse", "time.Time.ParseInLocation", "time.Time.Format", "time.Time.Format", "time.Time.Format", "time.Time.Format", "time.Time.Format", "time.Time.Format", "time.Time.Format", "time.Time.Format", "time.Time.Format", "time.Time.Format", "time.Time.Format", "time.Time.Format", "time.Time.Format", "time.Time.Format", "time.Time.Format", "time.Time.Format", "time.Time.Format", "time.Time.Format", "time.Time.Format", "time.Time.Format", "time.Time.Format", "time.Time.Format", "time.Time.Format", "time.Time.Format", "time.Time.Format", "time.Time.Format", "time.Time.Format", "time.Time.Format", "time.Time.Format", "time.Time.Format", "time.Time.Format", "time.Time.Format", "time.Time"], "_raw_llm_output": "date handling, time formatting, bson package usage, string manipulation, basic function definition,\ntime.Parse, time.ParseInLocation, time.Time.UTC, time.Time.Format, time.Time.Parse, time.Time.ParseInLocation,\ntime.Time.Format, time.Time.Format, time.Time.Format, time.Time.Format, time.Time.Format, time.Time.Format,\ntime.Time.Format, time.Time.Format, time.Time.Format, time.Time.Format, time.Time.Format, time.Time.Format,\ntime.Time.Format, time.Time.Format, time.Time.Format, time.Time.Format, time.Time.Format, time.Time.Format,\ntime.Time.Format, time.Time.Format, time.Time.Format, time.Time.Format, time.Time.Format, time.Time.Format,\ntime.Time.Format, time.Time.Format, time.Time.Format, time.Time.Format, time.Time.Format, time.Time.Format,\ntime.Time.Format, time.Time.Format, time.Time"}
{"seed": "// ParseListLoadBalancersResponse parses an HTTP response from a ListLoadBalancersWithResponse call\nfunc ParseListLoadBalancersResponse(rsp *http.Response) (*ListLoadBalancersResponse, error) {\n\tbodyBytes, err := ioutil.ReadAll(rsp.Body)\n\tdefer rsp.Body.Close()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse := &ListLoadBalancersResponse{\n\t\tBody:         bodyBytes,\n\t\tHTTPResponse: rsp,\n\t}\n\n\tswitch {\n\tcase strings.Contains(rsp.Header.Get(\"Content-Type\"), \"json\") && rsp.StatusCode == 200:\n\t\tvar dest struct {\n\t\t\tLoadBalancers *[]LoadBalancer `json:\"load-balancers,omitempty\"`\n\t\t}\n\t\tif err := json.Unmarshal(bodyBytes, &dest); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresponse.JSON200 = &dest\n\n\t}\n\n\treturn response, nil\n}", "id": 12693, "concepts": ["http.Response", "json.Unmarshal", "io.ReadAll", "ioutil.ReadAll", "json parsing", "error handling", "standard library usage"], "_raw_llm_output": "http.Response, json.Unmarshal, io.ReadAll, ioutil.ReadAll, json parsing, error handling, standard library usage"}
{"seed": "// NewHandler returns a new Handler based on the plugin name and optional path.\n//\n// protocPath and pluginPath are optional.\n//\n// - If the plugin path is set, this returns a new binary handler for that path.\n// - If the plugin path is unset, this does exec.LookPath for a binary named protoc-gen-pluginName,\n//   and if one is found, a new binary handler is returned for this.\n// - Else, if the name is in ProtocProxyPluginNames, this returns a new protoc proxy handler.\n// - Else, this returns error.\nfunc NewHandler(\n\tlogger *zap.Logger,\n\tpluginName string,\n\toptions ...HandlerOption,\n) (appproto.Handler, error) {\n\thandlerOptions := newHandlerOptions()\n\tfor _, option := range options {\n\t\toption(handlerOptions)\n\t}\n\tif handlerOptions.pluginPath != \"\" {\n\t\tpluginPath, err := exec.LookPath(handlerOptions.pluginPath)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn newBinaryHandler(logger, pluginPath), nil\n\t}\n\tpluginPath, err := exec.LookPath(\"protoc-gen-\" + pluginName)\n\tif err == nil {\n\t\treturn newBinaryHandler(logger, pluginPath), nil\n\t}\n\tif _, ok := ProtocProxyPluginNames[pluginName]; ok {\n\t\tif handlerOptions.protocPath == \"\" {\n\t\t\thandlerOptions.protocPath = \"protoc\"\n\t\t}\n\t\tprotocPath, err := exec.LookPath(handlerOptions.protocPath)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn newProtocProxyHandler(logger, protocPath, pluginName), nil\n\t}\n\treturn nil, fmt.Errorf(\"could not find protoc plugin for name %s\", pluginName)\n}", "id": 12706, "concepts": ["exec.LookPath", "error handling (errors.New)", "if/else statements", "string formatting", "map iteration", "map lookup", "function definition", "function call"], "_raw_llm_output": "exec.LookPath, error handling (errors.New), if/else statements, string formatting, map iteration, map lookup, function definition, function call"}
{"seed": "// NewTokenGT applies the GT predicate on the \"new_token\" field.\nfunc NewTokenGT(v string) predicate.User {\n\treturn predicate.User(sql.FieldGT(FieldNewToken, v))\n}", "id": 12708, "concepts": ["sql package usage", "predicate definition"], "_raw_llm_output": "sql package usage, predicate definition"}
{"seed": "// MarshalUriSANs takes URI strings and returns the ASN.1 structure to be used\n// in the Value field for the SAN Extension\nfunc MarshalUriSANs(uris []string) (derBytes []byte, err error) {\n\tvar rawValues []asn1.RawValue\n\tfor _, name := range uris {\n\t\trawValues = append(rawValues, asn1.RawValue{Tag: 6, Class: 2, Bytes: []byte(name)})\n\t}\n\n\treturn asn1.Marshal(rawValues)\n}", "id": 12722, "concepts": ["asn1 package usage", "ASN.1 structure", "ASN.1 encoding"], "_raw_llm_output": "asn1 package usage, ASN.1 structure, ASN.1 encoding"}
{"seed": "// NewPostAdminUsersParamsWithHTTPClient creates a new PostAdminUsersParams object\n// with the default values initialized, and the ability to set a custom HTTPClient for a request\nfunc NewPostAdminUsersParamsWithHTTPClient(client *http.Client) *PostAdminUsersParams {\n\tvar ()\n\treturn &PostAdminUsersParams{\n\t\tHTTPClient: client,\n\t}\n}", "id": 12741, "concepts": ["http.Client", "function definition", "function composition"], "_raw_llm_output": "http.Client, function definition, function composition"}
{"seed": "// ====== \u65e9\u4e0a\u7684  \u5220\u9664\u6392\u5e8f\u6570\u7ec4\u4e2d\u7684\u91cd\u590d\u9879 ===\n/*\n\u601d\u8def\u56de\u987e\n\t\u9898\u76ee\u867d\u7136\u662f\u5220\u9664\u4f46\u662f\u8ddf\u786e\u5207\u6765\u8bf4\u662f\u4ea4\u6362\n\t\u4f7f\u7528\u53cc\u6307\u9488\uff0ci, j \n\t\u5982\u679cnums[i] != nums[j], i++, nums[i] = nums[j]\n*/\n\nfunc removeDuplicates(nums []int) int {\n\tlength, i := len(nums), 0\n\tfor j := 1; j < length; j++ {\n\t\tif nums[i] != nums[j] {\n\t\t\ti++\n\t\t\tnums[i]= nums[j]\n\t\t}\n\t}\n\treturn i + 1\n}", "id": 12743, "concepts": ["two-pointer", "array manipulation", "basic function definition"], "_raw_llm_output": "two-pointer, array manipulation, basic function definition"}
{"seed": "// BlobNotNil applies the NotNil predicate on the \"blob\" field.\nfunc BlobNotNil() predicate.User {\n\treturn predicate.User(sql.FieldNotNull(FieldBlob))\n}", "id": 12754, "concepts": ["predicate.User", "sql.FieldNotNull", "sql.Field"], "_raw_llm_output": "predicate.User, sql.FieldNotNull, sql.Field"}
{"seed": "// NewEdgeContextHeaders returns a new EdgeContextHeaders object from the given\n// HTTP headers.\nfunc NewEdgeContextHeaders(h http.Header) EdgeContextHeaders {\n\treturn EdgeContextHeaders{\n\t\tEdgeRequest: h.Get(EdgeContextHeader),\n\t}\n}", "id": 12761, "concepts": ["HTTP headers", "EdgeContextHeader", "basic function definition"], "_raw_llm_output": "HTTP headers, EdgeContextHeader, basic function definition"}
{"seed": "// LoadMultiSourceInfoNode parses YAML documents with multiple entries, or\n// normal single YAML/JSON documents.\nfunc LoadMultiSourceInfoNode(contents []byte) ([]SourceInfoNode, error) {\n\tdec := yaml.NewDecoder(bytes.NewReader(contents))\n\tvar documents []*yaml.Node\n\tfor {\n\t\tvalue := yaml.Node{}\n\t\terr := dec.Decode(&value)\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif value.Kind == yaml.DocumentNode {\n\t\t\tfor _, doc := range value.Content {\n\t\t\t\tdocuments = append(documents, doc)\n\t\t\t}\n\t\t} else {\n\t\t\tdocuments = append(documents, &value)\n\t\t}\n\t}\n\n\tif len(documents) < 1 {\n\t\treturn nil, fmt.Errorf(\"No document contents\")\n\t}\n\n\tnodes := []SourceInfoNode{}\n\tfor _, doc := range documents {\n\t\tnodes = append(nodes, SourceInfoNode{body: doc})\n\t}\n\treturn nodes, nil\n}", "id": 12774, "concepts": ["yaml package usage", "yaml.Node", "yaml.DocumentNode", "io.EOF", "io.Reader", "io.EOF", "io.Reader", "io.EOF", "io.Reader", "io.EOF", "io.Reader", "io.EOF", "io.Reader", "io.EOF", "io.Reader", "io.EOF", "io.Reader", "io.EOF", "io.Reader", "io.EOF", "io.Reader", "io.EOF", "io.Reader", "io.EOF", "io.Reader", "io.EOF", "io.Reader", "io.EOF", "io.Reader", "io.EOF", "io.Reader", "io.EOF", "io.Reader", "io.EOF", "io.Reader", "io.EOF", "io.Reader", "io.EOF", "io.Reader", "io.EOF", "io.Reader", "io.EOF", "io.Reader", "io.EOF", "io.Reader", "io.EOF", "io.Reader", "io.EOF", "io.Reader", "io.EOF", "io.Reader", "io.EOF", "io.Reader", "io.EOF", "io.Reader", "io.EOF", "io.Reader", "io.EOF", "io.Reader", "io.EOF", "io.Reader", "io.EOF", "io.Reader", "io."], "_raw_llm_output": "yaml package usage, yaml.Node, yaml.DocumentNode, io.EOF, io.Reader, io.EOF, io.Reader, io.EOF, io.Reader, io.EOF, io.Reader, io.EOF, io.Reader, io.EOF, io.Reader, io.EOF, io.Reader, io.EOF, io.Reader, io.EOF, io.Reader, io.EOF, io.Reader, io.EOF, io.Reader, io.EOF, io.Reader, io.EOF, io.Reader, io.EOF, io.Reader, io.EOF, io.Reader, io.EOF, io.Reader, io.EOF, io.Reader, io.EOF, io.Reader, io.EOF, io.Reader, io.EOF, io.Reader, io.EOF, io.Reader, io.EOF, io.Reader, io.EOF, io.Reader, io.EOF, io.Reader, io.EOF, io.Reader, io.EOF, io.Reader, io.EOF, io.Reader, io.EOF, io.Reader, io.EOF, io.Reader, io.EOF, io.Reader, io."}
{"seed": "// Nickname applies equality check predicate on the \"nickname\" field. It's identical to NicknameEQ.\nfunc Nickname(v string) predicate.User {\n\treturn predicate.User(sql.FieldEQ(FieldNickname, v))\n}", "id": 12791, "concepts": ["struct field access", "predicate.User", "sql.FieldEQ"], "_raw_llm_output": "struct field access, predicate.User, sql.FieldEQ"}
{"seed": "// MustReadFileInts reads a file of ints, one per line, or panics.\nfunc MustReadFileInts(filename string) []int {\n\tints, err := ReadFileInts(filename)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn ints\n}", "id": 12792, "concepts": ["panic", "error handling (idiomatic if err != nil)", "standard library usage"], "_raw_llm_output": "panic, error handling (idiomatic if err != nil), standard library usage"}
{"seed": "// PhoneLT applies the LT predicate on the \"phone\" field.\nfunc PhoneLT(v string) predicate.User {\n\treturn predicate.User(sql.FieldLT(FieldPhone, v))\n}", "id": 12796, "concepts": ["sql package usage", "predicate.User", "sql.FieldLT"], "_raw_llm_output": "sql package usage, predicate.User, sql.FieldLT"}
{"seed": "// DefaultExprs applies equality check predicate on the \"default_exprs\" field. It's identical to DefaultExprsEQ.\nfunc DefaultExprs(v string) predicate.User {\n\treturn predicate.User(sql.FieldEQ(FieldDefaultExprs, v))\n}", "id": 12799, "concepts": ["predicate.User", "sql.FieldEQ", "sql.FieldEQ"], "_raw_llm_output": "predicate.User, sql.FieldEQ, sql.FieldEQ"}
{"seed": "// SocialEmailLT applies the LT predicate on the \"social_email\" field.\nfunc SocialEmailLT(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.LT(s.C(FieldSocialEmail), v))\n\t})\n}", "id": 12807, "concepts": ["sql.Selector", "sql.LT", "sql.C", "sql.Where", "sql.Predicate", "sql.Field", "sql.Selector.Where", "sql.Selector.C", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector"], "_raw_llm_output": "sql.Selector, sql.LT, sql.C, sql.Where, sql.Predicate, sql.Field, sql.Selector.Where, sql.Selector.C, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector"}
{"seed": "// SolveFibonacciDPSO returns n'th (0 indexed) fibonacci number by using an array to store previous two pre-computed values\n// DPSO stands for Dynamic Programming & Space Optimized\nfunc SolveFibonacciDPSO(n int64) int64 {\n\tif n < 0 {\n\t\tpanic(\"invalid index\")\n\t}\n\tif n <= 1 {\n\t\treturn n\n\t}\n\tf := make([]int64, 2)\n\tf[0] = 0\n\tf[1] = 1\n\tfor i := int64(2); i < n; i++ {\n\t\tf[0], f[1] = f[1], f[0]+f[1]\n\t}\n\treturn f[0] + f[1]\n}", "id": 12809, "concepts": ["array", "integer addition", "integer subtraction", "integer multiplication", "integer division", "integer modulo", "integer bitwise AND", "integer bitwise OR", "integer bitwise XOR", "integer bitwise NOT", "integer bitwise left shift", "integer bitwise right shift", "integer bitwise left shift assignment", "integer bitwise right shift assignment", "integer bitwise AND assignment", "integer bitwise OR assignment", "integer bitwise XOR assignment", "integer bitwise NOT assignment", "integer bitwise left shift assignment", "integer bitwise right shift assignment", "integer bitwise AND assignment", "integer bitwise OR assignment", "integer bitwise XOR assignment", "integer bitwise NOT assignment", "integer bitwise left shift assignment", "integer bitwise right shift assignment", "integer bitwise AND assignment", "integer bitwise OR assignment", "integer bitwise XOR assignment", "integer bitwise NOT assignment", "integer bitwise left shift assignment", "integer bitwise right shift assignment", "integer bitwise AND assignment", "integer bitwise OR assignment", "integer bitwise XOR assignment", "integer bitwise NOT assignment", "integer bitwise left shift assignment", "integer bitwise right shift assignment", "integer bitwise AND assignment", "integer bitwise OR assignment", "integer bitwise XOR assignment", "integer bitwise NOT assignment", "integer bitwise left shift assignment", "integer bitwise right shift assignment", "integer"], "_raw_llm_output": "array, integer addition, integer subtraction, integer multiplication, integer division, integer modulo, integer bitwise AND, integer bitwise OR, integer bitwise XOR, integer bitwise NOT, integer bitwise left shift, integer bitwise right shift, integer bitwise left shift assignment, integer bitwise right shift assignment, integer bitwise AND assignment, integer bitwise OR assignment, integer bitwise XOR assignment, integer bitwise NOT assignment, integer bitwise left shift assignment, integer bitwise right shift assignment, integer bitwise AND assignment, integer bitwise OR assignment, integer bitwise XOR assignment, integer bitwise NOT assignment, integer bitwise left shift assignment, integer bitwise right shift assignment, integer bitwise AND assignment, integer bitwise OR assignment, integer bitwise XOR assignment, integer bitwise NOT assignment, integer bitwise left shift assignment, integer bitwise right shift assignment, integer bitwise AND assignment, integer bitwise OR assignment, integer bitwise XOR assignment, integer bitwise NOT assignment, integer bitwise left shift assignment, integer bitwise right shift assignment, integer bitwise AND assignment, integer bitwise OR assignment, integer bitwise XOR assignment, integer bitwise NOT assignment, integer bitwise left shift assignment, integer bitwise right shift assignment, integer"}
{"seed": "// validateRoles checks that 1) all configured roles actually exist in the\n// app type, and 2) all active roles (according to the app config) that\n// require more than 0 members are covered by the cluster config.\nfunc validateRoles(\n\tcr *kdv1.KubeDirectorCluster,\n\tappCR *kdv1.KubeDirectorApp,\n) string {\n\n\tvar configuredRoles, errorMessages []string\n\n\tallRoles := catalog.GetAllRoleIDs(appCR)\n\tfor _, role := range cr.Spec.Roles {\n\t\tif shared.StringInList(role.Name, allRoles) {\n\t\t\tconfiguredRoles = append(configuredRoles, role.Name)\n\t\t} else {\n\t\t\tinvalidRoleMsg := fmt.Sprintf(\n\t\t\t\tinvalidRole,\n\t\t\t\trole.Name,\n\t\t\t\tappCR.Name,\n\t\t\t\tstrings.Join(allRoles, \",\"),\n\t\t\t)\n\t\t\terrorMessages = append(errorMessages, invalidRoleMsg)\n\t\t}\n\t}\n\tfor _, activeRole := range catalog.GetSelectedRoleIDs(appCR) {\n\t\tif !shared.StringInList(activeRole, configuredRoles) {\n\t\t\trole := catalog.GetRoleFromID(appCR, activeRole)\n\t\t\t// If our app CR validation is on point this should never be nil,\n\t\t\t// but it doesn't hurt to be careful.\n\t\t\tif role != nil {\n\t\t\t\tvalidMin, _ := catalog.GetRoleCardinality(role)\n\t\t\t\tif validMin != 0 {\n\t\t\t\t\tunconfiguredRoleMsg := fmt.Sprintf(\n\t\t\t\t\t\tunconfiguredRole,\n\t\t\t\t\t\tactiveRole,\n\t\t\t\t\t\tappCR.Name,\n\t\t\t\t\t)\n\t\t\t\t\terrorMessages = append(errorMessages, unconfiguredRoleMsg)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif len(errorMessages) == 0 {\n\t\treturn \"\"\n\t}\n\treturn strings.Join(errorMessages, \"\\n\")\n}", "id": 12814, "concepts": ["string manipulation", "string formatting", "string concatenation", "string comparison", "string iteration (range loop)", "string length", "string index access", "string slice", "string slice iteration (range loop)", "string slice concatenation", "string slice length", "string slice index access", "string slice iteration (range loop)", "string slice iteration (range loop)", "string slice iteration (range loop)", "string slice iteration (range loop)", "string slice iteration (range loop)", "string slice iteration (range loop)", "string slice iteration (range loop)", "string slice iteration (range loop)", "string slice iteration (range loop)", "string slice iteration (range loop)", "string slice iteration (range loop)", "string slice iteration (range loop)", "string slice iteration (range loop)", "string slice iteration (range loop)", "string slice iteration (range loop)", "string slice iteration (range loop)", "string slice iteration (range loop)", "string slice iteration (range loop)", "string slice iteration (range loop)", "string slice iteration (range loop)", "string slice iteration (range loop)", "string slice iteration (range loop)", "string slice iteration (range loop)", "string slice iteration (range loop)", "string slice iteration (range loop)", "string slice iteration (range loop)", "string slice iteration (range loop)", "string slice iteration (range loop)", "string slice iteration (range loop)", "string slice"], "_raw_llm_output": "string manipulation, string formatting, string concatenation, string comparison, string iteration (range loop), string length, string index access, string slice, string slice iteration (range loop), string slice concatenation, string slice length, string slice index access, string slice iteration (range loop), string slice iteration (range loop), string slice iteration (range loop), string slice iteration (range loop), string slice iteration (range loop), string slice iteration (range loop), string slice iteration (range loop), string slice iteration (range loop), string slice iteration (range loop), string slice iteration (range loop), string slice iteration (range loop), string slice iteration (range loop), string slice iteration (range loop), string slice iteration (range loop), string slice iteration (range loop), string slice iteration (range loop), string slice iteration (range loop), string slice iteration (range loop), string slice iteration (range loop), string slice iteration (range loop), string slice iteration (range loop), string slice iteration (range loop), string slice iteration (range loop), string slice iteration (range loop), string slice iteration (range loop), string slice iteration (range loop), string slice iteration (range loop), string slice iteration (range loop), string slice iteration (range loop), string slice"}
{"seed": "// AnyValue returns a RESP value from an interface.\n// This function infers the types. Arrays are not allowed.\nfunc AnyValue(v interface{}) Value {\n\tswitch v := v.(type) {\n\tdefault:\n\t\treturn StringValue(fmt.Sprintf(\"%v\", v))\n\tcase nil:\n\t\treturn NullValue()\n\tcase int:\n\t\treturn IntegerValue(int(v))\n\tcase uint:\n\t\treturn IntegerValue(int(v))\n\tcase int8:\n\t\treturn IntegerValue(int(v))\n\tcase uint8:\n\t\treturn IntegerValue(int(v))\n\tcase int16:\n\t\treturn IntegerValue(int(v))\n\tcase uint16:\n\t\treturn IntegerValue(int(v))\n\tcase int32:\n\t\treturn IntegerValue(int(v))\n\tcase uint32:\n\t\treturn IntegerValue(int(v))\n\tcase int64:\n\t\treturn IntegerValue(int(v))\n\tcase uint64:\n\t\treturn IntegerValue(int(v))\n\tcase bool:\n\t\treturn BoolValue(v)\n\tcase float32:\n\t\treturn FloatValue(float64(v))\n\tcase float64:\n\t\treturn FloatValue(float64(v))\n\tcase []byte:\n\t\treturn BytesValue(v)\n\tcase string:\n\t\treturn StringValue(v)\n\t}\n}", "id": 12828, "concepts": ["type assertion", "type switch", "type inference", "type casting", "type conversion", "type checking", "type assertion", "type switch", "type inference", "type casting", "type conversion", "type checking", "type assertion", "type switch", "type inference", "type casting", "type conversion", "type checking", "type assertion", "type switch", "type inference", "type casting", "type conversion", "type checking", "type assertion", "type switch", "type inference", "type casting", "type conversion", "type checking", "type assertion", "type switch", "type inference", "type casting", "type conversion", "type checking", "type assertion", "type switch", "type inference", "type casting", "type conversion", "type checking", "type assertion", "type switch", "type inference", "type casting", "type conversion", "type checking", "type assertion", "type switch", "type inference", "type casting", "type conversion", "type checking", "type assertion", "type switch", "type inference", "type casting", "type conversion", "type checking", "type assertion", "type switch", "type inference", "type casting", "type conversion", "type checking", "type assertion", "type switch", "type inference", "type casting", "type conversion", "type checking", "type assertion", "type switch", "type inference", "type casting", "type conversion", "type checking", "type assertion", "type switch", "type inference", "type casting", "type conversion", "type checking", "type assertion", ""], "_raw_llm_output": "type assertion, type switch, type inference, type casting, type conversion, type checking, type assertion, type switch, type inference, type casting, type conversion, type checking, type assertion, type switch, type inference, type casting, type conversion, type checking, type assertion, type switch, type inference, type casting, type conversion, type checking, type assertion, type switch, type inference, type casting, type conversion, type checking, type assertion, type switch, type inference, type casting, type conversion, type checking, type assertion, type switch, type inference, type casting, type conversion, type checking, type assertion, type switch, type inference, type casting, type conversion, type checking, type assertion, type switch, type inference, type casting, type conversion, type checking, type assertion, type switch, type inference, type casting, type conversion, type checking, type assertion, type switch, type inference, type casting, type conversion, type checking, type assertion, type switch, type inference, type casting, type conversion, type checking, type assertion, type switch, type inference, type casting, type conversion, type checking, type assertion, type switch, type inference, type casting, type conversion, type checking, type assertion,"}
{"seed": "// NewGetSubscriptionsParams creates a new GetSubscriptionsParams object\n// with the default values initialized.\nfunc NewGetSubscriptionsParams() *GetSubscriptionsParams {\n\tvar ()\n\treturn &GetSubscriptionsParams{\n\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 12830, "concepts": ["struct definition", "struct initialization", "struct field access"], "_raw_llm_output": "struct definition, struct initialization, struct field access"}
{"seed": "// Compose the etcd API host:port location\nfunc getEtcdAPI(host string, port string) string {\n\treturn fmt.Sprintf(\"http://%s:%s\", host, port)\n}", "id": 12834, "concepts": ["string formatting", "fmt package usage"], "_raw_llm_output": "string formatting, fmt package usage"}
{"seed": "// IQ returns an option that matches IQ stanzas based on their type and the name\n// of the payload.\nfunc IQ(typ stanza.IQType, payload xml.Name, h IQHandler) Option {\n\treturn func(m *ServeMux) {\n\t\tif h == nil {\n\t\t\tpanic(\"mux: nil IQ handler\")\n\t\t}\n\t\tpat := pattern{Stanza: iqStanza, Payload: payload, Type: string(typ)}\n\t\tif _, ok := m.iqPatterns[pat]; ok {\n\t\t\tpanic(\"mux: multiple registrations for \" + pat.String())\n\t\t}\n\t\tif m.iqPatterns == nil {\n\t\t\tm.iqPatterns = make(map[pattern]IQHandler)\n\t\t}\n\t\tm.iqPatterns[pat] = h\n\t}\n}", "id": 12837, "concepts": ["struct definition", "map definition", "map iteration", "map lookup", "map assignment", "map key definition", "map value definition", "function definition", "function call", "function return", "function parameter", "function parameter definition", "function parameter assignment", "function parameter assignment to variable", "function parameter assignment to variable", "function parameter assignment to variable", "function parameter assignment to variable", "function parameter assignment to variable", "function parameter assignment to variable", "function parameter assignment to variable", "function parameter assignment to variable", "function parameter assignment to variable", "function parameter assignment to variable", "function parameter assignment to variable", "function parameter assignment to variable", "function parameter assignment to variable", "function parameter assignment to variable", "function parameter assignment to variable", "function parameter assignment to variable", "function parameter assignment to variable", "function parameter assignment to variable", "function parameter assignment to variable", "function parameter assignment to variable", "function parameter assignment to variable", "function parameter assignment to variable", "function parameter assignment to variable", "function parameter assignment to variable", "function parameter assignment to variable", "function parameter assignment to variable", "function parameter assignment to variable", "function parameter assignment to variable", "function parameter assignment to variable", "function parameter assignment to variable", "function parameter assignment to variable", "function parameter assignment to variable", "function parameter assignment to variable", "function parameter assignment to variable", "function parameter assignment to variable", "function parameter"], "_raw_llm_output": "struct definition, map definition, map iteration, map lookup, map assignment, map key definition, map value definition, function definition, function call, function return, function parameter, function parameter definition, function parameter assignment, function parameter assignment to variable, function parameter assignment to variable, function parameter assignment to variable, function parameter assignment to variable, function parameter assignment to variable, function parameter assignment to variable, function parameter assignment to variable, function parameter assignment to variable, function parameter assignment to variable, function parameter assignment to variable, function parameter assignment to variable, function parameter assignment to variable, function parameter assignment to variable, function parameter assignment to variable, function parameter assignment to variable, function parameter assignment to variable, function parameter assignment to variable, function parameter assignment to variable, function parameter assignment to variable, function parameter assignment to variable, function parameter assignment to variable, function parameter assignment to variable, function parameter assignment to variable, function parameter assignment to variable, function parameter assignment to variable, function parameter assignment to variable, function parameter assignment to variable, function parameter assignment to variable, function parameter assignment to variable, function parameter assignment to variable, function parameter assignment to variable, function parameter assignment to variable, function parameter assignment to variable, function parameter assignment to variable, function parameter assignment to variable, function parameter"}
{"seed": "// NewWithoutJitter works similarly to New, except that the created\n// Backoff will not use jitter.\nfunc NewWithoutJitter(max time.Duration, interval time.Duration) *Backoff {\n\tb := New(max, interval)\n\tb.noJitter = true\n\treturn b\n}", "id": 12838, "concepts": ["struct definition", "struct field access", "struct field assignment"], "_raw_llm_output": "struct definition, struct field access, struct field assignment"}
{"seed": "// NewDcimRacksListParamsWithTimeout creates a new DcimRacksListParams object\n// with the ability to set a timeout on a request.\nfunc NewDcimRacksListParamsWithTimeout(timeout time.Duration) *DcimRacksListParams {\n\treturn &DcimRacksListParams{\n\t\ttimeout: timeout,\n\t}\n}", "id": 12848, "concepts": ["function definition", "function parameter", "function return value", "timeout handling"], "_raw_llm_output": "function definition, function parameter, function return value, timeout handling"}
{"seed": "// IDEQ applies the EQ predicate on the ID field.\nfunc IDEQ(id int) predicate.User {\n\treturn predicate.User(sql.FieldEQ(FieldID, id))\n}", "id": 12857, "concepts": ["struct composition", "struct composition with anonymous field", "field equality"], "_raw_llm_output": "struct composition, struct composition with anonymous field, field equality"}
{"seed": "// makeHandler builds a router to convert sub-domains into OpenFaaS gateway URLs with\n// a username prefix and suffix of the destination function.\n// i.e. system.o6s.io/dashboard\n//      becomes: gateway:8080/function/system-dashboard, where gateway:8080\n//      is specified in upstreamURL\nfunc makeHandler(c *http.Client, timeout time.Duration, upstreamURL string) func(w http.ResponseWriter, r *http.Request) {\n\n\tif strings.HasSuffix(upstreamURL, \"/\") == false {\n\t\tupstreamURL = upstreamURL + \"/\"\n\t}\n\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\n\t\tvar host string\n\n\t\ttldSepCount := 1\n\t\ttldSep := \".\"\n\t\tif len(r.Host) == 0 || strings.Count(r.Host, tldSep) <= tldSepCount {\n\t\t\tw.WriteHeader(http.StatusBadRequest)\n\t\t\tw.Write([]byte(\"invalid sub-domain in Host header\"))\n\t\t\treturn\n\t\t}\n\n\t\thost = r.Host[0:strings.Index(r.Host, tldSep)]\n\n\t\trequestURI := r.RequestURI\n\t\tif strings.HasPrefix(requestURI, \"/\") {\n\t\t\trequestURI = requestURI[1:]\n\t\t}\n\n\t\tupstreamFullURL := fmt.Sprintf(\"%sfunction/%s-%s\", upstreamURL, host, requestURI)\n\n\t\tif r.Body != nil {\n\t\t\tdefer r.Body.Close()\n\t\t}\n\n\t\treq, _ := http.NewRequest(r.Method, upstreamFullURL, r.Body)\n\n\t\ttimeoutContext, cancel := context.WithTimeout(context.Background(), timeout)\n\t\tdefer cancel()\n\n\t\tcopyHeaders(req.Header, &r.Header)\n\n\t\tres, resErr := c.Do(req.WithContext(timeoutContext))\n\t\tif resErr != nil {\n\t\t\tw.WriteHeader(http.StatusServiceUnavailable)\n\t\t\tw.Write([]byte(resErr.Error()))\n\n\t\t\tfmt.Printf(\"Upstream %s status: %d\\n\", upstreamFullURL, http.StatusBadGateway)\n\t\t\treturn\n\t\t}\n\n\t\tcopyHeaders(w.Header(), &res.Header)\n\t\tfmt.Printf(\"Upstream %s status: %d\\n\", upstreamFullURL, res.StatusCode)\n\n\t\tw.WriteHeader(res.StatusCode)\n\t\tif res.Body != nil {\n\t\t\tdefer res.Body.Close()\n\n\t\t\tbytesOut, _ := ioutil.ReadAll(res.Body)\n\t\t\tw.Write(bytesOut)\n\t\t}\n\t}\n}", "id": 12861, "concepts": ["http client", "http request", "http response", "http request/response handling", "http client/server interaction", "http client timeout", "http client/server error handling", "http client/server response handling", "http client/server response body handling", "http client/server response header handling", "http client/server response status code handling", "http client/server response status code handling", "http client/server response status code handling", "http client/server response status code handling", "http client/server response status code handling", "http client/server response status code handling", "http client/server response status code handling", "http client/server response status code handling", "http client/server response status code handling", "http client/server response status code handling", "http client/server response status code handling", "http client/server response status code handling", "http client/server response status code handling", "http client/server response status code handling", "http client/server response status code handling", "http client/server response status code handling", "http client/server response status code handling", "http client/server response status code handling", "http client/server response status code handling", "http client/server response status code handling", "http client/server response status code handling", "http client/server response status code handling", "http client"], "_raw_llm_output": "http client, http request, http response, http request/response handling, http client/server interaction, http client timeout, http client/server error handling, http client/server response handling, http client/server response body handling, http client/server response header handling, http client/server response status code handling, http client/server response status code handling, http client/server response status code handling, http client/server response status code handling, http client/server response status code handling, http client/server response status code handling, http client/server response status code handling, http client/server response status code handling, http client/server response status code handling, http client/server response status code handling, http client/server response status code handling, http client/server response status code handling, http client/server response status code handling, http client/server response status code handling, http client/server response status code handling, http client/server response status code handling, http client/server response status code handling, http client/server response status code handling, http client/server response status code handling, http client/server response status code handling, http client/server response status code handling, http client/server response status code handling, http client"}
{"seed": "// PrivateEndpoint_STATUS_PrivateEndpoint_SubResourceEmbeddedGenerator returns a generator of PrivateEndpoint_STATUS_PrivateEndpoint_SubResourceEmbedded instances for property testing.\n// We first initialize privateEndpoint_STATUS_PrivateEndpoint_SubResourceEmbeddedGenerator with a simplified generator based on the\n// fields with primitive types then replacing it with a more complex one that also handles complex fields\n// to ensure any cycles in the object graph properly terminate.\nfunc PrivateEndpoint_STATUS_PrivateEndpoint_SubResourceEmbeddedGenerator() gopter.Gen {\n\tif privateEndpoint_STATUS_PrivateEndpoint_SubResourceEmbeddedGenerator != nil {\n\t\treturn privateEndpoint_STATUS_PrivateEndpoint_SubResourceEmbeddedGenerator\n\t}\n\n\tgenerators := make(map[string]gopter.Gen)\n\tAddIndependentPropertyGeneratorsForPrivateEndpoint_STATUS_PrivateEndpoint_SubResourceEmbedded(generators)\n\tprivateEndpoint_STATUS_PrivateEndpoint_SubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(PrivateEndpoint_STATUS_PrivateEndpoint_SubResourceEmbedded{}), generators)\n\n\t// The above call to gen.Struct() captures the map, so create a new one\n\tgenerators = make(map[string]gopter.Gen)\n\tAddIndependentPropertyGeneratorsForPrivateEndpoint_STATUS_PrivateEndpoint_SubResourceEmbedded(generators)\n\tAddRelatedPropertyGeneratorsForPrivateEndpoint_STATUS_PrivateEndpoint_SubResourceEmbedded(generators)\n\tprivateEndpoint_STATUS_PrivateEndpoint_SubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(PrivateEndpoint_STATUS_PrivateEndpoint_SubResourceEmbedded{}), generators)\n\n\treturn privateEndpoint_STATUS_PrivateEndpoint_SubResourceEmbeddedGenerator\n}", "id": 12864, "concepts": ["struct definition", "property generation", "property generation for related types"], "_raw_llm_output": "struct definition, property generation, property generation for related types"}
{"seed": "// NewSparseSSHAuthority returns a new  SparseSSHAuthority.\nfunc NewSparseSSHAuthority() *SparseSSHAuthority {\n\treturn &SparseSSHAuthority{}\n}", "id": 12878, "concepts": ["struct definition", "struct field initialization", "struct field access"], "_raw_llm_output": "struct definition, struct field initialization, struct field access"}
{"seed": "// GetDeploymentLogsForDevice returns the deployment logs given a deployment ID and DevEUI.\nfunc GetDeploymentLogsForDevice(ctx context.Context, db sqlx.Queryer, deploymentID uuid.UUID, devEUI lorawan.EUI64) ([]DeploymentLog, error) {\n\tvar logs []DeploymentLog\n\terr := sqlx.Select(db, &logs, `\n\t\tselect\n\t\t\t*\n\t\tfrom\n\t\t\tdeployment_log\n\t\twhere\n\t\t\tdeployment_id = $1\n\t\t\tand dev_eui = $2\n\t\torder by\n\t\t\tcreated_at`,\n\t\tdeploymentID,\n\t\tdevEUI,\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"sql select error: %w\", err)\n\t}\n\n\treturn logs, nil\n}", "id": 12890, "concepts": ["sqlx package usage", "sql query execution", "sql query parameters", "sql query ordering"], "_raw_llm_output": "sqlx package usage, sql query execution, sql query parameters, sql query ordering"}
{"seed": "// Returns `true` if a construct is a stack element (i.e. part of the synthesized cloudformation template).\n//\n// Uses duck-typing instead of `instanceof` to allow stack elements from different\n// versions of this library to be included in the same stack.\n//\n// Returns: The construct as a stack element or undefined if it is not a stack element.\n// Experimental.\nfunc CfnContactChannel_IsCfnElement(x interface{}) *bool {\n\t_init_.Initialize()\n\n\tvar returns *bool\n\n\t_jsii_.StaticInvoke(\n\t\t\"monocdk.aws_ssmcontacts.CfnContactChannel\",\n\t\t\"isCfnElement\",\n\t\t[]interface{}{x},\n\t\t&returns,\n\t)\n\n\treturn returns\n}", "id": 12894, "concepts": ["duck-typing", "CDK pattern", "synthesized cloudformation template"], "_raw_llm_output": "duck-typing, CDK pattern, synthesized cloudformation template"}
{"seed": "// CreatedAtIn applies the In predicate on the \"created_at\" field.\nfunc CreatedAtIn(vs ...time.Time) predicate.User {\n\treturn predicate.User(sql.FieldIn(FieldCreatedAt, vs...))\n}", "id": 12897, "concepts": ["sql.FieldIn", "sql.FieldNotIn", "sql.FieldBetween", "sql.FieldNotBetween", "sql.FieldEq", "sql.FieldNotEq", "sql.FieldGt", "sql.FieldGte", "sql.FieldLt", "sql.FieldLte", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldBetween", "sql.FieldNotBetween", "sql.FieldEq", "sql.FieldNotEq", "sql.FieldGt", "sql.FieldGte", "sql.FieldLt", "sql.FieldLte", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldBetween", "sql.FieldNotBetween", "sql.FieldEq", "sql.FieldNotEq", "sql.FieldGt", "sql.FieldGte", "sql.FieldLt", "sql.FieldLte", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldBetween", "sql.FieldNotBetween", "sql.FieldEq", "sql.FieldNotEq", "sql.FieldGt", "sql.FieldGte", "sql.FieldLt", "sql.FieldLte", "sql.FieldLike", "sql"], "_raw_llm_output": "sql.FieldIn, sql.FieldNotIn, sql.FieldBetween, sql.FieldNotBetween, sql.FieldEq, sql.FieldNotEq, sql.FieldGt, sql.FieldGte, sql.FieldLt, sql.FieldLte, sql.FieldLike, sql.FieldNotLike, sql.FieldIn, sql.FieldNotIn, sql.FieldBetween, sql.FieldNotBetween, sql.FieldEq, sql.FieldNotEq, sql.FieldGt, sql.FieldGte, sql.FieldLt, sql.FieldLte, sql.FieldLike, sql.FieldNotLike, sql.FieldIn, sql.FieldNotIn, sql.FieldBetween, sql.FieldNotBetween, sql.FieldEq, sql.FieldNotEq, sql.FieldGt, sql.FieldGte, sql.FieldLt, sql.FieldLte, sql.FieldLike, sql.FieldNotLike, sql.FieldIn, sql.FieldNotIn, sql.FieldBetween, sql.FieldNotBetween, sql.FieldEq, sql.FieldNotEq, sql.FieldGt, sql.FieldGte, sql.FieldLt, sql.FieldLte, sql.FieldLike, sql"}
{"seed": "// https://leetcode.com/problems/coin-change/\n// You are given coins of different denominations and a total amount of money amount.\n// Write a function to compute the fewest number of coins that you need to make up that amount.\n// If that amount of money cannot be made up by any combination of the coins, return -1.\n// Example 1:\n//   Input: coins = [1, 2, 5], amount = 11\n//   Output: 3\n//   Explanation: 11 = 5 + 5 + 1\n// Example 2:\n//   Input: coins = [2], amount = 3\n//   Output: -1\n// Note: You may assume that you have an infinite number of each kind of coin.\n\nfunc coinChange(coins []int, amount int) int {\n\t// let a(i, j) be the result for first i coins to get j amount.\n\t// then a(i, j) = min( a(i-1, j), a(i, j-coins[i])+1)\n\t// base case a(i, 0)=0, a(i, coins[i])=1\n\tif amount == 0 {\n\t\treturn 0\n\t}\n\ta0 := make([]int, amount+1)\n\ta1 := make([]int, amount+1)\n\tfor i := 0; i < len(coins); i++ {\n\t\ta1[0] = 0 // a(i, 0) = 0\n\t\tfor j := 1; j <= amount; j++ {\n\t\t\tif j == coins[i] {\n\t\t\t\ta1[j] = 1 // a(i, coins[i]) = 1\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\ta1[j] = a0[j] // a(i, j) = a(i-1, j)\n\t\t\tif j-coins[i] > 0 && a1[j-coins[i]] > 0 {\n\t\t\t\tif a0[j] == 0 || a1[j-coins[i]]+1 < a0[j] {\n\t\t\t\t\ta1[j] = a1[j-coins[i]] + 1\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//fmt.Println(a1)\n\t\ta0, a1 = a1, a0\n\t}\n\tif a0[amount] == 0 {\n\t\treturn -1\n\t}\n\treturn a0[amount]\n}", "id": 12906, "concepts": ["dynamic programming", "recursion", "base case handling", "mathematical series"], "_raw_llm_output": "dynamic programming, recursion, base case handling, mathematical series"}
{"seed": "/**\n * Problem : https://www.hackerrank.com/challenges/p1-paper-cutting/problem\n *\n * Domain : Mathematics\n * Sub Domain : Fundamentals\n * Difficulty : Easy\n * Author : Ridwan Maulana Tanjung\n */\n\n// CuttingPaperSquares calculate NxM papers into 1x1 pieces\nfunc CuttingPaperSquares(n int32, m int32) int64 {\n        return int64(n)*int64(m)-1\n}", "id": 12910, "concepts": ["integer multiplication", "integer subtraction", "integer division", "integer division with remainder", "integer division with remainder", "integer division with remainder", "integer division with remainder", "integer division with remainder", "integer division with remainder", "integer division with remainder", "integer division with remainder", "integer division with remainder", "integer division with remainder", "integer division with remainder", "integer division with remainder", "integer division with remainder", "integer division with remainder", "integer division with remainder", "integer division with remainder", "integer division with remainder", "integer division with remainder", "integer division with remainder", "integer division with remainder", "integer division with remainder", "integer division with remainder", "integer division with remainder", "integer division with remainder", "integer division with remainder", "integer division with remainder", "integer division with remainder", "integer division with remainder", "integer division with remainder", "integer division with remainder", "integer division with remainder", "integer division with remainder", "integer division with remainder", "integer division with remainder", "integer division with remainder", "integer division with remainder", "integer division with remainder", "integer division with remainder", "integer division with remainder", "integer division with remainder", "integer division with remainder", "integer division with remainder", "integer division with remainder", "integer division with remainder", "integer division with remainder", "integer division with remainder", "integer division with remainder", "integer division with remainder", "integer division with remainder", ""], "_raw_llm_output": "integer multiplication, integer subtraction, integer division, integer division with remainder, integer division with remainder, integer division with remainder, integer division with remainder, integer division with remainder, integer division with remainder, integer division with remainder, integer division with remainder, integer division with remainder, integer division with remainder, integer division with remainder, integer division with remainder, integer division with remainder, integer division with remainder, integer division with remainder, integer division with remainder, integer division with remainder, integer division with remainder, integer division with remainder, integer division with remainder, integer division with remainder, integer division with remainder, integer division with remainder, integer division with remainder, integer division with remainder, integer division with remainder, integer division with remainder, integer division with remainder, integer division with remainder, integer division with remainder, integer division with remainder, integer division with remainder, integer division with remainder, integer division with remainder, integer division with remainder, integer division with remainder, integer division with remainder, integer division with remainder, integer division with remainder, integer division with remainder, integer division with remainder, integer division with remainder, integer division with remainder, integer division with remainder, integer division with remainder, integer division with remainder, integer division with remainder, integer division with remainder, integer division with remainder,"}
{"seed": "// FilterStringsBySuffix takes a list of filenames and filters\n// out those whose file extensions are not in the list that is\n// passed in. NOTE! (1) No periods on the okay file extensions.\n// (2) The comparison is case-INsensitive. \n\nfunc FilterStringsBySuffix(inputs []string,\n\tokayExts []string) (OKoutputs []string) {\n\tif okayExts == nil || len(okayExts) == 0 {\n\t\treturn inputs\n\t}\n\tif inputs == nil || len(inputs) == 0 {\n\t\treturn inputs\n\t}\n\tOKoutputs = make([]string, 0, len(inputs))\n\tfor _, instring := range inputs {\n\t\tsfx := FP.Ext(instring)\n\t\tif IsInSliceIgnoreCase(sfx, okayExts) {\n\t\t\tOKoutputs = append(OKoutputs, instring)\n\t\t}\n\t}\n\treturn OKoutputs\n}", "id": 12919, "concepts": ["string manipulation", "slice iteration", "function definition", "function call", "function return", "slice definition", "slice append", "slice length", "slice capacity", "slice iteration (range loop)", "string comparison", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", ""], "_raw_llm_output": "string manipulation, slice iteration, function definition, function call, function return, slice definition, slice append, slice length, slice capacity, slice iteration (range loop), string comparison, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation,"}
{"seed": "/*\nGiven an array of strings, group anagrams together.\n\nFor example, given: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"],\nReturn:\n\t[\n\t[\"ate\", \"eat\",\"tea\"],\n\t[\"nat\",\"tan\"],\n\t[\"bat\"]\n\t]\n\tNote: All inputs will be in lower-case.\n*/\n\n// The idea is to create a character set for each output set of anagrams.\n// We use an array of size math.MaxUint8 to store the number of occurences of\n// each character, then we make that array a key of a set which maps to the\n// anagrams list. Whenever a string with a same set of character reoccurs,\n//  that string is appended to the result set\n//\n// \tThe expected running time is O(N)\n// \tThe worst space complexity is O(|N|), worst case happens O(N) when the\n// \tgiven input strings are not anagrams to one another\nfunc groupAnagrams(strs []string) [][]string {\n\tvar set = make(map[[math.MaxUint8]int][]string)\n\tfor _, str := range strs {\n\t\tvar charSet = [math.MaxUint8]int{}\n\t\tfor _, letter := range []byte(str) {\n\t\t\tcharSet[letter]++\n\t\t}\n\t\tif _, ok := set[charSet]; !ok {\n\t\t\tset[charSet] = []string{str}\n\t\t} else {\n\t\t\tset[charSet] = append(set[charSet], str)\n\t\t}\n\t}\n\tres := make([][]string, 0, len(set))\n\tfor _, v := range set {\n\t\tres = append(res, v)\n\t}\n\treturn res\n}", "id": 12921, "concepts": ["string manipulation", "character set", "map", "slice", "function definition", "basic algorithm"], "_raw_llm_output": "string manipulation, character set, map, slice, function definition, basic algorithm"}
{"seed": "//\n// ToString function converts GUID to string\n// \"{XXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}\".\n//\n// The resulting string is uppercase.\n//\nfunc ToString(guid *windows.GUID) string {\n\treturn fmt.Sprintf(\"{%06X-%04X-%04X-%04X-%012X}\", guid.Data1, guid.Data2, guid.Data3, guid.Data4[:2], guid.Data4[2:])\n}", "id": 12922, "concepts": ["string formatting", "GUID handling", "windows package usage"], "_raw_llm_output": "string formatting, GUID handling, windows package usage"}
{"seed": "// GetNotificationOccurrenceUserService returns an instance of the Notification_Occurrence_User SoftLayer service\nfunc GetNotificationOccurrenceUserService(sess *session.Session) Notification_Occurrence_User {\n\treturn Notification_Occurrence_User{Session: sess}\n}", "id": 12928, "concepts": ["session package usage", "struct definition", "method definition"], "_raw_llm_output": "session package usage, struct definition, method definition"}
{"seed": "// SomeFloat64Err finds item in the list based on supplied function.\n//\n// Takes 2 input:\n//\t1. Function\n//\t2. List\n//\n// Returns:\n//\t(bool,err).\n//\tTrue if condition satisfies, else false\nfunc SomeFloat64Err(f func(float64) (bool, error), list []float64) (bool, error) {\n\tif f == nil {\n\t\treturn false, nil\n\t}\n\tfor _, v := range list {\n\t\tr, err := f(v)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\tif r {\n\t\t\treturn true, nil\n\t\t}\n\t}\n\treturn false, nil\n}", "id": 12930, "concepts": ["function definition", "function composition", "function composition with error handling", "function composition with error handling"], "_raw_llm_output": "function definition, function composition, function composition with error handling, function composition with error handling"}
{"seed": "// Register registers a driver to be initialized automatically on Init().\n//\n// The d.String() value must be unique across all registered drivers.\n//\n// It is an error to call Register() after Init() was called.\nfunc Register(d Driver) error {\n\tmu.Lock()\n\tdefer mu.Unlock()\n\tif state != nil {\n\t\treturn errors.New(\"periph: can't call Register() after Init()\")\n\t}\n\n\tn := d.String()\n\tif _, ok := byName[n]; ok {\n\t\treturn errors.New(\"periph: driver with same name \" + strconv.Quote(n) + \" was already registered\")\n\t}\n\tbyName[n] = d\n\treturn nil\n}", "id": 12931, "concepts": ["map iteration", "mutex", "error handling", "string formatting", "string comparison"], "_raw_llm_output": "map iteration, mutex, error handling, string formatting, string comparison"}
{"seed": "// signHashUsingPublicKey produces a signature,\n// for a given input, which is located within the given (parent) transaction,\n// using the given (optional private) key, and using any extra objects (on top of the normal properties).\n// The public key is to be given, as based on that the function can figure out what algorithm to use,\n// and this also allows the function to know how to interpret the given (private) key.\nfunc signHashUsingPublicKey(pk PublicKey, tx Transaction, key interface{}, extraObjects []interface{}) ([]byte, error) {\n\tswitch pk.Algorithm {\n\tcase SignatureAlgoEd25519:\n\t\t// decode the ed-secretKey\n\t\tvar edSK crypto.SecretKey\n\t\tswitch k := key.(type) {\n\t\tcase crypto.SecretKey:\n\t\t\tedSK = k\n\t\tcase ByteSlice:\n\t\t\tif len(k) != crypto.SecretKeySize {\n\t\t\t\treturn nil, errors.New(\"invalid secret key size\")\n\t\t\t}\n\t\t\tcopy(edSK[:], k)\n\t\tcase []byte:\n\t\t\tif len(k) != crypto.SecretKeySize {\n\t\t\t\treturn nil, errors.New(\"invalid secret key size\")\n\t\t\t}\n\t\t\tcopy(edSK[:], k)\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"%T is an unknown secret key type\", key)\n\t\t}\n\t\tif edSK.IsNil() {\n\t\t\treturn nil, crypto.ErrSecretNilKey\n\t\t}\n\t\tsigHash, err := tx.SignatureHash(extraObjects...)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tsig := crypto.SignHash(sigHash, edSK)\n\t\treturn sig[:], nil\n\n\tdefault:\n\t\treturn nil, ErrUnknownSignAlgorithmType\n\t}\n}", "id": 12946, "concepts": ["crypto package usage", "byte slice handling", "interface conversion", "error handling", "switch statement", "function definition", "function call", "function return", "function parameter", "function return", "function parameter", "function return", "function parameter", "function return", "function parameter", "function return", "function parameter", "function return", "function parameter", "function return", "function parameter", "function return", "function parameter", "function return", "function parameter", "function return", "function parameter", "function return", "function parameter", "function return", "function parameter", "function return", "function parameter", "function return", "function parameter", "function return", "function parameter", "function return", "function parameter", "function return", "function parameter", "function return", "function parameter", "function return", "function parameter", "function return", "function parameter", "function return", "function parameter", "function return", "function parameter", "function return", "function parameter", "function return", "function parameter", "function return", "function parameter", "function return", "function parameter", "function return", "function parameter", "function return", "function parameter", "function return", "function parameter", "function return", "function parameter", "function return", "function parameter", "function return", "function parameter", "function return", "function parameter", "function return", "function parameter", "function return", "function parameter", "function return", "function parameter", "function return", "function parameter", "function return", "function parameter", "function return", "function"], "_raw_llm_output": "crypto package usage, byte slice handling, interface conversion, error handling, switch statement, function definition, function call, function return, function parameter, function return, function parameter, function return, function parameter, function return, function parameter, function return, function parameter, function return, function parameter, function return, function parameter, function return, function parameter, function return, function parameter, function return, function parameter, function return, function parameter, function return, function parameter, function return, function parameter, function return, function parameter, function return, function parameter, function return, function parameter, function return, function parameter, function return, function parameter, function return, function parameter, function return, function parameter, function return, function parameter, function return, function parameter, function return, function parameter, function return, function parameter, function return, function parameter, function return, function parameter, function return, function parameter, function return, function parameter, function return, function parameter, function return, function parameter, function return, function parameter, function return, function parameter, function return, function parameter, function return, function parameter, function return, function parameter, function return, function parameter, function return, function parameter, function return, function parameter, function return, function"}
{"seed": "// NewFollowersPage initializes result type FollowersPage from viewed result\n// type FollowersPage.\nfunc NewFollowersPage(vres *followingviews.FollowersPage) *FollowersPage {\n\treturn newFollowersPage(vres.Projected)\n}", "id": 12956, "concepts": ["type conversion", "pointer handling", "struct initialization"], "_raw_llm_output": "type conversion, pointer handling, struct initialization"}
{"seed": "// IsNil returns whether an error is nil or not.\n// It can be used with ErrorCollection or generic errors\nfunc IsNil(err error) bool {\n\tswitch v := err.(type) {\n\tcase *ErrorCollection:\n\t\tif len(v.Errors) == 0 {\n\t\t\treturn true\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\tdefault:\n\t\tif err == nil {\n\t\t\treturn true\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n}", "id": 12962, "concepts": ["error handling (type assertion)", "error handling (nil check)"], "_raw_llm_output": "error handling (type assertion), error handling (nil check)"}
{"seed": "/*\n\tUsing Map := While traversing every element add the element as key and its position as its value in a map\n  \t\t\t\t Check the required value (i.e target - arr[i]) in the map\n  \t\t\t\t If the map contains the required value then we have two elements with the required sum and\n\t\t\t\t return the positions.\n\tTime Complexity : O(n)\n*/\nfunc twoSumEfficient(arr []int, target int) []int {\n\tm := make(map[int]int)\n\tfor i := 0; i < len(arr); i++ {\n\t\tcompliment := target - arr[i]\n\t\tif _, ok := m[compliment]; ok {\n\t\t\treturn []int{m[compliment], i}\n\t\t}\n\t\tm[arr[i]] = i\n\t}\n\treturn []int{}\n}", "id": 12969, "concepts": ["map", "array iteration", "map lookup"], "_raw_llm_output": "map, array iteration, map lookup"}
{"seed": "// setupTests creates a clusterHandler with a fake xds client for control over\n// xds client.\nfunc setupTests() (*clusterHandler, *fakeclient.Client) {\n\txdsC := fakeclient.NewClient()\n\tch := newClusterHandler(&cdsBalancer{xdsClient: xdsC})\n\treturn ch, xdsC\n}", "id": 12975, "concepts": ["fake client", "xds client", "cds balancer", "cluster handler"], "_raw_llm_output": "fake client, xds client, cds balancer, cluster handler"}
{"seed": "// newMarkAllocator returns a mark allocator initialised with the specified\n// base and size.\nfunc newMarkAllocator(base, size int) *markAllocator {\n\tma := &markAllocator{\n\t\tmarks: make([]uint32, 0, size),\n\t}\n\tfor i := 0; i < size; i++ {\n\t\tma.put(uint32(base + i))\n\t}\n\treturn ma\n}", "id": 12976, "concepts": ["slice initialisation", "slice append", "slice capacity", "slice length", "slice\nusage", "slice iteration (range loop)", "bitwise operations", "bit shifting", "integer summation", "integer division"], "_raw_llm_output": "slice initialisation, slice append, slice capacity, slice length, slice\nusage, slice iteration (range loop), bitwise operations, bit shifting,\ninteger summation, integer division"}
{"seed": "// GetManageAccountIdentitiesByEmail is used to retrieve all of the identities (UID and Profiles),\n// associated with a specified email in Cloud Storage.\n// Note: This is intended for specific workflows where an email may be associated to multiple UIDs.\nfunc GetManageAccountIdentitiesByEmail(email string) (AccountProfilesData, error) {\n\tdata := new(AccountProfilesData)\n\treq, reqErr := CreateRequest(\"GET\", os.Getenv(\"DOMAIN\")+\"/identity/v2/manage/account/identities\", \"\")\n\tif reqErr != nil {\n\t\treturn *data, reqErr\n\t}\n\n\tq := req.URL.Query()\n\tq.Add(\"email\", email)\n\treq.URL.RawQuery = q.Encode()\n\treq.Header.Add(\"content-Type\", \"application/x-www-form-urlencoded\")\n\treq.Header.Add(\"X-LoginRadius-ApiKey\", os.Getenv(\"APIKEY\"))\n\treq.Header.Add(\"X-LoginRadius-ApiSecret\", os.Getenv(\"APISECRET\"))\n\n\terr := RunRequest(req, data)\n\treturn *data, err\n}", "id": 12978, "concepts": ["http.Request", "http.Client", "URL query parameter handling", "http.Header", "http.Request.URL", "http.Request.Header", "http.Request.Body", "http.Request.URL.Query", "http.Request.URL.RawQuery", "http.Request.URL.Query.Encode", "http.Request.URL.Query.Add", "http.Request.URL.Query.Get", "http.Request.URL.Query.Set", "http.Request.URL.Query.Del", "http.Request.URL.Query.Encode", "http.Request.URL.Query.Encode", "http.Request.URL.Query.Encode", "http.Request.URL.Query.Encode", "http.Request.URL.Query.Encode", "http.Request.URL.Query.Encode", "http.Request.URL.Query.Encode", "http.Request.URL.Query.Encode", "http.Request.URL.Query.Encode", "http.Request.URL.Query.Encode", "http.Request.URL.Query.Encode", "http.Request.URL.Query.Encode", "http.Request.URL.Query.Encode", "http.Request.URL.Query.Encode", "http.Request.URL.Query.Encode", "http.Request"], "_raw_llm_output": "http.Request, http.Client, URL query parameter handling, http.Header, http.Request.URL, http.Request.Header, http.Request.Body, http.Request.URL.Query, http.Request.URL.RawQuery, http.Request.URL.Query.Encode, http.Request.URL.Query.Add, http.Request.URL.Query.Get, http.Request.URL.Query.Set, http.Request.URL.Query.Del, http.Request.URL.Query.Encode, http.Request.URL.Query.Encode, http.Request.URL.Query.Encode, http.Request.URL.Query.Encode, http.Request.URL.Query.Encode, http.Request.URL.Query.Encode, http.Request.URL.Query.Encode, http.Request.URL.Query.Encode, http.Request.URL.Query.Encode, http.Request.URL.Query.Encode, http.Request.URL.Query.Encode, http.Request.URL.Query.Encode, http.Request.URL.Query.Encode, http.Request.URL.Query.Encode, http.Request.URL.Query.Encode, http.Request"}
{"seed": "// BlobNEQ applies the NEQ predicate on the \"blob\" field.\nfunc BlobNEQ(v []byte) predicate.User {\n\treturn predicate.User(sql.FieldNEQ(FieldBlob, v))\n}", "id": 12979, "concepts": ["sql.FieldNEQ", "predicate.User", "sql.Field", "sql.FieldNEQ usage"], "_raw_llm_output": "sql.FieldNEQ, predicate.User, sql.Field, sql.FieldNEQ usage"}
{"seed": "// RelativePosition_Values returns all elements of the RelativePosition enum\nfunc RelativePosition_Values() []string {\n\treturn []string{\n\t\tRelativePositionBeforeProgram,\n\t\tRelativePositionAfterProgram,\n\t}\n}", "id": 12987, "concepts": ["enumerations", "basic function definition"], "_raw_llm_output": "enumerations, basic function definition"}
{"seed": "// ParseUint32 parses and returns the *Uint32 value represented by the provided\n// string, or an error if parsing is unsuccessful.\nfunc ParseUint32(s string) (*Uint32, error) {\n\ti, err := strconv.ParseInt(s, 0, 32)\n\tif err != nil {\n\t\treturn nil, makeParseError(s, types.T_uint32, err)\n\t}\n\treturn NewUint32(uint32(i)), nil\n}", "id": 12996, "concepts": ["string parsing", "error handling", "integer conversion"], "_raw_llm_output": "string parsing, error handling, integer conversion"}
{"seed": "// PossibleTemplateDeploymentPreflightOptionsValues returns the possible values for the TemplateDeploymentPreflightOptions const type.\nfunc PossibleTemplateDeploymentPreflightOptionsValues() []TemplateDeploymentPreflightOptions {\n\treturn []TemplateDeploymentPreflightOptions{\n\t\tTemplateDeploymentPreflightOptionsDeploymentRequests,\n\t\tTemplateDeploymentPreflightOptionsNone,\n\t\tTemplateDeploymentPreflightOptionsRegisteredOnly,\n\t\tTemplateDeploymentPreflightOptionsTestOnly,\n\t\tTemplateDeploymentPreflightOptionsValidationRequests,\n\t}\n}", "id": 12997, "concepts": ["const type", "enum type", "possible values"], "_raw_llm_output": "const type, enum type, possible values"}
{"seed": "// RealBucketARN returns a string representation of the given S3 bucket ARN\n// which matches the official format defined by AWS.\n// https://docs.aws.amazon.com/service-authorization/latest/reference/list_amazons3.html#amazons3-resources-for-iam-policies\n//\n// This is necessary because our AWSS3Source API accepts that bucket ARNs\n// include a region and an account ID, which are both absent from the public\n// ARN.\nfunc RealBucketARN(arn apis.ARN) string {\n\tarn.Region = \"\"\n\tarn.AccountID = \"\"\n\n\treturn arn.String()\n}", "id": 13008, "concepts": ["string manipulation", "string formatting", "API usage"], "_raw_llm_output": "string manipulation, string formatting, API usage"}
{"seed": "// ParseListPrivateNetworksResponse parses an HTTP response from a ListPrivateNetworksWithResponse call\nfunc ParseListPrivateNetworksResponse(rsp *http.Response) (*ListPrivateNetworksResponse, error) {\n\tbodyBytes, err := ioutil.ReadAll(rsp.Body)\n\tdefer rsp.Body.Close()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse := &ListPrivateNetworksResponse{\n\t\tBody:         bodyBytes,\n\t\tHTTPResponse: rsp,\n\t}\n\n\tswitch {\n\tcase strings.Contains(rsp.Header.Get(\"Content-Type\"), \"json\") && rsp.StatusCode == 200:\n\t\tvar dest struct {\n\t\t\tPrivateNetworks *[]PrivateNetwork `json:\"private-networks,omitempty\"`\n\t\t}\n\t\tif err := json.Unmarshal(bodyBytes, &dest); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresponse.JSON200 = &dest\n\n\t}\n\n\treturn response, nil\n}", "id": 13009, "concepts": ["HTTP response parsing", "JSON parsing", "error handling"], "_raw_llm_output": "HTTP response parsing, JSON parsing, error handling"}
{"seed": "// ClearNetworkConfiguration clears the azure-vnet.json contents.\n// This will be called only when reboot is detected - This is windows specific\nfunc ClearNetworkConfiguration() (bool, error) {\n\tjsonStore := CNIRuntimePath + \"azure-vnet.json\"\n\tlog.Printf(\"Deleting the json store %s\", jsonStore)\n\tcmd := exec.Command(\"cmd\", \"/c\", \"del\", jsonStore)\n\n\tif err := cmd.Run(); err != nil {\n\t\tlog.Printf(\"Error deleting the json store %s\", jsonStore)\n\t\treturn true, err\n\t}\n\n\treturn true, nil\n}", "id": 13016, "concepts": ["file deletion", "cmd.Run", "exec.Command", "os.Exit", "error handling"], "_raw_llm_output": "file deletion, cmd.Run, exec.Command, os.Exit, error handling"}
{"seed": "// IsEncodingError returns whether the error is an EncodingError.\nfunc IsEncodingError(err error) bool {\n\t_, ok := err.(*EncodingError)\n\treturn ok\n}", "id": 13025, "concepts": ["error handling (errors.As)", "error type assertion"], "_raw_llm_output": "error handling (errors.As), error type assertion"}
{"seed": "// CheckAndConsumeKey checks a given key whether it is valid or not, and\n// consumes it if valid. Returns whether the key given was valid.\nfunc CheckAndConsumeKey(key string) bool {\n\tmut.Lock()\n\tdefer mut.Unlock()\n\tfor i, k := range validKeys {\n\t\tif k == key {\n\t\t\tvalidKeys = append(validKeys[:i], validKeys[i+1:]...)\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}", "id": 13029, "concepts": ["mutex usage", "slice manipulation", "basic function definition"], "_raw_llm_output": "mutex usage, slice manipulation, basic function definition"}
{"seed": "// NewAPICheck returns a new *APICheck\nfunc NewAPICheck() *APICheck {\n\n\treturn &APICheck{\n\t\tModelVersion:     1,\n\t\tAuthorized:       map[string]bool{},\n\t\tTargetIdentities: []string{},\n\t}\n}", "id": 13037, "concepts": ["struct definition", "map definition", "slice definition", "basic function definition"], "_raw_llm_output": "struct definition, map definition, slice definition, basic function definition"}
{"seed": "// String converts an string to a pointer\nfunc String(v string) *string {\n\treturn &v\n}", "id": 13044, "concepts": ["pointer", "string conversion"], "_raw_llm_output": "pointer, string conversion"}
{"seed": "// RiskDetailPUnknownFutureValue returns a pointer to RiskDetailVUnknownFutureValue\nfunc RiskDetailPUnknownFutureValue() *RiskDetail {\n\tv := RiskDetailVUnknownFutureValue\n\treturn &v\n}", "id": 13067, "concepts": ["pointer usage", "struct definition"], "_raw_llm_output": "pointer usage, struct definition"}
{"seed": "// Dl_ is a convenience wrapper for Dl without the attrs argument.\nfunc Dl_(children ...HTML) HTML {\n  return Dl(nil, children...)\n}", "id": 13079, "concepts": ["HTML struct definition", "HTML struct field definition", "HTML struct field initialization", "HTML struct field access", "HTML struct field assignment", "HTML struct field type assertion", "HTML struct field method definition", "HTML struct field method invocation"], "_raw_llm_output": "HTML struct definition, HTML struct field definition, HTML struct field initialization, HTML struct field access, HTML struct field assignment, HTML struct field type assertion, HTML struct field method definition, HTML struct field method invocation"}
{"seed": "// WithRunner replaces the runner of the CollectorIntegration.\n// The runner function should run while the context provided is not done.\nfunc WithRunner(runner func(context.Context) error) CollectorIntegrationConfig {\n\treturn func(i *CollectorIntegration) {\n\t\ti.runner = runner\n\t}\n}", "id": 13080, "concepts": ["function composition", "function composition with function arguments", "function composition with function return values", "function composition with function return values and function arguments"], "_raw_llm_output": "function composition, function composition with function arguments, function composition with function return values, function composition with function return values and function arguments"}
{"seed": "// Create a new Queue instance.\n// If maxFlowSize > maxQueueSize or if helper is nil then it will panic.\n// The maxFlowSize value limits the total size of all items that can be queued in a single flow.\n// The maxQueueSize value limits the total size of all items that can be in the queue.\n// It is recomeneded that maxQueueSize be set to maxFlowSize*<Max # of expected flows>, and\n// that maxFlowSize be at least twice the largest expected item size.\n//\nfunc NewQueue(maxQueueSize, maxFlowSize uint64, helper Interface) *Queue {\n\tif maxFlowSize > maxQueueSize {\n\t\tpanic(\"MaxFlowSize > MaxQueueSize\")\n\t}\n\n\tif helper == nil {\n\t\tpanic(\"helper is nil\")\n\t}\n\n\tq := new(Queue)\n\tq.cond.L = &q.lock\n\tq.maxQueueSize = maxQueueSize\n\tq.maxFlowSize = maxFlowSize\n\tq.helper = helper\n\tq.flows = make(map[uint64]*flowInfo)\n\n\treturn q\n}", "id": 13084, "concepts": ["map", "mutex", "condition variable", "concurrency", "error handling"], "_raw_llm_output": "map, mutex, condition variable, concurrency, error handling"}
{"seed": "// generateTestPairs generates test pairs.\n// It uses a post-processed cartesian productof a set of\n// continuous integers with itself to determine mail account\n// pairings for testing. This tests every sensible combination\n// of the servers given.\nfunc generateTestPairs(amountofaccounts int) [][]int {\n\n\tconst amountofpairmembers = 2\n\tvar r [][]int\n\n\tcp := cartesianSelfProduct(amountofpairmembers, generateContinuousIntArray(amountofaccounts))\n\tr = sortAndRemoveIdentical(cp)\n\tr = removeDuplicatesFromArray(r)\n\tr = decrementValuesByOne(r)\n\treturn r\n\n}", "id": 13099, "concepts": ["slice iteration (range loop)", "slice manipulation", "slice comparison", "slice sorting", "slice removal", "slice deduplication", "slice mutation", "slice generation", "slice generation (cartesian product)", "slice generation (continuous integer array)", "slice generation (cartesian product of continuous integer array)", "slice generation (cartesian product of continuous integer array with itself)", "slice generation (cartesian product of continuous integer array with itself)"], "_raw_llm_output": "slice iteration (range loop), slice manipulation, slice comparison, slice sorting, slice removal, slice deduplication, slice mutation, slice generation, slice generation (cartesian product), slice generation (continuous integer array), slice generation (cartesian product of continuous integer array), slice generation (cartesian product of continuous integer array with itself), slice generation (cartesian product of continuous integer array with itself)"}
{"seed": "// projectRefPipelineForCommitQueue is an aggregation pipeline to find projects that are\n// 1) explicitly enabled, or that default to the repo which is enabled, and\n// 2) the commit queue is explicitly enabled, or defaults to the repo which has the commit queue enabled\nfunc projectRefPipelineForCommitQueueEnabled() []bson.M {\n\treturn []bson.M{\n\t\tlookupRepoStep,\n\t\t{\"$match\": bson.M{\n\t\t\t\"$and\": []bson.M{\n\t\t\t\t{\"$or\": []bson.M{\n\t\t\t\t\t{ProjectRefEnabledKey: true},\n\t\t\t\t\t{ProjectRefEnabledKey: nil, bsonutil.GetDottedKeyName(\"repo_ref\", RepoRefEnabledKey): true},\n\t\t\t\t}},\n\t\t\t\t{\"$or\": []bson.M{\n\t\t\t\t\t{\n\t\t\t\t\t\tbsonutil.GetDottedKeyName(projectRefCommitQueueKey, commitQueueEnabledKey): true,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tbsonutil.GetDottedKeyName(projectRefCommitQueueKey, commitQueueEnabledKey):          nil,\n\t\t\t\t\t\tbsonutil.GetDottedKeyName(\"repo_ref\", RepoRefCommitQueueKey, commitQueueEnabledKey): true,\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n}", "id": 13104, "concepts": ["bson package usage", "bson.M usage", "bson.D usage", "bson.M lookup", "bson.M match", "bson.M aggregation pipeline", "bson.M aggregation pipeline lookup", "bson.M aggregation pipeline match", "bson.M aggregation pipeline match $or", "bson.M aggregation pipeline match $and", "bson.M aggregation pipeline match $and $or", "bson.M aggregation pipeline match $and $or $or", "bson.M aggregation pipeline match $and $or $or $or", "bson.M aggregation pipeline match $and $or $or $or $or", "bson.M aggregation pipeline match $and $or $or $or $or $or", "bson.M aggregation pipeline match $and $or $or $or $or $or $or", "bson.M aggregation pipeline match $and $or $or $or $or $or $or $or", "bson.M aggregation pipeline match $and $or $or $or $or $or $or $or $or", "bson.M aggregation pipeline match $and $or $or $or $or $or $or $or $or $or", "bson.M aggregation pipeline match $and $or $or $or $or $or $or $or"], "_raw_llm_output": "bson package usage, bson.M usage, bson.D usage, bson.M lookup, bson.M match, bson.M aggregation pipeline, bson.M aggregation pipeline lookup, bson.M aggregation pipeline match, bson.M aggregation pipeline match $or, bson.M aggregation pipeline match $and, bson.M aggregation pipeline match $and $or, bson.M aggregation pipeline match $and $or $or, bson.M aggregation pipeline match $and $or $or $or, bson.M aggregation pipeline match $and $or $or $or $or, bson.M aggregation pipeline match $and $or $or $or $or $or, bson.M aggregation pipeline match $and $or $or $or $or $or $or, bson.M aggregation pipeline match $and $or $or $or $or $or $or $or, bson.M aggregation pipeline match $and $or $or $or $or $or $or $or $or, bson.M aggregation pipeline match $and $or $or $or $or $or $or $or $or $or, bson.M aggregation pipeline match $and $or $or $or $or $or $or $or"}
{"seed": "// NewPostDockerRegistriesSearchListParams creates a new PostDockerRegistriesSearchListParams object\n// with the default values initialized.\nfunc NewPostDockerRegistriesSearchListParams() *PostDockerRegistriesSearchListParams {\n\tvar ()\n\treturn &PostDockerRegistriesSearchListParams{\n\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 13109, "concepts": ["struct definition", "anonymous struct definition", "function definition", "default value initialization"], "_raw_llm_output": "struct definition, anonymous struct definition, function definition, default value initialization"}
{"seed": "// BulkCreditSamedayIsNil applies the IsNil predicate on the \"bulkCreditSameday\" field.\nfunc BulkCreditSamedayIsNil() predicate.Bulk {\n\treturn predicate.Bulk(func(s *sql.Selector) {\n\t\ts.Where(sql.IsNull(s.C(FieldBulkCreditSameday)))\n\t})\n}", "id": 13112, "concepts": ["sql.Selector", "sql.IsNull", "sql.C", "predicate.Bulk", "predicate.Bulk"], "_raw_llm_output": "sql.Selector, sql.IsNull, sql.C, predicate.Bulk, predicate.Bulk"}
{"seed": "// MustKinToQuarks calls KinToQuarks, panicking if there's an error.\n//\n// This should only be used if you know for sure this will not panic.\nfunc MustKinToQuarks(val string) int64 {\n\tresult, err := KinToQuarks(val)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn result\n}", "id": 13128, "concepts": ["error handling (panic)", "error handling (idiomatic if err != nil)", "error handling (errors.Is)"], "_raw_llm_output": "error handling (panic), error handling (idiomatic if err != nil), error handling (errors.Is)"}
{"seed": "// NewEventItemRequestBuilder instantiates a new EventItemRequestBuilder and sets the default values.\nfunc NewEventItemRequestBuilder(rawUrl string, requestAdapter i2ae4187f7daee263371cb1c977df639813ab50ffa529013b7437480d1ec0158f.RequestAdapter)(*EventItemRequestBuilder) {\n    urlParams := make(map[string]string)\n    urlParams[\"request-raw-url\"] = rawUrl\n    return NewEventItemRequestBuilderInternal(urlParams, requestAdapter)\n}", "id": 13146, "concepts": ["request builder", "request adapter", "request URL"], "_raw_llm_output": "request builder, request adapter, request URL"}
{"seed": "// Main represents the HTML element 'main'.\n// For more information visit https://www.w3schools.com/tags/tag_main.asp.\nfunc Main(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"main\", Attributes: attrs, Children: children}\n}", "id": 13148, "concepts": ["HTML tree", "HTML element definition", "HTML attribute definition", "HTML element usage"], "_raw_llm_output": "HTML tree, HTML element definition, HTML attribute definition, HTML element usage"}
{"seed": "// New creates and initializes a new Scorecard\nfunc New() Scorecard {\n\treturn make(Scorecard)\n}", "id": 13152, "concepts": ["map initialization", "map creation"], "_raw_llm_output": "map initialization, map creation"}
{"seed": "// Param represents the HTML void element 'param'.\n// For more information visit https://www.w3schools.com/tags/tag_param.asp.\nfunc Param(attrs []htmlgo.Attribute) HTML {\n\treturn &htmlgo.Tree{Tag: \"param\", Attributes: attrs, SelfClosing: true}\n}", "id": 13154, "concepts": ["HTML generation", "HTML tree traversal", "HTML generation", "HTML tree traversal", "HTML generation", "HTML tree traversal", "HTML generation", "HTML tree traversal", "HTML generation", "HTML tree traversal", "HTML generation", "HTML tree traversal", "HTML generation", "HTML tree traversal", "HTML generation", "HTML tree traversal", "HTML generation", "HTML tree traversal", "HTML generation", "HTML tree traversal", "HTML generation", "HTML tree traversal", "HTML generation", "HTML tree traversal", "HTML generation", "HTML tree traversal", "HTML generation", "HTML tree traversal", "HTML generation", "HTML tree traversal", "HTML generation", "HTML tree traversal", "HTML generation", "HTML tree traversal", "HTML generation", "HTML tree traversal", "HTML generation", "HTML tree traversal", "HTML generation", "HTML tree traversal", "HTML generation", "HTML tree traversal", "HTML generation", "HTML tree traversal", "HTML generation", "HTML tree traversal", "HTML generation", "HTML tree traversal", "HTML generation", "HTML tree traversal", "HTML generation", "HTML tree traversal", "HTML generation", "HTML tree traversal", "HTML generation", "HTML tree traversal", "HTML generation", "HTML tree traversal", "HTML generation", "HTML tree traversal", "HTML generation", "HTML tree traversal", "HTML generation", "HTML tree traversal", "HTML generation", "HTML tree traversal", "HTML generation", "HTML tree traversal", "HTML generation", "HTML tree traversal", "HTML generation", "HTML tree traversal", "HTML generation", ""], "_raw_llm_output": "HTML generation, HTML tree traversal, HTML generation, HTML tree traversal, HTML generation, HTML tree traversal, HTML generation, HTML tree traversal, HTML generation, HTML tree traversal, HTML generation, HTML tree traversal, HTML generation, HTML tree traversal, HTML generation, HTML tree traversal, HTML generation, HTML tree traversal, HTML generation, HTML tree traversal, HTML generation, HTML tree traversal, HTML generation, HTML tree traversal, HTML generation, HTML tree traversal, HTML generation, HTML tree traversal, HTML generation, HTML tree traversal, HTML generation, HTML tree traversal, HTML generation, HTML tree traversal, HTML generation, HTML tree traversal, HTML generation, HTML tree traversal, HTML generation, HTML tree traversal, HTML generation, HTML tree traversal, HTML generation, HTML tree traversal, HTML generation, HTML tree traversal, HTML generation, HTML tree traversal, HTML generation, HTML tree traversal, HTML generation, HTML tree traversal, HTML generation, HTML tree traversal, HTML generation, HTML tree traversal, HTML generation, HTML tree traversal, HTML generation, HTML tree traversal, HTML generation, HTML tree traversal, HTML generation, HTML tree traversal, HTML generation, HTML tree traversal, HTML generation, HTML tree traversal, HTML generation, HTML tree traversal, HTML generation, HTML tree traversal, HTML generation,"}
{"seed": "// ReplaceReferenceSequenceDictionaryFromSamFile returns a filter for\n// replacing the reference sequence dictionary in a Header with one\n// parsed from the given SAM/DICT file.\nfunc ReplaceReferenceSequenceDictionaryFromSamFile(samFile string) (f sam.Filter, err error) {\n\tinput, err := sam.Open(samFile, true)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer func() {\n\t\tnerr := input.Close()\n\t\tif err == nil {\n\t\t\terr = nerr\n\t\t}\n\t}()\n\theader, _, err := sam.ParseHeader(input.Reader)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn ReplaceReferenceSequenceDictionary(header.SQ), nil\n}", "id": 13157, "concepts": ["sam.Filter", "sam.Header", "sam.Header.SQ", "sam.Open", "sam.ParseHeader", "sam.Reader", "sam.SQ", "sam.SQ.Name", "sam.SQ.Sequence", "sam.SQ.Length", "sam.SQ.Md5", "sam.SQ.Url", "sam.SQ.Md5", "sam.SQ.Md5", "sam.SQ.Md5", "sam.SQ.Md5", "sam.SQ.Md5", "sam.SQ.Md5", "sam.SQ.Md5", "sam.SQ.Md5", "sam.SQ.Md5", "sam.SQ.Md5", "sam.SQ.Md5", "sam.SQ.Md5", "sam.SQ.Md5", "sam.SQ.Md5", "sam.SQ.Md5", "sam.SQ.Md5", "sam.SQ.Md5", "sam.SQ.Md5", "sam.SQ.Md5", "sam.SQ.Md5", "sam.SQ.Md5", "sam.SQ.Md5", "sam.SQ.Md5", "sam.SQ.Md5", "sam.SQ.Md5", "sam.SQ.Md5", "sam.SQ.Md5", "sam.SQ."], "_raw_llm_output": "sam.Filter, sam.Header, sam.Header.SQ, sam.Open, sam.ParseHeader, sam.Reader, sam.SQ, sam.SQ.Name, sam.SQ.Sequence, sam.SQ.Length, sam.SQ.Md5, sam.SQ.Url, sam.SQ.Md5, sam.SQ.Md5, sam.SQ.Md5, sam.SQ.Md5, sam.SQ.Md5, sam.SQ.Md5, sam.SQ.Md5, sam.SQ.Md5, sam.SQ.Md5, sam.SQ.Md5, sam.SQ.Md5, sam.SQ.Md5, sam.SQ.Md5, sam.SQ.Md5, sam.SQ.Md5, sam.SQ.Md5, sam.SQ.Md5, sam.SQ.Md5, sam.SQ.Md5, sam.SQ.Md5, sam.SQ.Md5, sam.SQ.Md5, sam.SQ.Md5, sam.SQ.Md5, sam.SQ.Md5, sam.SQ.Md5, sam.SQ.Md5, sam.SQ."}
{"seed": "// SensitiveType returns a Sensitive dgo.Type that wraps the given dgo.Type\nfunc SensitiveType(args []interface{}) dgo.Type {\n\tswitch len(args) {\n\tcase 0:\n\t\treturn DefaultSensitiveType\n\tcase 1:\n\t\tif st, ok := Value(args[0]).(dgo.Type); ok {\n\t\t\treturn &sensitiveType{wrapped: st}\n\t\t}\n\t\tpanic(illegalArgument(`SensitiveType`, `Type`, args, 0))\n\t}\n\tpanic(illegalArgumentCount(`SensitiveType`, 0, 1, len(args)))\n}", "id": 13159, "concepts": ["type definition", "type assertion", "type conversion", "type embedding"], "_raw_llm_output": "type definition, type assertion, type conversion, type embedding"}
{"seed": "// DefaultExprNotNil applies the NotNil predicate on the \"default_expr\" field.\nfunc DefaultExprNotNil() predicate.User {\n\treturn predicate.User(sql.FieldNotNull(FieldDefaultExpr))\n}", "id": 13167, "concepts": ["sql.FieldNotNull", "predicate.User", "sql package usage"], "_raw_llm_output": "sql.FieldNotNull, predicate.User, sql package usage"}
{"seed": "// NicknameHasSuffix applies the HasSuffix predicate on the \"nickname\" field.\nfunc NicknameHasSuffix(v string) predicate.User {\n\treturn predicate.User(sql.FieldHasSuffix(FieldNickname, v))\n}", "id": 13176, "concepts": ["predicate.User", "sql.FieldHasSuffix"], "_raw_llm_output": "predicate.User, sql.FieldHasSuffix"}
{"seed": "// WithMaxAge creates a new Option that sets the\n// max age of a log file before it gets purged from\n// the file system.\nfunc WithMaxAge(d time.Duration) Option {\n\treturn OptionFn(func(rl *RotateLogs) error {\n\t\trl.maxAge = d\n\t\treturn nil\n\t})\n}", "id": 13191, "concepts": ["Option pattern", "time.Duration", "function composition"], "_raw_llm_output": "Option pattern, time.Duration, function composition"}
{"seed": "// PossibleMinimumTLSVersionValues returns an array of possible values for the MinimumTLSVersion const type.\nfunc PossibleMinimumTLSVersionValues() []MinimumTLSVersion {\n\treturn []MinimumTLSVersion{MinimumTLSVersionOneFullStopTwo, MinimumTLSVersionOneFullStopZero}\n}", "id": 13192, "concepts": ["const declaration", "array declaration", "array iteration"], "_raw_llm_output": "const declaration, array declaration, array iteration"}
{"seed": "// NewMessageSigner creates a new instance for signing and verifying published messages\n// If getPublicKey is not provided, verification of signature is skipped\nfunc NewMessageSigner(messenger IMessenger, signingKey *ecdsa.PrivateKey,\n\tgetPublicKey func(address string) *ecdsa.PublicKey,\n) *MessageSigner {\n\n\tsigner := &MessageSigner{\n\t\tGetPublicKey: getPublicKey,\n\t\tmessenger:    messenger,\n\t\tsignMessages: true,\n\t\tprivateKey:   signingKey, // private key for signing\n\t}\n\treturn signer\n}", "id": 13193, "concepts": ["struct definition", "anonymous function", "function definition", "function call", "function return", "function pointer", "function composition", "function composition with anonymous function", "function composition with function pointer", "function composition with function call", "function composition with function definition", "function composition with function definition and return", "function composition with function definition and return and function call", "function composition with function definition and return and function call and function definition", "function composition with function definition and return and function call and function definition and return", "function composition with function definition and return and function call and function definition and return and function call and function definition and return", "function composition with function definition and return and function call and function definition and return and function call and function definition and return and function call"], "_raw_llm_output": "struct definition, anonymous function, function definition, function call, function return, function pointer, function composition, function composition with anonymous function, function composition with function pointer, function composition with function call, function composition with function definition, function composition with function definition and return, function composition with function definition and return and function call, function composition with function definition and return and function call and function definition, function composition with function definition and return and function call and function definition and return, function composition with function definition and return and function call and function definition and return and function call and function definition and return, function composition with function definition and return and function call and function definition and return and function call and function definition and return and function call"}
{"seed": "// NewRootCmd creates a new instance of the root command\nfunc NewRootCmd() *cobra.Command {\n\tctx := context.Background()\n\n\tcmd := &cobra.Command{\n\t\tUse:   \"grpc-sample\",\n\t\tShort: \"Go gRPC sample is a sample to realize micro service with grpc.\",\n\t\tLong: `\nGo gRPC sample is a sample to realize micro service with grpc.`,\n\t}\n\n\tcmd.AddCommand(NewServerStartCmd(ctx))\n\tcmd.AddCommand(NewServiceStartCmd(ctx))\n\n\treturn cmd\n}", "id": 13198, "concepts": ["cobra package usage", "context package usage", "basic function definition"], "_raw_llm_output": "cobra package usage, context package usage, basic function definition"}
{"seed": "// CreatedAtNEQ applies the NEQ predicate on the \"created_at\" field.\nfunc CreatedAtNEQ(v time.Time) predicate.User {\n\treturn predicate.User(sql.FieldNEQ(FieldCreatedAt, v))\n}", "id": 13200, "concepts": ["predicate.User", "sql.FieldNEQ", "time.Time"], "_raw_llm_output": "predicate.User, sql.FieldNEQ, time.Time"}
{"seed": "// NewPostDockerRegistriesUUIDSearchListParamsWithContext creates a new PostDockerRegistriesUUIDSearchListParams object\n// with the default values initialized, and the ability to set a context for a request\nfunc NewPostDockerRegistriesUUIDSearchListParamsWithContext(ctx context.Context) *PostDockerRegistriesUUIDSearchListParams {\n\tvar ()\n\treturn &PostDockerRegistriesUUIDSearchListParams{\n\n\t\tContext: ctx,\n\t}\n}", "id": 13203, "concepts": ["context package usage", "function definition", "basic function parameters"], "_raw_llm_output": "context package usage, function definition, basic function parameters"}
{"seed": "// newGenState creates a new genState instance, initialised with the default state\n// required for code generation.\nfunc newGenState() *genState {\n\treturn &genState{\n\t\t// Mark the name that is used for the binary type as a reserved name\n\t\t// within the output structs.\n\t\tdefinedGlobals: map[string]bool{\n\t\t\tygot.BinaryTypeName: true,\n\t\t\tygot.EmptyTypeName:  true,\n\t\t},\n\t\tuniqueDirectoryNames:         make(map[string]string),\n\t\tuniqueEnumeratedTypedefNames: make(map[string]string),\n\t\tuniqueIdentityNames:          make(map[string]string),\n\t\tuniqueEnumeratedLeafNames:    make(map[string]string),\n\t\tuniqueProtoMsgNames:          make(map[string]map[string]bool),\n\t\tuniqueProtoPackages:          make(map[string]string),\n\t\tgeneratedUnions:              make(map[string]bool),\n\t}\n}", "id": 13217, "concepts": ["map iteration (range loop)", "map lookup", "map creation", "map deletion", "map iteration (range loop)", "map lookup", "map creation", "map deletion", "map iteration (range loop)", "map lookup", "map creation", "map deletion", "map iteration (range loop)", "map lookup", "map creation", "map deletion", "map iteration (range loop)", "map lookup", "map creation", "map deletion", "map iteration (range loop)", "map lookup", "map creation", "map deletion", "map iteration (range loop)", "map lookup", "map creation", "map deletion", "map iteration (range loop)", "map lookup", "map creation", "map deletion", "map iteration (range loop)", "map lookup", "map creation", "map deletion", "map iteration (range loop)", "map lookup", "map creation", "map deletion", "map iteration (range loop)", "map lookup", "map creation", "map deletion", "map iteration (range loop)", "map lookup", "map creation", "map deletion", "map iteration (range loop)", "map lookup", "map creation", "map deletion", "map iteration (range loop)", "map lookup", "map creation", "map deletion", "map iteration (range loop)", "map lookup", "map creation", "map deletion", "map iteration (range loop)", "map lookup", "map creation", "map deletion", "map iteration (range loop)", "map lookup", "map creation", "map deletion", ""], "_raw_llm_output": "map iteration (range loop), map lookup, map creation, map deletion, map iteration (range loop), map lookup, map creation, map deletion, map iteration (range loop), map lookup, map creation, map deletion, map iteration (range loop), map lookup, map creation, map deletion, map iteration (range loop), map lookup, map creation, map deletion, map iteration (range loop), map lookup, map creation, map deletion, map iteration (range loop), map lookup, map creation, map deletion, map iteration (range loop), map lookup, map creation, map deletion, map iteration (range loop), map lookup, map creation, map deletion, map iteration (range loop), map lookup, map creation, map deletion, map iteration (range loop), map lookup, map creation, map deletion, map iteration (range loop), map lookup, map creation, map deletion, map iteration (range loop), map lookup, map creation, map deletion, map iteration (range loop), map lookup, map creation, map deletion, map iteration (range loop), map lookup, map creation, map deletion, map iteration (range loop), map lookup, map creation, map deletion, map iteration (range loop), map lookup, map creation, map deletion,"}
{"seed": "// GenerateBuildMetadata creates a BuildMetadata instance representing a fresh (as yet unbuilt)\n// build of the component specified by the given componentID.\nfunc GenerateBuildMetadata(componentID string) (BuildMetadata, error) {\n\tif componentID == \"\" {\n\t\treturn BuildMetadata{}, ErrEmptyComponentID\n\t}\n\tcreatedAt := time.Now()\n\tbuildID := fmt.Sprintf(\"%s%s:%d\", DockerImagePrefix, componentID, createdAt.Unix())\n\treturn BuildMetadata{ID: buildID, ComponentID: componentID, CreatedAt: createdAt}, nil\n}", "id": 13225, "concepts": ["time package usage", "string formatting", "basic function definition", "error handling"], "_raw_llm_output": "time package usage, string formatting, basic function definition, error handling"}
{"seed": "// With returns a new contextual logger with keyvals prepended to those passed\n// to calls to Log. If logger is also a contextual logger created by With or\n// WithPrefix, keyvals is appended to the existing context.\n//\n// The returned Logger replaces all value elements (odd indexes) containing a\n// Valuer with their generated value for each call to its Log method.\nfunc With(logger Logger, keyvals ...interface{}) Logger {\n\treturn &ctLogger{\n\t\tlogger: kit_log.With(logger.ToGoKitLogger(), keyvals...),\n\t}\n}", "id": 13226, "concepts": ["contextual logging", "kit/log package usage", "context usage", "contextual logger usage"], "_raw_llm_output": "contextual logging, kit/log package usage, context usage, contextual logger usage"}
{"seed": "// HeroPlayedLT applies the LT predicate on the \"hero_played\" field.\nfunc HeroPlayedLT(v uint) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.LT(s.C(FieldHeroPlayed), v))\n\t})\n}", "id": 13228, "concepts": ["sql package usage", "sql.Selector", "sql.Where", "sql.LT", "sql.C", "sql.Field", "sql.Predicate"], "_raw_llm_output": "sql package usage, sql.Selector, sql.Where, sql.LT, sql.C, sql.Field, sql.Predicate"}
{"seed": "// ToObserverOutput specifies that the output should be collected in memory so\n// that they can be read by an observer by calling ObserverLogs().\nfunc ToObserverOutput() Option {\n\treturn func(cfg *Config) {\n\t\tcfg.toObserver = true\n\t\tcfg.ToStderr = false\n\t}\n}", "id": 13238, "concepts": ["function composition", "function options", "function composition"], "_raw_llm_output": "function composition, function options, function composition"}
{"seed": "// ValidateConfig validates a testrun config element.\nfunc ValidateConfig(fldPath *field.Path, config tmv1beta1.ConfigElement) field.ErrorList {\n\tvar allErrs field.ErrorList\n\tif config.Name == \"\" {\n\t\tallErrs = append(allErrs, field.Required(fldPath.Child(\"name\"), \"Required value\"))\n\t}\n\n\t// configmaps should either have a value or a value from defined\n\tif len(config.Value) == 0 && config.ValueFrom == nil {\n\t\tallErrs = append(allErrs, field.Required(fldPath.Child(\"value/valueFrom\"), \"A config must consist of a value or a reference to a value\"))\n\t}\n\n\t// if a valuefrom is defined then a configmap or a secret reference should be defined\n\tif config.ValueFrom != nil {\n\t\tallErrs = append(allErrs, strconf.Validate(fldPath.Child(\"valueFrom\"), config.ValueFrom)...)\n\t}\n\n\tif config.Type != tmv1beta1.ConfigTypeEnv && config.Type != tmv1beta1.ConfigTypeFile {\n\t\tallErrs = append(allErrs, field.Invalid(fldPath.Child(\"type\"), config.Type, \"unknown config type\"))\n\t\treturn allErrs\n\t}\n\n\tif config.Type == tmv1beta1.ConfigTypeEnv {\n\t\tif errs := validation.IsEnvVarName(config.Name); len(errs) != 0 {\n\t\t\tallErrs = append(allErrs, field.Invalid(fldPath.Child(\"name\"), config.Name, strings.Join(errs, \":\")))\n\t\t}\n\t\tif errs := validation.IsCIdentifier(config.Name); len(errs) != 0 {\n\t\t\tallErrs = append(allErrs, field.Invalid(fldPath.Child(\"name\"), config.Name, strings.Join(errs, \":\")))\n\t\t}\n\t}\n\n\tif config.Type == tmv1beta1.ConfigTypeFile {\n\t\tif config.Path == \"\" {\n\t\t\tallErrs = append(allErrs, field.Required(fldPath.Child(\"path\"), fmt.Sprintf(\"path is required for configtype %q\", tmv1beta1.ConfigTypeFile)))\n\t\t}\n\t\t// check if value is base64 encoded\n\t\tif config.Value != \"\" {\n\t\t\tif _, err := base64.StdEncoding.DecodeString(config.Value); err != nil {\n\t\t\t\tallErrs = append(allErrs, field.Invalid(fldPath.Child(\"value\"), config.Value, \"Value must be base64 encoded\"))\n\t\t\t}\n\t\t}\n\t}\n\treturn allErrs\n}", "id": 13250, "concepts": ["string manipulation", "rune handling", "character comparison", "string validation", "base64 encoding", "field validation", "field path manipulation", "field error handling", "field error list", "field error list append", "field error list append", "field error list append", "field error list append", "field error list append", "field error list append", "field error list append", "field error list append", "field error list append", "field error list append", "field error list append", "field error list append", "field error list append", "field error list append", "field error list append", "field error list append", "field error list append", "field error list append", "field error list append", "field error list append", "field error list append", "field error list append", "field error list append", "field error list append", "field error list append", "field error list append", "field error list append", "field error list append", "field error list append", "field error list append", "field error list append", "field error list append", "field error list append", "field error list append", "field error list append", "field error list append", "field error list append", "field error list append", "field error list append", "field error list append", "field error list append", "field error list append", "field error list append", "field error list append", "field error"], "_raw_llm_output": "string manipulation, rune handling, character comparison, string validation, base64 encoding, field validation, field path manipulation, field error handling, field error list, field error list append, field error list append, field error list append, field error list append, field error list append, field error list append, field error list append, field error list append, field error list append, field error list append, field error list append, field error list append, field error list append, field error list append, field error list append, field error list append, field error list append, field error list append, field error list append, field error list append, field error list append, field error list append, field error list append, field error list append, field error list append, field error list append, field error list append, field error list append, field error list append, field error list append, field error list append, field error list append, field error list append, field error list append, field error list append, field error list append, field error list append, field error list append, field error list append, field error list append, field error list append, field error list append, field error list append, field error list append, field error"}
{"seed": "// isGoMod reports if uri is a go.mod file.\nfunc isGoMod(uri span.URI) bool {\n\treturn filepath.Base(uri.Filename()) == \"go.mod\"\n}", "id": 13270, "concepts": ["filepath package usage", "string manipulation"], "_raw_llm_output": "filepath package usage, string manipulation"}
{"seed": "// toYAML takes an interface, marshals it to yaml, and returns a string. It will\n// always return a string, even on marshal error (empty string).\n//\n// This code is under copyright (full attribution in NOTICE) and is from:\n\n// https://github.com/helm/helm/blob/a499b4b179307c267bdf3ec49b880e3dbd2a5591/pkg/engine/funcs.go#L83\n//\n// This is designed to be called from a template.\nfunc toYAML(v interface{}) string {\n\tdata, err := yaml.Marshal(v)\n\tif err != nil {\n\t\t// Swallow errors inside of a template.\n\t\treturn \"\"\n\t}\n\n\treturn strings.TrimSuffix(string(data), \"\\n\")\n}", "id": 13271, "concepts": ["yaml package usage", "interface conversion", "string manipulation", "error handling"], "_raw_llm_output": "yaml package usage, interface conversion, string manipulation, error handling"}
{"seed": "// ParseNodeConfigurationIDInsensitively parses 'input' case-insensitively into a NodeConfigurationId\n// note: this method should only be used for API response data and not user input\nfunc ParseNodeConfigurationIDInsensitively(input string) (*NodeConfigurationId, error) {\n\tparser := resourceids.NewParserFromResourceIdType(NodeConfigurationId{})\n\tparsed, err := parser.Parse(input, true)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"parsing %q: %+v\", input, err)\n\t}\n\n\tvar ok bool\n\tid := NodeConfigurationId{}\n\n\tif id.SubscriptionId, ok = parsed.Parsed[\"subscriptionId\"]; !ok {\n\t\treturn nil, resourceids.NewSegmentNotSpecifiedError(id, \"subscriptionId\", *parsed)\n\t}\n\n\tif id.ResourceGroupName, ok = parsed.Parsed[\"resourceGroupName\"]; !ok {\n\t\treturn nil, resourceids.NewSegmentNotSpecifiedError(id, \"resourceGroupName\", *parsed)\n\t}\n\n\tif id.AutomationAccountName, ok = parsed.Parsed[\"automationAccountName\"]; !ok {\n\t\treturn nil, resourceids.NewSegmentNotSpecifiedError(id, \"automationAccountName\", *parsed)\n\t}\n\n\tif id.NodeConfigurationName, ok = parsed.Parsed[\"nodeConfigurationName\"]; !ok {\n\t\treturn nil, resourceids.NewSegmentNotSpecifiedError(id, \"nodeConfigurationName\", *parsed)\n\t}\n\n\treturn &id, nil\n}", "id": 13272, "concepts": ["string manipulation", "string parsing", "resource id parsing", "string comparison"], "_raw_llm_output": "string manipulation, string parsing, resource id parsing, string comparison"}
{"seed": "// ReadRatePlanRefRTRate reads a full RatePlanRefRTRate structure from the database based on the supplied row object\nfunc ReadRatePlanRefRTRate(row *sql.Row, a *RatePlanRefRTRate) error {\n\terr := row.Scan(&a.RPRID, &a.BID, &a.RTID, &a.FLAGS, &a.Val, &a.CreateTS, &a.CreateBy, &a.LastModTime, &a.LastModBy)\n\tSkipSQLNoRowsError(&err)\n\treturn err\n}", "id": 13280, "concepts": ["SQL package usage", "database usage", "SQL injection", "error handling", "SQL query execution"], "_raw_llm_output": "SQL package usage, database usage, SQL injection, error handling, SQL query execution"}
{"seed": "// NewCreateFeedCreated creates a CreateFeedCreated with default headers values\nfunc NewCreateFeedCreated() *CreateFeedCreated {\n\treturn &CreateFeedCreated{}\n}", "id": 13285, "concepts": ["struct definition", "struct field initialization", "struct field access", "struct field type"], "_raw_llm_output": "struct definition, struct field initialization, struct field access, struct field type"}
{"seed": "// tokenFromTreeID returns the record token for a tlog tree.\nfunc tokenFromTreeID(treeID int64) []byte {\n\tb := make([]byte, 8)\n\tbinary.LittleEndian.PutUint64(b, uint64(treeID))\n\treturn b\n}", "id": 13286, "concepts": ["byte array manipulation", "binary encoding", "integer conversion"], "_raw_llm_output": "byte array manipulation, binary encoding, integer conversion"}
{"seed": "// NewRevertInstanceToSnapshotRequest calls the generic RevertInstanceToSnapshot builder with application/json body\nfunc NewRevertInstanceToSnapshotRequest(server string, instanceId string, body RevertInstanceToSnapshotJSONRequestBody) (*http.Request, error) {\n\tvar bodyReader io.Reader\n\tbuf, err := json.Marshal(body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tbodyReader = bytes.NewReader(buf)\n\treturn NewRevertInstanceToSnapshotRequestWithBody(server, instanceId, \"application/json\", bodyReader)\n}", "id": 13287, "concepts": ["http.Request", "io.Reader", "json.Marshal", "bytes.NewReader", "standard library usage"], "_raw_llm_output": "http.Request, io.Reader, json.Marshal, bytes.NewReader, standard library usage"}
{"seed": "// ByteToStr converts []byte to string\r\n// Params:\r\n//      inputBytes: []byte to be converted to string\r\n//\r\n// Return: string converted from []byte\r\n// Note: This will stop at the first null-byte\r\nfunc ByteToStr(inputBytes []byte) string {\r\n\treturn string(inputBytes[:])\r\n}", "id": 13292, "concepts": ["byte handling", "string conversion", "string manipulation"], "_raw_llm_output": "byte handling, string conversion, string manipulation"}
{"seed": "// NewTokenHasSuffix applies the HasSuffix predicate on the \"new_token\" field.\nfunc NewTokenHasSuffix(v string) predicate.User {\n\treturn predicate.User(sql.FieldHasSuffix(FieldNewToken, v))\n}", "id": 13299, "concepts": ["sql.FieldHasSuffix", "predicate.User", "sql.FieldHasSuffix usage"], "_raw_llm_output": "sql.FieldHasSuffix, predicate.User, sql.FieldHasSuffix usage"}
{"seed": "// IsNotFound determines whether an error indicates something was not found.\n// It does this by walking down the stack of errors built by pkg/errors and\n// returning true for the first error that implements the following interface:\n//\n// type notfounder interface {\n//   NotFound()\n// }\nfunc IsNotFound(err error) bool {\n\tif err == nil {\n\t\treturn false\n\t}\n\tfor {\n\t\tif _, ok := err.(interface {\n\t\t\tNotFound()\n\t\t}); ok {\n\t\t\treturn true\n\t\t}\n\t\tif c, ok := err.(interface {\n\t\t\tCause() error\n\t\t}); ok {\n\t\t\terr = c.Cause()\n\t\t\tcontinue\n\t\t}\n\t\treturn false\n\t}\n}", "id": 13303, "concepts": ["error handling (interface assertion)", "error handling (pkg/errors)", "error handling (walking the error stack)"], "_raw_llm_output": "error handling (interface assertion), error handling (pkg/errors), error handling (walking the error stack)"}
{"seed": "// PossibleCustomHTTPSProvisioningSubstateValues returns an array of possible values for the CustomHTTPSProvisioningSubstate const type.\nfunc PossibleCustomHTTPSProvisioningSubstateValues() []CustomHTTPSProvisioningSubstate {\n\treturn []CustomHTTPSProvisioningSubstate{CustomHTTPSProvisioningSubstateCertificateDeleted, CustomHTTPSProvisioningSubstateCertificateDeployed, CustomHTTPSProvisioningSubstateDeletingCertificate, CustomHTTPSProvisioningSubstateDeployingCertificate, CustomHTTPSProvisioningSubstateDomainControlValidationRequestApproved, CustomHTTPSProvisioningSubstateDomainControlValidationRequestRejected, CustomHTTPSProvisioningSubstateDomainControlValidationRequestTimedOut, CustomHTTPSProvisioningSubstateIssuingCertificate, CustomHTTPSProvisioningSubstatePendingDomainControlValidationREquestApproval, CustomHTTPSProvisioningSubstateSubmittingDomainControlValidationRequest}\n}", "id": 13308, "concepts": ["const type", "type switch", "array iteration", "array definition"], "_raw_llm_output": "const type, type switch, array iteration, array definition"}
{"seed": "// ReadRentableUseType reads a full RentableUseType structure of data from the database based on the supplied Row pointer.\nfunc ReadRentableUseType(row *sql.Row, a *RentableUseType) error {\n\terr := row.Scan(\n\t\t&a.UTID,\n\t\t&a.RID,\n\t\t&a.BID,\n\t\t&a.DtStart,\n\t\t&a.DtStop,\n\t\t&a.Comment,\n\t\t&a.UseType,\n\t\t&a.CreateTS,\n\t\t&a.CreateBy,\n\t\t&a.LastModTime,\n\t\t&a.LastModBy)\n\tSkipSQLNoRowsError(&err)\n\treturn err\n}", "id": 13318, "concepts": ["sql.Row", "sql.Scan", "error handling (SkipSQLNoRowsError)", "struct definition", "field access"], "_raw_llm_output": "sql.Row, sql.Scan, error handling (SkipSQLNoRowsError), struct definition, field access"}
{"seed": "// graphRoots returns the roots of the graph.  That is, it returns the node's\n// values for all nodes which contain an input degree of 0.\nfunc graphRoots(graph hashGraph) []*wire.MsgTx {\n\troots := make([]*wire.MsgTx, 0, len(graph))\n\tfor _, node := range graph {\n\t\tif node.inDegree == 0 {\n\t\t\troots = append(roots, node.value)\n\t\t}\n\t}\n\treturn roots\n}", "id": 13323, "concepts": ["hash map", "hash graph", "hash table", "hash function", "hash collision", "graph", "graph traversal", "graph node", "graph edge", "graph root", "graph leaf", "graph traversal", "graph traversal algorithm", "graph traversal algorithm complexity", "graph traversal algorithm implementation"], "_raw_llm_output": "hash map, hash graph, hash table, hash function, hash collision, graph, graph traversal, graph node, graph edge, graph root, graph leaf, graph traversal, graph traversal algorithm, graph traversal algorithm complexity, graph traversal algorithm implementation"}
{"seed": "// NewGetMachineRolesListAllSpacesParams creates a new GetMachineRolesListAllSpacesParams object\n// with the default values initialized.\nfunc NewGetMachineRolesListAllSpacesParams() *GetMachineRolesListAllSpacesParams {\n\tvar ()\n\treturn &GetMachineRolesListAllSpacesParams{\n\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 13330, "concepts": ["struct definition", "struct initialization", "struct field initialization", "method definition", "method call", "method parameter"], "_raw_llm_output": "struct definition, struct initialization, struct field initialization, method definition, method call, method parameter"}
{"seed": "// Keygen_ is a convenience wrapper for Keygen without the attrs argument.\nfunc Keygen_(children ...HTML) HTML {\n  return Keygen(nil, children...)\n}", "id": 13331, "concepts": ["HTML", "HTML tag", "HTML attribute", "HTML attribute value", "HTML attribute key", "HTML attribute key value", "HTML attribute key value pair"], "_raw_llm_output": "HTML, HTML tag, HTML attribute, HTML attribute value, HTML attribute key, HTML attribute key value, HTML attribute key value pair"}
{"seed": "// FlagType registers a new type. By default strings, boolean, integer,\n// floating point, and time.Duration values are understood. Registering a new\n// type will allow the specified type (or any pointer indirection of the type),\n// to be used as struct fields or as elements within a slice. The flag.Getter\n// returned by the FlagGetterFactory should return a \"deep copy\" of the flag\n// value when Get() is invoked. This ensures that return values of\n// LoadFromFlags will not share values between invocations unexpectedly.\nfunc FlagType(typ interface{}, factory FlagGetterFactory) Option {\n\treturn flagTypeOpt{\n\t\ttyp:     reflect.TypeOf(typ),\n\t\tfactory: factory,\n\t}\n}", "id": 13336, "concepts": ["reflection", "interface", "struct", "flag package usage"], "_raw_llm_output": "reflection, interface, struct, flag package usage"}
{"seed": "// Max creates a Constraint which will declare an instance is valid\n// if its value is less than or equal to refValue.\nfunc Max[\n\tValueT typecons.Ordered,\n](refValue ValueT) OrderedConstraint[ValueT] {\n\treturn Func(\n\t\tfmt.Sprintf(\"max %v\", refValue),\n\t\tLessThanOrEqualTo(refValue).IsValid)\n}", "id": 13341, "concepts": ["type constraints", "type parameters", "type constraints", "type parameters", "type constraints", "type parameters", "type constraints", "type parameters", "type constraints", "type parameters", "type constraints", "type parameters", "type constraints", "type parameters", "type constraints", "type parameters", "type constraints", "type parameters", "type constraints", "type parameters", "type constraints", "type parameters", "type constraints", "type parameters", "type constraints", "type parameters", "type constraints", "type parameters", "type constraints", "type parameters", "type constraints", "type parameters", "type constraints", "type parameters", "type constraints", "type parameters", "type constraints", "type parameters", "type constraints", "type parameters", "type constraints", "type parameters", "type constraints", "type parameters", "type constraints", "type parameters", "type constraints", "type parameters", "type constraints", "type parameters", "type constraints", "type parameters", "type constraints", "type parameters", "type constraints", "type parameters", "type constraints", "type parameters", "type constraints", "type parameters", "type constraints", "type parameters", "type constraints", "type parameters", "type constraints", "type parameters", "type constraints", "type parameters", "type constraints", "type parameters", "type constraints", "type parameters", "type constraints", "type parameters", "type constraints", "type parameters", "type constraints", "type parameters", "type constraints", "type parameters", "type constraints", "type parameters", "type constraints", "type parameters", "type constraints", ""], "_raw_llm_output": "type constraints, type parameters, type constraints, type parameters, type constraints, type parameters, type constraints, type parameters, type constraints, type parameters, type constraints, type parameters, type constraints, type parameters, type constraints, type parameters, type constraints, type parameters, type constraints, type parameters, type constraints, type parameters, type constraints, type parameters, type constraints, type parameters, type constraints, type parameters, type constraints, type parameters, type constraints, type parameters, type constraints, type parameters, type constraints, type parameters, type constraints, type parameters, type constraints, type parameters, type constraints, type parameters, type constraints, type parameters, type constraints, type parameters, type constraints, type parameters, type constraints, type parameters, type constraints, type parameters, type constraints, type parameters, type constraints, type parameters, type constraints, type parameters, type constraints, type parameters, type constraints, type parameters, type constraints, type parameters, type constraints, type parameters, type constraints, type parameters, type constraints, type parameters, type constraints, type parameters, type constraints, type parameters, type constraints, type parameters, type constraints, type parameters, type constraints, type parameters, type constraints, type parameters, type constraints, type parameters, type constraints,"}
{"seed": "// NewBofaChkUpdateOK creates BofaChkUpdateOK with default headers values\nfunc NewBofaChkUpdateOK() *BofaChkUpdateOK {\n\n\treturn &BofaChkUpdateOK{}\n}", "id": 13344, "concepts": ["struct definition", "struct field initialization", "struct field access"], "_raw_llm_output": "struct definition, struct field initialization, struct field access"}
{"seed": "// DefaultExprContains applies the Contains predicate on the \"default_expr\" field.\nfunc DefaultExprContains(v string) predicate.User {\n\treturn predicate.User(sql.FieldContains(FieldDefaultExpr, v))\n}", "id": 13346, "concepts": ["predicate.User", "sql.FieldContains"], "_raw_llm_output": "predicate.User, sql.FieldContains"}
{"seed": "// ConvertToMap accepts a map[string]interface{} or struct and converts it to a\n// map[string]*dynamodb.AttributeValue.\n//\n// If in contains any structs, it is first JSON encoded/decoded it to convert it\n// to a map[string]interface{}, so `json` struct tags are respected.\n//\n// Deprecated: Use MarshalMap instead\nfunc ConvertToMap(in interface{}) (item map[string]*dynamodb.AttributeValue, err error) {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tif e, ok := r.(runtime.Error); ok {\n\t\t\t\terr = e\n\t\t\t} else if s, ok := r.(string); ok {\n\t\t\t\terr = fmt.Errorf(s)\n\t\t\t} else {\n\t\t\t\terr = r.(error)\n\t\t\t}\n\t\t\titem = nil\n\t\t}\n\t}()\n\n\tif in == nil {\n\t\treturn nil, awserr.New(\"SerializationError\",\n\t\t\t\"in must be a map[string]interface{} or struct, got <nil>\", nil)\n\t}\n\n\tv := reflect.ValueOf(in)\n\tif v.Kind() != reflect.Struct && !(v.Kind() == reflect.Map && v.Type().Key().Kind() == reflect.String) {\n\t\treturn nil, awserr.New(\"SerializationError\",\n\t\t\tfmt.Sprintf(\"in must be a map[string]interface{} or struct, got %s\",\n\t\t\t\tv.Type().String()),\n\t\t\tnil)\n\t}\n\n\tif isTyped(reflect.TypeOf(in)) {\n\t\tvar out map[string]interface{}\n\t\tin = convertToUntyped(in, out)\n\t}\n\n\titem = make(map[string]*dynamodb.AttributeValue)\n\tfor k, v := range in.(map[string]interface{}) {\n\t\titem[k] = convertTo(v)\n\t}\n\n\treturn item, nil\n}", "id": 13357, "concepts": ["reflect package usage", "map iteration", "interface conversion", "map creation"], "_raw_llm_output": "reflect package usage, map iteration, interface conversion, map creation"}
{"seed": "//New createa a new instance of the AuthnReqListsService client.\n//\n// Example:\n//   cfg := config.NewConfig().WithUsername(\"Administrator\").WithPassword(\"2Access\").WithEndpoint(paURL)\n//\n//   //Create a AuthnReqListsService from the configuration\n//   svc := authnReqLists.New(cfg)\n//\nfunc New(cfg *config.Config) *AuthnReqListsService {\n\n\treturn &AuthnReqListsService{Client: client.New(\n\t\t*cfg,\n\t\tmetadata.ClientInfo{\n\t\t\tServiceName: ServiceName,\n\t\t\tEndpoint:    *cfg.Endpoint,\n\t\t\tAPIVersion:  pingaccess.SDKVersion,\n\t\t},\n\t)}\n}", "id": 13360, "concepts": ["client creation", "configuration", "client metadata"], "_raw_llm_output": "client creation, configuration, client metadata"}
{"seed": "// NewGetStoresParamsWithHTTPClient creates a new GetStoresParams object\n// with the default values initialized, and the ability to set a custom HTTPClient for a request\nfunc NewGetStoresParamsWithHTTPClient(client *http.Client) *GetStoresParams {\n\tvar ()\n\treturn &GetStoresParams{\n\t\tHTTPClient: client,\n\t}\n}", "id": 13362, "concepts": ["http.Client usage", "function definition", "function composition"], "_raw_llm_output": "http.Client usage, function definition, function composition"}
{"seed": "/*\n148. Sort List \u7c7b\u4f3c 234\nSort a linked list in O(n log n) time using constant space complexity.\n\u94fe\u8868\u7248\u672c\u7684\u5feb\u6392\uff1f\u5f52\u5e76\u6392\u5e8f\n[ref](https://leetcode-cn.com/problems/sort-list/solution/sort-list-gui-bing-pai-xu-lian-biao-by-jyd/)\n\u8fd9\u91cc\u8981\u600e\u4e48\u5212\u5206\uff0c\u6ca1\u529e\u6cd5\uff0c\u53ea\u80fd\u4ece\u5f00\u5934\u5411\u540e\u904d\u5386\u627e\u5230\u4e2d\u70b9\n\u4e2d\u70b9\u7684\u67e5\u627e\u4f7f\u7528\u53cc\u6307\u9488\n\n\u5148\u5224\u65ad head \u4ee5\u53ca head.Next \u5982\u679c\u4efb\u610f\u4e3a nil \u5c31\u8fd4\u56de head\n\u4f7f\u7528 fast \u548c slow \u6307\u9488\u627e\u5230\u4e2d\u95f4\u8282\u70b9\n\u5c06 slow.Next = nil left, right \u7b49\u4e8e\u9012\u5f52\u8c03\u7528 head \u4ee5\u53ca slow.Next\n\u521d\u59cb\u5316\u4e24\u4e2a\u65b0\u8282\u70b9\uff0c\u5176\u4e2d\u4e00\u4e2a\u7528\u6765\u8fdb\u884c\u5f52\u5e76\u5904\u7406\n\u6700\u540e\u8fd4\u56de\u672a\u4f7f\u7528\u7684\u8282\u70b9\n*/\nfunc sortList(head *ListNode) *ListNode {\n\tif head == nil || head.Next == nil {\n\t\treturn head\n\t}\n\t// \u627e\u5230\u4e2d\u95f4\u8282\u70b9 slow \u8fd9\u91cc\u56e0\u4e3a fast \u5728\u524d\u9762\uff0c\u6240\u4ee5\u53ea\u9700\u8981\u5224\u65ad fast\n\tfast, slow := head.Next, head\n\tfor fast != nil && fast.Next != nil {\n\t\tfast = fast.Next.Next\n\t\tslow = slow.Next\n\t}\n\t// \u5982\u679c\u662f\u5947\u6570\u8282\u70b9\uff0cslow \u5c31\u662f\u4e2d\u95f4\u8282\u70b9\uff0c\u5426\u5219\u662f\u4e2d\u95f4\u7684\u524d\u4e00\u4e2a\n\t// \u8fd9\u91cc\u9012\u5f52\u8c03\u7528 head \u548c slow.Next \u5c06\u540e\u8005\u8bbe\u7f6e\u4e3a nil \u8fdb\u884c\u622a\u65ad\n\ttemp := slow.Next\n\tslow.Next = nil\n\t// \u56e0\u4e3a\u6700\u540e\u9700\u8981\u8fd4\u56de\uff0c\u6240\u4ee5\u8fd9\u91cc\u9700\u8981\u9012\u5f52\u7684\u7ed3\u679c\n\tleft := sortList(head)\n\tright := sortList(temp)\n\t// \u56e0\u4e3a\u8fd9\u91cc\u521d\u59cb\u5316\u7684\u662f\u7a7a\u8282\u70b9\uff0c\u6240\u4ee5\u5143\u7d20\u52a0\u5230\u7a7a\u8282\u70b9\u7684 next \u4e2d\n\tnewHead := &ListNode{}\n\tres := newHead\n\tfor left != nil && right != nil {\n\t\tif left.Val < right.Val {\n\t\t\tnewHead.Next = left\n\t\t\tleft = left.Next\n\t\t} else {\n\t\t\tnewHead.Next = right\n\t\t\tright = right.Next\n\t\t}\n\t\tnewHead = newHead.Next\n\t}\n\tif left != nil {\n\t\tnewHead.Next = left\n\t} else {\n\t\tnewHead.Next = right\n\t}\n\treturn res.Next\n}", "id": 13372, "concepts": ["linked list", "two pointers", "recursion"], "_raw_llm_output": "linked list, two pointers, recursion"}
{"seed": "// IsOptionalFieldPathNotFound returns true if the supplied error indicates a\n// field path was not found, and the supplied policy indicates a patch from that\n// field path was optional.\nfunc IsOptionalFieldPathNotFound(err error, s *PatchPolicy) bool {\n\tswitch {\n\tcase s == nil:\n\t\tfallthrough\n\tcase s.FromFieldPath == nil:\n\t\tfallthrough\n\tcase *s.FromFieldPath == FromFieldPathPolicyOptional:\n\t\treturn fieldpath.IsNotFound(err)\n\tdefault:\n\t\treturn false\n\t}\n}", "id": 13387, "concepts": ["error handling (errors.Is)", "pointer dereferencing", "pointer comparison", "pointer equality", "pointer nil", "pointer nil-ness", "pointer nil-ness comparison"], "_raw_llm_output": "error handling (errors.Is), pointer dereferencing, pointer comparison,\npointer equality, pointer nil, pointer nil-ness, pointer nil-ness comparison"}
{"seed": "// JoinErrors concatenates error text of all errors into one semi-colon delimited string\nfunc JoinErrors(errors ...error) string {\n\tjoinedErrorString := \"\"\n\tfor _, error := range errors {\n\t\tif error != nil {\n\t\t\tif joinedErrorString == \"\" {\n\t\t\t\tjoinedErrorString = error.Error()\n\t\t\t} else {\n\t\t\t\tjoinedErrorString = fmt.Sprintf(\"%v; %v\", joinedErrorString, error.Error())\n\t\t\t}\n\t\t}\n\t}\n\treturn joinedErrorString\n}", "id": 13389, "concepts": ["error handling (errors.New)", "string concatenation", "error handling (fmt.Sprintf)"], "_raw_llm_output": "error handling (errors.New), string concatenation, error handling (fmt.Sprintf)"}
{"seed": "// NewDeleteSingleBeadSimulationDefault creates a DeleteSingleBeadSimulationDefault with default headers values\nfunc NewDeleteSingleBeadSimulationDefault(code int) *DeleteSingleBeadSimulationDefault {\n\treturn &DeleteSingleBeadSimulationDefault{\n\t\t_statusCode: code,\n\t}\n}", "id": 13394, "concepts": ["struct definition", "struct field initialization", "anonymous struct"], "_raw_llm_output": "struct definition, struct field initialization, anonymous struct"}
{"seed": "// BulkCreditSamedayNEQ applies the NEQ predicate on the \"bulkCreditSameday\" field.\nfunc BulkCreditSamedayNEQ(v float64) predicate.Bulk {\n\treturn predicate.Bulk(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldBulkCreditSameday), v))\n\t})\n}", "id": 13395, "concepts": ["sql package usage", "predicate.Bulk", "sql.NEQ"], "_raw_llm_output": "sql package usage, predicate.Bulk, sql.NEQ"}
{"seed": "// SocialNameLTE applies the LTE predicate on the \"social_name\" field.\nfunc SocialNameLTE(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.LTE(s.C(FieldSocialName), v))\n\t})\n}", "id": 13400, "concepts": ["sql.Selector", "sql.C", "sql.LTE", "predicate.User", "function definition"], "_raw_llm_output": "sql.Selector, sql.C, sql.LTE, predicate.User, function definition"}
{"seed": "// acceptsOfferType This function determines if an offer type matches a given specification.\n// It checks if the specification is equal to */* (i.e., all types are accepted).\n// It gets the MIME type of the offer (either from the offer itself or by its file extension).\n// It checks if the offer MIME type matches the specification MIME type or if the specification is of the form <MIME_type>/* and the offer MIME type has the same MIME type.\n// Returns true if the offer type matches the specification, false otherwise.\nfunc acceptsOfferType(spec, offerType string) bool {\n\t// Accept: */*\n\tif spec == \"*/*\" {\n\t\treturn true\n\t}\n\n\tvar mimetype string\n\tif strings.IndexByte(offerType, '/') != -1 {\n\t\tmimetype = offerType // MIME type\n\t} else {\n\t\tmimetype = utils.GetMIME(offerType) // extension\n\t}\n\n\tif spec == mimetype {\n\t\t// Accept: <MIME_type>/<MIME_subtype>\n\t\treturn true\n\t}\n\n\ts := strings.IndexByte(mimetype, '/')\n\t// Accept: <MIME_type>/*\n\tif strings.HasPrefix(spec, mimetype[:s]) && (spec[s:] == \"/*\" || mimetype[s:] == \"/*\") {\n\t\treturn true\n\t}\n\n\treturn false\n}", "id": 13423, "concepts": ["string manipulation", "string indexing", "string comparison", "string prefix check", "string suffix check", "string substring check", "string length check", "string index check", "string contains check", "string prefix check", "string suffix check", "string prefix check", "string suffix check", "string prefix check", "string suffix check", "string prefix check", "string suffix check", "string prefix check", "string suffix check", "string prefix check", "string suffix check", "string prefix check", "string suffix check", "string prefix check", "string suffix check", "string prefix check", "string suffix check", "string prefix check", "string suffix check", "string prefix check", "string suffix check", "string prefix check", "string suffix check", "string prefix check", "string suffix check", "string prefix check", "string suffix check", "string prefix check", "string suffix check", "string prefix check", "string suffix check", "string prefix check", "string suffix check", "string prefix check", "string suffix check", "string prefix check", "string suffix check", "string prefix check", "string suffix check", "string prefix check", "string suffix check", "string prefix check", "string suffix check", "string prefix check", "string suffix check", "string prefix check", "string suffix check", "string prefix check", "string suffix check", "string prefix check", "string suffix check", "string prefix check", "string suffix check", "string prefix check", "string suffix"], "_raw_llm_output": "string manipulation, string indexing, string comparison, string prefix check, string suffix check, string substring check, string length check, string index check, string contains check, string prefix check, string suffix check, string prefix check, string suffix check, string prefix check, string suffix check, string prefix check, string suffix check, string prefix check, string suffix check, string prefix check, string suffix check, string prefix check, string suffix check, string prefix check, string suffix check, string prefix check, string suffix check, string prefix check, string suffix check, string prefix check, string suffix check, string prefix check, string suffix check, string prefix check, string suffix check, string prefix check, string suffix check, string prefix check, string suffix check, string prefix check, string suffix check, string prefix check, string suffix check, string prefix check, string suffix check, string prefix check, string suffix check, string prefix check, string suffix check, string prefix check, string suffix check, string prefix check, string suffix check, string prefix check, string suffix check, string prefix check, string suffix check, string prefix check, string suffix check, string prefix check, string suffix check, string prefix check, string suffix check, string prefix check, string suffix"}
{"seed": "// ReadRentalAgreementRentable reads a full RentalAgreementRentable structure of data from the database based on the supplied Row pointer.\nfunc ReadRentalAgreementRentable(row *sql.Row, a *RentalAgreementRentable) error {\n\terr := row.Scan(&a.RARID, &a.RAID, &a.BID, &a.RID, &a.CLID, &a.ContractRent, &a.RARDtStart, &a.RARDtStop, &a.CreateTS, &a.CreateBy, &a.LastModTime, &a.LastModBy)\n\tSkipSQLNoRowsError(&err)\n\treturn err\n}", "id": 13424, "concepts": ["sql.Row", "sql.Scan", "sql.ErrNoRows", "error handling", "pointer usage"], "_raw_llm_output": "sql.Row, sql.Scan, sql.ErrNoRows, error handling, pointer usage"}
{"seed": "// NewConvertibleLogicalType creates a LogicalType where the go type and storage representation\n// can be converted between each other with reflect.Value.Convert.\nfunc NewConvertibleLogicalType(identifier string, goType, storageType reflect.Type) LogicalType {\n\tif !(goType.ConvertibleTo(storageType) && storageType.ConvertibleTo(goType)) {\n\t\tpanic(fmt.Sprintf(\"Can't create ConvertibleTo LogicalType: %v and %v are not convertable to each other\", goType, storageType))\n\t}\n\treturn &convertibleLogicalType{identifier: identifier, goT: goType, storageT: storageType}\n}", "id": 13429, "concepts": ["reflect.Type", "reflect.Value", "type conversion", "basic function definition"], "_raw_llm_output": "reflect.Type, reflect.Value, type conversion, basic function definition"}
{"seed": "// ReadBootstrapListFromFile parses a file containing bootstrap peers. It assumes a text file with an IP:Port address on each line.\n// It will ignore lines starting with a comment \"//\"\nfunc ReadBootstrapListFromFile(path string) ([]*krpc.NodeInfo, error) {\n\tfile, err := os.Open(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\n\t// Read the file line by line and parse the multiaddress string\n\tvar bootstrapNI []*krpc.NodeInfo\n\tscanner := bufio.NewScanner(file)\n\tfor scanner.Scan() {\n\t\tline := scanner.Text()\n\t\t// Ignore lines that are commented out\n\t\tif strings.HasPrefix(line, \"//\") {\n\t\t\tcontinue\n\t\t}\n\t\t// Remove any whitespaces (esp necessary with badly formatted IPv6 addrs)\n\t\taddr := strings.Join(strings.Fields(line), \"\")\n\t\tainfo, err := ParseAddrString(addr)\n\t\tif err != nil {\n\t\t\tlog.WithField(\"err\", err).Error(\"Error parsing bootstrap peers.\")\n\t\t\treturn nil, err\n\t\t}\n\t\tbootstrapNI = append(bootstrapNI, ainfo)\n\t}\n\n\treturn bootstrapNI, nil\n}", "id": 13430, "concepts": ["file reading", "string manipulation", "error handling", "string parsing", "multiaddress parsing"], "_raw_llm_output": "file reading, string manipulation, error handling, string parsing, multiaddress parsing"}
{"seed": "// U represents the HTML element 'u'.\n// For more information visit https://www.w3schools.com/tags/tag_u.asp.\nfunc U(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"u\", Attributes: attrs, Children: children}\n}", "id": 13452, "concepts": ["HTML generation", "HTML tree manipulation", "HTML element definition"], "_raw_llm_output": "HTML generation, HTML tree manipulation, HTML element definition"}
{"seed": "// SocialPayloadEqualFold applies the EqualFold predicate on the \"social_payload\" field.\nfunc SocialPayloadEqualFold(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.EqualFold(s.C(FieldSocialPayload), v))\n\t})\n}", "id": 13454, "concepts": ["sql.Selector", "sql.EqualFold", "predicate.User", "function definition"], "_raw_llm_output": "sql.Selector, sql.EqualFold, predicate.User, function definition"}
{"seed": "// ParseDir parses all the go files in a directory and returns their mapped structs\nfunc ParseDir(path string) ([]*StructData, error) {\n\tvar res []*StructData\n\n\terr := filepath.Walk(path, func(fpath string, info os.FileInfo, err error) error {\n\t\tif fpath == path {\n\t\t\treturn nil\n\t\t}\n\t\tif info.IsDir() {\n\t\t\treturn filepath.SkipDir\n\t\t}\n\t\tif filepath.Ext(fpath) != \".go\" {\n\t\t\treturn nil\n\t\t}\n\t\tstructs, err := ParseFile(fpath)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tres = append(res, structs...)\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn res, nil\n}", "id": 13455, "concepts": ["filepath.Walk", "filepath.SkipDir", "filepath.Ext", "os.FileInfo", "os.File", "os.Open", "ioutil.ReadFile", "strings.Fields", "strings.TrimSpace", "strings.Split", "strings.HasPrefix", "strings.HasSuffix", "strings.Contains", "strings.Trim", "strings.ToLower", "strings.ToUpper", "strings.Join", "fmt.Println", "fmt.Sprintf", "fmt.Errorf", "fmt.Errorf", "fmt.Fprintln", "fmt.Fprintln", "fmt.Fprint", "fmt.Fprint", "fmt.Fprintf", "fmt.Fprintf", "fmt.Errorf", "fmt.Errorf", "fmt.Errorf", "fmt.Errorf", "fmt.Errorf", "fmt.Errorf", "fmt.Errorf", "fmt.Errorf", "fmt.Errorf", "fmt.Errorf", "fmt.Errorf", "fmt.Errorf", "fmt.Errorf", "fmt.Errorf", "fmt.Errorf", "fmt.Errorf", "fmt.Errorf", "fmt.Errorf", "fmt.Errorf", "fmt.Errorf", "fmt.Errorf", "fmt.Errorf", "fmt.Errorf", "fmt.Errorf", "fmt.Errorf", "fmt.Errorf", "fmt.Errorf", "fmt.Errorf", "fmt.Errorf", "fmt.Errorf", "fmt.Errorf", "fmt.Errorf", "fmt.Errorf", "fmt.Errorf", "fmt.Errorf", ""], "_raw_llm_output": "filepath.Walk, filepath.SkipDir, filepath.Ext, os.FileInfo, os.File, os.Open, ioutil.ReadFile, strings.Fields, strings.TrimSpace, strings.Split, strings.HasPrefix, strings.HasSuffix, strings.Contains, strings.Trim, strings.ToLower, strings.ToUpper, strings.Join, fmt.Println, fmt.Sprintf, fmt.Errorf, fmt.Errorf, fmt.Fprintln, fmt.Fprintln, fmt.Fprint, fmt.Fprint, fmt.Fprintf, fmt.Fprintf, fmt.Errorf, fmt.Errorf, fmt.Errorf, fmt.Errorf, fmt.Errorf, fmt.Errorf, fmt.Errorf, fmt.Errorf, fmt.Errorf, fmt.Errorf, fmt.Errorf, fmt.Errorf, fmt.Errorf, fmt.Errorf, fmt.Errorf, fmt.Errorf, fmt.Errorf, fmt.Errorf, fmt.Errorf, fmt.Errorf, fmt.Errorf, fmt.Errorf, fmt.Errorf, fmt.Errorf, fmt.Errorf, fmt.Errorf, fmt.Errorf, fmt.Errorf, fmt.Errorf, fmt.Errorf, fmt.Errorf, fmt.Errorf, fmt.Errorf, fmt.Errorf, fmt.Errorf,"}
{"seed": "// DeleteCachedToken removes the cached token file.\nfunc DeleteCachedToken() error {\n\terr := os.Remove(TokenCachePath)\n\treturn err\n}", "id": 13464, "concepts": ["os.Remove", "file deletion"], "_raw_llm_output": "os.Remove, file deletion"}
{"seed": "/*\nEncrypt generates a literal of the form <b64URLmetadata>.<b64URLciphertext>.<b64URLnonce> given an AEAD cipher, a metadata string and a data\nstring. Only the data is encrypted - the metadata must be appropriate to expose in the clear. Each call generates a random\nnonce of the length required by the cipher.\n*/\nfunc Encrypt(aeadCipher cipher.AEAD, metadata, data string) (string, error) {\n\n\tvar (\n\t\tnonce         = make([]byte, aeadCipher.NonceSize())\n\t\tciphertext    []byte\n\t\tb64metadata   []byte\n\t\tb64ciphertext []byte\n\t\tb64nonce      []byte\n\t\tbuf           bytes.Buffer\n\t\terr           error\n\t)\n\n\t//A nonce of the length required by the AEAD is generated\n\t_, err = rand.Read(nonce)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t//Seal encrypts the data using the aeadCipher's key and the nonce and appends an authentication code for the metadata\n\tciphertext = aeadCipher.Seal(ciphertext, nonce, []byte(data), []byte(metadata))\n\n\t//Base64 Encode metadata, ciphertext and nonce\n\tb64metadata = make([]byte, base64.URLEncoding.EncodedLen(len([]byte(metadata))))\n\tbase64.URLEncoding.Encode(b64metadata, []byte(metadata))\n\tb64ciphertext = make([]byte, base64.URLEncoding.EncodedLen(len(ciphertext)))\n\tbase64.URLEncoding.Encode(b64ciphertext, ciphertext)\n\tb64nonce = make([]byte, base64.URLEncoding.EncodedLen(len(nonce)))\n\tbase64.URLEncoding.Encode(b64nonce, nonce)\n\n\t//Compose a <b64URLmetadata>.<b64URLciphertext>.<b64URLnonce> literal\n\tbuf.Write(b64metadata)\n\tbuf.Write([]byte(\".\"))\n\tbuf.Write(b64ciphertext)\n\tbuf.Write([]byte(\".\"))\n\tbuf.Write(b64nonce)\n\n\t//Return the AEAD literal\n\treturn string(buf.Bytes()), nil\n}", "id": 13482, "concepts": ["crypto/cipher", "crypto/rand", "encoding/base64", "bytes.Buffer", "crypto/rand.Read", "crypto/cipher.AEAD", "crypto/cipher.Seal", "crypto/cipher.NonceSize", "bytes.Buffer.Write", "base64.URLEncoding", "base64.URLEncoding.EncodedLen", "base64.URLEncoding.Encode", "bytes.Buffer.Bytes"], "_raw_llm_output": "crypto/cipher, crypto/rand, encoding/base64, bytes.Buffer, crypto/rand.Read, crypto/cipher.AEAD, crypto/cipher.Seal, crypto/cipher.NonceSize, bytes.Buffer.Write, base64.URLEncoding, base64.URLEncoding.EncodedLen, base64.URLEncoding.Encode, bytes.Buffer.Bytes"}
{"seed": "// NameNotIn applies the NotIn predicate on the \"name\" field.\nfunc NameNotIn(vs ...string) predicate.User {\n\treturn predicate.User(sql.FieldNotIn(FieldName, vs...))\n}", "id": 13486, "concepts": ["sql.FieldNotIn", "sql.FieldEq", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldEq", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldEq", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldEq", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldEq", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldEq", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldEq", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldEq", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldEq", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldEq", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldEq", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldEq", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldEq", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldEq", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldEq", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldEq", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldEq", "sql.FieldIn", ""], "_raw_llm_output": "sql.FieldNotIn, sql.FieldEq, sql.FieldIn, sql.FieldNotIn, sql.FieldEq, sql.FieldIn, sql.FieldNotIn, sql.FieldEq, sql.FieldIn, sql.FieldNotIn, sql.FieldEq, sql.FieldIn, sql.FieldNotIn, sql.FieldEq, sql.FieldIn, sql.FieldNotIn, sql.FieldEq, sql.FieldIn, sql.FieldNotIn, sql.FieldEq, sql.FieldIn, sql.FieldNotIn, sql.FieldEq, sql.FieldIn, sql.FieldNotIn, sql.FieldEq, sql.FieldIn, sql.FieldNotIn, sql.FieldEq, sql.FieldIn, sql.FieldNotIn, sql.FieldEq, sql.FieldIn, sql.FieldNotIn, sql.FieldEq, sql.FieldIn, sql.FieldNotIn, sql.FieldEq, sql.FieldIn, sql.FieldNotIn, sql.FieldEq, sql.FieldIn, sql.FieldNotIn, sql.FieldEq, sql.FieldIn, sql.FieldNotIn, sql.FieldEq, sql.FieldIn, sql.FieldNotIn, sql.FieldEq, sql.FieldIn,"}
{"seed": "// Scan scans ports from 1 to numPorts (included)\n// using numWorkers in parallel.\n// It returns the sorted list of open ports.\nfunc Scan(host string, numPorts, numWorkers int) []int {\n\tdial := func(host string, port int) bool {\n\t\taddress := host + fmt.Sprintf(\":%d\", port)\n\t\tconn, err := net.Dial(\"tcp\", address)\n\t\tif err != nil {\n\t\t\treturn false\n\t\t}\n\t\tconn.Close()\n\t\treturn true\n\t}\n\n\treturn scan(dial, host, numPorts, numWorkers)\n}", "id": 13491, "concepts": ["net/http package usage", "concurrency", "sync.WaitGroup"], "_raw_llm_output": "net/http package usage, concurrency, sync.WaitGroup"}
{"seed": "// Int32Pointer generates int32 pointer from int32\nfunc Int32Pointer(i int32) *int32 {\n\treturn &i\n}", "id": 13507, "concepts": ["pointer", "int32 type", "pointer dereference"], "_raw_llm_output": "pointer, int32 type, pointer dereference"}
{"seed": "// Taken from 3.go.\n// See https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes.\nfunc sieve(n int) []int {\n\t// Populate 2 to n. +1 size so indexes coincide with values for readabililty.\n\ttmp := make([]int, n+1)\n\tfor i := 2; i <= n; i++ {\n\t\ttmp[i] = i\n\t}\n\n\tcurr := 2\n\tfor curr < n {\n\t\t// 0 represents a 'crossed out' value.\n\t\tfor i := 2 * curr; i <= n; i += curr {\n\t\t\ttmp[i] = 0\n\t\t}\n\n\t\t// Skip to next prime number.\n\t\tfor curr = curr + 1; curr < n && tmp[curr] == 0; curr++ {\n\t\t}\n\t}\n\n\t// Now filter our crossed out set.\n\tvar ret []int\n\tfor _, n := range tmp {\n\t\tif n > 0 {\n\t\t\tret = append(ret, n)\n\t\t}\n\t}\n\n\treturn ret\n}", "id": 13509, "concepts": ["slice iteration (range loop)", "slice manipulation", "slice construction", "slice filtering", "integer manipulation"], "_raw_llm_output": "slice iteration (range loop), slice manipulation, slice construction, slice filtering, integer manipulation"}
{"seed": "// BufferNotIn applies the NotIn predicate on the \"buffer\" field.\nfunc BufferNotIn(vs ...[]byte) predicate.User {\n\treturn predicate.User(sql.FieldNotIn(FieldBuffer, vs...))\n}", "id": 13513, "concepts": ["sql.FieldNotIn", "sql.Field", "sql.FieldNotIn", "sql.Field", "sql.FieldNotIn", "sql.FieldNotIn", "sql.FieldNotIn", "sql.FieldNotIn", "sql.FieldNotIn", "sql.FieldNotIn", "sql.FieldNotIn", "sql.FieldNotIn", "sql.FieldNotIn", "sql.FieldNotIn", "sql.FieldNotIn", "sql.FieldNotIn", "sql.FieldNotIn", "sql.FieldNotIn", "sql.FieldNotIn", "sql.FieldNotIn", "sql.FieldNotIn", "sql.FieldNotIn", "sql.FieldNotIn", "sql.FieldNotIn", "sql.FieldNotIn", "sql.FieldNotIn", "sql.FieldNotIn", "sql.FieldNotIn", "sql.FieldNotIn", "sql.FieldNotIn", "sql.FieldNotIn", "sql.FieldNotIn", "sql.FieldNotIn", "sql.FieldNotIn", "sql.FieldNotIn", "sql.FieldNotIn", "sql.FieldNotIn", "sql.FieldNotIn", "sql.FieldNotIn", "sql.FieldNotIn", "sql.FieldNotIn", "sql.FieldNotIn", "sql.FieldNotIn", "sql.FieldNotIn", "sql.FieldNotIn", "sql.FieldNotIn", "sql.FieldNotIn", "sql.FieldNotIn", "sql.FieldNotIn", "sql.FieldNotIn", "sql.FieldNotIn", "sql."], "_raw_llm_output": "sql.FieldNotIn, sql.Field, sql.FieldNotIn, sql.Field, sql.FieldNotIn, sql.FieldNotIn, sql.FieldNotIn, sql.FieldNotIn, sql.FieldNotIn, sql.FieldNotIn, sql.FieldNotIn, sql.FieldNotIn, sql.FieldNotIn, sql.FieldNotIn, sql.FieldNotIn, sql.FieldNotIn, sql.FieldNotIn, sql.FieldNotIn, sql.FieldNotIn, sql.FieldNotIn, sql.FieldNotIn, sql.FieldNotIn, sql.FieldNotIn, sql.FieldNotIn, sql.FieldNotIn, sql.FieldNotIn, sql.FieldNotIn, sql.FieldNotIn, sql.FieldNotIn, sql.FieldNotIn, sql.FieldNotIn, sql.FieldNotIn, sql.FieldNotIn, sql.FieldNotIn, sql.FieldNotIn, sql.FieldNotIn, sql.FieldNotIn, sql.FieldNotIn, sql.FieldNotIn, sql.FieldNotIn, sql.FieldNotIn, sql.FieldNotIn, sql.FieldNotIn, sql.FieldNotIn, sql.FieldNotIn, sql.FieldNotIn, sql.FieldNotIn, sql.FieldNotIn, sql.FieldNotIn, sql.FieldNotIn, sql.FieldNotIn, sql."}
{"seed": "// DefaultExprIsNil applies the IsNil predicate on the \"default_expr\" field.\nfunc DefaultExprIsNil() predicate.User {\n\treturn predicate.User(sql.FieldIsNull(FieldDefaultExpr))\n}", "id": 13557, "concepts": ["struct field access", "sql.FieldIsNull", "predicate.User", "predicate.Field"], "_raw_llm_output": "struct field access, sql.FieldIsNull, predicate.User, predicate.Field"}
{"seed": "// NewPutOrdersOrderFidProductsOrderProductFidSetInitialTermParams creates a new PutOrdersOrderFidProductsOrderProductFidSetInitialTermParams object,\n// with the default timeout for this client.\n//\n// Default values are not hydrated, since defaults are normally applied by the API server side.\n//\n// To enforce default values in parameter, use SetDefaults or WithDefaults.\nfunc NewPutOrdersOrderFidProductsOrderProductFidSetInitialTermParams() *PutOrdersOrderFidProductsOrderProductFidSetInitialTermParams {\n\treturn &PutOrdersOrderFidProductsOrderProductFidSetInitialTermParams{\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 13561, "concepts": ["struct definition", "default timeout", "struct field initialization", "method definition", "method call"], "_raw_llm_output": "struct definition, default timeout, struct field initialization, method definition, method call"}
{"seed": "// getAllVdcComputePolicies retrieves all VDC compute policies using OpenAPI endpoint. Query parameters can be supplied to perform additional\n// filtering\n// Deprecated: use getAllVdcComputePoliciesV2\nfunc getAllVdcComputePolicies(client *Client, queryParameters url.Values) ([]*VdcComputePolicy, error) {\n\tendpoint := types.OpenApiPathVersion1_0_0 + types.OpenApiEndpointVdcComputePolicies\n\tminimumApiVersion, err := client.checkOpenApiEndpointCompatibility(endpoint)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\turlRef, err := client.OpenApiBuildEndpoint(endpoint)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponses := []*types.VdcComputePolicy{{}}\n\n\terr = client.OpenApiGetAllItems(minimumApiVersion, urlRef, queryParameters, &responses, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar wrappedVdcComputePolicies []*VdcComputePolicy\n\tfor _, response := range responses {\n\t\twrappedVdcComputePolicy := &VdcComputePolicy{\n\t\t\tclient:           client,\n\t\t\tVdcComputePolicy: response,\n\t\t}\n\t\twrappedVdcComputePolicies = append(wrappedVdcComputePolicies, wrappedVdcComputePolicy)\n\t}\n\n\treturn wrappedVdcComputePolicies, nil\n}", "id": 13590, "concepts": ["OpenAPI", "OpenAPI endpoint", "OpenAPI endpoint compatibility", "OpenAPI GetAllItems"], "_raw_llm_output": "OpenAPI, OpenAPI endpoint, OpenAPI endpoint compatibility, OpenAPI GetAllItems"}
{"seed": "// ValidateBackupBucketSpec validates the specification of a BackupBucket object.\nfunc ValidateBackupBucketSpec(spec *extensionsv1alpha1.BackupBucketSpec, fldPath *field.Path) field.ErrorList {\n\tallErrs := field.ErrorList{}\n\n\tif len(spec.Type) == 0 {\n\t\tallErrs = append(allErrs, field.Required(fldPath.Child(\"type\"), \"field is required\"))\n\t}\n\n\tif len(spec.Region) == 0 {\n\t\tallErrs = append(allErrs, field.Required(fldPath.Child(\"region\"), \"field is required\"))\n\t}\n\n\tif len(spec.SecretRef.Name) == 0 {\n\t\tallErrs = append(allErrs, field.Required(fldPath.Child(\"secretRef\", \"name\"), \"field is required\"))\n\t}\n\n\treturn allErrs\n}", "id": 13594, "concepts": ["field.ErrorList", "field.Path", "field.Required", "field.Error", "field.Child", "field.Path.Child"], "_raw_llm_output": "field.ErrorList, field.Path, field.Required, field.Error, field.Child, field.Path.Child"}
{"seed": "// projectRefPipelineForMatchingTrigger is an aggregation pipeline to find projects that have the projectKey\n// explicitly set to the val, OR that default to the repo, which has the repoKey explicitly set to the val\nfunc projectRefPipelineForValueIsBool(projectKey, repoKey string, val bool) []bson.M {\n\treturn []bson.M{\n\t\tlookupRepoStep,\n\t\t{\"$match\": bson.M{\n\t\t\t\"$or\": []bson.M{\n\t\t\t\t{projectKey: val},\n\t\t\t\t{projectKey: nil, bsonutil.GetDottedKeyName(\"repo_ref\", repoKey): val},\n\t\t\t},\n\t\t}},\n\t}\n}", "id": 13602, "concepts": ["aggregation pipeline", "bson package usage", "bson.M usage", "bsonutil usage", "bson.D usage", "bson.A usage"], "_raw_llm_output": "aggregation pipeline, bson package usage, bson.M usage, bsonutil usage, bson.D usage, bson.A usage"}
{"seed": "// IsString reports whether value is a string type.\nfunc IsString(value interface{}) bool {\n\treturn kindOf(value) == reflect.String\n}", "id": 13609, "concepts": ["interface", "reflection", "type assertion"], "_raw_llm_output": "interface, reflection, type assertion"}
{"seed": "// WithAutogenerateComment creates a new Option to add 'DO NOT MODIFY' message at the\n// head of the generated proto file\nfunc WithAutogeneratedComment(b bool) Option {\n\treturn option.New(optkeyAutogenerateComment, b)\n}", "id": 13619, "concepts": ["Option pattern", "basic function definition", "boolean value handling"], "_raw_llm_output": "Option pattern, basic function definition, boolean value handling"}
{"seed": "// limitNumClients is HTTP handling middleware that ensures no more than\n// maxClients requests are passed concurrently to the given handler f.\nfunc limitNumClients(f http.HandlerFunc, maxClients int) http.HandlerFunc {\n\tsema := make(chan struct{}, maxClients)\n\n\treturn func(w http.ResponseWriter, req *http.Request) {\n\t\tsema <- struct{}{}\n\t\tdefer func() { <-sema }()\n\t\tf(w, req)\n\t}\n}", "id": 13626, "concepts": ["concurrency", "channels", "mutexes", "standard library usage"], "_raw_llm_output": "concurrency, channels, mutexes, standard library usage"}
{"seed": "//SortBouts sorts bouts by bashoId, day, then bout number.\nfunc SortBouts(b []Bout) error {\n\n\tsort.SliceStable(b,\n\t\tfunc(i int, j int) bool {\n\t\t\tbouti := b[i]\n\t\t\tboutj := b[j]\n\n\t\t\tif bouti.BashoID != boutj.BashoID {\n\t\t\t\treturn bouti.BashoID < boutj.BashoID\n\t\t\t} else if bouti.Day != boutj.Day {\n\t\t\t\treturn bouti.Day < boutj.Day\n\t\t\t}\n\t\t\treturn bouti.Boutnum < boutj.Boutnum\n\t\t})\n\n\treturn nil\n}", "id": 13636, "concepts": ["slice sorting", "slice iteration (range loop)", "slice comparison", "basic function definition"], "_raw_llm_output": "slice sorting, slice iteration (range loop), slice comparison, basic function definition"}
{"seed": "// hashSignature generates a HMAC hash of a string using a secret\nfunc hashSignature(alg Algorithm, signatureValue string, secret *pbauth.Secret) (string, error) {\n\tif strings.TrimSpace(signatureValue) == \"\" {\n\t\treturn \"\", consts.ErrInvalidSignatureValue\n\t}\n\tif err := ValidateSecret(secret); err != nil {\n\t\treturn \"\", err\n\t}\n\tkey := []byte(secret.Key)\n\tvar h hash.Hash\n\tswitch alg {\n\tcase Hs256:\n\t\th = hmac.New(sha256.New, key)\n\tcase Hs512:\n\t\th = hmac.New(sha512.New, key)\n\tdefault:\n\t\treturn \"\", consts.ErrNoHashAlgorithm\n\t}\n\th.Write([]byte(signatureValue))\n\treturn base64.URLEncoding.EncodeToString(h.Sum(nil)), nil\n}", "id": 13646, "concepts": ["cryptography", "HMAC", "base64 encoding", "crypto/hmac package usage", "crypto/sha256", "crypto/sha512", "crypto/sha512"], "_raw_llm_output": "cryptography, HMAC, base64 encoding, crypto/hmac package usage, crypto/sha256, crypto/sha512, crypto/sha512"}
{"seed": "// NewCreateExtensionsV1beta1NamespacedIngressUnauthorized creates CreateExtensionsV1beta1NamespacedIngressUnauthorized with default headers values\nfunc NewCreateExtensionsV1beta1NamespacedIngressUnauthorized() *CreateExtensionsV1beta1NamespacedIngressUnauthorized {\n\n\treturn &CreateExtensionsV1beta1NamespacedIngressUnauthorized{}\n}", "id": 13660, "concepts": ["package initialization", "struct initialization", "function definition", "function call", "function return", "function parameter", "function return value", "function return value type", "function return value type conversion"], "_raw_llm_output": "package initialization, struct initialization, function definition, function call, function return, function parameter, function return value, function return value type, function return value type conversion"}
{"seed": "// isControl \u5224\u65ad token \u662f\u5426\u662f\u4e00\u4e2a\u63a7\u5236\u5b57\u7b26\u3002\nfunc isControl(token byte) bool {\n\treturn unicode.IsControl(rune(token))\n}", "id": 13665, "concepts": ["rune handling", "unicode.IsControl"], "_raw_llm_output": "rune handling, unicode.IsControl"}
{"seed": "// BetterHeroScore applies equality check predicate on the \"better_hero_score\" field. It's identical to BetterHeroScoreEQ.\nfunc BetterHeroScore(v int) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldBetterHeroScore), v))\n\t})\n}", "id": 13666, "concepts": ["sql.Selector", "sql.EQ", "sql.Where", "sql.C", "sql.Selector.Where", "sql.Selector.C", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where"], "_raw_llm_output": "sql.Selector, sql.EQ, sql.Where, sql.C, sql.Selector.Where, sql.Selector.C, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where"}
{"seed": "/*\nChecks the frequency of occurance of word within a file with a given filename\nUses strings.Fields to seperate words by whitespace..much faster than regexing \\S+\\s+ repeatedly and incrementing counter\n\nAssumptions for search \"report\":\n\t--only \"report\", \"report,\" or \"report.\" count as an occurance of \"report\"\n\t--instances such as \"Report\" and \"Report-...\" would not count as an occurance as they most likely have different meanings than the desired word\n\nParams:\n\tfilename: name of file to open and measure word frequency on\n\tword: search for repetitions of this word\nReturn:\n\tint: number of occurances of word\n\ttime.Duration: how long the word frequency operation took\n*/\nfunc wordFreq(filename string, word string)(int, time.Duration){\n\tstartTime := time.Now()\n\tfile, err := os.Open(filename)\n\tif err != nil {\n\t\treturn -1000, time.Since(startTime)\n\t}\n\tdefer file.Close()\n\n\tscanner := bufio.NewScanner(file)\n\twc := 0\n\tfor scanner.Scan() {\n\t\twords := strings.Fields(scanner.Text())\n\t\tfor _, lword := range words {\n\t\t\tif lword == word || lword == word+\",\" || lword == word+\".\"{\n\t\t\t\twc += 1\n\t\t\t}\n\t\t}\n\t}\n\n\tdur := time.Since(startTime)\n\treturn wc, dur\n}", "id": 13668, "concepts": ["file I/O", "string manipulation", "string iteration", "string comparison", "string concatenation", "string formatting", "string slices", "string regex", "string split", "string join", "string fields", "string contains", "string index", "string length", "string replace", "string trim", "string upper", "string lower", "string split", "string join", "string repeat", "string replace", "string trim", "string trim space", "string trim left", "string trim right", "string trim prefix", "string trim suffix", "string trim prefix space", "string trim suffix space", "string trim prefix space", "string trim suffix space", "string trim prefix space", "string trim suffix space", "string trim prefix space", "string trim suffix space", "string trim prefix space", "string trim suffix space", "string trim prefix space", "string trim suffix space", "string trim prefix space", "string trim suffix space", "string trim prefix space", "string trim suffix space", "string trim prefix space", "string trim suffix space", "string trim prefix space", "string trim suffix space", "string trim prefix space", "string trim suffix space", "string trim prefix space", "string trim suffix space", "string trim prefix space", "string trim suffix space", "string trim prefix space", "string trim suffix space", "string trim prefix space", "string trim suffix space", "string trim prefix space", "string trim suffix space", "string trim prefix"], "_raw_llm_output": "file I/O, string manipulation, string iteration, string comparison, string concatenation, string formatting, string slices, string regex, string split, string join, string fields, string contains, string index, string length, string replace, string trim, string upper, string lower, string split, string join, string repeat, string replace, string trim, string trim space, string trim left, string trim right, string trim prefix, string trim suffix, string trim prefix space, string trim suffix space, string trim prefix space, string trim suffix space, string trim prefix space, string trim suffix space, string trim prefix space, string trim suffix space, string trim prefix space, string trim suffix space, string trim prefix space, string trim suffix space, string trim prefix space, string trim suffix space, string trim prefix space, string trim suffix space, string trim prefix space, string trim suffix space, string trim prefix space, string trim suffix space, string trim prefix space, string trim suffix space, string trim prefix space, string trim suffix space, string trim prefix space, string trim suffix space, string trim prefix space, string trim suffix space, string trim prefix space, string trim suffix space, string trim prefix space, string trim suffix space, string trim prefix"}
{"seed": "// Col_ is a convenience wrapper for Col without the attrs argument.\nfunc Col_() HTML {\n  return Col(nil)\n}", "id": 13669, "concepts": ["function definition", "function call", "function return", "function argument", "function argument default value", "function argument type", "function argument type conversion", "function argument type assertion", "function argument type switch", "function argument type switch case", "function argument type switch default", "function argument type switch case fallthrough", "function argument type switch case fallthrough", "function argument type switch case fallthrough", "function argument type switch case fallthrough", "function argument type switch case fallthrough", "function argument type switch case fallthrough", "function argument type switch case fallthrough", "function argument type switch case fallthrough", "function argument type switch case fallthrough", "function argument type switch case fallthrough", "function argument type switch case fallthrough", "function argument type switch case fallthrough", "function argument type switch case fallthrough", "function argument type switch case fallthrough", "function argument type switch case fallthrough", "function argument type switch case fallthrough", "function argument type switch case fallthrough", "function argument type switch case fallthrough", "function argument type switch case fallthrough", "function argument type switch case fallthrough", "function argument type switch case fallthrough", "function argument type switch case fallthrough", "function argument type switch case fallthrough", "function argument type switch case fallthrough", "function argument type switch case fallthrough", "function argument type switch case fallthrough"], "_raw_llm_output": "function definition, function call, function return, function argument, function argument default value, function argument type, function argument type conversion, function argument type assertion, function argument type switch, function argument type switch case, function argument type switch default, function argument type switch case fallthrough, function argument type switch case fallthrough, function argument type switch case fallthrough, function argument type switch case fallthrough, function argument type switch case fallthrough, function argument type switch case fallthrough, function argument type switch case fallthrough, function argument type switch case fallthrough, function argument type switch case fallthrough, function argument type switch case fallthrough, function argument type switch case fallthrough, function argument type switch case fallthrough, function argument type switch case fallthrough, function argument type switch case fallthrough, function argument type switch case fallthrough, function argument type switch case fallthrough, function argument type switch case fallthrough, function argument type switch case fallthrough, function argument type switch case fallthrough, function argument type switch case fallthrough, function argument type switch case fallthrough, function argument type switch case fallthrough, function argument type switch case fallthrough, function argument type switch case fallthrough, function argument type switch case fallthrough, function argument type switch case fallthrough"}
{"seed": "// OpenOrCreate opens (or creates) a policy map at the specified path, which\n// is used to govern which peer identities can communicate with the endpoint\n// protected by this map.\nfunc OpenOrCreate(path string) (*PolicyMap, error) {\n\tm := newMap(path)\n\terr := m.OpenOrCreate()\n\treturn m, err\n}", "id": 13681, "concepts": ["struct definition", "map iteration", "map lookup", "map creation", "map deletion", "map iteration", "map lookup", "map creation", "map deletion", "map iteration", "map lookup", "map creation", "map deletion", "map iteration", "map lookup", "map creation", "map deletion", "map iteration", "map lookup", "map creation", "map deletion", "map iteration", "map lookup", "map creation", "map deletion", "map iteration", "map lookup", "map creation", "map deletion", "map iteration", "map lookup", "map creation", "map deletion", "map iteration", "map lookup", "map creation", "map deletion", "map iteration", "map lookup", "map creation", "map deletion", "map iteration", "map lookup", "map creation", "map deletion", "map iteration", "map lookup", "map creation", "map deletion", "map iteration", "map lookup", "map creation", "map deletion", "map iteration", "map lookup", "map creation", "map deletion", "map iteration", "map lookup", "map creation", "map deletion", "map iteration", "map lookup", "map creation", "map deletion", "map iteration", "map lookup", "map creation", "map deletion", "map iteration", "map lookup", "map creation", "map deletion", "map iteration", "map lookup", "map creation", "map deletion", "map iteration", "map lookup", "map creation", "map deletion", "map iteration", "map lookup", "map creation", "map deletion", ""], "_raw_llm_output": "struct definition, map iteration, map lookup, map creation, map deletion, map iteration, map lookup, map creation, map deletion, map iteration, map lookup, map creation, map deletion, map iteration, map lookup, map creation, map deletion, map iteration, map lookup, map creation, map deletion, map iteration, map lookup, map creation, map deletion, map iteration, map lookup, map creation, map deletion, map iteration, map lookup, map creation, map deletion, map iteration, map lookup, map creation, map deletion, map iteration, map lookup, map creation, map deletion, map iteration, map lookup, map creation, map deletion, map iteration, map lookup, map creation, map deletion, map iteration, map lookup, map creation, map deletion, map iteration, map lookup, map creation, map deletion, map iteration, map lookup, map creation, map deletion, map iteration, map lookup, map creation, map deletion, map iteration, map lookup, map creation, map deletion, map iteration, map lookup, map creation, map deletion, map iteration, map lookup, map creation, map deletion, map iteration, map lookup, map creation, map deletion, map iteration, map lookup, map creation, map deletion,"}
{"seed": "// RequestMethodAndURL return string containing method(GET, POST, PATCH etc) and string given an HTTP request.\nfunc RequestMethodAndURL(r *http.Request) string {\n\treturn fmt.Sprintf(\"%v %v\", r.Method, r.URL)\n}", "id": 13682, "concepts": ["HTTP request handling", "string formatting", "HTTP request handling"], "_raw_llm_output": "HTTP request handling, string formatting, HTTP request handling"}
{"seed": "// NewListLoadBalancersRequest generates requests for ListLoadBalancers\nfunc NewListLoadBalancersRequest(server string) (*http.Request, error) {\n\tvar err error\n\n\tqueryUrl, err := url.Parse(server)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbasePath := fmt.Sprintf(\"/load-balancer\")\n\tif basePath[0] == '/' {\n\t\tbasePath = basePath[1:]\n\t}\n\n\tqueryUrl, err = queryUrl.Parse(basePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq, err := http.NewRequest(\"GET\", queryUrl.String(), nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn req, nil\n}", "id": 13693, "concepts": ["url parsing", "http request generation", "url manipulation"], "_raw_llm_output": "url parsing, http request generation, url manipulation"}
{"seed": "// MapToResourceTags transforms a go map[string]string to a CloudFormation-compliant\n// Tags representation.  See http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html\nfunc MapToResourceTags(tagMap map[string]string) []interface{} {\n\tvar tags []interface{}\n\tfor eachKey, eachValue := range tagMap {\n\t\ttags = append(tags, map[string]interface{}{\n\t\t\t\"Key\":   eachKey,\n\t\t\t\"Value\": eachValue,\n\t\t})\n\t}\n\treturn tags\n}", "id": 13697, "concepts": ["map iteration (range loop)", "map to slice conversion", "interface conversion"], "_raw_llm_output": "map iteration (range loop), map to slice conversion, interface conversion"}
{"seed": "// CanSkip is for these cases, we can skip the columns in encoded row:\n// 1. the column is included in primary key;\n// 2. the column's default value is null, and the value equals to that;\n// 3. the column is virtual generated.\nfunc CanSkip(info *model.TableInfo, col *table.Column, value types.Datum) bool {\n\ttrace_util_0.Count(_tables_00000, 342)\n\tif col.IsPKHandleColumn(info) {\n\t\ttrace_util_0.Count(_tables_00000, 346)\n\t\treturn true\n\t}\n\ttrace_util_0.Count(_tables_00000, 343)\n\tif col.GetDefaultValue() == nil && value.IsNull() {\n\t\ttrace_util_0.Count(_tables_00000, 347)\n\t\treturn true\n\t}\n\ttrace_util_0.Count(_tables_00000, 344)\n\tif col.IsGenerated() && !col.GeneratedStored {\n\t\ttrace_util_0.Count(_tables_00000, 348)\n\t\treturn true\n\t}\n\ttrace_util_0.Count(_tables_00000, 345)\n\treturn false\n}", "id": 13698, "concepts": ["slice iteration (range loop)", "basic function definition", "null handling", "struct field access", "boolean logic", "comparison", "type conversion", "type assertion", "type switch", "type check", "type switch"], "_raw_llm_output": "slice iteration (range loop), basic function definition, null handling, struct field access, boolean logic, comparison, type conversion, type assertion, type switch, type check, type switch"}
{"seed": "// Em_ is a convenience wrapper for Em without the attrs argument.\nfunc Em_(children ...HTML) HTML {\n  return Em(nil, children...)\n}", "id": 13699, "concepts": ["HTML type", "function definition", "function argument", "function return value", "function call"], "_raw_llm_output": "HTML type, function definition, function argument, function return value, function call"}
{"seed": "// RunJSONSerializationTestForFailoverGroupReadOnlyEndpoint runs a test to see if a specific instance of FailoverGroupReadOnlyEndpoint round trips to JSON and back losslessly\nfunc RunJSONSerializationTestForFailoverGroupReadOnlyEndpoint(subject FailoverGroupReadOnlyEndpoint) string {\n\t// Serialize to JSON\n\tbin, err := json.Marshal(subject)\n\tif err != nil {\n\t\treturn err.Error()\n\t}\n\n\t// Deserialize back into memory\n\tvar actual FailoverGroupReadOnlyEndpoint\n\terr = json.Unmarshal(bin, &actual)\n\tif err != nil {\n\t\treturn err.Error()\n\t}\n\n\t// Check for outcome\n\tmatch := cmp.Equal(subject, actual, cmpopts.EquateEmpty())\n\tif !match {\n\t\tactualFmt := pretty.Sprint(actual)\n\t\tsubjectFmt := pretty.Sprint(subject)\n\t\tresult := diff.Diff(subjectFmt, actualFmt)\n\t\treturn result\n\t}\n\n\treturn \"\"\n}", "id": 13705, "concepts": ["JSON serialization", "JSON deserialization", "cmp package usage"], "_raw_llm_output": "JSON serialization, JSON deserialization, cmp package usage"}
{"seed": "// NewReplaceSubscriptionParamsWithHTTPClient creates a new ReplaceSubscriptionParams object\n// with the default values initialized, and the ability to set a custom HTTPClient for a request\nfunc NewReplaceSubscriptionParamsWithHTTPClient(client *http.Client) *ReplaceSubscriptionParams {\n\tvar ()\n\treturn &ReplaceSubscriptionParams{\n\t\tHTTPClient: client,\n\t}\n}", "id": 13710, "concepts": ["http.Client", "http.NewRequest", "http.Do", "http.Request", "http.Response", "http.Status", "http.Header", "http.Cookie", "http.CookieJar", "http.Transport", "http.RoundTripper", "http.Client.Do", "http.Client.Get", "http.Client.Post", "http.Client.PostForm", "http.Client.Head", "http.Client.CloseIdleConnections", "http.Client.Timeout", "http.Client.Transport", "http.Client.Jar", "http.Client.CheckRedirect", "http.Client.Jar.SetCookies", "http.Client.Jar.Cookies", "http.Client.Jar.Cookies", "http.Client.Jar.Cookies", "http.Client.Jar.Cookies", "http.Client.Jar.Cookies", "http.Client.Jar.Cookies", "http.Client.Jar.Cookies", "http.Client.Jar.Cookies", "http.Client.Jar.Cookies", "http.Client.Jar.Cookies", "http.Client.Jar.Cookies", "http.Client.Jar.Cookies", "http.Client.Jar.Cookies", "http.Client.Jar.Cookies", "http.Client.Jar.Cookies", "http.Client.Jar.Cookies", "http.Client.Jar.Cookies"], "_raw_llm_output": "http.Client, http.NewRequest, http.Do, http.Request, http.Response, http.Status, http.Header, http.Cookie, http.CookieJar, http.Transport, http.RoundTripper, http.Client.Do, http.Client.Get, http.Client.Post, http.Client.PostForm, http.Client.Head, http.Client.CloseIdleConnections, http.Client.Timeout, http.Client.Transport, http.Client.Jar, http.Client.CheckRedirect, http.Client.Jar.SetCookies, http.Client.Jar.Cookies, http.Client.Jar.Cookies, http.Client.Jar.Cookies, http.Client.Jar.Cookies, http.Client.Jar.Cookies, http.Client.Jar.Cookies, http.Client.Jar.Cookies, http.Client.Jar.Cookies, http.Client.Jar.Cookies, http.Client.Jar.Cookies, http.Client.Jar.Cookies, http.Client.Jar.Cookies, http.Client.Jar.Cookies, http.Client.Jar.Cookies, http.Client.Jar.Cookies, http.Client.Jar.Cookies, http.Client.Jar.Cookies"}
{"seed": "// NewPlanetClient returns a client for the Planet from the given config.\nfunc NewPlanetClient(c config) *PlanetClient {\n\treturn &PlanetClient{config: c}\n}", "id": 13713, "concepts": ["struct definition", "struct field access", "struct initialization"], "_raw_llm_output": "struct definition, struct field access, struct initialization"}
{"seed": "// GetCurrent returns the current, open code review.\n//\n// If there are multiple matching reviews, then an error is returned.\nfunc GetCurrent(repo repository.Repo) (*Review, error) {\n\treviewRef, err := repo.GetHeadRef()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar matchingReviews []Summary\n\tfor _, review := range ListOpen(repo) {\n\t\tif review.Request.ReviewRef == reviewRef {\n\t\t\tmatchingReviews = append(matchingReviews, review)\n\t\t}\n\t}\n\tif matchingReviews == nil {\n\t\treturn nil, nil\n\t}\n\tif len(matchingReviews) != 1 {\n\t\treturn nil, fmt.Errorf(\"There are %d open reviews for the ref \\\"%s\\\"\", len(matchingReviews), reviewRef)\n\t}\n\treturn matchingReviews[0].Details()\n}", "id": 13723, "concepts": ["error handling (fmt.Errorf)", "error wrapping (errors.Is)", "error handling (errors.As)", "error handling (idiomatic if err != nil)", "error handling (error wrapping)", "error handling (error wrapping)", "error handling (error wrapping)", "error handling (error wrapping)", "error handling (error wrapping)", "error handling (error wrapping)", "error handling (error wrapping)", "error handling (error wrapping)", "error handling (error wrapping)", "error handling (error wrapping)", "error handling (error wrapping)", "error handling (error wrapping)", "error handling (error wrapping)", "error handling (error wrapping)", "error handling (error wrapping)", "error handling (error wrapping)", "error handling (error wrapping)", "error handling (error wrapping)", "error handling (error wrapping)", "error handling (error wrapping)", "error handling (error wrapping)", "error handling (error wrapping)", "error handling (error wrapping)", "error handling (error wrapping)", "error handling (error wrapping)", "error handling (error wrapping)", "error handling (error wrapping)", "error handling (error wrapping)", "error handling (error wrapping)", "error handling (error wrapping)", "error handling (error wrapping)", "error handling (error wrapping)", "error handling (error wrapping)", "error handling (error wrapping)", "error handling (error wrapping)", "error handling (error wrapping)", "error handling (error wrapping)", "error"], "_raw_llm_output": "error handling (fmt.Errorf), error wrapping (errors.Is), error handling (errors.As), error handling (idiomatic if err != nil), error handling (error wrapping), error handling (error wrapping), error handling (error wrapping), error handling (error wrapping), error handling (error wrapping), error handling (error wrapping), error handling (error wrapping), error handling (error wrapping), error handling (error wrapping), error handling (error wrapping), error handling (error wrapping), error handling (error wrapping), error handling (error wrapping), error handling (error wrapping), error handling (error wrapping), error handling (error wrapping), error handling (error wrapping), error handling (error wrapping), error handling (error wrapping), error handling (error wrapping), error handling (error wrapping), error handling (error wrapping), error handling (error wrapping), error handling (error wrapping), error handling (error wrapping), error handling (error wrapping), error handling (error wrapping), error handling (error wrapping), error handling (error wrapping), error handling (error wrapping), error handling (error wrapping), error handling (error wrapping), error handling (error wrapping), error handling (error wrapping), error handling (error wrapping), error handling (error wrapping), error handling (error wrapping), error"}
{"seed": "// WithTimeFormat sets the TimeFormat setting.\n//\n// See `Configuration`.\nfunc WithTimeFormat(timeformat string) Configurator {\n\treturn func(app *Application) {\n\t\tapp.config.TimeFormat = timeformat\n\t}\n}", "id": 13728, "concepts": ["function composition", "function definition", "function composition", "function composition", "function composition"], "_raw_llm_output": "function composition, function definition, function composition, function composition, function composition"}
{"seed": "// This loads config-dev or config-prod depending on what environment it detects\n// The environment is specified using a ENVIRONMENT_TYPE=PROD environment variable set\n// on the Heroku/Docker environment\n// Returns true if success, false if not\nfunc LoadConfig() (bool, *Config) {\n\tconfig := new(Config)\n\tconfigEnvironment := os.Getenv(\"ENVIRONMENT_TYPE\")\n\t// Default to the development config since it is safer\n\tconfigFileName := \"config-dev.json\"\n\n\tif configEnvironment == \"PROD\" {\n\t\t// Development Environment\n\t\tconfigFileName = \"config-prod.json\"\n\t}\n\n\t// Open our jsonFile\n\tjsonFile, err := os.Open(configFileName)\n\t// if we os.Open returns an error then handle it and return an empty config\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn false, config\n\t}\n\t// defer the closing of our jsonFile so that we can parse it later on\n\tdefer jsonFile.Close()\n\n\tjsonParser := json.NewDecoder(jsonFile)\n\n\tparseError := jsonParser.Decode(config)\n\tif parseError != nil {\n\t\t// Return config as is, program will end anyway as we return false here\n\t\tfmt.Println(err)\n\t\treturn false, config\n\t}\n\treturn true, config\n}", "id": 13759, "concepts": ["os.Open", "os.Getenv", "json.NewDecoder", "json.Decode", "basic function definition"], "_raw_llm_output": "os.Open, os.Getenv, json.NewDecoder, json.Decode, basic function definition"}
{"seed": "// SocialTypeContainsFold applies the ContainsFold predicate on the \"social_type\" field.\nfunc SocialTypeContainsFold(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.ContainsFold(s.C(FieldSocialType), v))\n\t})\n}", "id": 13771, "concepts": ["sql.Selector", "sql.ContainsFold", "predicate.User", "function composition"], "_raw_llm_output": "sql.Selector, sql.ContainsFold, predicate.User, function composition"}
{"seed": "// Rp_ is a convenience wrapper for Rp without the attrs argument.\nfunc Rp_(children ...HTML) HTML {\n  return Rp(nil, children...)\n}", "id": 13775, "concepts": ["HTML", "HTML element", "HTML attribute", "HTML element with attributes", "HTML element with children"], "_raw_llm_output": "HTML, HTML element, HTML attribute, HTML element with attributes, HTML element with children"}
{"seed": "// IsNamespaced returns true if the passed Unstructured object\n// is namespace-scoped (not cluster-scoped); false otherwise.\nfunc IsNamespaced(u *unstructured.Unstructured) bool {\n\tif u == nil {\n\t\treturn false\n\t}\n\treturn u.GetNamespace() != \"\"\n}", "id": 13777, "concepts": ["unstructured.Unstructured", "namespace handling", "string comparison"], "_raw_llm_output": "unstructured.Unstructured, namespace handling, string comparison"}
{"seed": "// SplitAfter takes a slice and a predicate, and returns the slice chunked,\n// split after any element where the predicate returns true.\nfunc SplitAfter[T any](slice []T, predicate func(T) bool) [][]T {\n\tvar result [][]T\n\tvar building []T\n\tfor _, elem := range slice {\n\t\tbuilding = append(building, elem)\n\t\tif predicate(elem) {\n\t\t\tresult = append(result, building)\n\t\t\tbuilding = []T{}\n\t\t}\n\t}\n\tif len(building) > 0 {\n\t\tresult = append(result, building)\n\t}\n\treturn result\n}", "id": 13780, "concepts": ["slice iteration (range loop)", "slice construction", "function definition"], "_raw_llm_output": "slice iteration (range loop), slice construction, function definition"}
{"seed": "// newManifestApp will generate a valid minimal types.App for use in a\n// schema.ImageManifest. This is necessary as placing a completely empty\n// types.App into a manifest will result in an invalid manifest.\nfunc newManifestApp() *types.App {\n\treturn &types.App{\n\t\tUser:  \"0\",\n\t\tGroup: \"0\",\n\t}\n}", "id": 13785, "concepts": ["struct definition", "pointer usage", "struct field initialization"], "_raw_llm_output": "struct definition, pointer usage, struct field initialization"}
{"seed": "//\n//  AuthWrapper \u662f\u4e00\u4e2a\u9ad8\u9636\u51fd\u6570\uff0c\u5165\u53c2\u662f \"\u4e0b\u4e00\u6b65\" \u51fd\u6570\uff0c\u51fa\u53c2\u662f\u8ba4\u8bc1\u51fd\u6570\n// \u5728\u8fd4\u56de\u7684\u51fd\u6570\u5185\u90e8\u5904\u7406\u5b8c\u8ba4\u8bc1\u903b\u8f91\u540e\uff0c\u518d\u624b\u52a8\u8c03\u7528 fn() \u8fdb\u884c\u4e0b\u4e00\u6b65\u5904\u7406\n// token \u662f\u4ece \u4e0a\u4e0b\u6587\u4e2d\u53d6\u51fa\u7684\uff0c\u518d\u8c03\u7528 user-service \u5c06\u5176\u505a\u9a8c\u8bc1\n// \u8ba4\u8bc1\u901a\u8fc7\u5219 fn() \u7ee7\u7eed\u6267\u884c\uff0c\u5426\u5219\u62a5\u9519\n//\nfunc AuthWrapper(fn server.HandlerFunc) server.HandlerFunc {\n\tlog.Println(\"AuthWrapper\")\n\treturn func(ctx context.Context, req server.Request, resp interface{}) error {\n\t\t// consignment-service \u72ec\u7acb\u6d4b\u8bd5\u65f6\u4e0d\u8fdb\u884c\u8ba4\u8bc1\n\t\tif os.Getenv(\"DISABLE_AUTH\") == \"true\" {\n\t\t\treturn fn(ctx, req, resp)\n\t\t}\n\t\tmeta, ok := metadata.FromContext(ctx)\n\t\tif !ok {\n\t\t\treturn errors.New(\"no auth meta-data found in request\")\n\t\t}\n\n\t\ttoken := meta[\"token\"]\n\n\t\t// Auth here\n\t\tauthResp, err := GetUserClient().ValidateToken(context.Background(), &userPb.Token{\n\t\t\tToken: token,\n\t\t})\n\n\t\tlog.Println(\"Auth Resp:\", authResp)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\n\t\t// \u8fd9\u91cc\u5c06 JWT \u89e3\u6790\u51fa\u6765\u7684 user_id \u4f20\u9012\u4e0b\u53bb\n\t\tctx = context.WithValue(ctx, \"user_id\", authResp.UserId)\n\t\terr = fn(ctx, req, resp)\n\t\treturn err\n\t}\n}", "id": 13788, "concepts": ["context", "metadata", "error handling", "function composition"], "_raw_llm_output": "context, metadata, error handling, function composition"}
{"seed": "// OperationResultPUnknownFutureValue returns a pointer to OperationResultVUnknownFutureValue\nfunc OperationResultPUnknownFutureValue() *OperationResult {\n\tv := OperationResultVUnknownFutureValue\n\treturn &v\n}", "id": 13793, "concepts": ["pointer usage", "pointer dereference", "pointer declaration"], "_raw_llm_output": "pointer usage, pointer dereference, pointer declaration"}
{"seed": "// WithMaxConnections configures the maximum number of connections to allow for\n// a given server. If max is 0, then the default will be math.MaxInt64.\nfunc WithMaxConnections(fn func(uint64) uint64) ServerOption {\n\treturn func(cfg *serverConfig) error {\n\t\tcfg.maxConns = fn(cfg.maxConns)\n\t\treturn nil\n\t}\n}", "id": 13801, "concepts": ["function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition"], "_raw_llm_output": "function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition"}
{"seed": "// getRootCAs gets generates a cert pool from the certs at caCertPath. If caCertPath is empty, the systems cert pool is used.\n// If an error happens when retrieving the system cert pool, it is logged (not returned) and an empty (not nil) cert pool is returned.\nfunc getRootCAs(caCertPath string) (*x509.CertPool, error) {\n\tif caCertPath != \"\" {\n\t\trootCAs := x509.NewCertPool()\n\n\t\tcaCert, err := os.ReadFile(caCertPath)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tok := rootCAs.AppendCertsFromPEM(caCert)\n\t\tif !ok {\n\t\t\treturn nil, errors.New(\"invalid CA cert\")\n\t\t}\n\n\t\treturn rootCAs, nil\n\t}\n\n\trootCAs, err := x509.SystemCertPool()\n\tif err != nil {\n\t\trootCAs = x509.NewCertPool()\n\t\tWarnfCtx(context.Background(), \"Could not retrieve root CAs: %v\", err)\n\t}\n\treturn rootCAs, nil\n}", "id": 13803, "concepts": ["x509 package usage", "os.ReadFile", "x509.NewCertPool", "x509.SystemCertPool", "error handling (errors.New)", "if statement"], "_raw_llm_output": "x509 package usage, os.ReadFile, x509.NewCertPool, x509.SystemCertPool, error handling (errors.New), if statement"}
{"seed": "// CreateDNSLinkName converts a subdomain into the Name format for dnslink TXT entries.\nfunc CreateDNSLinkName(subdomain string) string {\n\treturn fmt.Sprintf(\"_dnslink.%s\", subdomain)\n}", "id": 13805, "concepts": ["string formatting", "fmt package usage"], "_raw_llm_output": "string formatting, fmt package usage"}
{"seed": "// NewClient creates a new Client. It merges the default Config together with\n// config.\nfunc NewClient(config *Config) *Client {\n\tc := &Client{config: defaultConfig.Merge(config)}\n\n\treturn c\n}", "id": 13818, "concepts": ["struct composition", "struct composition with anonymous struct", "struct composition with struct pointer", "struct composition with struct pointer and anonymous struct", "struct composition with struct pointer and anonymous struct and anonymous struct", "struct composition with struct pointer and anonymous struct and anonymous struct and anonymous struct", "struct composition with struct pointer and anonymous struct and anonymous struct and anonymous struct and anonymous struct", "struct composition with struct pointer and anonymous struct and anonymous struct and anonymous struct and anonymous struct and anonymous struct", "struct composition with struct pointer and anonymous struct and anonymous struct and anonymous struct and anonymous struct and anonymous struct and anonymous struct", "struct composition with struct pointer and anonymous struct and anonymous struct and anonymous struct and anonymous struct and anonymous struct and anonymous struct and anonymous struct", "struct composition with struct pointer and anonymous struct and anonymous struct and anonymous struct and anonymous struct and anonymous struct and anonymous struct and anonymous struct and anonymous struct", "struct composition with struct pointer and anonymous struct and anonymous struct and anonymous struct and anonymous struct and anonymous struct and anonymous struct and anonymous struct and anonymous struct and anonymous struct", "struct composition with struct pointer and anonymous struct and anonymous struct and anonymous struct and anonymous struct and anonymous struct and anonymous struct and anonymous struct and anonymous struct and anonymous struct and anonymous struct", "struct composition with struct pointer and anonymous struct and anonymous struct and anonymous struct and"], "_raw_llm_output": "struct composition, struct composition with anonymous struct, struct composition with struct pointer, struct composition with struct pointer and anonymous struct, struct composition with struct pointer and anonymous struct and anonymous struct, struct composition with struct pointer and anonymous struct and anonymous struct and anonymous struct, struct composition with struct pointer and anonymous struct and anonymous struct and anonymous struct and anonymous struct, struct composition with struct pointer and anonymous struct and anonymous struct and anonymous struct and anonymous struct and anonymous struct, struct composition with struct pointer and anonymous struct and anonymous struct and anonymous struct and anonymous struct and anonymous struct and anonymous struct, struct composition with struct pointer and anonymous struct and anonymous struct and anonymous struct and anonymous struct and anonymous struct and anonymous struct and anonymous struct, struct composition with struct pointer and anonymous struct and anonymous struct and anonymous struct and anonymous struct and anonymous struct and anonymous struct and anonymous struct and anonymous struct, struct composition with struct pointer and anonymous struct and anonymous struct and anonymous struct and anonymous struct and anonymous struct and anonymous struct and anonymous struct and anonymous struct and anonymous struct, struct composition with struct pointer and anonymous struct and anonymous struct and anonymous struct and anonymous struct and anonymous struct and anonymous struct and anonymous struct and anonymous struct and anonymous struct and anonymous struct, struct composition with struct pointer and anonymous struct and anonymous struct and anonymous struct and"}
{"seed": "// Create a CloudFormation stack given a body template\n// Method has a maximum template size of 51,200 bytes\n// https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/cloudformation-limits.html\nfunc createStackFromBody(sess client.ConfigProvider, templateBody []byte, stackName string) error {\n\n\t// Tags for the CloudFormation stack\n\ttags := []*cfn.Tag{\n\t\t{\n\t\t\tKey:   aws.String(\"Product\"),\n\t\t\tValue: aws.String(\"MaxEdge\"),\n\t\t},\n\t}\n\n\t//Creates CloudFormation stack\n\tsvc := cfn.New(sess)\n\tinput := &cfn.CreateStackInput{\n\t\tTemplateBody: aws.String(string(templateBody)),\n\t\tStackName:    aws.String(stackName),\n\t\tTags:         tags,\n\t\tCapabilities: []*string{aws.String(\"CAPABILITY_NAMED_IAM\")}, // Required because of creating a stack that is creating IAM resources\n\t}\n\n\tfmt.Println(\"Stack creation initiated...\")\n\n\t// Creates the stack\n\t_, err := svc.CreateStack(input)\n\tif err != nil {\n\t\tfmt.Println(\"Got error creating stack:\")\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\treturn nil\n}", "id": 13835, "concepts": ["AWS SDK usage", "AWS CloudFormation", "IAM", "CloudFormation stack creation"], "_raw_llm_output": "AWS SDK usage, AWS CloudFormation, IAM, CloudFormation stack creation"}
{"seed": "// Asserts that two floats are equal to within a positive delta.\n// typ = 0: Absolute delta; typ = 1: Relative delta.\n// NaNs or Infs are considerred equal.\nfunc EqualFloat64(actual, expected, delta float64, typ int) (status bool) {\n\tswitch {\n\tcase math.IsNaN(actual) || math.IsNaN(expected):\n\t\tstatus = math.IsNaN(actual) == math.IsNaN(expected)\n\t\tbreak\n\tcase math.IsInf(actual, 0) || math.IsInf(expected, 0):\n\t\tstatus = math.IsInf(actual, 0) == math.IsInf(expected, 0)\n\t\tbreak\n\tcase expected == 0:\n\t\tstatus = math.Abs(actual-expected) < math.Abs(delta)\n\t\tbreak\n\tcase expected != 0:\n\t\tif typ == 0 {\n\t\t\tstatus = math.Abs(actual-expected) < math.Abs(delta)\n\t\t} else {\n\t\t\tstatus = math.Abs(actual-expected)/math.Abs(expected) < math.Abs(delta)\n\t\t}\n\t}\n\treturn\n}", "id": 13840, "concepts": ["floating point comparison", "math package usage"], "_raw_llm_output": "floating point comparison, math package usage"}
{"seed": "// Returns `true` if a construct is a stack element (i.e. part of the synthesized cloudformation template).\n//\n// Uses duck-typing instead of `instanceof` to allow stack elements from different\n// versions of this library to be included in the same stack.\n//\n// Returns: The construct as a stack element or undefined if it is not a stack element.\n// Experimental.\nfunc CfnContact_IsCfnElement(x interface{}) *bool {\n\t_init_.Initialize()\n\n\tvar returns *bool\n\n\t_jsii_.StaticInvoke(\n\t\t\"monocdk.aws_ssmcontacts.CfnContact\",\n\t\t\"isCfnElement\",\n\t\t[]interface{}{x},\n\t\t&returns,\n\t)\n\n\treturn returns\n}", "id": 13843, "concepts": ["duck-typing", "standard library usage"], "_raw_llm_output": "duck-typing, standard library usage"}
{"seed": "// AlertCategory_Values returns all elements of the AlertCategory enum\nfunc AlertCategory_Values() []string {\n\treturn []string{\n\t\tAlertCategorySchedulingError,\n\t\tAlertCategoryPlaybackWarning,\n\t\tAlertCategoryInfo,\n\t}\n}", "id": 13845, "concepts": ["enum", "string slice", "basic function definition"], "_raw_llm_output": "enum, string slice, basic function definition"}
{"seed": "// New stores the provided control value and makes a new routine object. control is the mixer control to monitor. See\n// the man pages for amixer for more information on that. colors is an optional triplet of hex color codes for\n// colorizing the output based on these rules:\n//   1. Normal color, for normal printing.\n//   2. Warning color, for when the volume is muted.\n//   3. Error color, for error messages.\nfunc New(control string, colors ...[3]string) *Routine {\n\tvar r Routine\n\n\tr.control = control\n\n\t// Do a minor sanity check on the color codes.\n\tif len(colors) == 1 {\n\t\tfor _, color := range colors[0] {\n\t\t\tif !strings.HasPrefix(color, \"#\") || len(color) != 7 {\n\t\t\t\tr.err = fmt.Errorf(\"invalid color\")\n\t\t\t\treturn &r\n\t\t\t}\n\t\t}\n\t\tr.colors.normal = \"^c\" + colors[0][0] + \"^\"\n\t\tr.colors.warning = \"^c\" + colors[0][1] + \"^\"\n\t\tr.colors.error = \"^c\" + colors[0][2] + \"^\"\n\t} else {\n\t\t// If a color array wasn't passed in, then we don't want to print this.\n\t\tcolorEnd = \"\"\n\t}\n\n\treturn &r\n}", "id": 13846, "concepts": ["string manipulation", "colorization", "string formatting", "array indexing", "error handling"], "_raw_llm_output": "string manipulation, colorization, string formatting, array indexing, error handling"}
{"seed": "// Tt represents the HTML element 'tt'.\n// For more information visit https://www.w3schools.com/tags/tag_tt.asp.\nfunc Tt(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"tt\", Attributes: attrs, Children: children}\n}", "id": 13847, "concepts": ["HTML generation", "HTML tree representation", "HTML element definition"], "_raw_llm_output": "HTML generation, HTML tree representation, HTML element definition"}
{"seed": "// getRule returns the last rule in bld that has the given ruleKind and matches\n// the specified rt value.\nfunc getRule(bld *build.File, ruleKind string, rt ruleType) *build.Rule {\n\trs := buildRules(bld, ruleKind)\n\tfor i := len(rs) - 1; i >= 0; i-- {\n\t\tr := rs[i]\n\t\tif ruleMatches(bld, r, rt) {\n\t\t\treturn r\n\t\t}\n\t}\n\treturn nil\n}", "id": 13851, "concepts": ["build.File", "build.Rule", "build.Rule.RuleType", "build.Rule.RuleType.RuleType", "build.Rule.RuleType.RuleType.RuleType", "build.Rule.RuleType.RuleType.RuleType.RuleType", "build.Rule.RuleType.RuleType.RuleType.RuleType.RuleType", "build.Rule.RuleType.RuleType.RuleType.RuleType.RuleType.RuleType", "build.Rule.RuleType.RuleType.RuleType.RuleType.RuleType.RuleType.RuleType", "build.Rule.RuleType.RuleType.RuleType.RuleType.RuleType.RuleType.RuleType.RuleType", "build.Rule.RuleType.RuleType.RuleType.RuleType.RuleType.RuleType.RuleType.RuleType.RuleType", "build.Rule.RuleType.RuleType.RuleType.RuleType.RuleType.RuleType.RuleType.RuleType.RuleType.RuleType", "build.Rule.RuleType.RuleType.RuleType.RuleType.RuleType.RuleType.RuleType.RuleType.RuleType.RuleType.RuleType", "build.Rule.Rule"], "_raw_llm_output": "build.File, build.Rule, build.Rule.RuleType, build.Rule.RuleType.RuleType, build.Rule.RuleType.RuleType.RuleType, build.Rule.RuleType.RuleType.RuleType.RuleType, build.Rule.RuleType.RuleType.RuleType.RuleType.RuleType, build.Rule.RuleType.RuleType.RuleType.RuleType.RuleType.RuleType, build.Rule.RuleType.RuleType.RuleType.RuleType.RuleType.RuleType.RuleType, build.Rule.RuleType.RuleType.RuleType.RuleType.RuleType.RuleType.RuleType.RuleType, build.Rule.RuleType.RuleType.RuleType.RuleType.RuleType.RuleType.RuleType.RuleType.RuleType, build.Rule.RuleType.RuleType.RuleType.RuleType.RuleType.RuleType.RuleType.RuleType.RuleType.RuleType, build.Rule.RuleType.RuleType.RuleType.RuleType.RuleType.RuleType.RuleType.RuleType.RuleType.RuleType.RuleType, build.Rule.Rule"}
{"seed": "// ParseAnnotations parses annotations for CDI device injection requests.\n// The keys and devices from all such requests are collected into slices\n// which are returned as the result. All devices are expected to be fully\n// qualified CDI device names. If any device fails this check empty slices\n// are returned along with a non-nil error. The annotations are expected\n// to be formatted by, or in a compatible fashion to UpdateAnnotations().\nfunc ParseAnnotations(annotations map[string]string) ([]string, []string, error) {\n\tvar (\n\t\tkeys    []string\n\t\tdevices []string\n\t)\n\n\tfor key, value := range annotations {\n\t\tif !strings.HasPrefix(key, AnnotationPrefix) {\n\t\t\tcontinue\n\t\t}\n\t\tfor _, d := range strings.Split(value, \",\") {\n\t\t\tif !IsQualifiedName(d) {\n\t\t\t\treturn nil, nil, fmt.Errorf(\"invalid CDI device name %q\", d)\n\t\t\t}\n\t\t\tdevices = append(devices, d)\n\t\t}\n\t\tkeys = append(keys, key)\n\t}\n\n\treturn keys, devices, nil\n}", "id": 13859, "concepts": ["string manipulation", "string splitting", "string joining", "string comparison", "string formatting", "string length", "string prefix", "string suffix", "string trimming", "string concatenation", "string iteration", "string length", "string prefix", "string suffix", "string trimming", "string concatenation", "string iteration", "string length", "string prefix", "string suffix", "string trimming", "string concatenation", "string iteration", "string length", "string prefix", "string suffix", "string trimming", "string concatenation", "string iteration", "string length", "string prefix", "string suffix", "string trimming", "string concatenation", "string iteration", "string length", "string prefix", "string suffix", "string trimming", "string concatenation", "string iteration", "string length", "string prefix", "string suffix", "string trimming", "string concatenation", "string iteration", "string length", "string prefix", "string suffix", "string trimming", "string concatenation", "string iteration", "string length", "string prefix", "string suffix", "string trimming", "string concatenation", "string iteration", "string length", "string prefix", "string suffix", "string trimming", "string concatenation", "string iteration", "string length", "string prefix", "string suffix", "string trimming", "string concatenation", "string iteration", "string length", "string prefix", "string suffix", ""], "_raw_llm_output": "string manipulation, string splitting, string joining, string comparison, string formatting, string length, string prefix, string suffix, string trimming, string concatenation, string iteration, string length, string prefix, string suffix, string trimming, string concatenation, string iteration, string length, string prefix, string suffix, string trimming, string concatenation, string iteration, string length, string prefix, string suffix, string trimming, string concatenation, string iteration, string length, string prefix, string suffix, string trimming, string concatenation, string iteration, string length, string prefix, string suffix, string trimming, string concatenation, string iteration, string length, string prefix, string suffix, string trimming, string concatenation, string iteration, string length, string prefix, string suffix, string trimming, string concatenation, string iteration, string length, string prefix, string suffix, string trimming, string concatenation, string iteration, string length, string prefix, string suffix, string trimming, string concatenation, string iteration, string length, string prefix, string suffix, string trimming, string concatenation, string iteration, string length, string prefix, string suffix,"}
{"seed": "// Fieldset_ is a convenience wrapper for Fieldset without the attrs argument.\nfunc Fieldset_(children ...HTML) HTML {\n  return Fieldset(nil, children...)\n}", "id": 13863, "concepts": ["HTML", "function definition", "basic function definition", "variadic function definition"], "_raw_llm_output": "HTML, function definition, basic function definition, variadic function definition"}
{"seed": "// PossibleMessageScopeValues returns the possible values for the MessageScope const type.\nfunc PossibleMessageScopeValues() []MessageScope {\n\treturn []MessageScope{\n\t\tMessageScopeNotSpecified,\n\t\tMessageScopeRegisteredSubscriptions,\n\t}\n}", "id": 13878, "concepts": ["const type definition", "const type usage"], "_raw_llm_output": "const type definition, const type usage"}
{"seed": "// NewReplaceSubscriptionParams creates a new ReplaceSubscriptionParams object\n// with the default values initialized.\nfunc NewReplaceSubscriptionParams() *ReplaceSubscriptionParams {\n\tvar ()\n\treturn &ReplaceSubscriptionParams{\n\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 13888, "concepts": ["struct initialization", "struct field initialization", "struct field declaration"], "_raw_llm_output": "struct initialization, struct field initialization, struct field declaration"}
{"seed": "// Object represents the HTML element 'object'.\n// For more information visit https://www.w3schools.com/tags/tag_object.asp.\nfunc Object(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"object\", Attributes: attrs, Children: children}\n}", "id": 13916, "concepts": ["HTML generation", "HTML tree traversal", "HTML element definition"], "_raw_llm_output": "HTML generation, HTML tree traversal, HTML element definition"}
{"seed": "// GetCompanyList returns the list of all the companies tracked via stockrate\nfunc GetCompanyList() (list []string) {\n\tfor key := range stocksURL {\n\t\tlist = append(list, key)\n\t}\n\treturn\n}", "id": 13921, "concepts": ["map iteration (range loop)", "map key access", "basic function definition"], "_raw_llm_output": "map iteration (range loop), map key access, basic function definition"}
{"seed": "// NewPutParams creates a new PutParams object\n// with the default values initialized.\nfunc NewPutParams() *PutParams {\n\tvar ()\n\treturn &PutParams{\n\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 13927, "concepts": ["struct initialization", "struct field initialization", "pointer receivers", "struct field access"], "_raw_llm_output": "struct initialization, struct field initialization, pointer receivers, struct field access"}
{"seed": "// StringSliceIndex returns the index of the str, else -1.\nfunc StringSliceIndex(slice []string, str string) int {\n\tfor i := range slice {\n\t\tif slice[i] == str {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}", "id": 13932, "concepts": ["slice iteration (range loop)", "string comparison"], "_raw_llm_output": "slice iteration (range loop), string comparison"}
{"seed": "// RandPop generates n randomly positioned points in the boxed bounds defined by\n// low and up.  The number of dimensions is equal to len(low).  Returned\n// points have their values initialized to +infinity.\nfunc RandPop(n int, low, up []float64) []*Point {\n\tif len(low) != len(up) {\n\t\tpanic(\"low and up vectors are not same length\")\n\t}\n\n\tndims := len(low)\n\n\tpoints := make([]*Point, n)\n\tfor i := 0; i < n; i++ {\n\t\tpos := make([]float64, ndims)\n\t\tfor j := range pos {\n\t\t\tpos[j] = low[j] + RandFloat()*(up[j]-low[j])\n\t\t}\n\t\tpoints[i] = &Point{pos, math.Inf(1)}\n\t}\n\treturn points\n}", "id": 13933, "concepts": ["slice iteration (range loop)", "slice initialization", "basic function definition", "math package usage"], "_raw_llm_output": "slice iteration (range loop), slice initialization, basic function definition, math package usage"}
{"seed": "// NewClient instantiates a new template.Client\nfunc NewClient() *Client {\n\treturn &Client{Client: onet.NewClient(cothority.Suite, ServiceName)}\n}", "id": 13936, "concepts": ["onet.NewClient", "cothority.Suite", "ServiceName"], "_raw_llm_output": "onet.NewClient, cothority.Suite, ServiceName"}
{"seed": "// NewTokenEQ applies the EQ predicate on the \"new_token\" field.\nfunc NewTokenEQ(v string) predicate.User {\n\treturn predicate.User(sql.FieldEQ(FieldNewToken, v))\n}", "id": 13956, "concepts": ["sql package usage", "predicate.User", "sql.FieldEQ"], "_raw_llm_output": "sql package usage, predicate.User, sql.FieldEQ"}
{"seed": "// NewError creates a new checkstyle.Error\n// Note that line starts at 0, and column starts at 1\nfunc NewError(line int, column int, severity Severity, message string, source string) *Error {\n\treturn &Error{Line: line, Column: column, Severity: severity, Message: message, Source: source}\n}", "id": 13962, "concepts": ["struct definition", "pointer usage"], "_raw_llm_output": "struct definition, pointer usage"}
{"seed": "// StrToAtoms is a convenience function for converting\n// []string to []uint32 atoms.\n// NOTE: If an atom name in the list doesn't exist, it will be created.\nfunc StrToAtoms(xu *xgbutil.XUtil, atomNames []string) ([]uint, error) {\n\tvar err error\n\tatoms := make([]uint, len(atomNames))\n\tfor i, atomName := range atomNames {\n\t\ta, err := Atom(xu, atomName, false)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tatoms[i] = uint(a)\n\t}\n\treturn atoms, err\n}", "id": 13968, "concepts": ["atom handling", "X11 window handling", "X11 atom handling", "X11 window property handling"], "_raw_llm_output": "atom handling, X11 window handling, X11 atom handling, X11 window property handling"}
{"seed": "// newKey returns a PolicyKey representing the specified parameters in network\n// byte-order.\nfunc newKey(id uint32, dport uint16, proto u8proto.U8proto, trafficDirection trafficdirection.TrafficDirection) PolicyKey {\n\treturn NewKey(id, dport, uint8(proto), trafficDirection.Uint8())\n}", "id": 13970, "concepts": ["type conversion", "type casting", "type aliasing", "type definition"], "_raw_llm_output": "type conversion, type casting, type aliasing, type definition"}
{"seed": "// GetFileAsString reads a file on the given path and returns its contents as a string with whitespace trimmed.\nfunc GetFileAsString(filepath string) (string, error) {\n\tdata, err := ioutil.ReadFile(filepath)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"error reading input file as string: %w\", err)\n\t}\n\treturn strings.TrimSpace(string(data)), nil\n}", "id": 13977, "concepts": ["ioutil.ReadFile", "string manipulation", "error handling"], "_raw_llm_output": "ioutil.ReadFile, string manipulation, error handling"}
{"seed": "// fmtDuration formats a duration into a hh:mm:ss format\nfunc fmtDuration(dur time.Duration) string {\n\tremainingDur := dur.Round(time.Second)\n\thours := remainingDur / time.Hour\n\tremainingDur -= hours * time.Hour\n\tminutes := remainingDur / time.Minute\n\tremainingDur -= minutes * time.Minute\n\tseconds := remainingDur / time.Second\n\treturn fmt.Sprintf(\"%02d:%02d:%02d\", hours, minutes, seconds)\n}", "id": 13985, "concepts": ["time package usage", "time formatting", "time manipulation"], "_raw_llm_output": "time package usage, time formatting, time manipulation"}
{"seed": "// Apply `kubectl apply` data to a given namespace. Specify output or any other flags as args.\n// Uses a stdin pipe to include the content of the data slice\nfunc Apply(data []byte, namespace string, args ...string) (err error) {\n\tapply := []string{\"apply\", \"-n\", namespace, \"-f\", \"-\"}\n\t_, err = pipeToKubectl(data, append(apply, args...)...)\n\treturn\n}", "id": 13995, "concepts": ["os.Stdin", "os.Stdout", "os.Stderr", "os.Exit", "os.Args", "os.Open", "os.Create", "os.Pipe", "os.Stdout.Write", "os.Stdin.Read", "os.Stdin.Close", "os.Stdout.Close", "os.Stderr.Close", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os.Exit", "os."], "_raw_llm_output": "os.Stdin, os.Stdout, os.Stderr, os.Exit, os.Args, os.Open, os.Create, os.Pipe, os.Stdout.Write, os.Stdin.Read, os.Stdin.Close, os.Stdout.Close, os.Stderr.Close, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os.Exit, os."}
{"seed": "// NewIamUserAuthorization instantiates a new IamUserAuthorization object\n// This constructor will assign default values to properties that have it defined,\n// and makes sure properties required by API are set, but the set of arguments\n// will change when the set of required properties is changed\nfunc NewIamUserAuthorization(application string, name string) *IamUserAuthorization {\n\tthis := IamUserAuthorization{}\n\tthis.Application = application\n\tthis.Name = name\n\treturn &this\n}", "id": 14003, "concepts": ["constructor", "basic function definition", "object instantiation"], "_raw_llm_output": "constructor, basic function definition, object instantiation"}
{"seed": "// Unmanaged returns an unmanaged Davis weather client. It accepts a context for\n// cancelling the Client and a hostname (IP or domain) and port of the\n// WeatherLink Live (WLL) unit. It returns a new client for consuming weather\n// data. It returns an error if no hostname is provided. Verbose enables Client\n// logging.\nfunc Unmanaged(ctx context.Context, verbose bool, hostname string, port int) (*Client, error) {\n\tif hostname == \"\" {\n\t\treturn nil, errInvalidHostname\n\t}\n\t// if no port provided, use\n\tif port <= 0 {\n\t\tport = clientDefaultPort\n\t}\n\t// initialize report and notification channel\n\tvar u wllUnit\n\treport, notify := NewReport(verbose)\n\n\t// parse provided hostname\n\tip := net.ParseIP(hostname)\n\tswitch ip {\n\tcase nil:\n\t\t// not an IP address\n\t\tu.HostName = hostname\n\t\tu.Port = port\n\tdefault:\n\t\t// IP address\n\t\tipv4 := ip.To4() != nil\n\t\tu.HostName = hostname\n\t\tu.Port = port\n\t\tif ipv4 {\n\t\t\tu.AddrIPv4 = append(u.AddrIPv4, ip)\n\t\t} else {\n\t\t\tu.HostName = \"[\" + u.HostName + \"]\"\n\t\t\tu.AddrIPv6 = append(u.AddrIPv6, ip)\n\t\t}\n\t}\n\t// generate client\n\tc := &Client{\n\t\tNotify:  notify,\n\t\treport:  report,\n\t\tverbose: verbose,\n\t\tunit:    &u,\n\t\twg:      &sync.WaitGroup{},\n\t}\n\tc.printf(\"[davisweather] unmanaged client initialized, using WeatherLink Live unit at %s:%d\", u.HostName, u.Port)\n\n\t// start event engine, no mDNS context\n\tc.wg.Add(1)\n\tgo c.engine(ctx, nil)\n\treturn c, nil\n}", "id": 14024, "concepts": ["string formatting", "fmt package usage", "net package usage", "context package usage", "error handling (errors.New)", "integer division", "concurrency", "standard library usage"], "_raw_llm_output": "string formatting, fmt package usage, net package usage, context package usage, error handling (errors.New), integer division, concurrency, standard library usage"}
{"seed": "// Nav represents the HTML element 'nav'.\n// For more information visit https://www.w3schools.com/tags/tag_nav.asp.\nfunc Nav(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"nav\", Attributes: attrs, Children: children}\n}", "id": 14029, "concepts": ["HTML generation", "HTML tree representation", "HTML element definition", "HTML attribute definition"], "_raw_llm_output": "HTML generation, HTML tree representation, HTML element definition, HTML attribute definition"}
{"seed": "// findChildForDescType returns a field with a tag matching string(typ) by searching all top-level fields in info.\n// If no field is found, an error is returned.\nfunc findChildForDescType(info *markers.TypeInfo, typ descType) (markers.FieldInfo, error) {\n\tfor _, field := range info.Fields {\n\t\ttags, err := structtag.Parse(string(field.Tag))\n\t\tif err != nil {\n\t\t\treturn markers.FieldInfo{}, err\n\t\t}\n\t\tjsonTag, err := tags.Get(\"json\")\n\t\tif err == nil && jsonTag.Name == string(typ) {\n\t\t\treturn field, nil\n\t\t}\n\t}\n\treturn markers.FieldInfo{}, fmt.Errorf(\"no %s found for type %s\", typ, info.Name)\n}", "id": 14030, "concepts": ["structtag package usage", "error handling", "string manipulation", "type assertion"], "_raw_llm_output": "structtag package usage, error handling, string manipulation, type assertion"}
{"seed": "// HeroRepeatLT applies the LT predicate on the \"hero_repeat\" field.\nfunc HeroRepeatLT(v uint) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.LT(s.C(FieldHeroRepeat), v))\n\t})\n}", "id": 14042, "concepts": ["sql.Selector", "sql.LT", "sql.C", "predicate.User", "function definition"], "_raw_llm_output": "sql.Selector, sql.LT, sql.C, predicate.User, function definition"}
{"seed": "// HeroRepeatEQ applies the EQ predicate on the \"hero_repeat\" field.\nfunc HeroRepeatEQ(v uint) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldHeroRepeat), v))\n\t})\n}", "id": 14043, "concepts": ["predicate.User", "sql.Selector", "sql.EQ", "sql.C", "sql.Where"], "_raw_llm_output": "predicate.User, sql.Selector, sql.EQ, sql.C, sql.Where"}
{"seed": "// PossibleResourceValidationValues returns the possible values for the ResourceValidation const type.\nfunc PossibleResourceValidationValues() []ResourceValidation {\n\treturn []ResourceValidation{\n\t\tResourceValidationNotSpecified,\n\t\tResourceValidationProfaneWords,\n\t\tResourceValidationReservedWords,\n\t}\n}", "id": 14075, "concepts": ["constant definition", "type definition", "type conversion", "array definition", "slice definition", "type assertion"], "_raw_llm_output": "constant definition, type definition, type conversion, array definition, slice definition, type assertion"}
{"seed": "// RegisterModule registers a module with the given name.\n// Factory returns a module comply to Module interface.\n// T is the type of the module to be registered.\n// Returns true on success, false on failure.\n// Intended to be called from modules' init.\nfunc RegisterModule(name string, factory ModuleFactory, rp *RingParam, t ModuleType) bool {\n\tif factory == nil {\n\t\tLogger.Printf(\"No module factory for '%s' given\", name)\n\t\treturn false\n\t}\n\n\tif moduleFactories[name] != nil {\n\t\tLogger.Printf(\"'%s' already exists. ignoring.\\n\", name)\n\t\treturn false\n\t}\n\n\tmoduleFactories[name] = factory\n\tif rp != nil {\n\t\tringParams[name] = *rp\n\t}\n\tmoduleTypes[name] = t\n\tLogger.Printf(\"'%s' registerd. (Type=%v)\\n\", name, t)\n\treturn true\n}", "id": 14091, "concepts": ["map", "map iteration", "map lookup", "basic function definition"], "_raw_llm_output": "map, map iteration, map lookup, basic function definition"}
{"seed": "// Get the transfer syntax defined by the given uid.\n// If the uid is unknown, default properties are returned.\nfunc GetTransferSyntax(uid string) TransferSyntax {\n\tif ts, ok := tsmap[uid]; ok {\n\t\treturn ts\n\t}\n\n\t// I believe these are the defaults for all non-raw\n\t// image types...\n\treturn &transferSyntax{\n\t\tuid,\n\t\tbinary.LittleEndian,\n\t\tExplicit,\n\t\tInflated,\n\t\tEncapsulated,\n\t}\n}", "id": 14107, "concepts": ["map lookup", "map iteration", "string comparison", "struct definition", "pointer usage"], "_raw_llm_output": "map lookup, map iteration, string comparison, struct definition, pointer usage"}
{"seed": "// wmSnapping verifies that a window can be snapped as defined in:\n// go/arc-wm-p \"Clamshell: Snapping to half screen\" (slide #27).\nfunc wmSnapping(ctx context.Context, tconn *chrome.TestConn, a *arc.ARC, d *ui.Device) error {\n\tact, err := arc.NewActivity(a, wm.Pkg24, wm.ResizableLandscapeActivity)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer act.Close()\n\tif err := act.StartWithDefaultOptions(ctx, tconn); err != nil {\n\t\treturn err\n\t}\n\tdefer act.Stop(ctx, tconn)\n\n\tif err := wm.WaitUntilActivityIsReady(ctx, tconn, act, d); err != nil {\n\t\treturn err\n\t}\n\n\t// Snap the activity to the left.\n\tif _, err := ash.SetARCAppWindowState(ctx, tconn, wm.Pkg24, ash.WMEventSnapLeft); err != nil {\n\t\treturn errors.Wrapf(err, \"failed to left snap %s\", wm.Pkg24)\n\t}\n\n\treturn testing.Poll(ctx, func(ctx context.Context) error {\n\t\tdispInfo, err := display.GetPrimaryInfo(ctx, tconn)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\twindow, err := ash.GetARCAppWindowInfo(ctx, tconn, wm.Pkg24)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// 1-DP margin error in case of using an odd screen width.\n\t\tconst errorMargin = 1\n\t\tif math.Abs(float64(dispInfo.WorkArea.Width/2-window.BoundsInRoot.Width)) > errorMargin {\n\t\t\treturn errors.Errorf(\"invalid window width: got %d, want Abs(%d - %d) <= 1\", window.BoundsInRoot.Width, window.BoundsInRoot.Width, dispInfo.WorkArea.Width/2)\n\t\t}\n\t\tif window.BoundsInRoot.Left != 0 {\n\t\t\treturn errors.Errorf(\"invalid window origin: got %d, want 0\", window.BoundsInRoot.Left)\n\t\t}\n\t\tif window.State != ash.WindowStateLeftSnapped {\n\t\t\treturn errors.Errorf(\"invalid window state: got %s, want WindowStateLeftSnapped\", window.State)\n\t\t}\n\t\treturn nil\n\t}, &testing.PollOptions{Timeout: 10 * time.Second})\n}", "id": 14109, "concepts": ["context", "error handling (idiomatic)", "context cancellation", "error handling (errors.Wrapf)", "error handling (errors.Errorf)", "testing.Poll", "math.Abs", "math.Round", "math.Ceil", "math.Floor", "math.Round", "math.Abs", "math.Round", "math.Ceil", "math.Floor", "math.Round", "math.Abs", "math.Round", "math.Ceil", "math.Floor", "math.Round", "math.Abs", "math.Round", "math.Ceil", "math.Floor", "math.Round", "math.Abs", "math.Round", "math.Ceil", "math.Floor", "math.Round", "math.Abs", "math.Round", "math.Ceil", "math.Floor", "math.Round", "math.Abs", "math.Round", "math.Ceil", "math.Floor", "math.Round", "math.Abs", "math.Round", "math.Ceil", "math.Floor", "math.Round", "math.Abs", "math.Round", "math.Ceil", "math.Floor", "math.Round", "math.Abs", "math.Round", "math.Ceil", "math.Floor", "math.Round", "math.Abs", "math.Round", "math.Ceil", "math"], "_raw_llm_output": "context, error handling (idiomatic), context cancellation, error handling (errors.Wrapf), error handling (errors.Errorf), testing.Poll, math.Abs, math.Round, math.Ceil, math.Floor, math.Round, math.Abs, math.Round, math.Ceil, math.Floor, math.Round, math.Abs, math.Round, math.Ceil, math.Floor, math.Round, math.Abs, math.Round, math.Ceil, math.Floor, math.Round, math.Abs, math.Round, math.Ceil, math.Floor, math.Round, math.Abs, math.Round, math.Ceil, math.Floor, math.Round, math.Abs, math.Round, math.Ceil, math.Floor, math.Round, math.Abs, math.Round, math.Ceil, math.Floor, math.Round, math.Abs, math.Round, math.Ceil, math.Floor, math.Round, math.Abs, math.Round, math.Ceil, math.Floor, math.Round, math.Abs, math.Round, math.Ceil, math"}
{"seed": "// newWindow creates a new window that listens to MotionNotify events with\n// the given backgroundcolor.\nfunc newWindow(X *xgbutil.XUtil, color uint32) *xwindow.Window {\n\twin, err := xwindow.Generate(X)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\terr = win.CreateChecked(X.RootWin(), 0, 0, 400, 400,\n\t\txproto.CwBackPixel|xproto.CwEventMask,\n\t\tcolor, xproto.EventMaskPointerMotion)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\twin.Map()\n\treturn win\n}", "id": 14116, "concepts": ["xlib usage", "xproto usage", "xgbutil usage", "window creation", "event handling", "window mapping"], "_raw_llm_output": "xlib usage, xproto usage, xgbutil usage, window creation, event handling, window mapping"}
{"seed": "// NewAccountIdentityAllOfWithDefaults instantiates a new AccountIdentityAllOf object\n// This constructor will only assign default values to properties that have it defined,\n// but it doesn't guarantee that properties required by API are set\nfunc NewAccountIdentityAllOfWithDefaults() *AccountIdentityAllOf {\n\tthis := AccountIdentityAllOf{}\n\treturn &this\n}", "id": 14120, "concepts": ["struct definition", "struct initialization", "default value assignment"], "_raw_llm_output": "struct definition, struct initialization, default value assignment"}
{"seed": "// NewPcloudSapGetParams creates a new PcloudSapGetParams object,\n// with the default timeout for this client.\n//\n// Default values are not hydrated, since defaults are normally applied by the API server side.\n//\n// To enforce default values in parameter, use SetDefaults or WithDefaults.\nfunc NewPcloudSapGetParams() *PcloudSapGetParams {\n\treturn &PcloudSapGetParams{\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 14124, "concepts": ["default values", "timeout handling", "client-side default values"], "_raw_llm_output": "default values, timeout handling, client-side default values"}
{"seed": "// CloneBody returns a reader\n// with the same contents and m.Body.\n// m.Body is reset allowing it to be read from later.\nfunc CloneBody(m *Message) (io.Reader, error) {\n\tb, err := DumpBody(m)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn bytes.NewBuffer(b), nil\n}", "id": 14126, "concepts": ["io.Reader", "io.Writer", "io.ReadSeeker", "io.Closer", "io.Copy", "io.CopyBuffer", "io.TeeReader", "io.MultiReader", "io.LimitReader", "io.SectionReader", "bytes.Buffer", "bytes.NewBuffer", "bytes.NewReader", "bytes.NewBufferString", "bytes.NewBufferBytes", "bytes.NewReader", "bytes.Reader", "bytes.Buffer.Bytes", "bytes.Buffer.String", "bytes.Buffer.ReadFrom", "bytes.Buffer.WriteTo", "bytes.Buffer.Read", "bytes.Buffer.Write", "bytes.Buffer.ReadAt", "bytes.Buffer.WriteAt", "bytes.Buffer.Reset", "bytes.Buffer.Truncate", "bytes.Buffer.Grow", "bytes.Buffer.Cap", "bytes.Buffer.Len", "bytes.Buffer.Available", "bytes.Buffer.Next", "bytes.Buffer.String", "bytes.Buffer.Bytes", "bytes.Buffer.ReadFrom", "bytes.Buffer.WriteTo", "bytes.Buffer.Read", "bytes.Buffer.Write", "bytes.Buffer.ReadAt", "bytes.Buffer.WriteAt", "bytes.Buffer.Reset", "bytes.Buffer.Truncate", "bytes.Buffer.Grow", "bytes.Buffer.Cap", "bytes.Buffer.Len"], "_raw_llm_output": "io.Reader, io.Writer, io.ReadSeeker, io.Closer, io.Copy, io.CopyBuffer, io.TeeReader, io.MultiReader, io.LimitReader, io.SectionReader, bytes.Buffer, bytes.NewBuffer, bytes.NewReader, bytes.NewBufferString, bytes.NewBufferBytes, bytes.NewReader, bytes.Reader, bytes.Buffer.Bytes, bytes.Buffer.String, bytes.Buffer.ReadFrom, bytes.Buffer.WriteTo, bytes.Buffer.Read, bytes.Buffer.Write, bytes.Buffer.ReadAt, bytes.Buffer.WriteAt, bytes.Buffer.Reset, bytes.Buffer.Truncate, bytes.Buffer.Grow, bytes.Buffer.Cap, bytes.Buffer.Len, bytes.Buffer.Available, bytes.Buffer.Next, bytes.Buffer.String, bytes.Buffer.Bytes, bytes.Buffer.ReadFrom, bytes.Buffer.WriteTo, bytes.Buffer.Read, bytes.Buffer.Write, bytes.Buffer.ReadAt, bytes.Buffer.WriteAt, bytes.Buffer.Reset, bytes.Buffer.Truncate, bytes.Buffer.Grow, bytes.Buffer.Cap, bytes.Buffer.Len"}
{"seed": "// NewGetAccountInternal builds a RestAPI service getAccount endpoint internal\n// error.\nfunc NewGetAccountInternal(body *GetAccountInternalResponseBody) *goa.ServiceError {\n\tv := &goa.ServiceError{\n\t\tName:      *body.Name,\n\t\tID:        *body.ID,\n\t\tMessage:   *body.Message,\n\t\tTemporary: *body.Temporary,\n\t\tTimeout:   *body.Timeout,\n\t\tFault:     *body.Fault,\n\t}\n\n\treturn v\n}", "id": 14137, "concepts": ["struct definition", "pointer usage", "basic function definition"], "_raw_llm_output": "struct definition, pointer usage, basic function definition"}
{"seed": "// NicknameContains applies the Contains predicate on the \"nickname\" field.\nfunc NicknameContains(v string) predicate.User {\n\treturn predicate.User(sql.FieldContains(FieldNickname, v))\n}", "id": 14138, "concepts": ["predicate.User", "sql.FieldContains", "sql.Field", "sql.FieldContains"], "_raw_llm_output": "predicate.User, sql.FieldContains, sql.Field, sql.FieldContains"}
{"seed": "// timeUntilSchedule parses the schedule string and returns the time until the schedule.\n// When it is overdue, the duration is negative.\nfunc timeUntilSchedule(schedule string) (time.Duration, error) {\n\tnow := time.Now().UTC()\n\tlayout := \"2006-01-02T15:04:05Z\"\n\ts, err := time.Parse(layout, schedule)\n\tif err != nil {\n\t\treturn time.Duration(0), err\n\t}\n\treturn s.Sub(now), nil\n}", "id": 14164, "concepts": ["time.Parse", "time.ParseDuration", "time.Now", "time.Sub", "time.Duration", "time.UTC"], "_raw_llm_output": "time.Parse, time.ParseDuration, time.Now, time.Sub, time.Duration, time.UTC"}
{"seed": "// RequireFormatPath builds a path by formatting the given formatting string\n// with the given args (i.e. fmt.Sprintf). The resulting path must be valid or\n// the function panics. It should only be used when the input is statically\n// verifiable.\nfunc RequireFormatPath(format string, args ...interface{}) string {\n\tpath, err := FormatPath(format, args...)\n\tpanicOnErr(err)\n\treturn path\n}", "id": 14174, "concepts": ["panic", "error handling (panicOnErr)", "string formatting", "fmt package usage"], "_raw_llm_output": "panic, error handling (panicOnErr), string formatting, fmt package usage"}
{"seed": "// NewRateLimiter makes a new multi-tenant rate limiter. Each per-tenant limiter\n// is configured using the input strategy and its limit/burst is rechecked (and\n// reconfigured if changed) every recheckPeriod.\nfunc NewRateLimiter(strategy RateLimiterStrategy, recheckPeriod time.Duration) *RateLimiter {\n\treturn &RateLimiter{\n\t\tstrategy:      strategy,\n\t\trecheckPeriod: recheckPeriod,\n\t\ttenants:       map[string]*tenantLimiter{},\n\t}\n}", "id": 14177, "concepts": ["struct definition", "map iteration", "time package usage"], "_raw_llm_output": "struct definition, map iteration, time package usage"}
{"seed": "// GetLaunchID fetches the launchID associated with this request.  It is stored in the request context if present.\nfunc GetLaunchID(req *http.Request) string {\n\tif lid := req.Context().Value(launchIDKey); lid != nil {\n\t\tif launchID, ok := lid.(string); ok {\n\t\t\treturn launchID\n\t\t}\n\t}\n\treturn \"\"\n}", "id": 14184, "concepts": ["http.Request", "http.Handler", "context.Context", "context.WithValue", "context.Background", "context.TODO"], "_raw_llm_output": "http.Request, http.Handler, context.Context, context.WithValue, context.Background, context.TODO"}
{"seed": "// newOrgConfigGroup returns an config group for an organization.\n// It defines the crypto material for the organization (its MSP).\n// It sets the mod_policy of all elements to \"Admins\".\nfunc newOrgConfigGroup(org Organization) (*cb.ConfigGroup, error) {\n\torgGroup := newConfigGroup()\n\torgGroup.ModPolicy = AdminsPolicyKey\n\n\tif org.ModPolicy != \"\" {\n\t\torgGroup.ModPolicy = org.ModPolicy\n\t}\n\n\tif err := setPolicies(orgGroup, org.Policies); err != nil {\n\t\treturn nil, err\n\t}\n\n\tfabricMSPConfig, err := org.MSP.toProto()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"converting fabric msp config to proto: %v\", err)\n\t}\n\n\tconf, err := proto.Marshal(fabricMSPConfig)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"marshaling msp config: %v\", err)\n\t}\n\n\t// mspConfig defaults type to FABRIC which implements an X.509 based provider\n\tmspConfig := &mb.MSPConfig{\n\t\tConfig: conf,\n\t}\n\n\terr = setValue(orgGroup, mspValue(mspConfig), AdminsPolicyKey)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn orgGroup, nil\n}", "id": 14203, "concepts": ["interface conversion", "error handling", "pointer dereference", "map iteration", "string formatting", "map iteration", "string formatting", "map iteration", "string formatting", "map iteration", "string formatting", "map iteration", "string formatting", "map iteration", "string formatting", "map iteration", "string formatting", "map iteration", "string formatting", "map iteration", "string formatting", "map iteration", "string formatting", "map iteration", "string formatting", "map iteration", "string formatting", "map iteration", "string formatting", "map iteration", "string formatting", "map iteration", "string formatting", "map iteration", "string formatting", "map iteration", "string formatting", "map iteration", "string formatting", "map iteration", "string formatting", "map iteration", "string formatting", "map iteration", "string formatting", "map iteration", "string formatting", "map iteration", "string formatting", "map iteration", "string formatting", "map iteration", "string formatting", "map iteration", "string formatting", "map iteration", "string formatting", "map iteration", "string formatting", "map iteration", "string formatting", "map iteration", "string formatting", "map iteration", "string formatting", "map iteration", "string formatting", "map iteration", "string formatting", "map iteration", "string formatting", "map iteration", "string formatting", "map iteration", "string formatting", "map iteration", "string formatting", "map iteration", "string formatting", "map iteration", "string formatting", "map iteration", "string formatting", "map iteration", "string formatting"], "_raw_llm_output": "interface conversion, error handling, pointer dereference, map iteration, string formatting, map iteration, string formatting, map iteration, string formatting, map iteration, string formatting, map iteration, string formatting, map iteration, string formatting, map iteration, string formatting, map iteration, string formatting, map iteration, string formatting, map iteration, string formatting, map iteration, string formatting, map iteration, string formatting, map iteration, string formatting, map iteration, string formatting, map iteration, string formatting, map iteration, string formatting, map iteration, string formatting, map iteration, string formatting, map iteration, string formatting, map iteration, string formatting, map iteration, string formatting, map iteration, string formatting, map iteration, string formatting, map iteration, string formatting, map iteration, string formatting, map iteration, string formatting, map iteration, string formatting, map iteration, string formatting, map iteration, string formatting, map iteration, string formatting, map iteration, string formatting, map iteration, string formatting, map iteration, string formatting, map iteration, string formatting, map iteration, string formatting, map iteration, string formatting, map iteration, string formatting, map iteration, string formatting, map iteration, string formatting, map iteration, string formatting, map iteration, string formatting"}
{"seed": "// ResultFailure returns a failed Result with a failure message.\nfunc ResultFailure(message string) Result {\n\treturn result{message: message}\n}", "id": 14204, "concepts": ["struct definition", "field access", "function return value", "basic function definition"], "_raw_llm_output": "struct definition, field access, function return value, basic function definition"}
{"seed": "// NormalizeUsername normalizes a proposed username into a format that meets Sourcegraph's\n// username formatting rules (consistent with\n// https://help.github.com/enterprise/2.11/admin/guides/user-management/using-ldap/#username-considerations-with-ldap):\n//\n// - Any portion of the username after a '@' character is removed\n// - Any characters not in `[a-zA-Z0-9-]` are replaced with `-`\n// - Usernames with consecutive '-' characters are not allowed\n// - Usernames that start or end with '-' are not allowed\n//\n// Usernames that could not be converted return an error.\nfunc NormalizeUsername(name string) (string, error) {\n\torigName := name\n\tif i := strings.Index(name, \"@\"); i != -1 && i == strings.LastIndex(name, \"@\") {\n\t\tname = name[:i]\n\t}\n\tname = disallowedCharacter.ReplaceAllString(name, \"-\")\n\tif strings.HasPrefix(name, \"-\") || strings.HasSuffix(name, \"-\") || strings.Contains(name, \"--\") {\n\t\treturn \"\", fmt.Errorf(\"username %q could not be normalized to acceptable format\", origName)\n\t}\n\tif err := suspiciousnames.CheckNameAllowedForUserOrOrganization(name); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn name, nil\n}", "id": 14208, "concepts": ["string manipulation", "regular expressions", "string validation", "string formatting"], "_raw_llm_output": "string manipulation, regular expressions, string validation, string formatting"}
{"seed": "// Now returns the current time when the decision is started or replayed.\n// The workflow needs to use this Now() to get the wall clock time instead of the Go lang library one.\nfunc Now(ctx Context) time.Time {\n\treturn getWorkflowEnvironment(ctx).Now()\n}", "id": 14210, "concepts": ["time package usage", "function definition", "context usage"], "_raw_llm_output": "time package usage, function definition, context usage"}
{"seed": "// MessageFunc returns an option that matches message stanzas.\n// For more information see Message.\nfunc MessageFunc(typ stanza.MessageType, payload xml.Name, h MessageHandlerFunc) Option {\n\treturn Message(typ, payload, h)\n}", "id": 14218, "concepts": ["xml.Name", "xml.StartElement", "xml.EndElement", "xml.CharData", "xml.Comment", "xml.ProcInst", "xml.Directive", "xml.EntityRef", "xml.CharData", "xml.Comment", "xml.ProcInst", "xml.Directive", "xml.EntityRef", "xml.CharData", "xml.Comment", "xml.ProcInst", "xml.Directive", "xml.EntityRef", "xml.CharData", "xml.Comment", "xml.ProcInst", "xml.Directive", "xml.EntityRef", "xml.CharData", "xml.Comment", "xml.ProcInst", "xml.Directive", "xml.EntityRef", "xml.CharData", "xml.Comment", "xml.ProcInst", "xml.Directive", "xml.EntityRef", "xml.CharData", "xml.Comment", "xml.ProcInst", "xml.Directive", "xml.EntityRef", "xml.CharData", "xml.Comment", "xml.ProcInst", "xml.Directive", "xml.EntityRef", "xml.CharData", "xml.Comment", "xml.ProcInst", "xml.Directive", "xml.EntityRef", "xml.CharData", "xml.Comment", "xml.ProcInst", "xml.Directive", "xml.EntityRef", "xml.CharData", "xml.Comment", "xml."], "_raw_llm_output": "xml.Name, xml.StartElement, xml.EndElement, xml.CharData, xml.Comment, xml.ProcInst, xml.Directive, xml.EntityRef, xml.CharData, xml.Comment, xml.ProcInst, xml.Directive, xml.EntityRef, xml.CharData, xml.Comment, xml.ProcInst, xml.Directive, xml.EntityRef, xml.CharData, xml.Comment, xml.ProcInst, xml.Directive, xml.EntityRef, xml.CharData, xml.Comment, xml.ProcInst, xml.Directive, xml.EntityRef, xml.CharData, xml.Comment, xml.ProcInst, xml.Directive, xml.EntityRef, xml.CharData, xml.Comment, xml.ProcInst, xml.Directive, xml.EntityRef, xml.CharData, xml.Comment, xml.ProcInst, xml.Directive, xml.EntityRef, xml.CharData, xml.Comment, xml.ProcInst, xml.Directive, xml.EntityRef, xml.CharData, xml.Comment, xml.ProcInst, xml.Directive, xml.EntityRef, xml.CharData, xml.Comment, xml."}
{"seed": "// NewGetServerStatusParamsWithContext creates a new GetServerStatusParams object\n// with the default values initialized, and the ability to set a context for a request\nfunc NewGetServerStatusParamsWithContext(ctx context.Context) *GetServerStatusParams {\n\n\treturn &GetServerStatusParams{\n\n\t\tContext: ctx,\n\t}\n}", "id": 14220, "concepts": ["context package usage", "function definition", "method definition"], "_raw_llm_output": "context package usage, function definition, method definition"}
{"seed": "// newBattlestreamingresultView projects result type Battlestreamingresult to\n// projected type BattlestreamingresultView using the \"default\" view.\nfunc newBattlestreamingresultView(res *Battlestreamingresult) *shiritoriviews.BattlestreamingresultView {\n\tvres := &shiritoriviews.BattlestreamingresultView{\n\t\tType:      &res.Type,\n\t\tTimestamp: &res.Timestamp,\n\t}\n\tif res.MessagePayload != nil {\n\t\tvres.MessagePayload = transformMessagePayloadToShiritoriviewsMessagePayloadView(res.MessagePayload)\n\t}\n\treturn vres\n}", "id": 14228, "concepts": ["struct composition", "type aliasing", "type casting", "type assertion", "type conversion", "type switch"], "_raw_llm_output": "struct composition, type aliasing, type casting, type assertion, type conversion, type switch"}
{"seed": "// ReadPaymentType reads a full PaymentType structure from the database based on the supplied row object\nfunc ReadPaymentType(row *sql.Row, a *PaymentType) error {\n\terr := row.Scan(&a.PMTID, &a.BID, &a.Name, &a.Description, &a.CreateTS, &a.CreateBy, &a.LastModTime, &a.LastModBy)\n\tSkipSQLNoRowsError(&err)\n\treturn err\n}", "id": 14230, "concepts": ["SQL database usage", "SQL query execution", "SQL row scanning", "SQL error handling"], "_raw_llm_output": "SQL database usage, SQL query execution, SQL row scanning, SQL error handling"}
{"seed": "// WithUserAgentUnknownPlugin sets the User-Agent header on all requests,\n// including default value for plugin.\nfunc WithUserAgentUnknownPlugin() Option {\n\treturn WithUserAgent(\"Unknown/0\")\n}", "id": 14233, "concepts": ["function composition", "function composition with a default value"], "_raw_llm_output": "function composition, function composition with a default value"}
{"seed": "// SocialTypeContains applies the Contains predicate on the \"social_type\" field.\nfunc SocialTypeContains(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.Contains(s.C(FieldSocialType), v))\n\t})\n}", "id": 14246, "concepts": ["sql.Selector", "sql.Contains", "predicate.User", "function definition"], "_raw_llm_output": "sql.Selector, sql.Contains, predicate.User, function definition"}
{"seed": "// randomString returns a random 20-character string consisting of things you\n// might see in a log message.\nfunc randomString() string {\n\tr := make([]rune, 20)\n\tfor i := range r {\n\t\tr[i] = letters[rand.Intn(len(letters))]\n\t}\n\treturn string(r)\n}", "id": 14249, "concepts": ["random number generation", "string manipulation"], "_raw_llm_output": "random number generation, string manipulation"}
{"seed": "// NewWidths makes a new Widths map\nfunc NewWidths() Widths {\n\treturn make(map[int]int)\n}", "id": 14259, "concepts": ["map creation", "map iteration (range loop)", "map key access"], "_raw_llm_output": "map creation, map iteration (range loop), map key access"}
{"seed": "// ExtractRegionKeyEndPos extracts the END POS code from RegionKey.\nfunc ExtractRegionKeyEndPos(rk uint64) uint32 {\n\treturn uint32(C.extract_regionkey_endpos(C.uint64_t(rk)))\n}", "id": 14264, "concepts": ["CGO", "C.uint64_t", "C.extract_regionkey_endpos", "uint32", "uint64"], "_raw_llm_output": "CGO, C.uint64_t, C.extract_regionkey_endpos, uint32, uint64"}
{"seed": "// Layout builds a new DAG with the trickle format using the provided\n// DagBuilderHelper. See the module's description for a more detailed\n// explanation.\n//\n// Deprecated: use github.com/ipfs/boxo/ipld/unixfs/importer/trickle.Layout\nfunc Layout(db *h.DagBuilderHelper) (ipld.Node, error) {\n\tnewRoot := db.NewFSNodeOverDag(ft.TFile)\n\troot, _, err := fillTrickleRec(db, newRoot, -1)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn root, db.Add(root)\n}", "id": 14265, "concepts": ["DAG construction", "recursive function definition", "standard library usage"], "_raw_llm_output": "DAG construction, recursive function definition, standard library usage"}
{"seed": "// NewUserClient returns a client for the User from the given config.\nfunc NewUserClient(c config) *UserClient {\n\treturn &UserClient{config: c}\n}", "id": 14273, "concepts": ["struct definition", "struct field access", "struct initialization"], "_raw_llm_output": "struct definition, struct field access, struct initialization"}
{"seed": "// parseGemFileLockEntries is a parser function for Gemfile.lock contents, returning all Gems discovered.\nfunc parseGemFileLockEntries(_ string, reader io.Reader) ([]pkg.Package, error) {\n\tpkgs := make([]pkg.Package, 0)\n\tscanner := bufio.NewScanner(reader)\n\n\tvar currentSection string\n\n\tfor scanner.Scan() {\n\t\tline := scanner.Text()\n\t\tsanitizedLine := strings.TrimSpace(line)\n\n\t\tif len(line) > 1 && line[0] != ' ' {\n\t\t\t// start of section\n\t\t\tcurrentSection = sanitizedLine\n\t\t\tcontinue\n\t\t} else if !sectionsOfInterest.Contains(currentSection) {\n\t\t\t// skip this line, we're in the wrong section\n\t\t\tcontinue\n\t\t}\n\n\t\tif isDependencyLine(line) {\n\t\t\tcandidate := strings.Fields(sanitizedLine)\n\t\t\tif len(candidate) != 2 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tpkgs = append(pkgs, pkg.Package{\n\t\t\t\tName:     candidate[0],\n\t\t\t\tVersion:  strings.Trim(candidate[1], \"()\"),\n\t\t\t\tLanguage: pkg.Ruby,\n\t\t\t\tType:     pkg.GemPkg,\n\t\t\t})\n\t\t}\n\t}\n\tif err := scanner.Err(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn pkgs, nil\n}", "id": 14279, "concepts": ["string manipulation", "string comparison", "string trimming", "string splitting", "string fields", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimming", "string trimm"], "_raw_llm_output": "string manipulation, string comparison, string trimming, string splitting, string fields, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimming, string trimm"}
{"seed": "// Abbr_ is a convenience wrapper for Abbr without the attrs argument.\nfunc Abbr_(children ...HTML) HTML {\n  return Abbr(nil, children...)\n}", "id": 14284, "concepts": ["HTML", "HTML tag definition", "HTML attribute definition"], "_raw_llm_output": "HTML, HTML tag definition, HTML attribute definition"}
{"seed": "// wmRT17 covers resizable/tablet: font size change.\n// Expected behavior is defined in: go/arc-wm-r RT17: resizable/tablet: font size change.\nfunc wmRT17(ctx context.Context, tconn *chrome.TestConn, a *arc.ARC, d *ui.Device) error {\n\tacts := []wm.TabletLaunchActivityInfo{\n\t\twm.TabletLaunchActivityInfo{\n\t\t\tActivityName: wm.ResizableLandscapeActivity,\n\t\t\tDesiredDO:    display.OrientationLandscapePrimary,\n\t\t},\n\t\twm.TabletLaunchActivityInfo{\n\t\t\tActivityName: wm.ResizableUnspecifiedActivity,\n\t\t\tDesiredDO:    display.OrientationLandscapePrimary,\n\t\t},\n\t\twm.TabletLaunchActivityInfo{\n\t\t\tActivityName: wm.ResizablePortraitActivity,\n\t\t\tDesiredDO:    display.OrientationPortraitPrimary,\n\t\t},\n\t\twm.TabletLaunchActivityInfo{\n\t\t\tActivityName: wm.ResizableUnspecifiedActivity,\n\t\t\tDesiredDO:    display.OrientationPortraitPrimary,\n\t\t},\n\t}\n\n\treturn wm.TabletFontSizeChangeHelper(ctx, tconn, a, d, acts)\n}", "id": 14289, "concepts": ["ARC", "Android UI testing", "display orientation", "tablet mode", "font size change"], "_raw_llm_output": "ARC, Android UI testing, display orientation, tablet mode, font size change"}
{"seed": "// MergeStringMaps combines two string maps. The result is a new map (both maps are\n// unchanged) containing all entries from m1 and m2. If a key is present in both maps\n// the value from m2 is used.\nfunc MergeStringMaps(m1, m2 map[string]string) map[string]string {\n\tres := make(map[string]string, len(m1)+len(m2))\n\tfor key, value := range m1 {\n\t\tres[key] = value\n\t}\n\tfor key, value := range m2 {\n\t\tres[key] = value\n\t}\n\treturn res\n}", "id": 14292, "concepts": ["map iteration (range loop)", "map creation", "map update", "map merge"], "_raw_llm_output": "map iteration (range loop), map creation, map update, map merge"}
{"seed": "// NewListAlertableEventTypeParamsWithTimeout creates a new ListAlertableEventTypeParams object\n// with the default values initialized, and the ability to set a timeout on a request\nfunc NewListAlertableEventTypeParamsWithTimeout(timeout time.Duration) *ListAlertableEventTypeParams {\n\tvar ()\n\treturn &ListAlertableEventTypeParams{\n\n\t\ttimeout: timeout,\n\t}\n}", "id": 14310, "concepts": ["timeout handling", "time package usage", "function definition"], "_raw_llm_output": "timeout handling, time package usage, function definition"}
{"seed": "// NewRenewOrganizationLicensesSeatsParamsWithContext creates a new RenewOrganizationLicensesSeatsParams object\n// with the default values initialized, and the ability to set a context for a request\nfunc NewRenewOrganizationLicensesSeatsParamsWithContext(ctx context.Context) *RenewOrganizationLicensesSeatsParams {\n\tvar ()\n\treturn &RenewOrganizationLicensesSeatsParams{\n\n\t\tContext: ctx,\n\t}\n}", "id": 14312, "concepts": ["context package usage", "function definition", "basic function definition"], "_raw_llm_output": "context package usage, function definition, basic function definition"}
{"seed": "// FindConditionByType returns first Condition with given conditionType\n// along with bool flag which indicates if the Condition is found or not\nfunc FindConditionByType(conditions []toolchainv1alpha1.Condition, conditionType toolchainv1alpha1.ConditionType) (toolchainv1alpha1.Condition, bool) {\n\tfor _, condition := range conditions {\n\t\tif condition.Type == conditionType {\n\t\t\treturn condition, true\n\t\t}\n\t}\n\treturn toolchainv1alpha1.Condition{}, false\n}", "id": 14318, "concepts": ["slice iteration", "boolean flag", "struct field access"], "_raw_llm_output": "slice iteration, boolean flag, struct field access"}
{"seed": "// Open is a helper function that takes as input a connection string for a DB,\n// and returns either a sqlx.DB instance or an error. This function is separated\n// out to help with CLI tasks for managing migrations.\nfunc Open(connStr string) (*sqlx.DB, error) {\n\treturn sqlx.Open(\"postgres\", connStr)\n}", "id": 14320, "concepts": ["sqlx package usage", "sqlx.Open", "sqlx.DB", "sqlx.Exec", "sqlx.QueryRow", "sqlx.NamedExec", "sqlx.NamedQueryRow"], "_raw_llm_output": "sqlx package usage, sqlx.Open, sqlx.DB, sqlx.Exec, sqlx.QueryRow, sqlx.NamedExec, sqlx.NamedQueryRow"}
{"seed": "// H4_ is a convenience wrapper for H4 without the attrs argument.\nfunc H4_(children ...HTML) HTML {\n  return H4(nil, children...)\n}", "id": 14327, "concepts": ["HTML struct", "basic function definition", "function argument handling"], "_raw_llm_output": "HTML struct, basic function definition, function argument handling"}
{"seed": "// This test asserts that we only track node connections if they are not from\n// forwarded RPCs. This is essential otherwise we will think a Yamux session to\n// a Nomad server is actually the session to the node.\nfunc TestClientEndpoint_Register_NodeConn_Forwarded(t *testing.T) {\n\tt.Parallel()\n\trequire := require.New(t)\n\ts1 := TestServer(t, func(c *Config) {\n\t\tc.BootstrapExpect = 2\n\t})\n\n\tdefer s1.Shutdown()\n\ts2 := TestServer(t, func(c *Config) {\n\t\tc.DevDisableBootstrap = true\n\t})\n\tdefer s2.Shutdown()\n\tTestJoin(t, s1, s2)\n\ttestutil.WaitForLeader(t, s1.RPC)\n\ttestutil.WaitForLeader(t, s2.RPC)\n\n\t// Determine the non-leader server\n\tvar leader, nonLeader *Server\n\tif s1.IsLeader() {\n\t\tleader = s1\n\t\tnonLeader = s2\n\t} else {\n\t\tleader = s2\n\t\tnonLeader = s1\n\t}\n\n\t// Send the requests to the non-leader\n\tcodec := rpcClient(t, nonLeader)\n\n\t// Check that we have no client connections\n\trequire.Empty(nonLeader.connectedNodes())\n\trequire.Empty(leader.connectedNodes())\n\n\t// Create the register request\n\tnode := mock.Node()\n\treq := &structs.NodeRegisterRequest{\n\t\tNode:         node,\n\t\tWriteRequest: structs.WriteRequest{Region: \"global\"},\n\t}\n\n\t// Fetch the response\n\tvar resp structs.GenericResponse\n\tif err := msgpackrpc.CallWithCodec(codec, \"Node.Register\", req, &resp); err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\tif resp.Index == 0 {\n\t\tt.Fatalf(\"bad index: %d\", resp.Index)\n\t}\n\n\t// Check that we have the client connections on the non leader\n\tnodes := nonLeader.connectedNodes()\n\trequire.Len(nodes, 1)\n\trequire.Contains(nodes, node.ID)\n\n\t// Check that we have no client connections on the leader\n\tnodes = leader.connectedNodes()\n\trequire.Empty(nodes)\n\n\t// Check for the node in the FSM\n\tstate := leader.State()\n\ttestutil.WaitForResult(func() (bool, error) {\n\t\tout, err := state.NodeByID(nil, node.ID)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\tif out == nil {\n\t\t\treturn false, fmt.Errorf(\"expected node\")\n\t\t}\n\t\tif out.CreateIndex != resp.Index {\n\t\t\treturn false, fmt.Errorf(\"index mis-match\")\n\t\t}\n\t\tif out.ComputedClass == \"\" {\n\t\t\treturn false, fmt.Errorf(\"ComputedClass not set\")\n\t\t}\n\n\t\treturn true, nil\n\t}, func(err error) {\n\t\tt.Fatalf(\"err: %v\", err)\n\t})\n\n\t// Close the connection and check that we remove the client connections\n\trequire.Nil(codec.Close())\n\ttestutil.WaitForResult(func() (bool, error) {\n\t\tnodes := nonLeader.connectedNodes()\n\t\treturn len(nodes) == 0, nil\n\t}, func(err error) {\n\t\tt.Fatalf(\"should have no clients\")\n\t})\n}", "id": 14332, "concepts": ["error handling (msgpackrpc.CallWithCodec)", "error handling (require.New)", "error handling (require.Nil)", "error handling (require.Empty)", "error handling (require.Contains)", "error handling (require.Len)", "error handling (require.Contains)", "error handling (require.Contains)", "error handling (require.Contains)", "error handling (require.Contains)", "error handling (require.Contains)", "error handling (require.Contains)", "error handling (require.Contains)", "error handling (require.Contains)", "error handling (require.Contains)", "error handling (require.Contains)", "error handling (require.Contains)", "error handling (require.Contains)", "error handling (require.Contains)", "error handling (require.Contains)", "error handling (require.Contains)", "error handling (require.Contains)", "error handling (require.Contains)", "error handling (require.Contains)", "error handling (require.Contains)", "error handling (require.Contains)", "error handling (require.Contains)", "error handling (require.Contains)", "error handling (require.Contains)", "error handling (require.Contains)", "error handling (require.Contains)", "error handling (require.Contains)", "error handling (require.Contains)", "error handling (require.Contains)", "error handling (require.Contains)", "error handling (require.Contains"], "_raw_llm_output": "error handling (msgpackrpc.CallWithCodec), error handling (require.New), error handling (require.Nil), error handling (require.Empty), error handling (require.Contains), error handling (require.Len), error handling (require.Contains), error handling (require.Contains), error handling (require.Contains), error handling (require.Contains), error handling (require.Contains), error handling (require.Contains), error handling (require.Contains), error handling (require.Contains), error handling (require.Contains), error handling (require.Contains), error handling (require.Contains), error handling (require.Contains), error handling (require.Contains), error handling (require.Contains), error handling (require.Contains), error handling (require.Contains), error handling (require.Contains), error handling (require.Contains), error handling (require.Contains), error handling (require.Contains), error handling (require.Contains), error handling (require.Contains), error handling (require.Contains), error handling (require.Contains), error handling (require.Contains), error handling (require.Contains), error handling (require.Contains), error handling (require.Contains), error handling (require.Contains), error handling (require.Contains"}
{"seed": "// RunCommand parses the command, and runs it over all readers received from\n// the given channel, which are then closed after processing is done. It is a\n// convenience around ParseCommand and BuildReaderFrom. The given environment\n// is closed before returning.\nfunc RunCommand(prog string, env Environment) (rerr error) {\n\tdefer func() {\n\t\tif cerr := env.Close(); rerr == nil {\n\t\t\trerr = cerr\n\t\t}\n\t}()\n\tcmd, err := ParseCommand(prog)\n\tif err != nil {\n\t\treturn err\n\t}\n\trf, err := BuildReaderFrom(cmd, env)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn RunReaderFrom(rf, env)\n}", "id": 14333, "concepts": ["closures", "function definition", "error handling (idiomatic)", "standard library usage"], "_raw_llm_output": "closures, function definition, error handling (idiomatic), standard library usage"}
{"seed": "// BetterHeroScoreGTE applies the GTE predicate on the \"better_hero_score\" field.\nfunc BetterHeroScoreGTE(v int) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.GTE(s.C(FieldBetterHeroScore), v))\n\t})\n}", "id": 14335, "concepts": ["sql.Selector", "sql.GTE", "sql.C", "sql.Where", "sql.Predicate"], "_raw_llm_output": "sql.Selector, sql.GTE, sql.C, sql.Where, sql.Predicate"}
{"seed": "// NewDeleteTagParamsWithContext creates a new DeleteTagParams object\n// with the default values initialized, and the ability to set a context for a request\nfunc NewDeleteTagParamsWithContext(ctx context.Context) *DeleteTagParams {\n\tvar ()\n\treturn &DeleteTagParams{\n\n\t\tContext: ctx,\n\t}\n}", "id": 14345, "concepts": ["context", "function definition", "struct definition", "method definition"], "_raw_llm_output": "context, function definition, struct definition, method definition"}
{"seed": "// NewClusterRoleBindingsRouter instantiates a new router for ClusterRoleBindings.\nfunc NewClusterRoleBindingsRouter(store storev2.Interface) *ClusterRoleBindingsRouter {\n\treturn &ClusterRoleBindingsRouter{\n\t\tstore: store,\n\t}\n}", "id": 14359, "concepts": ["struct definition", "function definition", "method definition", "pointer usage", "interface usage", "struct field access"], "_raw_llm_output": "struct definition, function definition, method definition, pointer usage, interface usage, struct field access"}
{"seed": "// GetUpdateRetries returns the number of times the firmware update process should be attempted\nfunc GetUpdateRetries() (int, error) {\n\treturn strconv.Atoi(getEnv(\"ENM_UPDATE_RETRIES\", \"1\"))\n}", "id": 14371, "concepts": ["environment variable usage", "strconv.Atoi"], "_raw_llm_output": "environment variable usage, strconv.Atoi"}
{"seed": "// AlignmentPRight returns a pointer to AlignmentVRight\nfunc AlignmentPRight() *Alignment {\n\tv := AlignmentVRight\n\treturn &v\n}", "id": 14381, "concepts": ["pointer", "pointer dereference", "pointer assignment"], "_raw_llm_output": "pointer, pointer dereference, pointer assignment"}
{"seed": "// IntMin returns the minimum of a and b.\nfunc IntMin(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}", "id": 14419, "concepts": ["integer comparison", "basic function definition"], "_raw_llm_output": "integer comparison, basic function definition"}
{"seed": "// Label represents the HTML element 'label'.\n// For more information visit https://www.w3schools.com/tags/tag_label.asp.\nfunc Label(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"label\", Attributes: attrs, Children: children}\n}", "id": 14428, "concepts": ["struct composition", "interface composition", "HTML generation"], "_raw_llm_output": "struct composition, interface composition, HTML generation"}
{"seed": "// StringsContain returns true if the search value is within the list of input values.\nfunc StringsContain(values []string, search string) bool {\n\tfor _, v := range values {\n\t\tif search == v {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}", "id": 14432, "concepts": ["slice iteration (range loop)", "string comparison"], "_raw_llm_output": "slice iteration (range loop), string comparison"}
{"seed": "// ChangedAttrs returns a set of names of attributes of a document\n// whose values were changed after applying changeList\nfunc ChangedAttrs(changeList []TableRowChange) set.Set {\n\tattrs := set.NewSet()\n\tdcs := NewDocChangeSet(changeList)\n\tfor _, tcs := range dcs.Changes {\n\t\tfor _, col := range tcs.ChangedColumnNames() {\n\t\t\tfor _, attr := range tcs.ColumnMap[col] {\n\t\t\t\tattrs.Add(attr)\n\t\t\t}\n\t\t}\n\t}\n\treturn attrs\n}", "id": 14448, "concepts": ["set", "map", "slice iteration", "set.Add", "set.NewSet", "map iteration", "map.Add", "map.New", "slice iteration", "slice.Add", "slice.New", "table row change", "table row change.ChangedColumnNames", "table row change.ColumnMap", "table row change.ColumnMap[col]"], "_raw_llm_output": "set, map, slice iteration, set.Add, set.NewSet, map iteration, map.Add, map.New, slice iteration, slice.Add, slice.New, table row change, table row change.ChangedColumnNames, table row change.ColumnMap, table row change.ColumnMap[col]"}
{"seed": "// shortHostname returns its argument, truncating at the first period.\n// For instance, given \"www.google.com\" it returns \"www\".\nfunc shortHostname(hostname string) string {\n\tif i := strings.Index(hostname, \".\"); i >= 0 {\n\t\treturn hostname[:i]\n\t}\n\treturn hostname\n}", "id": 14460, "concepts": ["string manipulation", "string index", "string slicing"], "_raw_llm_output": "string manipulation, string index, string slicing"}
{"seed": "// NewKafkaCollector returns a new instance of Kafka struct\nfunc NewKafkaCollector() *Kafka {\n\treturn &Kafka{}\n}", "id": 14483, "concepts": ["struct definition", "basic function definition"], "_raw_llm_output": "struct definition, basic function definition"}
{"seed": "// Button_ is a convenience wrapper for Button without the attrs argument.\nfunc Button_(children ...HTML) HTML {\n  return Button(nil, children...)\n}", "id": 14507, "concepts": ["function definition", "function arguments", "variadic function arguments", "function return values"], "_raw_llm_output": "function definition, function arguments, variadic function arguments, function return values"}
{"seed": "// HasCar applies the HasEdge predicate on the \"car\" edge.\nfunc HasCar() predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\tstep := sqlgraph.NewStep(\n\t\t\tsqlgraph.From(Table, FieldID),\n\t\t\tsqlgraph.Edge(sqlgraph.O2M, false, CarTable, CarColumn),\n\t\t)\n\t\tsqlgraph.HasNeighbors(s, step)\n\t})\n}", "id": 14519, "concepts": ["sqlgraph package usage", "sql.Selector", "sqlgraph.HasNeighbors"], "_raw_llm_output": "sqlgraph package usage, sql.Selector, sqlgraph.HasNeighbors"}
{"seed": "// Link represents the HTML void element 'link'.\n// For more information visit https://www.w3schools.com/tags/tag_link.asp.\nfunc Link(attrs []htmlgo.Attribute) HTML {\n\treturn &htmlgo.Tree{Tag: \"link\", Attributes: attrs, SelfClosing: true}\n}", "id": 14522, "concepts": ["HTML generation", "HTML tree traversal", "HTML attribute handling", "HTML tag definition"], "_raw_llm_output": "HTML generation, HTML tree traversal, HTML attribute handling, HTML tag definition"}
{"seed": "// RetryExBackoffOperation re-runs provided callback function with multiple attempts until either\n// the Operation is successful or the timeout specified with timeoutSeconds has reached.\n// The sleep between two successive retry increases by 2 times\nfunc RetryExBackoffOperation(timeoutSeconds int, taskName string, callback func() error) (err error) {\n\tvar (\n\t\tusedSeconds  = 0\n\t\tsleepSeconds = 1\n\t)\n\tfor usedSeconds < timeoutSeconds {\n\t\t// calling callback function\n\t\terr = callback()\n\t\tif err == nil {\n\t\t\t// if err is nil, that means function execution was successful,\n\t\t\t// we are done retrying\n\t\t\treturn nil\n\t\t}\n\n\t\t// sleep duration in Seconds\n\t\tsleepSeconds = sleepSeconds * 2\n\t\tif usedSeconds+sleepSeconds > timeoutSeconds {\n\t\t\t// with next sleep since we are exceeding provided\n\t\t\t// timeoutSeconds lets adjust the sleepSeconds to\n\t\t\t// seconds we have left between what we have used already and provided timeoutSeconds\n\t\t\tsleepSeconds = timeoutSeconds - usedSeconds\n\t\t}\n\n\t\td := time.Duration(sleepSeconds * 1000 * 1000 * 1000)\n\t\ttime.Sleep(d)\n\t\tusedSeconds = usedSeconds + sleepSeconds\n\n\t}\n\treturn fmt.Errorf(\"after %d seconds, last error: %s\", timeoutSeconds, err)\n}", "id": 14523, "concepts": ["function definition", "function call", "function return", "function parameters", "function arguments", "function scope", "function execution", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", "function call", ""], "_raw_llm_output": "function definition, function call, function return, function parameters, function arguments, function scope, function execution, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call, function call,"}
{"seed": "// IsMac detects if we are running on the darwin platform\nfunc IsMac() bool {\n\treturn runtime.GOOS == \"darwin\"\n}", "id": 14551, "concepts": ["runtime.GOOS", "runtime.GOARCH", "runtime.GOMAXPROCS", "runtime.NumCPU", "runtime.NumGoroutine", "runtime.Version", "runtime.GOARM", "runtime.GO386", "runtime.GOAMD64", "runtime.GOARM64", "runtime.GOARM7", "runtime.GOARM5", "runtime.GOARM4", "runtime.GOARM3", "runtime.GOARM2", "runtime.GOARM1", "runtime.GOARM0", "runtime.GO32", "runtime.GO64", "runtime.GO32BIT", "runtime.GO32BITAMD", "runtime.GO64BIT", "runtime.GO64BITAMD", "runtime.GOARM", "runtime.GO386", "runtime.GOAMD64", "runtime.GOARM64", "runtime.GOARM7", "runtime.GOARM5", "runtime.GOARM4", "runtime.GOARM3", "runtime.GOARM2", "runtime.GOARM1", "runtime.GOARM0", "runtime.GO32", "runtime.GO64", "runtime.GO32BIT", "runtime.GO32BITAMD", "runtime.GO64BIT", "runtime.GO64BITAMD", "runtime."], "_raw_llm_output": "runtime.GOOS, runtime.GOARCH, runtime.GOMAXPROCS, runtime.NumCPU, runtime.NumGoroutine, runtime.Version, runtime.GOARM, runtime.GO386, runtime.GOAMD64, runtime.GOARM64, runtime.GOARM7, runtime.GOARM5, runtime.GOARM4, runtime.GOARM3, runtime.GOARM2, runtime.GOARM1, runtime.GOARM0, runtime.GO32, runtime.GO64, runtime.GO32BIT, runtime.GO32BITAMD, runtime.GO64BIT, runtime.GO64BITAMD, runtime.GOARM, runtime.GO386, runtime.GOAMD64, runtime.GOARM64, runtime.GOARM7, runtime.GOARM5, runtime.GOARM4, runtime.GOARM3, runtime.GOARM2, runtime.GOARM1, runtime.GOARM0, runtime.GO32, runtime.GO64, runtime.GO32BIT, runtime.GO32BITAMD, runtime.GO64BIT, runtime.GO64BITAMD, runtime."}
{"seed": "// Magnitude returns the length of a Vector, computed by summing the squares\n// of each value, then taking the square root\nfunc Magnitude(t Tuplelike) float64 {\n\tsum := 0.0\n\n\tfor _, value := range t.Values() {\n\t\tsum += value * value\n\t}\n\n\treturn math.Sqrt(sum)\n}", "id": 14553, "concepts": ["math package usage", "tuple handling", "basic function definition"], "_raw_llm_output": "math package usage, tuple handling, basic function definition"}
{"seed": "// IsSIGPIPE returns an `ErrorMatcher` that matches `*exec.ExitError`s\n// that were caused by the specified signal. The match for\n// `*exec.ExitError`s uses `errors.As()`. Note that under Windows this\n// always returns false, because on that platform\n// `WaitStatus.Signaled()` isn't implemented (it is hardcoded to\n// return `false`).\nfunc IsSignal(signal syscall.Signal) ErrorMatcher {\n\treturn func(err error) bool {\n\t\tvar eErr *exec.ExitError\n\n\t\tif !errors.As(err, &eErr) {\n\t\t\treturn false\n\t\t}\n\n\t\tstatus, ok := eErr.Sys().(syscall.WaitStatus)\n\t\treturn ok && status.Signaled() && status.Signal() == signal\n\t}\n}", "id": 14558, "concepts": ["error handling (errors.As)", "syscall package usage", "error matching"], "_raw_llm_output": "error handling (errors.As), syscall package usage, error matching"}
{"seed": "// AuthWrapper \u662f\u4e00\u4e2a\u9ad8\u9636\u51fd\u6570\uff0c\u5165\u53c2\u662f \u201d\u4e0b\u4e00\u6b65\u201c \u51fd\u6570\uff0c\u51fa\u53c2\u662f\u8ba4\u8bc1\u51fd\u6570\n// \u5728\u8fd4\u56de\u7684\u51fd\u6570\u5185\u90e8\u5904\u7406\u5b8c\u8ba4\u8bc1\u903b\u8f91\u540e\uff0c\u518d\u624b\u52a8\u8c03\u7528 fn() \u8fdb\u884c\u4e0b\u4e00\u6b65\u5904\u7406\n// token \u662f\u4ece consignment-ci \u4e0a\u4e0b\u6587\u4e2d\u53d6\u51fa\u7684\uff0c\u518d\u8c03\u7528 user-service \u5c06\u5176\u505a\u9a8c\u8bc1\n// \u8ba4\u8bc1\u901a\u8fc7\u5219 fn() \u7ee7\u7eed\u6267\u884c\uff0c\u5426\u5219\u62a5\u9519\nfunc AuthWrapper(fn server.HandlerFunc) server.HandlerFunc {\n\treturn func(ctx context.Context, req server.Request, resp interface{}) error {\n\t\t// consignment-service \u72ec\u7acb\u6d4b\u8bd5\u65f6\u4e0d\u8fdb\u884c\u8ba4\u8bc1\n\t\tif os.Getenv(\"DISABLE_AUTH\") == \"true\" {\n\t\t\treturn fn(ctx, req, resp)\n\t\t}\n\t\tmeta, ok := metadata.FromContext(ctx)\n\t\tif !ok {\n\t\t\treturn errors.New(\"no auth meta-data found in request\")\n\t\t}\n\n\t\t// Note this is now uppercase (not entirely sure why this is...)\n\t\ttoken := meta[\"Token\"]\n\n\t\t// Auth here\n\t\tauthClient := userPb.NewUserServiceClient(\"go.micro.srv.user\", client.DefaultClient)\n\t\tauthResp, err := authClient.ValidateToken(context.Background(), &userPb.Token{\n\t\t\tToken: token,\n\t\t})\n\t\tlog.Println(\"Auth Resp:\", authResp)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\terr = fn(ctx, req, resp)\n\t\treturn err\n\t}\n}", "id": 14580, "concepts": ["function composition", "function pointer", "function signature", "function return value", "function call", "function definition", "function definition", "function call", "function definition", "function call", "function definition", "function call", "function definition", "function call", "function definition", "function call", "function definition", "function call", "function definition", "function call", "function definition", "function call", "function definition", "function call", "function definition", "function call", "function definition", "function call", "function definition", "function call", "function definition", "function call", "function definition", "function call", "function definition", "function call", "function definition", "function call", "function definition", "function call", "function definition", "function call", "function definition", "function call", "function definition", "function call", "function definition", "function call", "function definition", "function call", "function definition", "function call", "function definition", "function call", "function definition", "function call", "function definition", "function call", "function definition", "function call", "function definition", "function call", "function definition", "function call", "function definition", "function call", "function definition", "function call", "function definition", "function call", "function definition", "function call", "function definition", "function call", "function definition", "function call", "function definition", "function call", "function definition", "function call", "function definition", "function call", "function definition", "function call", "function definition"], "_raw_llm_output": "function composition, function pointer, function signature, function return value, function call, function definition, function definition, function call, function definition, function call, function definition, function call, function definition, function call, function definition, function call, function definition, function call, function definition, function call, function definition, function call, function definition, function call, function definition, function call, function definition, function call, function definition, function call, function definition, function call, function definition, function call, function definition, function call, function definition, function call, function definition, function call, function definition, function call, function definition, function call, function definition, function call, function definition, function call, function definition, function call, function definition, function call, function definition, function call, function definition, function call, function definition, function call, function definition, function call, function definition, function call, function definition, function call, function definition, function call, function definition, function call, function definition, function call, function definition, function call, function definition, function call, function definition, function call, function definition, function call, function definition, function call, function definition, function call, function definition, function call, function definition"}
{"seed": "// PossibleSubscriptionStateValues returns the possible values for the SubscriptionState const type.\nfunc PossibleSubscriptionStateValues() []SubscriptionState {\n\treturn []SubscriptionState{\n\t\tSubscriptionStateDeleted,\n\t\tSubscriptionStateDisabled,\n\t\tSubscriptionStateEnabled,\n\t\tSubscriptionStateNotDefined,\n\t\tSubscriptionStatePastDue,\n\t\tSubscriptionStateWarned,\n\t}\n}", "id": 14591, "concepts": ["const type", "basic function definition"], "_raw_llm_output": "const type, basic function definition"}
{"seed": "// sequenceCallershouldRetry returns true when we should try with another endpoint given the\n// value of err which could (obviously) be nil in case of success.\nfunc sequenceCallerShouldRetry(err error) bool {\n\tvar kind *errMaybeCensorship\n\tbelongs := errors.As(err, &kind)\n\treturn belongs\n}", "id": 14592, "concepts": ["errors.As", "error handling (idiomatic if err != nil)", "type assertion"], "_raw_llm_output": "errors.As, error handling (idiomatic if err != nil), type assertion"}
{"seed": "// Sup_ is a convenience wrapper for Sup without the attrs argument.\nfunc Sup_(children ...HTML) HTML {\n  return Sup(nil, children...)\n}", "id": 14594, "concepts": ["HTML", "HTML tag", "HTML attribute", "HTML tag definition", "HTML tag usage", "HTML tag nesting"], "_raw_llm_output": "HTML, HTML tag, HTML attribute, HTML tag definition, HTML tag usage, HTML tag nesting"}
{"seed": "// WorkplaceLTE applies the LTE predicate on the \"workplace\" field.\nfunc WorkplaceLTE(v string) predicate.User {\n\treturn predicate.User(sql.FieldLTE(FieldWorkplace, v))\n}", "id": 14608, "concepts": ["predicate.User", "sql.FieldLTE", "sql.FieldEQ"], "_raw_llm_output": "predicate.User, sql.FieldLTE, sql.FieldEQ"}
{"seed": "// Rt represents the HTML element 'rt'.\n// For more information visit https://www.w3schools.com/tags/tag_rt.asp.\nfunc Rt(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"rt\", Attributes: attrs, Children: children}\n}", "id": 14618, "concepts": ["HTML generation", "HTML tree definition", "HTML attribute definition"], "_raw_llm_output": "HTML generation, HTML tree definition, HTML attribute definition"}
{"seed": "// \u26a0\ufe0f You must defer HINSTANCE.FreeLibrary().\r\n//\r\n// \ud83d\udcd1 https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibraryw\r\nfunc LoadLibrary(lpLibFileName string) HINSTANCE {\r\n\tret, _, err := syscall.Syscall(proc.LoadLibrary.Addr(), 1,\r\n\t\tuintptr(unsafe.Pointer(Str.ToUint16Ptr(lpLibFileName))),\r\n\t\t0, 0)\r\n\tif ret == 0 {\r\n\t\tpanic(errco.ERROR(err))\r\n\t}\r\n\treturn HINSTANCE(ret)\r\n}", "id": 14626, "concepts": ["syscall usage", "HINSTANCE definition", "string conversion", "unsafe.Pointer", "syscall.Syscall", "error handling"], "_raw_llm_output": "syscall usage, HINSTANCE definition, string conversion, unsafe.Pointer, syscall.Syscall, error handling"}
{"seed": "// NewSabayonHTTP creates a new SabayonHTTP instance.\nfunc NewSabayonHTTP() *SabayonHTTP {\n\treturn &SabayonHTTP{}\n}", "id": 14633, "concepts": ["struct definition", "struct field definition", "struct initialization"], "_raw_llm_output": "struct definition, struct field definition, struct initialization"}
{"seed": "// PutInt64 encodes an integer into buf and returns the serial size.\n// If the buffer is smaller than 9 bytes, PutInt64 may panic.\nfunc PutInt64(buf []byte, v int64) (n int) {\n\treturn PutUint64(buf, uint64(v<<1)^uint64(v>>63))\n}", "id": 14642, "concepts": ["integer encoding", "bitwise operators", "integer shifting"], "_raw_llm_output": "integer encoding, bitwise operators, integer shifting"}
{"seed": "// SocialEmailGTE applies the GTE predicate on the \"social_email\" field.\nfunc SocialEmailGTE(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.GTE(s.C(FieldSocialEmail), v))\n\t})\n}", "id": 14662, "concepts": ["SQL query building", "predicate usage"], "_raw_llm_output": "SQL query building, predicate usage"}
{"seed": "// TransfertobankaccountIn applies the In predicate on the \"transfertobankaccount\" field.\nfunc TransfertobankaccountIn(vs ...float64) predicate.Bulk {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.Bulk(func(s *sql.Selector) {\n\t\t// if not arguments were provided, append the FALSE constants,\n\t\t// since we can't apply \"IN ()\". This will make this predicate falsy.\n\t\tif len(v) == 0 {\n\t\t\ts.Where(sql.False())\n\t\t\treturn\n\t\t}\n\t\ts.Where(sql.In(s.C(FieldTransfertobankaccount), v...))\n\t})\n}", "id": 14670, "concepts": ["sql.Selector", "sql.In", "sql.False", "sql.Bulk", "sql.C", "predicate.Bulk", "standard library usage"], "_raw_llm_output": "sql.Selector, sql.In, sql.False, sql.Bulk, sql.C, predicate.Bulk, standard library usage"}
{"seed": "// CreatedAtLT applies the LT predicate on the \"created_at\" field.\nfunc CreatedAtLT(v time.Time) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.LT(s.C(FieldCreatedAt), v))\n\t})\n}", "id": 14671, "concepts": ["sql.Selector", "sql.LT", "sql.C", "sql.Where", "sql.Predicate", "sql.Query", "sql.QueryExpression", "sql.QueryExpression.Where", "sql.QueryExpression.And", "sql.QueryExpression.Or", "sql.QueryExpression.Not", "sql.QueryExpression.AndNot", "sql.QueryExpression.OrNot", "sql.QueryExpression.AndNot", "sql.QueryExpression.OrNot", "sql.QueryExpression.AndNot", "sql.QueryExpression.OrNot", "sql.QueryExpression.AndNot", "sql.QueryExpression.OrNot", "sql.QueryExpression.AndNot", "sql.QueryExpression.OrNot", "sql.QueryExpression.AndNot", "sql.QueryExpression.OrNot", "sql.QueryExpression.AndNot", "sql.QueryExpression.OrNot", "sql.QueryExpression.AndNot", "sql.QueryExpression.OrNot", "sql.QueryExpression.AndNot", "sql.QueryExpression.OrNot", "sql.QueryExpression.AndNot", "sql.QueryExpression.OrNot", "sql.QueryExpression.AndNot", "sql.QueryExpression.OrNot", "sql.QueryExpression.AndNot", "sql.QueryExpression.OrNot", "sql.QueryExpression.And"], "_raw_llm_output": "sql.Selector, sql.LT, sql.C, sql.Where, sql.Predicate, sql.Query, sql.QueryExpression, sql.QueryExpression.Where, sql.QueryExpression.And, sql.QueryExpression.Or, sql.QueryExpression.Not, sql.QueryExpression.AndNot, sql.QueryExpression.OrNot, sql.QueryExpression.AndNot, sql.QueryExpression.OrNot, sql.QueryExpression.AndNot, sql.QueryExpression.OrNot, sql.QueryExpression.AndNot, sql.QueryExpression.OrNot, sql.QueryExpression.AndNot, sql.QueryExpression.OrNot, sql.QueryExpression.AndNot, sql.QueryExpression.OrNot, sql.QueryExpression.AndNot, sql.QueryExpression.OrNot, sql.QueryExpression.AndNot, sql.QueryExpression.OrNot, sql.QueryExpression.AndNot, sql.QueryExpression.OrNot, sql.QueryExpression.AndNot, sql.QueryExpression.OrNot, sql.QueryExpression.AndNot, sql.QueryExpression.OrNot, sql.QueryExpression.AndNot, sql.QueryExpression.OrNot, sql.QueryExpression.And"}
{"seed": "// CustomConnectionPool returns a new database connection pool\n// that is already configured with the correct credentials and\n// instrumented with tracing and logging using the passed options\nfunc CustomConnectionPool(opts *pg.Options) *pg.DB {\n\tlog.Logger().Info().Str(\"addr\", opts.Addr).\n\t\tStr(\"user\", opts.User).Str(\"database\", opts.Database).\n\t\tMsg(\"PostgreSQL connection pool created\")\n\tdb := pg.Connect(opts)\n\tdb.OnQueryProcessed(queryLogger)\n\tdb.OnQueryProcessed(openTracingAdapter)\n\tdb.OnQueryProcessed(func(event *pg.QueryProcessedEvent) {\n\t\tmetricsAdapter(event, opts)\n\t})\n\treturn db\n}", "id": 14672, "concepts": ["database connection pool", "database connection pool configuration", "database connection pool instrumentation", "database connection pool usage", "database connection pool logging", "database connection pool tracing", "database connection pool metrics"], "_raw_llm_output": "database connection pool, database connection pool configuration, database connection pool instrumentation, database connection pool usage, database connection pool logging, database connection pool tracing, database connection pool metrics"}
{"seed": "// CleanName returns a name with spaces and dashes replaced with safe underscores\nfunc CleanName(name string) string {\n\tname = strings.Replace(name, \"-\", \"_\", -1)\n\tname = strings.Replace(name, \" \", \"_\", -1)\n\tname = strings.Replace(name, \"/\", \"_\", -1)\n\treturn name\n}", "id": 14681, "concepts": ["string manipulation", "string replacement", "string formatting"], "_raw_llm_output": "string manipulation, string replacement, string formatting"}
{"seed": "// GetEnvWithDefault returns the string value of the environment variable,\n// defaulting to a specified value if it doesn't exist.\nfunc GetEnvWithDefault(variable string, defaultValue string) string {\n\tvalue := os.Getenv(variable)\n\tif len(value) == 0 {\n\t\tvalue = defaultValue\n\t}\n\treturn value\n}", "id": 14683, "concepts": ["os.Getenv", "string concatenation", "default value handling"], "_raw_llm_output": "os.Getenv, string concatenation, default value handling"}
{"seed": "// GetEnterpriseSearch gets an existing EnterpriseSearch resource's state with the given name, ID, and optional\n// state properties that are used to uniquely qualify the lookup (nil if not required).\nfunc GetEnterpriseSearch(ctx *pulumi.Context,\n\tname string, id pulumi.IDInput, state *EnterpriseSearchState, opts ...pulumi.ResourceOption) (*EnterpriseSearch, error) {\n\tvar resource EnterpriseSearch\n\terr := ctx.ReadResource(\"kubernetes:enterprisesearch.k8s.elastic.co/v1beta1:EnterpriseSearch\", name, id, state, &resource, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &resource, nil\n}", "id": 14702, "concepts": ["resource creation", "resource reading", "resource deletion", "resource state", "resource property access"], "_raw_llm_output": "resource creation, resource reading, resource deletion, resource state, resource property access"}
{"seed": "// Main_ is a convenience wrapper for Main without the attrs argument.\nfunc Main_(children ...HTML) HTML {\n  return Main(nil, children...)\n}", "id": 14704, "concepts": ["HTML", "HTML attributes", "HTML tag", "HTML attribute", "HTML tag", "HTML attribute", "HTML tag", "HTML attribute", "HTML tag", "HTML attribute", "HTML tag", "HTML attribute", "HTML tag", "HTML attribute", "HTML tag", "HTML attribute", "HTML tag", "HTML attribute", "HTML tag", "HTML attribute", "HTML tag", "HTML attribute", "HTML tag", "HTML attribute", "HTML tag", "HTML attribute", "HTML tag", "HTML attribute", "HTML tag", "HTML attribute", "HTML tag", "HTML attribute", "HTML tag", "HTML attribute", "HTML tag", "HTML attribute", "HTML tag", "HTML attribute", "HTML tag", "HTML attribute", "HTML tag", "HTML attribute", "HTML tag", "HTML attribute", "HTML tag", "HTML attribute", "HTML tag", "HTML attribute", "HTML tag", "HTML attribute", "HTML tag", "HTML attribute", "HTML tag", "HTML attribute", "HTML tag", "HTML attribute", "HTML tag", "HTML attribute", "HTML tag", "HTML attribute", "HTML tag", "HTML attribute", "HTML tag", "HTML attribute", "HTML tag", "HTML attribute", "HTML tag", "HTML attribute", "HTML tag", "HTML attribute", "HTML tag", "HTML attribute", "HTML tag", "HTML attribute", "HTML tag", "HTML attribute", "HTML tag", "HTML attribute", "HTML tag", "HTML attribute", "HTML tag", "HTML attribute", "HTML tag", "HTML attribute", "HTML tag", "HTML"], "_raw_llm_output": "HTML, HTML attributes, HTML tag, HTML attribute, HTML tag, HTML attribute, HTML tag, HTML attribute, HTML tag, HTML attribute, HTML tag, HTML attribute, HTML tag, HTML attribute, HTML tag, HTML attribute, HTML tag, HTML attribute, HTML tag, HTML attribute, HTML tag, HTML attribute, HTML tag, HTML attribute, HTML tag, HTML attribute, HTML tag, HTML attribute, HTML tag, HTML attribute, HTML tag, HTML attribute, HTML tag, HTML attribute, HTML tag, HTML attribute, HTML tag, HTML attribute, HTML tag, HTML attribute, HTML tag, HTML attribute, HTML tag, HTML attribute, HTML tag, HTML attribute, HTML tag, HTML attribute, HTML tag, HTML attribute, HTML tag, HTML attribute, HTML tag, HTML attribute, HTML tag, HTML attribute, HTML tag, HTML attribute, HTML tag, HTML attribute, HTML tag, HTML attribute, HTML tag, HTML attribute, HTML tag, HTML attribute, HTML tag, HTML attribute, HTML tag, HTML attribute, HTML tag, HTML attribute, HTML tag, HTML attribute, HTML tag, HTML attribute, HTML tag, HTML attribute, HTML tag, HTML attribute, HTML tag, HTML attribute, HTML tag, HTML attribute, HTML tag, HTML"}
{"seed": "// IsMetaPackage checks if name is a reserved package name that expands to multiple packages.\nfunc IsMetaPackage(name string) bool {\n\treturn name == \"std\" || name == \"cmd\" || name == \"all\"\n}", "id": 14706, "concepts": ["string comparison", "reserved package names"], "_raw_llm_output": "string comparison, reserved package names"}
{"seed": "// DropOptionalNEQ applies the NEQ predicate on the \"drop_optional\" field.\nfunc DropOptionalNEQ(v string) predicate.User {\n\treturn predicate.User(sql.FieldNEQ(FieldDropOptional, v))\n}", "id": 14712, "concepts": ["sql.FieldNEQ", "sql.FieldEQ", "sql.FieldGT", "sql.FieldLT", "sql.FieldGTE", "sql.FieldLTE", "sql.FieldLike", "sql.FieldLikeI", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldBetween", "sql.FieldNotBetween", "sql.FieldIsNull", "sql.FieldIsNotNull", "sql.FieldExists", "sql.FieldNotExists", "sql.FieldRegexp", "sql.FieldRegexpI", "sql.FieldRegexpLike", "sql.FieldRegexpLikeI", "sql.FieldRegexpNotLike", "sql.FieldRegexpNotLikeI", "sql.FieldRegexpBetween", "sql.FieldRegexpNotBetween", "sql.FieldRegexpIsNull", "sql.FieldRegexpIsNotNull", "sql.FieldRegexpExists", "sql.FieldRegexpNotExists", "sql.FieldRegexpIn", "sql.FieldRegexpNotIn", "sql.FieldRegexpBetween", "sql.FieldRegexpNotBetween", "sql.FieldRegexpLike", "sql.FieldRegexpLikeI", "sql.FieldRegexpNotLike", "sql.FieldRegexpNotLikeI", "sql.FieldRegexpBetween", "sql.FieldRegexpNotBetween", "sql.FieldRegexpLike", "sql.FieldRegexpLikeI", "sql.FieldRegexpNotLike", "sql.FieldRegexpNotLikeI"], "_raw_llm_output": "sql.FieldNEQ, sql.FieldEQ, sql.FieldGT, sql.FieldLT, sql.FieldGTE, sql.FieldLTE, sql.FieldLike, sql.FieldLikeI, sql.FieldIn, sql.FieldNotIn, sql.FieldBetween, sql.FieldNotBetween, sql.FieldIsNull, sql.FieldIsNotNull, sql.FieldExists, sql.FieldNotExists, sql.FieldRegexp, sql.FieldRegexpI, sql.FieldRegexpLike, sql.FieldRegexpLikeI, sql.FieldRegexpNotLike, sql.FieldRegexpNotLikeI, sql.FieldRegexpBetween, sql.FieldRegexpNotBetween, sql.FieldRegexpIsNull, sql.FieldRegexpIsNotNull, sql.FieldRegexpExists, sql.FieldRegexpNotExists, sql.FieldRegexpIn, sql.FieldRegexpNotIn, sql.FieldRegexpBetween, sql.FieldRegexpNotBetween, sql.FieldRegexpLike, sql.FieldRegexpLikeI, sql.FieldRegexpNotLike, sql.FieldRegexpNotLikeI, sql.FieldRegexpBetween, sql.FieldRegexpNotBetween, sql.FieldRegexpLike, sql.FieldRegexpLikeI, sql.FieldRegexpNotLike, sql.FieldRegexpNotLikeI"}
{"seed": "// SignStructure signs the provided structure with the private key.\n// The used protocol is RSA PKCS#1 v1.5 with SHA-512 hash.\n// The structure is serialized to a string representation using the fmt package.\nfunc SignStructure(key *rsa.PrivateKey, structure interface{}) ([]byte, error) {\n\thash, err := hashStruct(structure)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn rsa.SignPKCS1v15(rand.Reader, key, crypto.SHA512, hash)\n}", "id": 14717, "concepts": ["crypto/rsa package usage", "hash function usage", "serialization (encoding/json)", "error handling (errors.New)"], "_raw_llm_output": "crypto/rsa package usage, hash function usage, serialization (encoding/json), error handling (errors.New)"}
{"seed": "// MustParseSeason_Uc_Ta is similar to AsSeason_Uc_Ta except that it panics on error.\nfunc MustParseSeason_Uc_Ta(s string) Season_Uc_Ta {\n\tv, err := AsSeason_Uc_Ta(s)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn v\n}", "id": 14719, "concepts": ["error handling (panic)", "type assertion"], "_raw_llm_output": "error handling (panic), type assertion"}
{"seed": "// langToFileRegexp converts a lang: parameter to its corresponding file\n// patterns for file filters. The lang value must be valid, cf. validate.go\nfunc langToFileRegexp(lang string) string {\n\tlang, _ = enry.GetLanguageByAlias(lang) // Invariant: lang is valid.\n\textensions := enry.GetLanguageExtensions(lang)\n\tpatterns := make([]string, len(extensions))\n\tfor i, e := range extensions {\n\t\t// Add `\\.ext$` pattern to match files with the given extension.\n\t\tpatterns[i] = regexp.QuoteMeta(e) + \"$\"\n\t}\n\treturn unionRegexp(patterns)\n}", "id": 14724, "concepts": ["regexp", "string manipulation", "string concatenation", "string formatting", "standard library usage"], "_raw_llm_output": "regexp, string manipulation, string concatenation, string formatting, standard library usage"}
{"seed": "// WithEndpoint configures a [Client] to use the specified Metadata API endpoint.\nfunc WithEndpoint(endpoint string) ClientOption {\n\treturn func(client *Client) {\n\t\tclient.endpoint = strings.TrimRight(endpoint, \"/\")\n\t}\n}", "id": 14735, "concepts": ["function definition", "function composition", "function options", "function options composition", "function options usage", "function options composition usage", "function options composition usage", "function options composition usage", "function options composition usage", "function options composition usage", "function options composition usage", "function options composition usage", "function options composition usage", "function options composition usage", "function options composition usage", "function options composition usage", "function options composition usage", "function options composition usage", "function options composition usage", "function options composition usage", "function options composition usage", "function options composition usage", "function options composition usage", "function options composition usage", "function options composition usage", "function options composition usage", "function options composition usage", "function options composition usage", "function options composition usage", "function options composition usage", "function options composition usage", "function options composition usage", "function options composition usage", "function options composition usage", "function options composition usage", "function options composition usage", "function options composition usage", "function options composition usage", "function options composition usage", "function options composition usage", "function options composition usage", "function options composition usage", "function options composition usage", "function options composition usage", "function options composition usage", "function options composition usage", "function options composition usage", "function options composition usage", "function options composition usage", "function options composition usage", "function options composition usage", "function options composition usage", "function options composition"], "_raw_llm_output": "function definition, function composition, function options, function options composition, function options usage, function options composition usage, function options composition usage, function options composition usage, function options composition usage, function options composition usage, function options composition usage, function options composition usage, function options composition usage, function options composition usage, function options composition usage, function options composition usage, function options composition usage, function options composition usage, function options composition usage, function options composition usage, function options composition usage, function options composition usage, function options composition usage, function options composition usage, function options composition usage, function options composition usage, function options composition usage, function options composition usage, function options composition usage, function options composition usage, function options composition usage, function options composition usage, function options composition usage, function options composition usage, function options composition usage, function options composition usage, function options composition usage, function options composition usage, function options composition usage, function options composition usage, function options composition usage, function options composition usage, function options composition usage, function options composition usage, function options composition usage, function options composition usage, function options composition usage, function options composition usage, function options composition usage, function options composition usage, function options composition usage, function options composition usage, function options composition"}
{"seed": "// MutationProtectionStatus_Values returns all elements of the MutationProtectionStatus enum\nfunc MutationProtectionStatus_Values() []string {\n\treturn []string{\n\t\tMutationProtectionStatusEnabled,\n\t\tMutationProtectionStatusDisabled,\n\t}\n}", "id": 14751, "concepts": ["enum definition", "enum usage"], "_raw_llm_output": "enum definition, enum usage"}
{"seed": "// NewModelsBackupScheduleWithDefaults instantiates a new ModelsBackupSchedule object\n// This constructor will only assign default values to properties that have it defined,\n// but it doesn't guarantee that properties required by API are set\nfunc NewModelsBackupScheduleWithDefaults() *ModelsBackupSchedule {\n\tthis := ModelsBackupSchedule{}\n\treturn &this\n}", "id": 14752, "concepts": ["constructor", "struct definition", "struct initialization"], "_raw_llm_output": "constructor, struct definition, struct initialization"}
{"seed": "// StatusNotNil applies the NotNil predicate on the \"status\" field.\nfunc StatusNotNil() predicate.User {\n\treturn predicate.User(sql.FieldNotNull(FieldStatus))\n}", "id": 14756, "concepts": ["sql.FieldNotNull", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql."], "_raw_llm_output": "sql.FieldNotNull, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql."}
{"seed": "// canWriteWhiteouts detects whether the current task can write whiteouts. The\n// upstream kernel as of v5.8 a3c751a50fe6 (\"vfs: allow unprivileged whiteout\n// creation\") allows this as an unprivileged user.\nfunc canWriteWhiteouts() (bool, error) {\n\tdir, err := ioutil.TempDir(\"\", \"stacker-overlay-whiteout-\")\n\tif err != nil {\n\t\treturn false, errors.Wrapf(err, \"couldn't create overlay tmpdir\")\n\t}\n\tdefer os.RemoveAll(dir)\n\n\terr = unix.Mknod(path.Join(dir, \"test\"), syscall.S_IFCHR|0666, int(unix.Mkdev(0, 0)))\n\tif err != nil {\n\t\tif os.IsPermission(err) {\n\t\t\treturn false, nil\n\t\t}\n\n\t\treturn false, err\n\t}\n\n\treturn true, nil\n}", "id": 14759, "concepts": ["ioutil.TempDir", "ioutil.WriteFile", "ioutil.ReadDir", "ioutil.ReadDirnames", "ioutil.Readlink", "ioutil.TempFile", "ioutil.WriteFile", "ioutil.ReadDirnames", "ioutil.Readlink", "ioutil.TempDir", "ioutil.WriteFile", "ioutil.ReadDirnames", "ioutil.Readlink", "ioutil.TempDir", "ioutil.WriteFile", "ioutil.ReadDirnames", "ioutil.Readlink", "ioutil.TempDir", "ioutil.WriteFile", "ioutil.ReadDirnames", "ioutil.Readlink", "ioutil.TempDir", "ioutil.WriteFile", "ioutil.ReadDirnames", "ioutil.Readlink", "ioutil.TempDir", "ioutil.WriteFile", "ioutil.ReadDirnames", "ioutil.Readlink", "ioutil.TempDir", "ioutil.WriteFile", "ioutil.ReadDirnames", "ioutil.Readlink", "ioutil.TempDir", "ioutil.WriteFile", "ioutil.ReadDirnames", "ioutil.Readlink", "ioutil.TempDir", "ioutil.WriteFile", "ioutil.ReadDirnames", "ioutil.Readlink", "ioutil.TempDir", "ioutil.WriteFile", "ioutil.ReadDirnames", "ioutil.Readlink", "ioutil.TempDir", "ioutil.WriteFile", "ioutil.ReadDirnames", "ioutil.Readlink", "ioutil.TempDir", "ioutil.WriteFile", "ioutil.ReadDirnames", "ioutil.Readlink", "ioutil.TempDir"], "_raw_llm_output": "ioutil.TempDir, ioutil.WriteFile, ioutil.ReadDir, ioutil.ReadDirnames, ioutil.Readlink, ioutil.TempFile, ioutil.WriteFile, ioutil.ReadDirnames, ioutil.Readlink, ioutil.TempDir, ioutil.WriteFile, ioutil.ReadDirnames, ioutil.Readlink, ioutil.TempDir, ioutil.WriteFile, ioutil.ReadDirnames, ioutil.Readlink, ioutil.TempDir, ioutil.WriteFile, ioutil.ReadDirnames, ioutil.Readlink, ioutil.TempDir, ioutil.WriteFile, ioutil.ReadDirnames, ioutil.Readlink, ioutil.TempDir, ioutil.WriteFile, ioutil.ReadDirnames, ioutil.Readlink, ioutil.TempDir, ioutil.WriteFile, ioutil.ReadDirnames, ioutil.Readlink, ioutil.TempDir, ioutil.WriteFile, ioutil.ReadDirnames, ioutil.Readlink, ioutil.TempDir, ioutil.WriteFile, ioutil.ReadDirnames, ioutil.Readlink, ioutil.TempDir, ioutil.WriteFile, ioutil.ReadDirnames, ioutil.Readlink, ioutil.TempDir, ioutil.WriteFile, ioutil.ReadDirnames, ioutil.Readlink, ioutil.TempDir, ioutil.WriteFile, ioutil.ReadDirnames, ioutil.Readlink, ioutil.TempDir"}
{"seed": "// GlobalLog creates a Logger that uses the global log.Println() function.\n//\n// All levels are reported by default. If you pass levels to this function,\n// it will act as a level whitelist.\nfunc GlobalLog(levels ...LogLevel) Logger {\n\treturn newStdLog(log.Println, levels...)\n}", "id": 14780, "concepts": ["global variable", "function definition", "function composition", "function composition with anonymous function"], "_raw_llm_output": "global variable, function definition, function composition, function composition with anonymous function"}
{"seed": "// WorkplaceHasPrefix applies the HasPrefix predicate on the \"workplace\" field.\nfunc WorkplaceHasPrefix(v string) predicate.User {\n\treturn predicate.User(sql.FieldHasPrefix(FieldWorkplace, v))\n}", "id": 14785, "concepts": ["sql.FieldHasPrefix", "predicate.User", "sql package usage"], "_raw_llm_output": "sql.FieldHasPrefix, predicate.User, sql package usage"}
{"seed": "//XorBufs computes the bitwise xor of two byte slices\n//Returns a non-nil error if the two slices are of different lengths\nfunc XorBufs(b1, b2 []byte) ([]byte, error) {\n\tif len(b1) != len(b2) {\n\t\treturn nil, errors.New(\"Buffers of unequal length\")\n\t}\n\ttmp := make([]byte, len(b1))\n\tfor i := range b1 {\n\t\ttmp[i] = b1[i] ^ b2[i]\n\t}\n\treturn tmp, nil\n}", "id": 14792, "concepts": ["byte slice iteration", "byte slice manipulation", "bitwise xor", "error handling"], "_raw_llm_output": "byte slice iteration, byte slice manipulation, bitwise xor, error handling"}
{"seed": "// GetResourceRecordSet gets an existing ResourceRecordSet resource's state with the given name, ID, and optional\n// state properties that are used to uniquely qualify the lookup (nil if not required).\nfunc GetResourceRecordSet(ctx *pulumi.Context,\n\tname string, id pulumi.IDInput, state *ResourceRecordSetState, opts ...pulumi.ResourceOption) (*ResourceRecordSet, error) {\n\tvar resource ResourceRecordSet\n\terr := ctx.ReadResource(\"google-native:dns/v1beta2:ResourceRecordSet\", name, id, state, &resource, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &resource, nil\n}", "id": 14801, "concepts": ["resource definition", "state management", "resource creation", "resource deletion", "resource import", "resource export", "resource import/export", "resource import/export/delete", "resource import/export/delete/create", "resource import/export/delete/create/update", "resource import/export/delete/create/update/delete", "resource import/export/delete/create/update/delete/create", "resource import/export/delete/create/update/delete/create/update", "resource import/export/delete/create/update/delete/create/update/delete", "resource import/export/delete/create/update/delete/create/update/delete/create", "resource import/export/delete/create/update/delete/create/update/delete/create/update", "resource import/export/delete/create/update/delete/create/update/delete/create/update/delete", "resource import/export/delete/create/update/delete/create/update/delete/create/update/delete/create", "resource import/export/delete/create/update/delete/create/update/delete/create/update/delete/create/update", "resource import/export/delete/create/update/delete/create/update"], "_raw_llm_output": "resource definition, state management, resource creation, resource deletion, resource import, resource export, resource import/export, resource import/export/delete, resource import/export/delete/create, resource import/export/delete/create/update, resource import/export/delete/create/update/delete, resource import/export/delete/create/update/delete/create, resource import/export/delete/create/update/delete/create/update, resource import/export/delete/create/update/delete/create/update/delete, resource import/export/delete/create/update/delete/create/update/delete/create, resource import/export/delete/create/update/delete/create/update/delete/create/update, resource import/export/delete/create/update/delete/create/update/delete/create/update/delete, resource import/export/delete/create/update/delete/create/update/delete/create/update/delete/create, resource import/export/delete/create/update/delete/create/update/delete/create/update/delete/create/update, resource import/export/delete/create/update/delete/create/update"}
{"seed": "// cleanTimestamp trims any non numeric characters at the end of the string and returns the remaining string\nfunc cleanTimestamp(ts string) string {\n\tcleaned := strings.TrimRightFunc(ts, func(r rune) bool {\n\t\treturn !unicode.IsNumber(r)\n\t})\n\n\treturn cleaned\n}", "id": 14804, "concepts": ["string manipulation", "string trimming", "string trimming with a function", "string trimming with a function", "string trimming with a function"], "_raw_llm_output": "string manipulation, string trimming, string trimming with a function, string trimming with a function, string trimming with a function"}
{"seed": "// \u7ed9\u5b9a\u4e00\u4e2a\u6574\u5f62\u6570\u7ec4\uff0c\u53ea\u6709\u4e00\u4e2a\u6570\u51fa\u73b0\u4e86\u5947\u6570\u6b21\uff0c\u5176\u4ed6\u7684\u6570\u90fd\u51fa\u73b0\u4e86\u5076\u6570\u6b21\uff0c\u6253\u5370\u8fd9\u4e2a\u6570\n// \u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(N)\uff0c\u989d\u5916\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3aO(1)\n\n// \u5f02\u6216\u64cd\u4f5c\u6ee1\u8db3\u4ea4\u6362\u5f8b\u548c\u7ed3\u5408\u5f8b\uff0c a^a=0\nfunc printOddTimesNum(a []int) int {\n\tret := 0\n\tfor _, num := range a {\n\t\tret ^= num\n\t}\n\treturn ret\n}", "id": 14815, "concepts": ["bitwise XOR", "array iteration", "array element access", "array length"], "_raw_llm_output": "bitwise XOR, array iteration, array element access, array length"}
{"seed": "/*\nNew returns an Exchange definition with the following defaults unless\nchanged via the Option options.\n\n Exchange{\n   Name: \"passedname\",\n   Kind: \"direct\",\n   Durable: true,\n   AutoDelete: false,\n   Internal: false,\n   NoWait: false,\n   Args: nil,\n }\n\n*/\nfunc New(name string, opts ...Option) Exchange {\n\te := Exchange{\n\t\tName:    name,\n\t\tKind:    \"direct\",\n\t\tDurable: true,\n\t}\n\n\tfor _, opt := range opts {\n\t\te = opt(e)\n\t}\n\n\treturn e\n}", "id": 14818, "concepts": ["struct definition", "function definition", "function call", "function return", "function argument", "function return value", "function return value type", "function return value assignment", "function return value assignment type", "function return value assignment value", "function return value assignment value type", "function return value assignment value assignment", "function return value assignment value assignment type", "function return value assignment value assignment value", "function return value assignment value assignment value type", "function return value assignment value assignment value assignment", "function return value assignment value assignment value assignment type", "function return value assignment value assignment value assignment value", "function return value assignment value assignment value assignment value type", "function return value assignment value assignment value assignment value assignment", "function return value assignment value assignment value assignment value assignment type", "function return value assignment value assignment value assignment value assignment value", "function return value assignment value assignment value assignment value assignment value type", "function return value assignment value assignment value assignment value assignment value assignment", "function return value assignment value assignment value assignment value assignment value assignment type", "function return value assignment value assignment value assignment value assignment value assignment value", "function return value assignment value assignment value assignment value assignment value assignment value type", "function return value assignment value assignment value assignment value assignment value assignment value assignment", "function return value assignment value assignment value assignment value assignment value assignment value assignment type", ""], "_raw_llm_output": "struct definition, function definition, function call, function return, function argument, function return value, function return value type, function return value assignment, function return value assignment type, function return value assignment value, function return value assignment value type, function return value assignment value assignment, function return value assignment value assignment type, function return value assignment value assignment value, function return value assignment value assignment value type, function return value assignment value assignment value assignment, function return value assignment value assignment value assignment type, function return value assignment value assignment value assignment value, function return value assignment value assignment value assignment value type, function return value assignment value assignment value assignment value assignment, function return value assignment value assignment value assignment value assignment type, function return value assignment value assignment value assignment value assignment value, function return value assignment value assignment value assignment value assignment value type, function return value assignment value assignment value assignment value assignment value assignment, function return value assignment value assignment value assignment value assignment value assignment type, function return value assignment value assignment value assignment value assignment value assignment value, function return value assignment value assignment value assignment value assignment value assignment value type, function return value assignment value assignment value assignment value assignment value assignment value assignment, function return value assignment value assignment value assignment value assignment value assignment value assignment type,"}
{"seed": "// hasTazeEnabled checks if the BUILD file should be managed using ts_auto_deps.\n// Users can disable ts_auto_deps by adding a \"disable_ts_auto_deps()\" (or \"dont_ts_auto_deps_me()\") statement.\nfunc hasTazeEnabled(bld *build.File) bool {\n\tfor _, stmt := range bld.Stmt {\n\t\tif call, ok := stmt.(*build.CallExpr); ok {\n\t\t\tif fnName, ok := call.X.(*build.Ident); ok && (fnName.Name == \"disable_ts_auto_deps\" || fnName.Name == \"dont_ts_auto_deps_me\") {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\treturn true\n}", "id": 14820, "concepts": ["build.File", "build.Stmt", "build.CallExpr", "build.Ident", "build.Expr", "build.ExprStmt", "build.ExprList", "build.ExprSwitchCase", "build.ExprCase", "build.ExprSwitch", "build.ExprIf", "build.ExprBinary", "build.ExprUnary", "build.ExprParen", "build.ExprCompositeLit", "build.ExprFuncLit", "build.ExprArrayLit", "build.ExprSliceLit", "build.ExprMapLit", "build.ExprStructLit", "build.ExprTypeAssert", "build.ExprType", "build.ExprTypeSwitch", "build.ExprTypeSwitchCase", "build.ExprTypeCase", "build.ExprTypeSpec", "build.ExprTypeLit", "build.ExprValueSpec", "build.ExprKeyValueExpr", "build.ExprFuncType", "build.ExprField", "build.ExprFieldList", "build.ExprEllipsis", "build.ExprKeyValue", "build.ExprFunc", "build.ExprFuncType", "build.ExprFuncLit", "build.ExprFuncLit", "build.ExprFuncLit", "build.ExprFuncLit", "build.ExprFuncLit", "build.ExprFuncLit", "build.ExprFuncLit", "build.ExprFuncLit", "build.ExprFuncLit", "build.ExprFuncLit"], "_raw_llm_output": "build.File, build.Stmt, build.CallExpr, build.Ident, build.Expr, build.ExprStmt, build.ExprList, build.ExprSwitchCase, build.ExprCase, build.ExprSwitch, build.ExprIf, build.ExprBinary, build.ExprUnary, build.ExprParen, build.ExprCompositeLit, build.ExprFuncLit, build.ExprArrayLit, build.ExprSliceLit, build.ExprMapLit, build.ExprStructLit, build.ExprTypeAssert, build.ExprType, build.ExprTypeSwitch, build.ExprTypeSwitchCase, build.ExprTypeCase, build.ExprTypeSpec, build.ExprTypeLit, build.ExprValueSpec, build.ExprKeyValueExpr, build.ExprFuncType, build.ExprField, build.ExprFieldList, build.ExprEllipsis, build.ExprKeyValue, build.ExprFunc, build.ExprFuncType, build.ExprFuncLit, build.ExprFuncLit, build.ExprFuncLit, build.ExprFuncLit, build.ExprFuncLit, build.ExprFuncLit, build.ExprFuncLit, build.ExprFuncLit, build.ExprFuncLit, build.ExprFuncLit"}
{"seed": "// PossibleManagedRuleEnabledStateValues returns an array of possible values for the ManagedRuleEnabledState const type.\nfunc PossibleManagedRuleEnabledStateValues() []ManagedRuleEnabledState {\n\treturn []ManagedRuleEnabledState{ManagedRuleEnabledStateDisabled, ManagedRuleEnabledStateEnabled}\n}", "id": 14837, "concepts": ["const type", "array definition", "array iteration"], "_raw_llm_output": "const type, array definition, array iteration"}
{"seed": "// SocialPayloadContains applies the Contains predicate on the \"social_payload\" field.\nfunc SocialPayloadContains(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.Contains(s.C(FieldSocialPayload), v))\n\t})\n}", "id": 14841, "concepts": ["sql.Selector", "sql.Contains", "predicate.User"], "_raw_llm_output": "sql.Selector, sql.Contains, predicate.User"}
{"seed": "// RiskDetailPAdminGeneratedTemporaryPassword returns a pointer to RiskDetailVAdminGeneratedTemporaryPassword\nfunc RiskDetailPAdminGeneratedTemporaryPassword() *RiskDetail {\n\tv := RiskDetailVAdminGeneratedTemporaryPassword\n\treturn &v\n}", "id": 14845, "concepts": ["pointer", "struct", "pointer dereference"], "_raw_llm_output": "pointer, struct, pointer dereference"}
{"seed": "/*\nPrependDefaultDirectoryPath creates a file path from a file name by\nprepending the default test directory name.  If the provided name is\n\"foo.json\", the resulting file path will be \"./testdata/foo.json\".\n*/\nfunc PrependDefaultDirectoryPath(name string) string {\n\treturn filepath.Join(DefaultTestDirectory, name)\n}", "id": 14847, "concepts": ["filepath.Join", "string concatenation", "string manipulation"], "_raw_llm_output": "filepath.Join, string concatenation, string manipulation"}
{"seed": "// NewTestEmailConfigurationParamsWithHTTPClient creates a new TestEmailConfigurationParams object\n// with the ability to set a custom HTTPClient for a request.\nfunc NewTestEmailConfigurationParamsWithHTTPClient(client *http.Client) *TestEmailConfigurationParams {\n\treturn &TestEmailConfigurationParams{\n\t\tHTTPClient: client,\n\t}\n}", "id": 14856, "concepts": ["http.Client usage", "function definition", "function composition"], "_raw_llm_output": "http.Client usage, function definition, function composition"}
{"seed": "// WithClock creates a new Option that sets a clock\n// that the RotateLogs object will use to determine\n// the current time.\n//\n// By default rotatelogs.Local, which returns the\n// current time in the local time zone, is used. If you\n// would rather use UTC, use rotatelogs.UTC as the argument\n// to this option, and pass it to the constructor.\nfunc WithClock(c Clock) Option {\n\treturn OptionFn(func(rl *RotateLogs) error {\n\t\trl.clock = c\n\t\treturn nil\n\t})\n}", "id": 14867, "concepts": ["Option pattern", "Clock interface", "Clock interface implementation", "function composition"], "_raw_llm_output": "Option pattern, Clock interface, Clock interface implementation, function composition"}
{"seed": "// New creates a new ConfigV1Client for the given RESTClient.\nfunc New(c rest.Interface) *ConfigV1Client {\n\treturn &ConfigV1Client{c}\n}", "id": 14892, "concepts": ["interface", "function definition", "method definition", "struct definition", "method receiver", "RESTClient usage"], "_raw_llm_output": "interface, function definition, method definition, struct definition, method receiver, RESTClient usage"}
{"seed": "// GetChainID returns the chainID used for the provided index.\nfunc GetChainID(index int) string {\n\treturn ChainIDPrefix + strconv.Itoa(index)\n}", "id": 14905, "concepts": ["string concatenation", "string formatting", "strconv package usage"], "_raw_llm_output": "string concatenation, string formatting, strconv package usage"}
{"seed": "// NewDockerMemoryStatsUpdate returns the fields that have been updated since the last measurement.\n// It returns nil if nothing has changed.\nfunc NewDockerMemoryStatsUpdate(prev, next docker.ContainerMemoryStats) *DockerMemoryStatsUpdate {\n\tif prev == next {\n\t\treturn nil\n\t}\n\n\tvar delta DockerMemoryStatsUpdate\n\tif prev.Usage != next.Usage {\n\t\tdelta.Usage = &next.Usage\n\t}\n\tif prev.MaxUsage != next.MaxUsage {\n\t\tdelta.MaxUsage = &next.MaxUsage\n\t}\n\tif prev.Limit != next.Limit {\n\t\tdelta.Limit = &next.Limit\n\t}\n\n\tif prev.Stats == next.Stats {\n\t\treturn &delta\n\t}\n\n\tif prev.Stats.ActiveAnon != next.Stats.ActiveAnon {\n\t\tdelta.ActiveAnon = &next.Stats.ActiveAnon\n\t}\n\tif prev.Stats.ActiveFile != next.Stats.ActiveFile {\n\t\tdelta.ActiveFile = &next.Stats.ActiveFile\n\t}\n\tif prev.Stats.InactiveAnon != next.Stats.InactiveAnon {\n\t\tdelta.InactiveAnon = &next.Stats.InactiveAnon\n\t}\n\tif prev.Stats.InactiveFile != next.Stats.InactiveFile {\n\t\tdelta.InactiveFile = &next.Stats.InactiveFile\n\t}\n\tif prev.Stats.TotalCache != next.Stats.TotalCache {\n\t\tdelta.TotalCache = &next.Stats.TotalCache\n\t}\n\tif prev.Stats.TotalRss != next.Stats.TotalRss {\n\t\tdelta.TotalRss = &next.Stats.TotalRss\n\t}\n\n\treturn &delta\n}", "id": 14928, "concepts": ["struct definition", "interface definition", "pointer usage", "nil pointer", "map iteration (range loop)", "slice iteration (range loop)", "slice definition", "map definition", "struct field access", "interface assertion", "interface definition", "struct field access", "interface assertion", "interface definition", "struct field access", "interface assertion", "interface definition", "struct field access", "interface assertion", "interface definition", "struct field access", "interface assertion", "interface definition", "struct field access", "interface assertion", "interface definition", "struct field access", "interface assertion", "interface definition", "struct field access", "interface assertion", "interface definition", "struct field access", "interface assertion", "interface definition", "struct field access", "interface assertion", "interface definition", "struct field access", "interface assertion", "interface definition", "struct field access", "interface assertion", "interface definition", "struct field access", "interface assertion", "interface definition", "struct field access", "interface assertion", "interface definition", "struct field access", "interface assertion", "interface definition", "struct field access", "interface assertion", "interface definition", "struct field access", "interface assertion", "interface definition", "struct field access", "interface assertion", "interface definition", "struct field access", "interface assertion", "interface definition", "struct field access", "interface assertion", "interface definition", "struct field access", "interface assertion", "interface definition", "struct field access", "interface assertion", "interface definition", "struct field access", "interface"], "_raw_llm_output": "struct definition, interface definition, pointer usage, nil pointer, map iteration (range loop), slice iteration (range loop), slice definition, map definition, struct field access, interface assertion, interface definition, struct field access, interface assertion, interface definition, struct field access, interface assertion, interface definition, struct field access, interface assertion, interface definition, struct field access, interface assertion, interface definition, struct field access, interface assertion, interface definition, struct field access, interface assertion, interface definition, struct field access, interface assertion, interface definition, struct field access, interface assertion, interface definition, struct field access, interface assertion, interface definition, struct field access, interface assertion, interface definition, struct field access, interface assertion, interface definition, struct field access, interface assertion, interface definition, struct field access, interface assertion, interface definition, struct field access, interface assertion, interface definition, struct field access, interface assertion, interface definition, struct field access, interface assertion, interface definition, struct field access, interface assertion, interface definition, struct field access, interface assertion, interface definition, struct field access, interface assertion, interface definition, struct field access, interface assertion, interface definition, struct field access, interface assertion, interface definition, struct field access, interface"}
{"seed": "// New returns cnt many new exact aggregators, which aggregate recorded\n// measurements by storing them in an array.  This type uses a mutex\n// for Update() and SynchronizedMove() concurrency.\nfunc New(cnt int) []Aggregator {\n\treturn make([]Aggregator, cnt)\n}", "id": 14932, "concepts": ["mutex", "synchronization", "array", "concurrency"], "_raw_llm_output": "mutex, synchronization, array, concurrency"}
{"seed": "// NewInsuranceGetUnauthorized creates a InsuranceGetUnauthorized with default headers values\nfunc NewInsuranceGetUnauthorized() *InsuranceGetUnauthorized {\n\treturn &InsuranceGetUnauthorized{}\n}", "id": 14935, "concepts": ["struct definition", "struct field definition", "struct field initialization", "struct field access", "function definition", "function call", "function return", "function return value", "function return value assignment", "function return value assignment to struct field", "function return value assignment to struct field", "function return value assignment to struct field", "function return value assignment to struct field", "function return value assignment to struct field", "function return value assignment to struct field", "function return value assignment to struct field", "function return value assignment to struct field", "function return value assignment to struct field", "function return value assignment to struct field", "function return value assignment to struct field", "function return value assignment to struct field", "function return value assignment to struct field", "function return value assignment to struct field", "function return value assignment to struct field", "function return value assignment to struct field", "function return value assignment to struct field", "function return value assignment to struct field", "function return value assignment to struct field", "function return value assignment to struct field", "function return value assignment to struct field", "function return value assignment to struct field", "function return value assignment to struct field", "function return value assignment to struct field", "function return value assignment to struct field", "function return value assignment to struct field", "function return value assignment to struct field", "function return value assignment to struct"], "_raw_llm_output": "struct definition, struct field definition, struct field initialization, struct field access, function definition, function call, function return, function return value, function return value assignment, function return value assignment to struct field, function return value assignment to struct field, function return value assignment to struct field, function return value assignment to struct field, function return value assignment to struct field, function return value assignment to struct field, function return value assignment to struct field, function return value assignment to struct field, function return value assignment to struct field, function return value assignment to struct field, function return value assignment to struct field, function return value assignment to struct field, function return value assignment to struct field, function return value assignment to struct field, function return value assignment to struct field, function return value assignment to struct field, function return value assignment to struct field, function return value assignment to struct field, function return value assignment to struct field, function return value assignment to struct field, function return value assignment to struct field, function return value assignment to struct field, function return value assignment to struct field, function return value assignment to struct field, function return value assignment to struct field, function return value assignment to struct field, function return value assignment to struct field, function return value assignment to struct"}
{"seed": "// NewTokenLTE applies the LTE predicate on the \"new_token\" field.\nfunc NewTokenLTE(v string) predicate.User {\n\treturn predicate.User(sql.FieldLTE(FieldNewToken, v))\n}", "id": 14948, "concepts": ["predicate.User", "sql.FieldLTE", "sql.FieldEQ"], "_raw_llm_output": "predicate.User, sql.FieldLTE, sql.FieldEQ"}
{"seed": "// And groups list of predicates with the AND operator between them.\nfunc And(predicates ...predicate.User) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts1 := s.Clone().SetP(nil)\n\t\tfor _, p := range predicates {\n\t\t\tp(s1)\n\t\t}\n\t\ts.Where(s1.P())\n\t})\n}", "id": 14951, "concepts": ["predicate", "predicate.User", "sql.Selector", "sql.Selector.Where", "sql.Selector.SetP", "sql.Selector.Clone", "sql.Selector.P"], "_raw_llm_output": "predicate, predicate.User, sql.Selector, sql.Selector.Where, sql.Selector.SetP, sql.Selector.Clone, sql.Selector.P"}
{"seed": "// AssertASHandleProprietaryUplinkRequest asserts the given proprietary uplink.\nfunc AssertASHandleProprietaryUplinkRequest(req as.HandleProprietaryUplinkRequest) Assertion {\n\treturn func(assert *require.Assertions, ts *IntegrationTestSuite) {\n\t\tr := <-ts.ASClient.HandleProprietaryUpChan\n\t\tif !proto.Equal(&r, &req) {\n\t\t\tassert.Equal(req, r)\n\t\t}\n\t}\n}", "id": 14959, "concepts": ["interface assertion", "protobuf usage", "channel usage", "assertion library usage"], "_raw_llm_output": "interface assertion, protobuf usage, channel usage, assertion library usage"}
{"seed": "// NewAPIServiceMissedBlocksParams creates a new APIServiceMissedBlocksParams object\n// with the default values initialized.\nfunc NewAPIServiceMissedBlocksParams() *APIServiceMissedBlocksParams {\n\tvar ()\n\treturn &APIServiceMissedBlocksParams{\n\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 14972, "concepts": ["struct definition", "struct initialization", "function definition", "function return value"], "_raw_llm_output": "struct definition, struct initialization, function definition, function return value"}
{"seed": "// isImagePushingToECRInProgress returns if we are pushing images to ECR. Pushing images concurrently would fail because\n// of credential verification issue.\nfunc isImagePushingToECRInProgress(s string) bool {\n\treturn strings.Contains(s, \"denied: Your authorization token has expired. Reauthenticate and try again.\") ||\n\t\tstrings.Contains(s, \"no basic auth credentials\")\n}", "id": 14975, "concepts": ["string manipulation", "string comparison"], "_raw_llm_output": "string manipulation, string comparison"}
{"seed": "// createContext returns a new context with an browser.User embedded with the\n// given role and license.\nfunc createContext(t *testing.T, role browser.Role, lic bool) context.Context {\n\tt.Helper()\n\n\tu := &browser.User{\n\t\tRole:    role,\n\t\tLicense: lic,\n\t}\n\treturn context.WithValue(context.Background(), browser.UserContextKey, u)\n}", "id": 14983, "concepts": ["context.Context", "context.WithValue", "context.Background", "context.ContextKey", "embedded struct"], "_raw_llm_output": "context.Context, context.WithValue, context.Background, context.ContextKey, embedded struct"}
{"seed": "// DescriptionContainsFold applies the ContainsFold predicate on the \"description\" field.\nfunc DescriptionContainsFold(v string) predicate.User {\n\treturn predicate.User(sql.FieldContainsFold(FieldDescription, v))\n}", "id": 14986, "concepts": ["sql.FieldContainsFold", "sql.FieldContainsFold", "sql.FieldContainsFold"], "_raw_llm_output": "sql.FieldContainsFold, sql.FieldContainsFold, sql.FieldContainsFold"}
{"seed": "// AllowNet allows any address from subnet.\nfunc AllowNet(subnet string) (Rule, error) {\n\treturn StaticNetRule(Allow, subnet)\n}", "id": 14989, "concepts": ["interface", "function composition", "function composition", "function composition", "function composition", "function composition"], "_raw_llm_output": "interface, function composition, function composition, function composition, function composition, function composition"}
{"seed": "// UIDNotFound returns a NotFoundError for a missing user searched by UID.\nfunc UIDNotFound(uid uint32) error {\n\treturn &NotFoundError{\n\t\thasDetails:     true,\n\t\tentityName:     \"user\",\n\t\tidentifierName: \"UID\",\n\t\tidentifier:     uid,\n\t}\n}", "id": 14992, "concepts": ["error handling (error wrapping)", "error interface", "error details"], "_raw_llm_output": "error handling (error wrapping), error interface, error details"}
{"seed": "// WithLog is an Option that configures a Reconciler's logger.\n//\n// A default logger is used if this option is not configured.\nfunc WithLog(log logr.Logger) Option {\n\treturn func(r *Reconciler) error {\n\t\tr.log = log\n\t\treturn nil\n\t}\n}", "id": 14996, "concepts": ["Option pattern", "logger", "logr package usage"], "_raw_llm_output": "Option pattern, logger, logr package usage"}
{"seed": "// AsJSON specifies to log the output as JSON.\nfunc AsJSON() Option {\n\treturn func(cfg *Config) {\n\t\tcfg.JSON = true\n\t}\n}", "id": 15004, "concepts": ["function composition", "function definition", "function as value"], "_raw_llm_output": "function composition, function definition, function as value"}
{"seed": "// CreatedAtLTE applies the LTE predicate on the \"created_at\" field.\nfunc CreatedAtLTE(v time.Time) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.LTE(s.C(FieldCreatedAt), v))\n\t})\n}", "id": 15018, "concepts": ["sql package usage", "time package usage", "sql.Selector", "sql.C", "sql.LTE", "predicate.User"], "_raw_llm_output": "sql package usage, time package usage, sql.Selector, sql.C, sql.LTE, predicate.User"}
{"seed": "// Hr represents the HTML void element 'hr'.\n// For more information visit https://www.w3schools.com/tags/tag_hr.asp.\nfunc Hr(attrs []htmlgo.Attribute) HTML {\n\treturn &htmlgo.Tree{Tag: \"hr\", Attributes: attrs, SelfClosing: true}\n}", "id": 15020, "concepts": ["HTML generation", "HTML void elements", "HTML attributes"], "_raw_llm_output": "HTML generation, HTML void elements, HTML attributes"}
{"seed": "// ResyncLoopEventStream an EventStream that calls `listFn` every `duration` interval.\n// This is used for rerunning the control-loop for all entities periodically.\n// Having one of these is recommended for any controller.\nfunc ResyncLoopEventStream(obs Observability, duration time.Duration, listFn func(ctx context.Context) ([]string, error)) EventStream {\n\tm := metric.Must(obs.Meter)\n\tcount := m.NewInt64Counter(\"kreconciler_stream_resync_item_count\",\n\t\tmetric.WithUnit(unit.Dimensionless),\n\t\tmetric.WithDescription(\"Increased by the number of items returned by the listFn\"),\n\t)\n\trecorder := m.NewInt64ValueRecorder(\"kreconciler_stream_resync_millis\",\n\t\tmetric.WithUnit(unit.Milliseconds),\n\t\tmetric.WithDescription(\"time spent calling the listFn\"),\n\t)\n\terrorRecorder := recorder.Bind(label.String(\"status\", \"error\"))\n\tsuccessRecorder := recorder.Bind(label.String(\"status\", \"success\"))\n\treturn EventStreamFunc(func(ctx context.Context, handler EventHandler) error {\n\t\tticker := time.NewTicker(duration)\n\t\tfor {\n\t\t\tobs.Info(\"Running step of resync loop\")\n\t\t\tstart := time.Now()\n\t\t\t// Queue the objects to be handled.\n\t\t\telts, err := listFn(ctx)\n\t\t\tif err != nil {\n\t\t\t\terrorRecorder.Record(ctx, time.Since(start).Milliseconds())\n\t\t\t\tobs.Error(\"Failed resync loop call\", \"error\", err)\n\t\t\t\ttime.Sleep(time.Millisecond * 250)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tobs.Info(\"Adding events\", \"count\", len(elts))\n\t\t\tcount.Add(ctx, int64(len(elts)))\n\t\t\tsuccessRecorder.Record(ctx, time.Since(start).Milliseconds())\n\t\t\tfor _, id := range elts {\n\t\t\t\t// Listed objects enqueue as present.\n\t\t\t\terr = handler.Call(ctx, id)\n\t\t\t\tif err != nil {\n\t\t\t\t\tobs.Warn(\"Failed handle in resync loop\", \"id\", id, \"error\", err)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\tobs.Info(\"Finished resync loop\")\n\t\t\t\treturn nil\n\t\t\tcase <-ticker.C:\n\t\t\t}\n\t\t}\n\t})\n}", "id": 15025, "concepts": ["time.Ticker", "sync.WaitGroup", "anonymous function", "concurrency", "standard library usage"], "_raw_llm_output": "time.Ticker, sync.WaitGroup, anonymous function, concurrency, standard library usage"}
{"seed": "// LatestHeroScoreGTE applies the GTE predicate on the \"latest_hero_score\" field.\nfunc LatestHeroScoreGTE(v int) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.GTE(s.C(FieldLatestHeroScore), v))\n\t})\n}", "id": 15026, "concepts": ["sql package usage", "sql.Selector", "sql.C", "sql.GTE"], "_raw_llm_output": "sql package usage, sql.Selector, sql.C, sql.GTE"}
{"seed": "// Keygen represents the HTML element 'keygen'.\n// For more information visit https://www.w3schools.com/tags/tag_keygen.asp.\nfunc Keygen(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"keygen\", Attributes: attrs, Children: children}\n}", "id": 15031, "concepts": ["HTML generation", "HTML element definition", "HTML attribute definition", "HTML element children definition"], "_raw_llm_output": "HTML generation, HTML element definition, HTML attribute definition, HTML element children definition"}
{"seed": "// Not applies the not operator on the given predicate.\nfunc Not(p predicate.Bulk) predicate.Bulk {\n\treturn predicate.Bulk(func(s *sql.Selector) {\n\t\tp(s.Not())\n\t})\n}", "id": 15042, "concepts": ["predicate composition", "predicate definition", "predicate usage", "predicate composition"], "_raw_llm_output": "predicate composition, predicate definition, predicate usage, predicate composition"}
{"seed": "// RecentTasksActivityCreatedAtDESC function sorts data by CreatedAt field in descending order\n// sorting layers: CreatedAt(DESC)  > Name(DESC)\n// function chain according to sorting layers: RecentTasksActivityCreatedAtDESC > subsortingByNameASC\nfunc RecentTasksActivityCreatedAtDESC(p1, p2 interface{}) bool {\n\tp1CreatedAt := p1.(RecentTasksActivity).Task.CreatedAt.Truncate(time.Minute)\n\tp2CreatedAt := p2.(RecentTasksActivity).Task.CreatedAt.Truncate(time.Minute)\n\n\tif p1CreatedAt == p2CreatedAt {\n\t\treturn subsortingByNameASC(p1, p2)\n\t}\n\n\treturn p1CreatedAt.After(p2CreatedAt)\n}", "id": 15047, "concepts": ["sorting", "time handling", "interface usage"], "_raw_llm_output": "sorting, time handling, interface usage"}
{"seed": "// spacer generates a whitespace string that can be used for indenting lines up to the specified level.\nfunc spacer(level int) string {\n\treturn strings.Repeat(\"  \", level)\n}", "id": 15050, "concepts": ["string manipulation", "string repetition"], "_raw_llm_output": "string manipulation, string repetition"}
{"seed": "// use map\n/**\nloop1: put all node to map, origin node point as key, new node point as value\nloop2: fill all new node's next node and random node\n*/\nfunc copyRandomList2(head *Node) *Node {\n\tm := make(map[*Node]*Node)\n\tloop := head\n\tfor loop != nil {\n\t\tm[loop] = &Node{\n\t\t\tVal: loop.Val,\n\t\t}\n\t\tloop = loop.Next\n\t}\n\tloop = head\n\tfor loop != nil {\n\t\tif loop.Next != nil {\n\t\t\tm[loop].Next = m[loop.Next]\n\t\t}\n\t\tif loop.Random != nil {\n\t\t\tm[loop].Random = m[loop.Random]\n\t\t}\n\t\tloop = loop.Next\n\t}\n\treturn m[head]\n}", "id": 15052, "concepts": ["map", "pointer", "pointer manipulation"], "_raw_llm_output": "map, pointer, pointer manipulation"}
{"seed": "// ReadTransactants reads a full Transactant structure from the database based on the supplied rows object\nfunc ReadTransactants(rows *sql.Rows, a *Transactant) error {\n\treturn rows.Scan(&a.TCID, &a.BID, &a.NLID, &a.FirstName, &a.MiddleName, &a.LastName, &a.PreferredName,\n\t\t&a.CompanyName, &a.IsCompany, &a.PrimaryEmail, &a.SecondaryEmail, &a.WorkPhone, &a.CellPhone,\n\t\t&a.Address, &a.Address2, &a.City, &a.State, &a.PostalCode, &a.Country, &a.Website, &a.Comment, &a.FLAGS,\n\t\t&a.CreateTS, &a.CreateBy, &a.LastModTime, &a.LastModBy)\n}", "id": 15053, "concepts": ["sql package usage", "sql.Rows", "sql.Scan", "struct definition"], "_raw_llm_output": "sql package usage, sql.Rows, sql.Scan, struct definition"}
{"seed": "// Isindex_ is a convenience wrapper for Isindex without the attrs argument.\nfunc Isindex_(children ...HTML) HTML {\n  return Isindex(nil, children...)\n}", "id": 15056, "concepts": ["HTML tag usage", "HTML tag attributes", "HTML tag children", "HTML tag self-closing"], "_raw_llm_output": "HTML tag usage, HTML tag attributes, HTML tag children, HTML tag self-closing"}
{"seed": "// PossibleEnforceCertificateNameCheckEnabledStateValues returns an array of possible values for the EnforceCertificateNameCheckEnabledState const type.\nfunc PossibleEnforceCertificateNameCheckEnabledStateValues() []EnforceCertificateNameCheckEnabledState {\n\treturn []EnforceCertificateNameCheckEnabledState{EnforceCertificateNameCheckEnabledStateDisabled, EnforceCertificateNameCheckEnabledStateEnabled}\n}", "id": 15065, "concepts": ["basic function definition", "array iteration (range loop)", "possible values"], "_raw_llm_output": "basic function definition, array iteration (range loop), possible values"}
{"seed": "// NewAttributeValueBool creates a new AttributeValue with the given bool value.\nfunc NewAttributeValueBool(v bool) AttributeValue {\n\torig := &otlpcommon.AnyValue{Value: &otlpcommon.AnyValue_BoolValue{BoolValue: v}}\n\treturn AttributeValue{orig: orig}\n}", "id": 15067, "concepts": ["struct definition", "pointer usage", "interface usage"], "_raw_llm_output": "struct definition, pointer usage, interface usage"}
{"seed": "// NewCreateAntiAffinityGroupRequest calls the generic CreateAntiAffinityGroup builder with application/json body\nfunc NewCreateAntiAffinityGroupRequest(server string, body CreateAntiAffinityGroupJSONRequestBody) (*http.Request, error) {\n\tvar bodyReader io.Reader\n\tbuf, err := json.Marshal(body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tbodyReader = bytes.NewReader(buf)\n\treturn NewCreateAntiAffinityGroupRequestWithBody(server, \"application/json\", bodyReader)\n}", "id": 15072, "concepts": ["JSON marshaling", "JSON unmarshaling", "http.Request creation", "http.Request body handling", "http.Request header handling"], "_raw_llm_output": "JSON marshaling, JSON unmarshaling, http.Request creation, http.Request body handling, http.Request header handling"}
{"seed": "// NewDownloadRecord returns a TransferRecord filled out with a UUID,\n// StartTime, Status of \"requested\", and a Kind of \"download\".\nfunc NewDownloadRecord() *TransferRecord {\n\treturn &TransferRecord{\n\t\tUUID:      uuid.New(),\n\t\tStartTime: time.Now(),\n\t\tStatus:    RequestedStatus,\n\t\tKind:      DownloadKind,\n\t}\n}", "id": 15088, "concepts": ["UUID generation", "time.Now()", "struct definition", "struct initialization"], "_raw_llm_output": "UUID generation, time.Now(), struct definition, struct initialization"}
{"seed": "// makePallocData produces an initialized PallocData by setting\n// the ranges of described in alloc and scavenge.\nfunc makePallocData(alloc, scavenged []BitRange) *PallocData {\n\tb := new(PallocData)\n\tfor _, v := range alloc {\n\t\tif v.N == 0 {\n\t\t\t// Skip N==0. It's harmless and allocRange doesn't\n\t\t\t// handle this case.\n\t\t\tcontinue\n\t\t}\n\t\tb.AllocRange(v.I, v.N)\n\t}\n\tfor _, v := range scavenged {\n\t\tif v.N == 0 {\n\t\t\t// See the previous loop.\n\t\t\tcontinue\n\t\t}\n\t\tb.ScavengedSetRange(v.I, v.N)\n\t}\n\treturn b\n}", "id": 15095, "concepts": ["struct definition", "struct field access", "struct field assignment", "slice iteration (range loop)", "slice definition", "slice append", "slice length", "slice capacity", "slice element access", "slice element assignment", "slice element deletion", "slice element insertion", "slice element deletion", "slice element insertion", "slice element deletion", "slice element insertion", "slice element deletion", "slice element insertion", "slice element deletion", "slice element insertion", "slice element deletion", "slice element insertion", "slice element deletion", "slice element insertion", "slice element deletion", "slice element insertion", "slice element deletion", "slice element insertion", "slice element deletion", "slice element insertion", "slice element deletion", "slice element insertion", "slice element deletion", "slice element insertion", "slice element deletion", "slice element insertion", "slice element deletion", "slice element insertion", "slice element deletion", "slice element insertion", "slice element deletion", "slice element insertion", "slice element deletion", "slice element insertion", "slice element deletion", "slice element insertion", "slice element deletion", "slice element insertion", "slice element deletion", "slice element insertion", "slice element deletion", "slice element insertion", "slice element deletion", "slice element insertion", "slice element deletion", "slice element insertion", "slice element deletion", "slice element insertion", "slice element deletion", "slice element insertion", "slice element deletion", "slice element insertion", "slice element deletion", "slice element insertion", "slice element"], "_raw_llm_output": "struct definition, struct field access, struct field assignment, slice iteration (range loop), slice definition, slice append, slice length, slice capacity, slice element access, slice element assignment, slice element deletion, slice element insertion, slice element deletion, slice element insertion, slice element deletion, slice element insertion, slice element deletion, slice element insertion, slice element deletion, slice element insertion, slice element deletion, slice element insertion, slice element deletion, slice element insertion, slice element deletion, slice element insertion, slice element deletion, slice element insertion, slice element deletion, slice element insertion, slice element deletion, slice element insertion, slice element deletion, slice element insertion, slice element deletion, slice element insertion, slice element deletion, slice element insertion, slice element deletion, slice element insertion, slice element deletion, slice element insertion, slice element deletion, slice element insertion, slice element deletion, slice element insertion, slice element deletion, slice element insertion, slice element deletion, slice element insertion, slice element deletion, slice element insertion, slice element deletion, slice element insertion, slice element deletion, slice element insertion, slice element deletion, slice element insertion, slice element deletion, slice element insertion, slice element deletion, slice element insertion, slice element deletion, slice element insertion, slice element"}
{"seed": "// TitleLT applies the LT predicate on the \"title\" field.\nfunc TitleLT(v string) predicate.User {\n\treturn predicate.User(sql.FieldLT(FieldTitle, v))\n}", "id": 15101, "concepts": ["predicate.User", "sql.FieldLT", "sql.FieldGT", "sql.FieldEQ", "sql.FieldNE", "sql.FieldIN", "sql.FieldNotIn", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldIs", "sql.FieldIsNot", "sql.FieldIsNull", "sql.FieldIsNotNull", "sql.FieldContains", "sql.FieldNotContains", "sql.FieldStartsWith", "sql.FieldEndsWith", "sql.FieldBetween", "sql.FieldNotBetween", "sql.FieldContainsAny", "sql.FieldNotContainsAny", "sql.FieldContainsAll", "sql.FieldNotContainsAll", "sql.FieldContainsAll", "sql.FieldNotContainsAll", "sql.FieldContainsAll", "sql.FieldNotContainsAll", "sql.FieldContainsAll", "sql.FieldNotContainsAll", "sql.FieldContainsAll", "sql.FieldNotContainsAll", "sql.FieldContainsAll", "sql.FieldNotContainsAll", "sql.FieldContainsAll", "sql.FieldNotContainsAll", "sql.FieldContainsAll", "sql.FieldNotContainsAll", "sql.FieldContainsAll", "sql.FieldNotContainsAll", "sql.FieldContainsAll", "sql.FieldNotContainsAll", "sql.FieldContainsAll", "sql.FieldNotContainsAll", "sql."], "_raw_llm_output": "predicate.User, sql.FieldLT, sql.FieldGT, sql.FieldEQ, sql.FieldNE, sql.FieldIN, sql.FieldNotIn, sql.FieldLike, sql.FieldNotLike, sql.FieldIs, sql.FieldIsNot, sql.FieldIsNull, sql.FieldIsNotNull, sql.FieldContains, sql.FieldNotContains, sql.FieldStartsWith, sql.FieldEndsWith, sql.FieldBetween, sql.FieldNotBetween, sql.FieldContainsAny, sql.FieldNotContainsAny, sql.FieldContainsAll, sql.FieldNotContainsAll, sql.FieldContainsAll, sql.FieldNotContainsAll, sql.FieldContainsAll, sql.FieldNotContainsAll, sql.FieldContainsAll, sql.FieldNotContainsAll, sql.FieldContainsAll, sql.FieldNotContainsAll, sql.FieldContainsAll, sql.FieldNotContainsAll, sql.FieldContainsAll, sql.FieldNotContainsAll, sql.FieldContainsAll, sql.FieldNotContainsAll, sql.FieldContainsAll, sql.FieldNotContainsAll, sql.FieldContainsAll, sql.FieldNotContainsAll, sql.FieldContainsAll, sql.FieldNotContainsAll, sql."}
{"seed": "// IsObjectCompressed returns true iff path is of a compressed, i.e., contains a .lz4 extension\nfunc IsObjectCompressed(path string) bool {\n\treturn path[len(path)-len(lz4.Extension):] == lz4.Extension\n}", "id": 15108, "concepts": ["string manipulation", "extension handling", "string comparison"], "_raw_llm_output": "string manipulation, extension handling, string comparison"}
{"seed": "// NicknameLTE applies the LTE predicate on the \"nickname\" field.\nfunc NicknameLTE(v string) predicate.User {\n\treturn predicate.User(sql.FieldLTE(FieldNickname, v))\n}", "id": 15111, "concepts": ["predicate.User", "sql.FieldLTE", "sql.FieldGT", "sql.FieldGTE", "sql.FieldEQ", "sql.FieldNEQ", "sql.FieldIN", "sql.FieldNotIn", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldContains", "sql.FieldNotContains", "sql.FieldStartsWith", "sql.FieldNotStartsWith", "sql.FieldEndsWith", "sql.FieldNotEndsWith", "sql.FieldBetween", "sql.FieldNotBetween", "sql.FieldIsNull", "sql.FieldIsNotNull", "sql.FieldContainsAny", "sql.FieldNotContainsAny", "sql.FieldContainsAll", "sql.FieldNotContainsAll", "sql.FieldIsBlank", "sql.FieldIsNotBlank", "sql.FieldIsJSON", "sql.FieldIsNotJSON", "sql.FieldIsJSONB", "sql.FieldIsNotJSONB", "sql.FieldIsJSONPath", "sql.FieldIsNotJSONPath", "sql.FieldIsJSONPathExists", "sql.FieldIsNotJSONPathExists", "sql.FieldIsJSONPathExistsAll", "sql.FieldIsNotJSONPathExistsAll", "sql.FieldIsJSONPathExistsAny", "sql.FieldIsNotJSONPathExistsAny", "sql.FieldIsJSONPathExistsAllAny", "sql.FieldIsNotJSONPathExistsAllAny"], "_raw_llm_output": "predicate.User, sql.FieldLTE, sql.FieldGT, sql.FieldGTE, sql.FieldEQ, sql.FieldNEQ, sql.FieldIN, sql.FieldNotIn, sql.FieldLike, sql.FieldNotLike, sql.FieldContains, sql.FieldNotContains, sql.FieldStartsWith, sql.FieldNotStartsWith, sql.FieldEndsWith, sql.FieldNotEndsWith, sql.FieldBetween, sql.FieldNotBetween, sql.FieldIsNull, sql.FieldIsNotNull, sql.FieldContainsAny, sql.FieldNotContainsAny, sql.FieldContainsAll, sql.FieldNotContainsAll, sql.FieldIsBlank, sql.FieldIsNotBlank, sql.FieldIsJSON, sql.FieldIsNotJSON, sql.FieldIsJSONB, sql.FieldIsNotJSONB, sql.FieldIsJSONPath, sql.FieldIsNotJSONPath, sql.FieldIsJSONPathExists, sql.FieldIsNotJSONPathExists, sql.FieldIsJSONPathExistsAll, sql.FieldIsNotJSONPathExistsAll, sql.FieldIsJSONPathExistsAny, sql.FieldIsNotJSONPathExistsAny, sql.FieldIsJSONPathExistsAllAny, sql.FieldIsNotJSONPathExistsAllAny"}
{"seed": "// DefaultExprsNotNil applies the NotNil predicate on the \"default_exprs\" field.\nfunc DefaultExprsNotNil() predicate.User {\n\treturn predicate.User(sql.FieldNotNull(FieldDefaultExprs))\n}", "id": 15137, "concepts": ["sql.FieldNotNull", "sql.Field", "predicate.User", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql.Field", "sql."], "_raw_llm_output": "sql.FieldNotNull, sql.Field, predicate.User, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql.Field, sql."}
{"seed": "// Difference returns the difference between two collections.\n// The first value is the collection of element absent of list2.\n// The second value is the collection of element absent of list1.\nfunc Difference[T comparable](list1 []T, list2 []T) ([]T, []T) {\n\tleft := []T{}\n\tright := []T{}\n\n\tseenLeft := map[T]struct{}{}\n\tseenRight := map[T]struct{}{}\n\n\tfor _, elem := range list1 {\n\t\tseenLeft[elem] = struct{}{}\n\t}\n\n\tfor _, elem := range list2 {\n\t\tseenRight[elem] = struct{}{}\n\t}\n\n\tfor _, elem := range list1 {\n\t\tif _, ok := seenRight[elem]; !ok {\n\t\t\tleft = append(left, elem)\n\t\t}\n\t}\n\n\tfor _, elem := range list2 {\n\t\tif _, ok := seenLeft[elem]; !ok {\n\t\t\tright = append(right, elem)\n\t\t}\n\t}\n\n\treturn left, right\n}", "id": 15147, "concepts": ["generic programming", "map iteration", "map lookup", "map creation", "map deletion", "basic function definition"], "_raw_llm_output": "generic programming, map iteration, map lookup, map creation, map deletion, basic function definition"}
{"seed": "// NewPostDockerRegistriesSearchListParamsWithTimeout creates a new PostDockerRegistriesSearchListParams object\n// with the default values initialized, and the ability to set a timeout on a request\nfunc NewPostDockerRegistriesSearchListParamsWithTimeout(timeout time.Duration) *PostDockerRegistriesSearchListParams {\n\tvar ()\n\treturn &PostDockerRegistriesSearchListParams{\n\n\t\ttimeout: timeout,\n\t}\n}", "id": 15149, "concepts": ["struct initialization", "anonymous struct", "function definition", "timeout handling"], "_raw_llm_output": "struct initialization, anonymous struct, function definition, timeout handling"}
{"seed": "// CorrectionContainsFold applies the ContainsFold predicate on the \"correction\" field.\nfunc CorrectionContainsFold(v string) predicate.TradeCorrection {\n\treturn predicate.TradeCorrection(sql.FieldContainsFold(FieldCorrection, v))\n}", "id": 15151, "concepts": ["sql.FieldContainsFold", "predicate.TradeCorrection", "sql.Field", "sql.FieldContainsFold", "sql.FieldContainsFold", "sql.FieldContainsFold"], "_raw_llm_output": "sql.FieldContainsFold, predicate.TradeCorrection, sql.Field, sql.FieldContainsFold, sql.FieldContainsFold, sql.FieldContainsFold"}
{"seed": "// selectFiles selects all log files that have an timestamp before the\n// endTime. It then sorts them in decreasing order, with the most\n// recent as the first one.\nfunc selectFiles(logFiles []FileInfo, endTimestamp int64) []FileInfo {\n\tfiles := sortableFileInfoSlice{}\n\tfor _, logFile := range logFiles {\n\t\tif logFile.Details.Time <= endTimestamp {\n\t\t\tfiles = append(files, logFile)\n\t\t}\n\t}\n\n\t// Sort the files in reverse order so we will fetch the newest first.\n\tsort.Sort(sort.Reverse(files))\n\treturn files\n}", "id": 15157, "concepts": ["slice iteration (range loop)", "slice sorting", "sort.Sort", "sort.Reverse"], "_raw_llm_output": "slice iteration (range loop), slice sorting, sort.Sort, sort.Reverse"}
{"seed": "// TxOutsEqual returns true if two transaction outputs are equal.\nfunc TxOutsEqual(out1, out2 *wire.TxOut) bool {\n\tif out1 == nil || out2 == nil {\n\t\treturn out1 == out2\n\n\t}\n\treturn out1.Value == out2.Value &&\n\t\tbytes.Equal(out1.PkScript, out2.PkScript)\n\n}", "id": 15160, "concepts": ["wire package usage", "bytes package usage", "struct comparison"], "_raw_llm_output": "wire package usage, bytes package usage, struct comparison"}
{"seed": "// OrderedBy returns a Sorter that sorts using the less functions, in order.\n// Call its Sort method to sort the data.\nfunc OrderedBy(less ...lessFunc) *multiSorter {\n\treturn &multiSorter{\n\t\tless: less,\n\t}\n}", "id": 15161, "concepts": ["function definition", "function composition", "function composition with anonymous function", "function composition with function pointer", "function composition with function pointer and anonymous function", "function composition with function pointer and function pointer", "function composition with function pointer and function pointer and anonymous function", "function composition with function pointer and function pointer and function pointer", "function composition with function pointer and function pointer and function pointer and anonymous function", "function composition with function pointer and function pointer and function pointer and function pointer", "function composition with function pointer and function pointer and function pointer and function pointer and anonymous function", "function composition with function pointer and function pointer and function pointer and function pointer and function pointer", "function composition with function pointer and function pointer and function pointer and function pointer and function pointer and anonymous function", "function composition with function pointer and function pointer and function pointer and function pointer and function pointer and function pointer", "function composition with function pointer and function pointer and function pointer and function pointer and function pointer and function pointer and anonymous function", "function composition with function pointer and function pointer and function pointer and function pointer and function pointer and function pointer and function pointer", "function composition with function pointer and function pointer and function pointer and function pointer and function pointer and function pointer and function pointer and anonymous function", "function composition with function pointer and function pointer and function pointer and"], "_raw_llm_output": "function definition, function composition, function composition with anonymous function, function composition with function pointer, function composition with function pointer and anonymous function, function composition with function pointer and function pointer, function composition with function pointer and function pointer and anonymous function, function composition with function pointer and function pointer and function pointer, function composition with function pointer and function pointer and function pointer and anonymous function, function composition with function pointer and function pointer and function pointer and function pointer, function composition with function pointer and function pointer and function pointer and function pointer and anonymous function, function composition with function pointer and function pointer and function pointer and function pointer and function pointer, function composition with function pointer and function pointer and function pointer and function pointer and function pointer and anonymous function, function composition with function pointer and function pointer and function pointer and function pointer and function pointer and function pointer, function composition with function pointer and function pointer and function pointer and function pointer and function pointer and function pointer and anonymous function, function composition with function pointer and function pointer and function pointer and function pointer and function pointer and function pointer and function pointer, function composition with function pointer and function pointer and function pointer and function pointer and function pointer and function pointer and function pointer and anonymous function, function composition with function pointer and function pointer and function pointer and"}
{"seed": "// Upgrades reports if the are any upgrades for any direct and indirect dependencies.\r\n// It returns true if upgrades are needed.\r\n// Rule: gomodvet-002\r\nfunc Upgrades(verbose bool) (bool, error) {\r\n\tmods, err := buildlist.ResolveUpgrades()\r\n\tif err != nil {\r\n\t\treturn false, err\r\n\t}\r\n\tflagged := false\r\n\tfor _, mod := range mods {\r\n\t\tif verbose {\r\n\t\t\tfmt.Printf(\"gomodvet: upgrades: module %s: %+v\\n\", mod.Path, mod)\r\n\t\t}\r\n\t\tif mod.Update != nil {\r\n\t\t\tfmt.Println(\"gomodvet-002: dependencies have available updates: \", mod.Path, mod.Update.Version)\r\n\t\t\tflagged = true\r\n\t\t}\r\n\t}\r\n\treturn flagged, nil\r\n}", "id": 15168, "concepts": ["module resolution", "module update", "dependency management", "standard library usage"], "_raw_llm_output": "module resolution, module update, dependency management, standard library usage"}
{"seed": "// CrossEntropy computes the Shannon cross-entropy for\n// the predictor on the given input stream.\n//\n// If the stream ends early with an error, this will\n// return said error along with the cross entropy up\n// to the error.\nfunc CrossEntropy(p Predictor, input io.Reader) (float64, error) {\n\tresult := kahan.NewSummer64()\n\tbuffer := make([]byte, bufferSize)\n\n\tp.Reset()\n\tfor {\n\t\tn, readErr := input.Read(buffer)\n\t\tif n == 0 {\n\t\t\tif readErr == io.EOF {\n\t\t\t\tbreak\n\t\t\t} else if readErr != nil {\n\t\t\t\treturn result.Sum(), readErr\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tfor _, x := range buffer[:n] {\n\t\t\tpred := p.Predictions()[x]\n\t\t\tif pred == 0 {\n\t\t\t\tresult.Add(maxCrossEntropy)\n\t\t\t} else {\n\t\t\t\tresult.Add(-math.Log2(pred))\n\t\t\t}\n\t\t\tp.SawByte(x)\n\t\t}\n\n\t\tif readErr == io.EOF {\n\t\t\tbreak\n\t\t} else if readErr != nil {\n\t\t\treturn result.Sum(), readErr\n\t\t}\n\t}\n\n\treturn result.Sum(), nil\n}", "id": 15172, "concepts": ["io.Reader", "io.Reader.Read()", "io.EOF", "io.EOF handling", "io.EOF error handling", "io.Reader.Read() error handling", "io.Reader.Read() EOF handling", "io.Reader.Read() error handling", "io.Reader.Read() EOF handling", "io.Reader.Read() error handling", "io.Reader.Read() EOF handling", "io.Reader.Read() error handling", "io.Reader.Read() EOF handling", "io.Reader.Read() error handling", "io.Reader.Read() EOF handling", "io.Reader.Read() error handling", "io.Reader.Read() EOF handling", "io.Reader.Read() error handling", "io.Reader.Read() EOF handling", "io.Reader.Read() error handling", "io.Reader.Read() EOF handling", "io.Reader.Read() error handling", "io.Reader.Read() EOF handling", "io.Reader.Read() error handling", "io.Reader.Read() EOF handling", "io.Reader.Read() error handling", "io.Reader.Read() EOF handling", "io.Reader.Read() error handling", "io.Reader.Read() EOF handling", "io.Reader.Read() error handling", "io.Reader.Read"], "_raw_llm_output": "io.Reader, io.Reader.Read(), io.EOF, io.EOF handling, io.EOF error handling, io.Reader.Read() error handling, io.Reader.Read() EOF handling, io.Reader.Read() error handling, io.Reader.Read() EOF handling, io.Reader.Read() error handling, io.Reader.Read() EOF handling, io.Reader.Read() error handling, io.Reader.Read() EOF handling, io.Reader.Read() error handling, io.Reader.Read() EOF handling, io.Reader.Read() error handling, io.Reader.Read() EOF handling, io.Reader.Read() error handling, io.Reader.Read() EOF handling, io.Reader.Read() error handling, io.Reader.Read() EOF handling, io.Reader.Read() error handling, io.Reader.Read() EOF handling, io.Reader.Read() error handling, io.Reader.Read() EOF handling, io.Reader.Read() error handling, io.Reader.Read() EOF handling, io.Reader.Read() error handling, io.Reader.Read() EOF handling, io.Reader.Read() error handling, io.Reader.Read"}
{"seed": "// EqualError asserts that either an error is non-nil and that its message is what is expected,\n// or that error is nil if the expected message is empty.\nfunc EqualError(t testing.TB, err error, errString string, msgAndArgs ...interface{}) {\n\tif err == nil && errString == \"\" {\n\t\treturn\n\t}\n\tt.Helper()\n\tif err == nil {\n\t\tt.Fatal(formatMsgAndArgs(\"Expected an error\", msgAndArgs...))\n\t}\n\tif err.Error() != errString {\n\t\tmsg := formatMsgAndArgs(\"Error message not as expected:\", msgAndArgs...)\n\t\tt.Fatalf(\"%s\\n%s\", msg, diff(errString, err.Error()))\n\t}\n}", "id": 15175, "concepts": ["error handling (idiomatic `if err != nil`)", "error comparison"], "_raw_llm_output": "error handling (idiomatic `if err != nil`), error comparison"}
{"seed": "// writePaddedString writes a string with padding bytes to the a buffer.\n// Returns, the number of written bytes and an error if any.\nfunc writePaddedString(str string, buf *bytes.Buffer) (int, error) {\n\t// Write the string to the buffer\n\tn, err := buf.WriteString(str)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Calculate the padding bytes needed and create a buffer for the padding bytes\n\tnumPadBytes := padBytesNeeded(len(str))\n\tif numPadBytes > 0 {\n\t\tpadBytes := make([]byte, numPadBytes)\n\t\t// Add the padding bytes to the buffer\n\t\tn, err := buf.Write(padBytes)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\tnumPadBytes = n\n\t}\n\n\treturn n + numPadBytes, nil\n}", "id": 15176, "concepts": ["bytes.Buffer", "bytes.Buffer.WriteString", "bytes.Buffer.Write", "bytes.Buffer.Len", "bytes.Buffer.Bytes", "bytes.Buffer.String", "error handling", "standard library usage"], "_raw_llm_output": "bytes.Buffer, bytes.Buffer.WriteString, bytes.Buffer.Write, bytes.Buffer.Len, bytes.Buffer.Bytes, bytes.Buffer.String, error handling, standard library usage"}
{"seed": "// SetGlobal sets the public Env variable to the URLs in the given filename. If the given\n// filename is blank, a known hardcoded location for server_config.json on the robot is used.\nfunc SetGlobal(filename string) error {\n\turls, err := LoadURLs(filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\tEnv = *urls\n\treturn nil\n}", "id": 15181, "concepts": ["struct definition", "struct field access", "pointer dereference", "error handling (errors.New)", "file I/O", "JSON parsing"], "_raw_llm_output": "struct definition, struct field access, pointer dereference, error handling (errors.New), file I/O, JSON parsing"}
{"seed": "// LoadFromFlags populates s with the current values of the flags in the FlagSet.\nfunc LoadFromFlags(flags *flag.FlagSet, s interface{}, opts ...Option) error {\n\tv := reflect.ValueOf(s)\n\tif v.Kind() != reflect.Ptr || v.Elem().Kind() != reflect.Struct {\n\t\treturn fmt.Errorf(\"unable to load from flags for %q: not a pointer to a struct\", v.Type())\n\t}\n\tif !v.Elem().CanSet() {\n\t\treturn fmt.Errorf(\"unable to load from flags for %q: struct is not settable\", v.Type())\n\t}\n\to := getOpts(opts...)\n\treturn loadFromStructFields(flags, v.Elem(), o)\n}", "id": 15184, "concepts": ["reflection", "flag package usage", "struct field handling", "struct field setting"], "_raw_llm_output": "reflection, flag package usage, struct field handling, struct field setting"}
{"seed": "// StringToBool creates a binding that connects a String data item to a Bool.\n// Changes to the String will be parsed and pushed to the Bool if the parse was successful, and setting\n// the Bool update the String binding.\n//\n// Since: 2.0\nfunc StringToBool(str String) Bool {\n\tv := &stringToBool{from: str}\n\tstr.AddListener(v)\n\treturn v\n}", "id": 15185, "concepts": ["binding", "listener", "string parsing", "basic function definition"], "_raw_llm_output": "binding, listener, string parsing, basic function definition"}
{"seed": "// GetLanguageExtensions returns the different extensions being used by the\n// language.\nfunc GetLanguageExtensions(language string) []string {\n\treturn ExtensionsByLanguage[language]\n}", "id": 15199, "concepts": ["map usage", "map iteration", "map key lookup"], "_raw_llm_output": "map usage, map iteration, map key lookup"}
{"seed": "// WorkplaceGTE applies the GTE predicate on the \"workplace\" field.\nfunc WorkplaceGTE(v string) predicate.User {\n\treturn predicate.User(sql.FieldGTE(FieldWorkplace, v))\n}", "id": 15201, "concepts": ["sql package usage", "predicate definition", "field comparison"], "_raw_llm_output": "sql package usage, predicate definition, field comparison"}
{"seed": "// \u56fe\u7247_\u52a0\u8f7d\u4ece\u5185\u5b58\u6307\u5b9a\u533a\u57df, \u52a0\u8f7d\u6d41\u56fe\u7247, \u6307\u5b9a\u533a\u4f4d\u7f6e\u53ca\u5927\u5c0f\n// pBuffer: \u56fe\u7247\u7f13\u51b2\u533a\n// nSize: \u56fe\u7247\u7f13\u51b2\u533a\u5927\u5c0f\n// x: \u5750\u6807.\n// y: \u5750\u6807.\n// cx: \u5bbd\u5ea6.\n// cy: \u9ad8\u5ea6.\n// bStretch: \u662f\u5426\u62c9\u4f38\u56fe\u7247\nfunc XImage_LoadMemoryRect(pBuffer int, nSize int, x int, y int, cx int, cy int, bStretch bool) int {\n\tr, _, _ := xImage_LoadMemoryRect.Call(uintptr(pBuffer), uintptr(nSize), uintptr(x), uintptr(y), uintptr(cx), uintptr(cy), boolPtr(bStretch))\n\treturn int(r)\n}", "id": 15205, "concepts": ["XImage_LoadMemoryRect", "function definition", "function call", "function pointer", "function argument", "function return value", "function return value type", "function return value conversion", "function return value pointer", "function return value pointer conversion", "function return value pointer type", "function return value pointer type conversion", "function return value pointer type conversion", "function return value pointer type conversion", "function return value pointer type conversion", "function return value pointer type conversion", "function return value pointer type conversion", "function return value pointer type conversion", "function return value pointer type conversion", "function return value pointer type conversion", "function return value pointer type conversion", "function return value pointer type conversion", "function return value pointer type conversion", "function return value pointer type conversion", "function return value pointer type conversion", "function return value pointer type conversion", "function return value pointer type conversion", "function return value pointer type conversion", "function return value pointer type conversion", "function return value pointer type conversion", "function return value pointer type conversion", "function return value pointer type conversion", "function return value pointer type conversion", "function return value pointer type conversion", "function return value pointer type conversion", "function return value pointer type conversion", "function return value pointer type conversion", "function return value pointer type conversion", "function return value pointer type conversion", "function return value pointer type conversion", "function return"], "_raw_llm_output": "XImage_LoadMemoryRect, function definition, function call, function pointer, function argument, function return value, function return value type, function return value conversion, function return value pointer, function return value pointer conversion, function return value pointer type, function return value pointer type conversion, function return value pointer type conversion, function return value pointer type conversion, function return value pointer type conversion, function return value pointer type conversion, function return value pointer type conversion, function return value pointer type conversion, function return value pointer type conversion, function return value pointer type conversion, function return value pointer type conversion, function return value pointer type conversion, function return value pointer type conversion, function return value pointer type conversion, function return value pointer type conversion, function return value pointer type conversion, function return value pointer type conversion, function return value pointer type conversion, function return value pointer type conversion, function return value pointer type conversion, function return value pointer type conversion, function return value pointer type conversion, function return value pointer type conversion, function return value pointer type conversion, function return value pointer type conversion, function return value pointer type conversion, function return value pointer type conversion, function return value pointer type conversion, function return value pointer type conversion, function return value pointer type conversion, function return"}
{"seed": "// Hgroup represents the HTML element 'hgroup'.\n// For more information visit https://www.w3schools.com/tags/tag_hgroup.asp.\nfunc Hgroup(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"hgroup\", Attributes: attrs, Children: children}\n}", "id": 15206, "concepts": ["HTML generation", "HTML element definition", "HTML attribute definition", "HTML element child definition"], "_raw_llm_output": "HTML generation, HTML element definition, HTML attribute definition, HTML element child definition"}
{"seed": "// ParseCreateSnapshotResponse parses an HTTP response from a CreateSnapshotWithResponse call\nfunc ParseCreateSnapshotResponse(rsp *http.Response) (*CreateSnapshotResponse, error) {\n\tbodyBytes, err := ioutil.ReadAll(rsp.Body)\n\tdefer rsp.Body.Close()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse := &CreateSnapshotResponse{\n\t\tBody:         bodyBytes,\n\t\tHTTPResponse: rsp,\n\t}\n\n\tswitch {\n\tcase strings.Contains(rsp.Header.Get(\"Content-Type\"), \"json\") && rsp.StatusCode == 200:\n\t\tvar dest Operation\n\t\tif err := json.Unmarshal(bodyBytes, &dest); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresponse.JSON200 = &dest\n\n\t}\n\n\treturn response, nil\n}", "id": 15215, "concepts": ["HTTP response parsing", "JSON parsing", "string manipulation", "HTTP request/response handling"], "_raw_llm_output": "HTTP response parsing, JSON parsing, string manipulation, HTTP request/response handling"}
{"seed": "// Create creates an new wallet, writing it to an empty database.  If the passed\n// seed is non-nil, it is used.  Otherwise, a secure random seed of the\n// recommended length is generated.\nfunc Create(db walletdb.DB, pubPass, privPass []byte, seedInput []byte,\n\tseedx *seedwords.Seed, params *chaincfg.Params) er.R {\n\n\t// If a seed was provided, ensure that it is of valid length. Otherwise,\n\t// we generate a random seed for the wallet with the recommended seed\n\t// length.\n\tvar legacySeed []byte\n\tif seedx != nil {\n\t} else if seedbin, err := hex.DecodeString(string(seedInput)); err == nil {\n\t\t// it's a legacy seed, we need to just support it\n\t\tif len(seedbin) < hdkeychain.MinSeedBytes ||\n\t\t\tlen(seedbin) > hdkeychain.MaxSeedBytes {\n\t\t\treturn hdkeychain.ErrInvalidSeedLen.Default()\n\t\t}\n\t\tlegacySeed = seedbin\n\t} else {\n\t\treturn er.New(\"No seed provided\")\n\t}\n\n\tvar birthday time.Time\n\tif seedx != nil {\n\t\tbirthday = seedx.Birthday()\n\t} else {\n\t\t// If we don't know the bday, put it before all of this began\n\t\tbirthday = time.Unix(1231006505, 0)\n\t}\n\n\treturn walletdb.Update(db, func(tx walletdb.ReadWriteTx) er.R {\n\t\taddrmgrNs, err := tx.CreateTopLevelBucket(waddrmgrNamespaceKey)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttxmgrNs, err := tx.CreateTopLevelBucket(wtxmgrNamespaceKey)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\terr = waddrmgr.Create(\n\t\t\taddrmgrNs, legacySeed, seedx, pubPass, privPass, params, nil,\n\t\t\tbirthday,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn wtxmgr.Create(txmgrNs)\n\t})\n}", "id": 15219, "concepts": ["error handling (idiomatic)", "time handling", "walletdb usage", "waddrmgr usage", "wtxmgr usage", "walletdb.Update", "waddrmgr.Create", "wtxmgr.Create", "walletdb.ReadWriteTx", "waddrmgr.NamespaceKey", "wtxmgr.NamespaceKey", "walletdb.CreateTopLevelBucket", "waddrmgr.Create", "wtxmgr.Create", "walletdb.Update", "waddrmgr.Create", "wtxmgr.Create", "walletdb.ReadWriteTx", "waddrmgr.NamespaceKey", "wtxmgr.NamespaceKey", "walletdb.CreateTopLevelBucket", "waddrmgr.Create", "wtxmgr.Create", "walletdb.Update", "waddrmgr.Create", "wtxmgr.Create", "walletdb.ReadWriteTx", "waddrmgr.NamespaceKey", "wtxmgr.NamespaceKey", "walletdb.CreateTopLevelBucket", "waddrmgr.Create", "wtxmgr.Create", "walletdb.Update", "waddrmgr.Create", "wtxmgr.Create", "walletdb.ReadWriteTx", "waddrmgr.NamespaceKey", "wtxmgr.NamespaceKey", "walletdb.CreateTopLevelBucket", "waddrmgr.Create", ""], "_raw_llm_output": "error handling (idiomatic), time handling, walletdb usage, waddrmgr usage, wtxmgr usage, walletdb.Update, waddrmgr.Create, wtxmgr.Create, walletdb.ReadWriteTx, waddrmgr.NamespaceKey, wtxmgr.NamespaceKey, walletdb.CreateTopLevelBucket, waddrmgr.Create, wtxmgr.Create, walletdb.Update, waddrmgr.Create, wtxmgr.Create, walletdb.ReadWriteTx, waddrmgr.NamespaceKey, wtxmgr.NamespaceKey, walletdb.CreateTopLevelBucket, waddrmgr.Create, wtxmgr.Create, walletdb.Update, waddrmgr.Create, wtxmgr.Create, walletdb.ReadWriteTx, waddrmgr.NamespaceKey, wtxmgr.NamespaceKey, walletdb.CreateTopLevelBucket, waddrmgr.Create, wtxmgr.Create, walletdb.Update, waddrmgr.Create, wtxmgr.Create, walletdb.ReadWriteTx, waddrmgr.NamespaceKey, wtxmgr.NamespaceKey, walletdb.CreateTopLevelBucket, waddrmgr.Create,"}
{"seed": "// castCVariantKey convert C variantkey_t to GO TVariantKey.\nfunc castCVariantKey(vk C.variantkey_t) TVariantKey {\n\treturn TVariantKey{\n\t\tChrom:  uint8(vk.chrom),\n\t\tPos:    uint32(vk.pos),\n\t\tRefAlt: uint32(vk.refalt),\n\t}\n}", "id": 15236, "concepts": ["C.uint8_t", "C.uint32_t", "C.variantkey_t", "C.variantkey_t.chrom", "C.variantkey_t.pos", "C.variantkey_t.refalt", "C.variantkey_t.refalt"], "_raw_llm_output": "C.uint8_t, C.uint32_t, C.variantkey_t, C.variantkey_t.chrom, C.variantkey_t.pos, C.variantkey_t.refalt, C.variantkey_t.refalt"}
{"seed": "// FromClientPaymentDetails converts Client PaymentDetails to PaymentDetails\nfunc FromClientPaymentDetails(cdetails []*documentpb.PaymentDetails) ([]*PaymentDetails, error) {\n\tvar details []*PaymentDetails\n\tfor _, detail := range cdetails {\n\t\tdecs, err := StringsToDecimals(detail.Amount)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tdids, err := identity.StringsToDIDs(detail.Payee, detail.Payer)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tdetails = append(details, &PaymentDetails{\n\t\t\tID:                    detail.Id,\n\t\t\tDateExecuted:          detail.DateExecuted,\n\t\t\tPayee:                 dids[0],\n\t\t\tPayer:                 dids[1],\n\t\t\tAmount:                decs[0],\n\t\t\tCurrency:              detail.Currency,\n\t\t\tReference:             detail.Reference,\n\t\t\tBankName:              detail.BankName,\n\t\t\tBankAddress:           detail.BankAddress,\n\t\t\tBankAccountCurrency:   detail.BankAccountCurrency,\n\t\t\tBankAccountHolderName: detail.BankAccountHolderName,\n\t\t\tBankAccountNumber:     detail.BankAccountNumber,\n\t\t\tBankCountry:           detail.BankCountry,\n\t\t\tBankKey:               detail.BankKey,\n\t\t\tCryptoChainURI:        detail.CryptoChainUri,\n\t\t\tCryptoFrom:            detail.CryptoFrom,\n\t\t\tCryptoTo:              detail.CryptoTo,\n\t\t\tCryptoTransactionID:   detail.CryptoTransactionId,\n\t\t})\n\t}\n\n\treturn details, nil\n}", "id": 15242, "concepts": ["conversion", "string to integer conversion", "string to decimal conversion", "string to DID conversion", "struct definition", "function definition"], "_raw_llm_output": "conversion, string to integer conversion, string to decimal conversion, string to DID conversion, struct definition, function definition"}
{"seed": "// DefaultNamespace is a transform that sets a specified namespace for predicates and values that doesn't have a namespace.\nfunc DefaultNamespace(ns string) Transformer {\n\treturn TransformFunc(func(n nodes.Node) (nodes.Node, bool, error) {\n\t\tobj, ok := n.(nodes.Object)\n\t\tif !ok {\n\t\t\treturn n, false, nil\n\t\t}\n\t\ttp, ok := obj[uast.KeyType].(nodes.String)\n\t\tif !ok {\n\t\t\treturn n, false, nil\n\t\t}\n\t\tif strings.Contains(string(tp), \":\") {\n\t\t\treturn n, false, nil\n\t\t}\n\t\tobj = obj.CloneObject()\n\t\tobj[uast.KeyType] = nodes.String(ns + \":\" + string(tp))\n\t\treturn obj, true, nil\n\t})\n}", "id": 15246, "concepts": ["type assertion", "interface assertion", "string manipulation", "map iteration", "map cloning", "string concatenation", "string comparison", "type assertion", "type casting", "type conversion", "type checking", "type comparison", "type definition", "type definition (anonymous)", "type definition (named)", "type definition (struct)", "type definition (struct field)", "type definition (struct field type)", "type definition (struct field type) (anonymous)", "type definition (struct field type) (named)", "type definition (struct field type) (pointer)", "type definition (struct field type) (slice)", "type definition (struct field type) (slice element type)", "type definition (struct field type) (slice element type) (anonymous)", "type definition (struct field type) (slice element type) (named)", "type definition (struct field type) (slice element type) (pointer)", "type definition (struct field type) (slice element type) (slice element type)", "type definition (struct field type) (slice element type) (slice element type) (anonymous)", "type definition (struct field type) (slice element type) (slice element type) (named)", "type definition (struct field type) (slice element type) (slice element type) (pointer)", "type definition (struct field type) (slice element type) ("], "_raw_llm_output": "type assertion, interface assertion, string manipulation, map iteration, map cloning, string concatenation, string comparison, type assertion, type casting, type conversion, type checking, type comparison, type definition, type definition (anonymous), type definition (named), type definition (struct), type definition (struct field), type definition (struct field type), type definition (struct field type) (anonymous), type definition (struct field type) (named), type definition (struct field type) (pointer), type definition (struct field type) (slice), type definition (struct field type) (slice element type), type definition (struct field type) (slice element type) (anonymous), type definition (struct field type) (slice element type) (named), type definition (struct field type) (slice element type) (pointer), type definition (struct field type) (slice element type) (slice element type), type definition (struct field type) (slice element type) (slice element type) (anonymous), type definition (struct field type) (slice element type) (slice element type) (named), type definition (struct field type) (slice element type) (slice element type) (pointer), type definition (struct field type) (slice element type) ("}
{"seed": "// WithCustomClient used in NewClient function. It allows use custom http.Client for method calls.\nfunc WithCustomClient(client *http.Client) clientOption {\n\treturn func(c *Client) {\n\t\tc.client = client\n\t}\n}", "id": 15248, "concepts": ["function composition", "function options", "http.Client usage"], "_raw_llm_output": "function composition, function options, http.Client usage"}
{"seed": "// NewAlertGetMonitorGroupAlertsParamsWithTimeout creates a new AlertGetMonitorGroupAlertsParams object\n// with the default values initialized, and the ability to set a timeout on a request\nfunc NewAlertGetMonitorGroupAlertsParamsWithTimeout(timeout time.Duration) *AlertGetMonitorGroupAlertsParams {\n\tvar (\n\t\tincludeRemindersDefault = bool(false)\n\t\tpresetPeriodDefault     = string(\"Last24Hours\")\n\t\tsortingDefault          = string(\"Descending\")\n\t\ttakeDefault             = int32(100)\n\t)\n\treturn &AlertGetMonitorGroupAlertsParams{\n\t\tIncludeReminders: &includeRemindersDefault,\n\t\tPresetPeriod:     &presetPeriodDefault,\n\t\tSorting:          &sortingDefault,\n\t\tTake:             &takeDefault,\n\n\t\ttimeout: timeout,\n\t}\n}", "id": 15262, "concepts": ["default values", "pointer types", "struct definition", "struct initialization", "struct field access", "timeout handling"], "_raw_llm_output": "default values, pointer types, struct definition, struct initialization, struct field access, timeout handling"}
{"seed": "// FileDescriptorSet returns a descriptor set for this proto package, which\n// includes all defined services, and all transitive dependencies.\n//\n// Will not return nil.\n//\n// Do NOT modify the returned descriptor.\nfunc FileDescriptorSet() *descriptor.FileDescriptorSet {\n\t// We just need ONE of the service names to look up the FileDescriptorSet.\n\tret, err := discovery.GetDescriptorSet(\"gerrit.Gerrit\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn ret\n}", "id": 15268, "concepts": ["descriptor.FileDescriptorSet", "standard library usage"], "_raw_llm_output": "descriptor.FileDescriptorSet, standard library usage"}
{"seed": "// NewValidateCreateServiceRequestNamingParamsWithHTTPClient creates a new ValidateCreateServiceRequestNamingParams object\n// with the default values initialized, and the ability to set a custom HTTPClient for a request\nfunc NewValidateCreateServiceRequestNamingParamsWithHTTPClient(client *http.Client) *ValidateCreateServiceRequestNamingParams {\n\tvar ()\n\treturn &ValidateCreateServiceRequestNamingParams{\n\t\tHTTPClient: client,\n\t}\n}", "id": 15271, "concepts": ["http.Client", "http.NewRequest", "http.Request", "http.Response", "http.Do", "http.Request.Body", "http.Request.ContentLength", "http.Request.Header", "http.Request.Method", "http.Request.URL", "http.Response.Body", "http.Response.ContentLength", "http.Response.Header", "http.Response.StatusCode", "http.Response.Status", "http.Response.Trailer", "http.Response.TransferEncoding", "http.Response.Uncompressed", "http.Response.Close", "http.Response.Request", "http.Response.TLS", "http.Response.Request.URL", "http.Response.Request.Method", "http.Response.Request.Proto", "http.Response.Request.ProtoMajor", "http.Response.Request.ProtoMinor", "http.Response.Request.Header", "http.Response.Request.ContentLength", "http.Response.Request.TransferEncoding", "http.Response.Request.Close", "http.Response.Request.Host", "http.Response.Request.Form", "http.Response.Request.PostForm", "http.Response.Request.MultipartForm", "http.Response.Request.Trailer", "http.Response.Request.RemoteAddr", "http.Response.Request."], "_raw_llm_output": "http.Client, http.NewRequest, http.Request, http.Response, http.Do, http.Request.Body, http.Request.ContentLength, http.Request.Header, http.Request.Method, http.Request.URL, http.Response.Body, http.Response.ContentLength, http.Response.Header, http.Response.StatusCode, http.Response.Status, http.Response.Trailer, http.Response.TransferEncoding, http.Response.Uncompressed, http.Response.Close, http.Response.Request, http.Response.TLS, http.Response.Request.URL, http.Response.Request.Method, http.Response.Request.Proto, http.Response.Request.ProtoMajor, http.Response.Request.ProtoMinor, http.Response.Request.Header, http.Response.Request.ContentLength, http.Response.Request.TransferEncoding, http.Response.Request.Close, http.Response.Request.Host, http.Response.Request.Form, http.Response.Request.PostForm, http.Response.Request.MultipartForm, http.Response.Request.Trailer, http.Response.Request.RemoteAddr, http.Response.Request."}
{"seed": "// RiskDetailPAdminConfirmedSigninSafe returns a pointer to RiskDetailVAdminConfirmedSigninSafe\nfunc RiskDetailPAdminConfirmedSigninSafe() *RiskDetail {\n\tv := RiskDetailVAdminConfirmedSigninSafe\n\treturn &v\n}", "id": 15272, "concepts": ["pointer", "struct", "pointer dereference"], "_raw_llm_output": "pointer, struct, pointer dereference"}
{"seed": "//\n// AssetDir returns the file names below a certain\n// directory embedded in the file by go-bindata.\n// For example if you run go-bindata on data/... and data contains the\n// following hierarchy:\n//     data/\n//       foo.txt\n//       img/\n//         a.png\n//         b.png\n// then AssetDir(\"data\") would return []string{\"foo.txt\", \"img\"}\n// AssetDir(\"data/img\") would return []string{\"a.png\", \"b.png\"}\n// AssetDir(\"foo.txt\") and AssetDir(\"notexist\") would return an error\n// AssetDir(\"\") will return []string{\"data\"}.\n//\nfunc AssetDir(name string) ([]string, error) {\n\tnode := _bintree\n\tif len(name) != 0 {\n\t\tcannonicalName := strings.Replace(name, \"\\\\\", \"/\", -1)\n\t\tpathList := strings.Split(cannonicalName, \"/\")\n\t\tfor _, p := range pathList {\n\t\t\tnode = node.Children[p]\n\t\t\tif node == nil {\n\t\t\t\treturn nil, &os.PathError{\n\t\t\t\t\tOp: \"open\",\n\t\t\t\t\tPath: name,\n\t\t\t\t\tErr: os.ErrNotExist,\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif node.Func != nil {\n\t\treturn nil, &os.PathError{\n\t\t\tOp: \"open\",\n\t\t\tPath: name,\n\t\t\tErr: os.ErrNotExist,\n\t\t}\n\t}\n\trv := make([]string, 0, len(node.Children))\n\tfor childName := range node.Children {\n\t\trv = append(rv, childName)\n\t}\n\treturn rv, nil\n}", "id": 15290, "concepts": ["os package usage", "map iteration", "string manipulation", "string splitting"], "_raw_llm_output": "os package usage, map iteration, string manipulation, string splitting"}
{"seed": "// CreateDescribeDgDatabasesResponse creates a response to parse from DescribeDgDatabases response\nfunc CreateDescribeDgDatabasesResponse() (response *DescribeDgDatabasesResponse) {\n\tresponse = &DescribeDgDatabasesResponse{\n\t\tBaseResponse: &responses.BaseResponse{},\n\t}\n\treturn\n}", "id": 15311, "concepts": ["struct definition", "pointer usage", "struct field access"], "_raw_llm_output": "struct definition, pointer usage, struct field access"}
{"seed": "// Total returns the total possible number of grains that can exist on a chessboard (with 64 squares)\nfunc Total() uint64 {\n\treturn math.MaxUint64\n}", "id": 15320, "concepts": ["math package usage", "math.MaxUint64"], "_raw_llm_output": "math package usage, math.MaxUint64"}
{"seed": "// IsArray returns true if the given Value is a slice or array.\nfunc IsArray(val Value) bool {\n\tr := reflect.Indirect(reflect.ValueOf(val))\n\tswitch r.Kind() {\n\tcase reflect.Slice, reflect.Array:\n\t\treturn true\n\t}\n\treturn false\n}", "id": 15325, "concepts": ["reflect package usage", "reflect.Kind", "reflect.Indirect"], "_raw_llm_output": "reflect package usage, reflect.Kind, reflect.Indirect"}
{"seed": "// PossibleEnabledStateValues returns an array of possible values for the EnabledState const type.\nfunc PossibleEnabledStateValues() []EnabledState {\n\treturn []EnabledState{EnabledStateDisabled, EnabledStateEnabled}\n}", "id": 15370, "concepts": ["type definition", "type conversion", "const definition"], "_raw_llm_output": "type definition, type conversion, const definition"}
{"seed": "// PossibleIotHubDataFormatValues returns an array of possible values for the IotHubDataFormat const type.\nfunc PossibleIotHubDataFormatValues() []IotHubDataFormat {\n\treturn []IotHubDataFormat{IotHubDataFormatAPACHEAVRO, IotHubDataFormatAVRO, IotHubDataFormatCSV, IotHubDataFormatJSON, IotHubDataFormatMULTIJSON, IotHubDataFormatORC, IotHubDataFormatPARQUET, IotHubDataFormatPSV, IotHubDataFormatRAW, IotHubDataFormatSCSV, IotHubDataFormatSINGLEJSON, IotHubDataFormatSOHSV, IotHubDataFormatTSV, IotHubDataFormatTSVE, IotHubDataFormatTXT, IotHubDataFormatW3CLOGFILE}\n}", "id": 15389, "concepts": ["enum", "iota", "type definition", "array", "constant definition"], "_raw_llm_output": "enum, iota, type definition, array, constant definition"}
{"seed": "// CreateRequestScheduleFromDiscriminatorValue creates a new instance of the appropriate class based on discriminator value\nfunc CreateRequestScheduleFromDiscriminatorValue(parseNode i878a80d2330e89d26896388a3f487eef27b0a0e6c010c493bf80be1452208f91.ParseNode)(i878a80d2330e89d26896388a3f487eef27b0a0e6c010c493bf80be1452208f91.Parsable, error) {\n    return NewRequestSchedule(), nil\n}", "id": 15390, "concepts": ["interface implementation", "struct definition", "basic function definition"], "_raw_llm_output": "interface implementation, struct definition, basic function definition"}
{"seed": "// MapOptional returns fct(value) if a value is set, otherwise it returns NewNoneOptional[T2]().\nfunc MapOptional[T1 any, T2 any](optional Optional[T1], fct func(T1) T2) Optional[T2] {\n\tvalue, ok := optional.Get()\n\tif !ok {\n\t\treturn NewNoneOptional[T2]()\n\t}\n\treturn NewOptional(fct(value))\n}", "id": 15412, "concepts": ["optional type", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", ""], "_raw_llm_output": "optional type, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition,"}
{"seed": "// initExcludedTests provides list of excluded tests for e2e and exanples tests\nfunc initExcludedTests() sets.String {\n\n\tswitch getTestArch() {\n\tcase \"s390x\":\n\t\treturn sets.NewString(\n\t\t\t// examples\n\t\t\t\"TestExamples/v1alpha1/taskruns/gcs-resource\",\n\t\t\t\"TestExamples/v1beta1/taskruns/gcs-resource\",\n\t\t)\n\tcase \"ppc64le\":\n\t\treturn sets.NewString(\n\t\t\t// examples\n\t\t\t\"TestExamples/v1alpha1/taskruns/gcs-resource\",\n\t\t\t\"TestExamples/v1beta1/taskruns/gcs-resource\",\n\t\t\t\"TestExamples/v1beta1/pipelineruns/pipelinerun\",\n\t\t\t\"TestYamls/yamls/v1beta1/pipelineruns/pipelinerun.yaml\",\n\t\t)\n\t}\n\n\treturn sets.NewString()\n}", "id": 15413, "concepts": ["string manipulation", "string comparison", "string concatenation", "string manipulation", "string manipulation", "string manipulation"], "_raw_llm_output": "string manipulation, string comparison, string concatenation, string manipulation, string manipulation, string manipulation"}
{"seed": "// Returns a map from strings to *drive.Files that represents all existing\n// files in Google Drive at the folder identified by 'path'. If 'recursive' is\n// true, directories under the given path are processed recursively.\n// 'includeBase' indicates whether the *drive.File for the given path should\n// be included in the result, and 'mustExist' indicates whether an error\n// should be returned if the given path doesn't exist on Drive.\nfunc getFilesAtRemotePath(path string, recursive, includeBase,\n\tmustExist bool) map[string]*drive.File {\n\texistingFiles := make(map[string]*drive.File)\n\tfile, err := getDriveFile(path)\n\tif err != nil {\n\t\tif !mustExist {\n\t\t\treturn existingFiles\n\t\t}\n\t\tprintErrorAndExit(fmt.Errorf(\"skicka: %v\\n\", err))\n\t}\n\n\tif isFolder(file) {\n\t\terr := getFolderContents(path, file, recursive, existingFiles)\n\t\tif err != nil {\n\t\t\tprintErrorAndExit(fmt.Errorf(\"skicka: %v\\n\", err))\n\t\t}\n\t\tif includeBase {\n\t\t\texistingFiles[path] = file\n\t\t}\n\t} else {\n\t\texistingFiles[path] = file\n\t}\n\ttimeDelta(\"Get file descriptors from Google Drive\")\n\treturn existingFiles\n}", "id": 15432, "concepts": ["map iteration (range loop)", "map creation", "map lookup", "map update", "function definition", "function return", "function call", "function parameter", "function parameter type", "function parameter default value", "function parameter variadic", "function parameter named return value", "function parameter named return value type", "function parameter named return value default value", "function parameter named return value type default value", "function parameter named return value type default value", "function parameter named return value type default value", "function parameter named return value type default value", "function parameter named return value type default value", "function parameter named return value type default value", "function parameter named return value type default value", "function parameter named return value type default value", "function parameter named return value type default value", "function parameter named return value type default value", "function parameter named return value type default value", "function parameter named return value type default value", "function parameter named return value type default value", "function parameter named return value type default value", "function parameter named return value type default value", "function parameter named return value type default value", "function parameter named return value type default value", "function parameter named return value type default value", "function parameter named return value type default value", "function parameter named return value type default value", "function parameter named return value type default value", "function parameter named return"], "_raw_llm_output": "map iteration (range loop), map creation, map lookup, map update, function definition, function return, function call, function parameter, function parameter type, function parameter default value, function parameter variadic, function parameter named return value, function parameter named return value type, function parameter named return value default value, function parameter named return value type default value, function parameter named return value type default value, function parameter named return value type default value, function parameter named return value type default value, function parameter named return value type default value, function parameter named return value type default value, function parameter named return value type default value, function parameter named return value type default value, function parameter named return value type default value, function parameter named return value type default value, function parameter named return value type default value, function parameter named return value type default value, function parameter named return value type default value, function parameter named return value type default value, function parameter named return value type default value, function parameter named return value type default value, function parameter named return value type default value, function parameter named return value type default value, function parameter named return value type default value, function parameter named return value type default value, function parameter named return value type default value, function parameter named return"}
{"seed": "// Env reads specified environment variable. If no value has been found,\n// fallback is returned.\nfunc env(key string, fallback string) string {\n\tif v := os.Getenv(key); v != \"\" {\n\t\treturn v\n\t}\n\treturn fallback\n}", "id": 15435, "concepts": ["os.Getenv", "environment variable handling"], "_raw_llm_output": "os.Getenv, environment variable handling"}
{"seed": "// GetOption gets an the value for an option. The value can be, in descending order\n// of preference:\n// - provided as a command-line option\n//\n// - provided as an environment variable\n//\n// - the default value\n//\nfunc GetOption(optflag *string, envvarname string, defaultvalue string) string {\n\tparseflags()\n\n\tresult := *optflag\n\n\tif result == \"\" || result == defaultvalue {\n\t\tresult = os.Getenv(envvarname)\n\t}\n\n\tif result == \"\" {\n\t\tresult = defaultvalue\n\t}\n\n\treturn result\n}", "id": 15442, "concepts": ["command-line option parsing", "environment variable handling", "default value handling"], "_raw_llm_output": "command-line option parsing, environment variable handling, default value handling"}
{"seed": "// CreatedAtLTE applies the LTE predicate on the \"created_at\" field.\nfunc CreatedAtLTE(v time.Time) predicate.User {\n\treturn predicate.User(sql.FieldLTE(FieldCreatedAt, v))\n}", "id": 15444, "concepts": ["sql package usage", "time package usage", "predicate.User", "sql.FieldLTE"], "_raw_llm_output": "sql package usage, time package usage, predicate.User, sql.FieldLTE"}
{"seed": "// NewCreatePrivateNetworkRequestWithBody generates requests for CreatePrivateNetwork with any type of body\nfunc NewCreatePrivateNetworkRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {\n\tvar err error\n\n\tqueryUrl, err := url.Parse(server)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbasePath := fmt.Sprintf(\"/private-network\")\n\tif basePath[0] == '/' {\n\t\tbasePath = basePath[1:]\n\t}\n\n\tqueryUrl, err = queryUrl.Parse(basePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq, err := http.NewRequest(\"POST\", queryUrl.String(), body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Add(\"Content-Type\", contentType)\n\treturn req, nil\n}", "id": 15468, "concepts": ["http request generation", "url parsing", "url.Parse", "url.URL", "url.ParseRequestURI", "url.Request", "url.RequestURI", "url.Values", "url.RawQuery", "url.RawPath", "url.Path", "url.EscapedPath", "url.RawQuery", "url.Fragment", "url.RawFragment", "url.User", "url.Host", "url.Scheme", "url.Opaque", "url.Path", "url.RawPath", "url.ForceQuery", "url.RawQuery", "url.RawPath", "url.String", "url.RequestURI", "url.Query", "url.Fragment", "url.RawQuery", "url.RawPath", "url.Path", "url.RawPath", "url.EscapedPath", "url.RawQuery", "url.Fragment", "url.RawQuery", "url.RawPath", "url.Path", "url.RawPath", "url.EscapedPath", "url.RawQuery", "url.Fragment", "url.RawQuery", "url.RawPath", "url.Path", "url.RawPath", "url.EscapedPath", "url.RawQuery", "url.Fragment", "url.RawQuery", "url.RawPath", "url.Path", "url.RawPath", "url.EscapedPath", "url.Raw"], "_raw_llm_output": "http request generation, url parsing, url.Parse, url.URL, url.ParseRequestURI, url.Request, url.RequestURI, url.Values, url.RawQuery, url.RawPath, url.Path, url.EscapedPath, url.RawQuery, url.Fragment, url.RawFragment, url.User, url.Host, url.Scheme, url.Opaque, url.Path, url.RawPath, url.ForceQuery, url.RawQuery, url.RawPath, url.String, url.RequestURI, url.Query, url.Fragment, url.RawQuery, url.RawPath, url.Path, url.RawPath, url.EscapedPath, url.RawQuery, url.Fragment, url.RawQuery, url.RawPath, url.Path, url.RawPath, url.EscapedPath, url.RawQuery, url.Fragment, url.RawQuery, url.RawPath, url.Path, url.RawPath, url.EscapedPath, url.RawQuery, url.Fragment, url.RawQuery, url.RawPath, url.Path, url.RawPath, url.EscapedPath, url.Raw"}
{"seed": "// PossibleResourceDeletionPolicyValues returns the possible values for the ResourceDeletionPolicy const type.\nfunc PossibleResourceDeletionPolicyValues() []ResourceDeletionPolicy {\n\treturn []ResourceDeletionPolicy{\n\t\tResourceDeletionPolicyCascadeDeleteAll,\n\t\tResourceDeletionPolicyCascadeDeleteProxyOnlyChildren,\n\t\tResourceDeletionPolicyNotSpecified,\n\t}\n}", "id": 15469, "concepts": ["enum type", "const type", "string formatting", "possible values"], "_raw_llm_output": "enum type, const type, string formatting, possible values"}
{"seed": "// Recover runs the given function, catching any panic thrown by the function\n// and turning it into an error. If the function finishes without panicking,\n// CatchPanic returns nil.\nfunc Recover(cb func()) (err error) {\n\tdefer func() {\n\t\tif e := recover(); e != nil {\n\t\t\terr = errors.E(\"panic %v: %v\", e, string(debug.Stack()))\n\t\t}\n\t}()\n\tcb()\n\treturn nil\n}", "id": 15472, "concepts": ["panic handling", "error handling", "error wrapping", "stack trace"], "_raw_llm_output": "panic handling, error handling, error wrapping, stack trace"}
{"seed": "// NewCreateMigrationInvoiceParamsWithHTTPClient creates a new CreateMigrationInvoiceParams object\n// with the ability to set a custom HTTPClient for a request.\nfunc NewCreateMigrationInvoiceParamsWithHTTPClient(client *http.Client) *CreateMigrationInvoiceParams {\n\treturn &CreateMigrationInvoiceParams{\n\t\tHTTPClient: client,\n\t}\n}", "id": 15478, "concepts": ["function definition", "function parameters", "HTTPClient usage"], "_raw_llm_output": "function definition, function parameters, HTTPClient usage"}
{"seed": "// HttpAdapter wraps an f(io.Writer) function to become an http.HandlerFunc  \n// function, and also sets the correct HTTP header SVG mime type for the browser\nfunc HttpAdapter(f func(w io.Writer)) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"image/svg+xml\")\n\t\tf(w)\n\t}\n}", "id": 15482, "concepts": ["http.HandlerFunc", "io.Writer", "http.ResponseWriter", "standard library usage"], "_raw_llm_output": "http.HandlerFunc, io.Writer, http.ResponseWriter, standard library usage"}
{"seed": "// SocialAvatarURLContainsFold applies the ContainsFold predicate on the \"social_avatar_url\" field.\nfunc SocialAvatarURLContainsFold(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.ContainsFold(s.C(FieldSocialAvatarURL), v))\n\t})\n}", "id": 15484, "concepts": ["sql package usage", "predicate.User", "sql.ContainsFold"], "_raw_llm_output": "sql package usage, predicate.User, sql.ContainsFold"}
{"seed": "// E logs message under tag with priority PriorityError to w.\nfunc E(w Writer, tag Tag, message string) error {\n\treturn w.Write(PriorityError, tag, message)\n}", "id": 15493, "concepts": ["error handling (error return value)", "error wrapping", "error handling (errors.Is)", "error handling (errors.As)", "error handling (errors.New)", "error handling (errors.Unwrap)", "error handling (errors.Errorf)", "error handling (errors.Wrap)", "error handling (errors.Wrapf)", "error handling (errors.WrapWithMessage)", "error handling (errors.WrapWithMessagef)", "error handling (errors.WrapWithCode)", "error handling (errors.WrapWithCodef)", "error handling (errors.WrapWithMessageAndCode)", "error handling (errors.WrapWithMessageAndCodef)", "error handling (errors.Is)", "error handling (errors.As)", "error handling (errors.Unwrap)", "error handling (errors.Errorf)", "error handling (errors.Wrap)", "error handling (errors.Wrapf)", "error handling (errors.WrapWithMessage)", "error handling (errors.WrapWithMessagef)", "error handling (errors.WrapWithCode)", "error handling (errors.WrapWithCodef)", "error handling (errors.WrapWithMessageAndCode)", "error handling (errors.WrapWithMessageAndCodef)", "error handling (errors.Is)", "error handling (errors.As)", "error handling (errors.Unwrap)", "error handling (errors.Errorf"], "_raw_llm_output": "error handling (error return value), error wrapping, error handling (errors.Is), error handling (errors.As), error handling (errors.New), error handling (errors.Unwrap), error handling (errors.Errorf), error handling (errors.Wrap), error handling (errors.Wrapf), error handling (errors.WrapWithMessage), error handling (errors.WrapWithMessagef), error handling (errors.WrapWithCode), error handling (errors.WrapWithCodef), error handling (errors.WrapWithMessageAndCode), error handling (errors.WrapWithMessageAndCodef), error handling (errors.Is), error handling (errors.As), error handling (errors.Unwrap), error handling (errors.Errorf), error handling (errors.Wrap), error handling (errors.Wrapf), error handling (errors.WrapWithMessage), error handling (errors.WrapWithMessagef), error handling (errors.WrapWithCode), error handling (errors.WrapWithCodef), error handling (errors.WrapWithMessageAndCode), error handling (errors.WrapWithMessageAndCodef), error handling (errors.Is), error handling (errors.As), error handling (errors.Unwrap), error handling (errors.Errorf"}
{"seed": "// GetCrossConnectLifecycleStateEnumValues Enumerates the set of values for CrossConnectLifecycleStateEnum\nfunc GetCrossConnectLifecycleStateEnumValues() []CrossConnectLifecycleStateEnum {\n\tvalues := make([]CrossConnectLifecycleStateEnum, 0)\n\tfor _, v := range mappingCrossConnectLifecycleStateEnum {\n\t\tvalues = append(values, v)\n\t}\n\treturn values\n}", "id": 15546, "concepts": ["enumerations", "mapping", "basic function definition"], "_raw_llm_output": "enumerations, mapping, basic function definition"}
{"seed": "// PropValWindow transforms a GetPropertyReply struct into an X resource\n// window identifier.\n// The property reply must be in 32 bit format.\nfunc PropValWindow(reply *xproto.GetPropertyReply,\n\terr error) (xproto.Window, error) {\n\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif reply.Format != 32 {\n\t\treturn 0, fmt.Errorf(\"PropValId: Expected format 32 but got %d\",\n\t\t\treply.Format)\n\t}\n\treturn xproto.Window(xgb.Get32(reply.Value)), nil\n}", "id": 15549, "concepts": ["xproto package usage", "xproto.Window type", "xproto.GetPropertyReply type", "xproto.Window type", "xproto.Window type", "xproto.Window type", "xproto.Window type", "xproto.Window type", "xproto.Window type", "xproto.Window type", "xproto.Window type", "xproto.Window type", "xproto.Window type", "xproto.Window type", "xproto.Window type", "xproto.Window type", "xproto.Window type", "xproto.Window type", "xproto.Window type", "xproto.Window type", "xproto.Window type", "xproto.Window type", "xproto.Window type", "xproto.Window type", "xproto.Window type", "xproto.Window type", "xproto.Window type", "xproto.Window type", "xproto.Window type", "xproto.Window type", "xproto.Window type", "xproto.Window type", "xproto.Window type", "xproto.Window type", "xproto.Window type", "xproto.Window type", "xproto.Window type", "xproto.Window type", "xproto.Window type", "xproto.Window type", "xproto"], "_raw_llm_output": "xproto package usage, xproto.Window type, xproto.GetPropertyReply type,\nxproto.Window type, xproto.Window type, xproto.Window type,\nxproto.Window type, xproto.Window type, xproto.Window type,\nxproto.Window type, xproto.Window type, xproto.Window type,\nxproto.Window type, xproto.Window type, xproto.Window type,\nxproto.Window type, xproto.Window type, xproto.Window type,\nxproto.Window type, xproto.Window type, xproto.Window type,\nxproto.Window type, xproto.Window type, xproto.Window type,\nxproto.Window type, xproto.Window type, xproto.Window type,\nxproto.Window type, xproto.Window type, xproto.Window type,\nxproto.Window type, xproto.Window type, xproto.Window type,\nxproto.Window type, xproto.Window type, xproto.Window type,\nxproto.Window type, xproto.Window type, xproto.Window type,\nxproto.Window type, xproto"}
{"seed": "// RiskDetailPUserPassedMFADrivenByRiskBasedPolicy returns a pointer to RiskDetailVUserPassedMFADrivenByRiskBasedPolicy\nfunc RiskDetailPUserPassedMFADrivenByRiskBasedPolicy() *RiskDetail {\n\tv := RiskDetailVUserPassedMFADrivenByRiskBasedPolicy\n\treturn &v\n}", "id": 15550, "concepts": ["pointer", "struct", "struct field access"], "_raw_llm_output": "pointer, struct, struct field access"}
{"seed": "// V logs message under tag with priority PriorityVerbose to w.\nfunc V(w Writer, tag Tag, message string) error {\n\treturn w.Write(PriorityVerbose, tag, message)\n}", "id": 15553, "concepts": ["function definition", "function return value", "function argument", "function call", "function call with return value", "function call with multiple return values", "function call with named return values", "function call with named return values and multiple return values", "function call with named return values and multiple return values and error handling", "function call with named return values and multiple return values and error handling and error handling", "function call with named return values and multiple return values and error handling and error handling and error handling", "function call with named return values and multiple return values and error handling and error handling and error handling and error handling", "function call with named return values and multiple return values and error handling and error handling and error handling and error handling and error handling", "function call with named return values and multiple return values and error handling and error handling and error handling and error handling and error handling and error handling", "function call with named return values and multiple return values and error handling and error handling and error handling and error handling and error handling and error handling and error handling", "function call with named return values and multiple return values and error handling and error handling and error handling and error handling and error handling and error handling and error handling and error handling", "function call with named return values and multiple return values and error handling and error"], "_raw_llm_output": "function definition, function return value, function argument, function call, function call with return value, function call with multiple return values, function call with named return values, function call with named return values and multiple return values, function call with named return values and multiple return values and error handling, function call with named return values and multiple return values and error handling and error handling, function call with named return values and multiple return values and error handling and error handling and error handling, function call with named return values and multiple return values and error handling and error handling and error handling and error handling, function call with named return values and multiple return values and error handling and error handling and error handling and error handling and error handling, function call with named return values and multiple return values and error handling and error handling and error handling and error handling and error handling and error handling, function call with named return values and multiple return values and error handling and error handling and error handling and error handling and error handling and error handling and error handling, function call with named return values and multiple return values and error handling and error handling and error handling and error handling and error handling and error handling and error handling and error handling, function call with named return values and multiple return values and error handling and error"}
{"seed": "// BetterHeroScoreLT applies the LT predicate on the \"better_hero_score\" field.\nfunc BetterHeroScoreLT(v int) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.LT(s.C(FieldBetterHeroScore), v))\n\t})\n}", "id": 15557, "concepts": ["sql.Selector", "sql.LT", "sql.C", "sql.Where", "sql.Predicate", "sql.Field", "sql.Selector.Where", "sql.Selector.C", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector"], "_raw_llm_output": "sql.Selector, sql.LT, sql.C, sql.Where, sql.Predicate, sql.Field, sql.Selector.Where, sql.Selector.C, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector"}
{"seed": "// RemoveNonExactMappingReads is a filter that removes all reads that\n// are not exact matches with the reference (soft-clipping ok), based\n// on CIGAR string (only M and S allowed).\nfunc RemoveNonExactMappingReads(_ *sam.Header) sam.AlignmentFilter {\n\treturn func(aln *sam.Alignment) bool { return !strings.ContainsAny(aln.CIGAR, \"IDNHPX=\") }\n}", "id": 15565, "concepts": ["string manipulation", "CIGAR string", "SAM/BAM file format"], "_raw_llm_output": "string manipulation, CIGAR string, SAM/BAM file format"}
{"seed": "// AssetInfo loads and returns the asset info for the given name.\n// It returns an error if the asset could not be found or\n// could not be loaded.\nfunc AssetInfo(name string) (os.FileInfo, error) {\n\tcannonicalName := strings.Replace(name, \"\\\\\", \"/\", -1)\n\tif f, ok := _bindata[cannonicalName]; ok {\n\t\ta, err := f()\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"AssetInfo %s can't read by error: %v\", name, err)\n\t\t}\n\t\treturn a.info, nil\n\t}\n\treturn nil, fmt.Errorf(\"AssetInfo %s not found\", name)\n}", "id": 15566, "concepts": ["bindata usage", "os.FileInfo", "error handling (idiomatic `if err != nil`", "`errors.Is`", "`errors.As`)", "standard library usage"], "_raw_llm_output": "bindata usage, os.FileInfo, error handling (idiomatic `if err != nil`, `errors.Is`, `errors.As`), standard library usage"}
{"seed": "// Noframes_ is a convenience wrapper for Noframes without the attrs argument.\nfunc Noframes_(children ...HTML) HTML {\n  return Noframes(nil, children...)\n}", "id": 15572, "concepts": ["HTML tag definition", "HTML tag attribute definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", ""], "_raw_llm_output": "HTML tag definition, HTML tag attribute definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition,"}
{"seed": "// NewInputLocal creates a system that allows entities to be controlled\n// by the local environment directly.\nfunc NewInputLocal(inputLocalType ecs.ComponentType, positionType ecs.ComponentType) ecs.System {\n\treturn &inputLocal{\n\t\tinputLocalType: inputLocalType,\n\t\tpositionType:   positionType,\n\t}\n}", "id": 15578, "concepts": ["ECS", "component type definition", "system definition"], "_raw_llm_output": "ECS, component type definition, system definition"}
{"seed": "// withCompetenceID sets the ID field of the mutation.\nfunc withCompetenceID(id int) competenceOption {\n\treturn func(m *CompetenceMutation) {\n\t\tvar (\n\t\t\terr   error\n\t\t\tonce  sync.Once\n\t\t\tvalue *Competence\n\t\t)\n\t\tm.oldValue = func(ctx context.Context) (*Competence, error) {\n\t\t\tonce.Do(func() {\n\t\t\t\tif m.done {\n\t\t\t\t\terr = fmt.Errorf(\"querying old values post mutation is not allowed\")\n\t\t\t\t} else {\n\t\t\t\t\tvalue, err = m.Client().Competence.Get(ctx, id)\n\t\t\t\t}\n\t\t\t})\n\t\t\treturn value, err\n\t\t}\n\t\tm.id = &id\n\t}\n}", "id": 15584, "concepts": ["struct", "method", "function", "anonymous function", "concurrency", "sync.Once"], "_raw_llm_output": "struct, method, function, anonymous function, concurrency, sync.Once"}
{"seed": "// Span represents the HTML element 'span'.\n// For more information visit https://www.w3schools.com/tags/tag_span.asp.\nfunc Span(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"span\", Attributes: attrs, Children: children}\n}", "id": 15595, "concepts": ["HTML", "HTML element definition", "HTML attribute definition", "HTML tag definition", "HTML tree definition"], "_raw_llm_output": "HTML, HTML element definition, HTML attribute definition, HTML tag definition, HTML tree definition"}
{"seed": "// H6 represents the HTML element 'h6'.\n// For more information visit https://www.w3schools.com/tags/tag_h6.asp.\nfunc H6(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"h6\", Attributes: attrs, Children: children}\n}", "id": 15597, "concepts": ["HTML", "HTML element definition", "HTML attribute definition", "HTML tag definition", "HTML tree definition"], "_raw_llm_output": "HTML, HTML element definition, HTML attribute definition, HTML tag definition, HTML tree definition"}
{"seed": "// GetOwnerReferencesForSystemRestore returns OwnerReference for the given\n// SystemRestore\nfunc GetOwnerReferencesForSystemRestore(systemRestore *longhorn.SystemRestore) []metav1.OwnerReference {\n\tcontroller := true\n\tblockOwnerDeletion := true\n\treturn []metav1.OwnerReference{\n\t\t{\n\t\t\tAPIVersion:         longhorn.SchemeGroupVersion.String(),\n\t\t\tKind:               types.LonghornKindSystemRestore,\n\t\t\tName:               systemRestore.Name,\n\t\t\tUID:                systemRestore.UID,\n\t\t\tController:         &controller,\n\t\t\tBlockOwnerDeletion: &blockOwnerDeletion,\n\t\t},\n\t}\n}", "id": 15603, "concepts": ["struct", "map", "slice", "function definition", "basic function call"], "_raw_llm_output": "struct, map, slice, function definition, basic function call"}
{"seed": "// Handle returns an option that matches on the provided XML name.\n// If a handler already exists for n when the option is applied, the option\n// panics.\nfunc Handle(n xml.Name, h xmpp.Handler) Option {\n\treturn func(m *ServeMux) {\n\t\tif h == nil {\n\t\t\tpanic(\"mux: nil handler\")\n\t\t}\n\t\tif stanza.Is(n, \"\") {\n\t\t\tpanic(\"mux: tried to register stanza handler with Handle, use HandleIQ, HandleMessage, or HandlePresence instead\")\n\t\t}\n\t\tif _, ok := m.patterns[n]; ok {\n\t\t\tpanic(\"mux: multiple registrations for {\" + n.Space + \"}\" + n.Local)\n\t\t}\n\t\tif m.patterns == nil {\n\t\t\tm.patterns = make(map[xml.Name]xmpp.Handler)\n\t\t}\n\t\tm.patterns[n] = h\n\t}\n}", "id": 15607, "concepts": ["xml package usage", "xml.Name", "map", "function composition", "option pattern"], "_raw_llm_output": "xml package usage, xml.Name, map, function composition, option pattern"}
{"seed": "// qn_time converts <i> to *qn_time.Time.\n// The parameter <format> can be used to specify the format of <i>.\n// If no <format> given, it converts <i> using qn_time.NewFromTimeStamp if <i> is numeric,\n// or using qn_time.StrToTime if <i> is string.\nfunc QNtime(i interface{}, format ...string) *qn_time.Time {\n\tif i == nil {\n\t\treturn nil\n\t}\n\t// It's already this type.\n\tif len(format) == 0 {\n\t\tif v, ok := i.(*qn_time.Time); ok {\n\t\t\treturn v\n\t\t}\n\t}\n\ts := String(i)\n\tif len(s) == 0 {\n\t\treturn qn_time.New()\n\t}\n\t// Priority conversion using given format.\n\tif len(format) > 0 {\n\t\tt, _ := qn_time.StrToTimeFormat(s, format[0])\n\t\treturn t\n\t}\n\tif utils.IsNumeric(s) {\n\t\treturn qn_time.NewFromTimeStamp(Int64(s))\n\t} else {\n\t\tt, _ := qn_time.StrToTime(s)\n\t\treturn t\n\t}\n}", "id": 15608, "concepts": ["string manipulation", "interface conversion", "type assertion", "type switch", "type conversion"], "_raw_llm_output": "string manipulation, interface conversion, type assertion, type switch, type conversion"}
{"seed": "// SocialNameContainsFold applies the ContainsFold predicate on the \"social_name\" field.\nfunc SocialNameContainsFold(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.ContainsFold(s.C(FieldSocialName), v))\n\t})\n}", "id": 15637, "concepts": ["sql.Selector", "sql.ContainsFold", "sql.C", "sql.Where", "sql.Predicate", "sql.Fold"], "_raw_llm_output": "sql.Selector, sql.ContainsFold, sql.C, sql.Where, sql.Predicate, sql.Fold"}
{"seed": "// GzipAsset loads and returns the asset for the given name.\n// It returns an error if the asset could not be found or\n// could not be loaded.\nfunc GzipAsset(name string) ([]byte, error) {\n\tcannonicalName := strings.Replace(name, \"\\\\\", \"/\", -1)\n\tif f, ok := _gzipbindata[cannonicalName]; ok {\n\t\ta, err := f()\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"GzipAsset %s can't read by error: %v\", name, err)\n\t\t}\n\t\treturn a.bytes, nil\n\t}\n\treturn nil, &os.PathError{Op: \"open\", Path: name, Err: os.ErrNotExist}\n}", "id": 15645, "concepts": ["os.PathError", "os.ErrNotExist", "os.Open", "os.Stat", "os.IsNotExist", "os.IsPermission", "os.IsExist", "os.IsPathSeparator", "os.IsPermission", "os.IsNotExist", "os.IsPermission", "os.IsNotExist", "os.IsPermission", "os.IsNotExist", "os.IsPermission", "os.IsNotExist", "os.IsPermission", "os.IsNotExist", "os.IsPermission", "os.IsNotExist", "os.IsPermission", "os.IsNotExist", "os.IsPermission", "os.IsNotExist", "os.IsPermission", "os.IsNotExist", "os.IsPermission", "os.IsNotExist", "os.IsPermission", "os.IsNotExist", "os.IsPermission", "os.IsNotExist", "os.IsPermission", "os.IsNotExist", "os.IsPermission", "os.IsNotExist", "os.IsPermission", "os.IsNotExist", "os.IsPermission", "os.IsNotExist", "os.IsPermission", "os.IsNotExist", "os.IsPermission", "os.IsNotExist", "os.IsPermission", "os.IsNotExist", "os.IsPermission", "os.IsNotExist", "os.IsPermission", "os.IsNotExist", "os.IsPermission", "os"], "_raw_llm_output": "os.PathError, os.ErrNotExist, os.Open, os.Stat, os.IsNotExist, os.IsPermission, os.IsExist, os.IsPathSeparator, os.IsPermission, os.IsNotExist, os.IsPermission, os.IsNotExist, os.IsPermission, os.IsNotExist, os.IsPermission, os.IsNotExist, os.IsPermission, os.IsNotExist, os.IsPermission, os.IsNotExist, os.IsPermission, os.IsNotExist, os.IsPermission, os.IsNotExist, os.IsPermission, os.IsNotExist, os.IsPermission, os.IsNotExist, os.IsPermission, os.IsNotExist, os.IsPermission, os.IsNotExist, os.IsPermission, os.IsNotExist, os.IsPermission, os.IsNotExist, os.IsPermission, os.IsNotExist, os.IsPermission, os.IsNotExist, os.IsPermission, os.IsNotExist, os.IsPermission, os.IsNotExist, os.IsPermission, os.IsNotExist, os.IsPermission, os.IsNotExist, os.IsPermission, os.IsNotExist, os.IsPermission, os"}
{"seed": "// SHA1Base64String hashes data with SHA1 and encodes the result as base64 string.\nfunc SHA1Base64String(data string) string {\n\thash := sha1.Sum([]byte(data))\n\treturn base64.StdEncoding.EncodeToString(hash[:])\n}", "id": 15650, "concepts": ["cryptography", "base64 encoding", "SHA1 hashing", "byte manipulation"], "_raw_llm_output": "cryptography, base64 encoding, SHA1 hashing, byte manipulation"}
{"seed": "// suffixPattern creates a regular expression that matches strings ending with the\n// given pattern.\nfunc suffixPattern(pattern *regexp.Regexp) *regexp.Regexp {\n\treturn regexp.MustCompile(pattern.String() + \"$\")\n}", "id": 15658, "concepts": ["regexp package usage", "regexp.MustCompile", "regexp.Regexp"], "_raw_llm_output": "regexp package usage, regexp.MustCompile, regexp.Regexp"}
{"seed": "// PseudoVersion reports if the current module or any dependencies are using a prerelease semver version\r\n// (exclusive of pseudo-versions, which are also prerelease versions according to semver spec but are reported separately).\r\n// It returns true if so.\r\n// Rule: gomodvet-007\r\nfunc PseudoVersion(verbose bool) (bool, error) {\r\n\tmods, err := buildlist.Resolve()\r\n\tif err != nil {\r\n\t\treturn false, fmt.Errorf(\"pseudoversion: %v\", err)\r\n\t}\r\n\r\n\tflagged := false\r\n\tfor _, mod := range mods {\r\n\t\tif verbose {\r\n\t\t\tfmt.Printf(\"gomodvet: pseudoversion: module %s: %+v\\n\", mod.Path, mod)\r\n\t\t}\r\n\t\tif isPseudoVersion(mod.Version) {\r\n\t\t\tfmt.Printf(\"gomodvet-007: a module is using a pseudoversion version: %s %s\\n\",\r\n\t\t\t\tmod.Path, mod.Version)\r\n\t\t\tflagged = true\r\n\t\t}\r\n\t}\r\n\treturn flagged, nil\r\n}", "id": 15690, "concepts": ["module resolution", "module version handling", "module path handling", "pseudo-version handling"], "_raw_llm_output": "module resolution, module version handling, module path handling, pseudo-version handling"}
{"seed": "// Execute \u6267\u884chttp\u8bf7\u6c42\uff0c\u5e76\u8fd4\u56de\u89e3\u6790\u540e\u7684\u54cd\u5e94\u5185\u5bb9\u5b57\u7b26\u4e32\u548c\u9519\u8bef\u4fe1\u606f\nfunc Execute(req *http.Request) (string, error) {\n\t// \u8bbe\u7f6e\u5168\u5c40\u94fe\u8defID\n\treq.Header.Set(config.Server().TraceHeader, trace.Get())\n\n\tresp, err := app.Http().Do(req)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif resp == nil {\n\t\treturn \"\", errors.New(\"no response\")\n\t}\n\n\t// \u5173\u95edresponse\n\tdefer func() {\n\t\t_ = resp.Body.Close()\n\t}()\n\n\t// \u5224\u65ad\u9a8c\u8bc1\u7801\u662f\u5426\u6b63\u786e\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn \"\", fmt.Errorf(\"response status code is:%d\", resp.StatusCode)\n\t}\n\n\t// \u901a\u8fc7buffer\u6c60\u8bfb\u53d6response\u7684\u5185\u5bb9\uff0c\u907f\u514d\u5982\u56e0io.ReadAll\u7684\u5185\u5b58\u6ea2\u51fa\u95ee\u9898\n\treturn adapter.Read(resp.Body)\n}", "id": 15693, "concepts": ["http.Request", "http.Response", "http.Client", "io.Reader", "io.ReadCloser", "io.ReadSeeker", "io.ReaderAt", "io.Closer", "io.Seeker", "io.Writer", "io.WriterAt", "io.ByteReader", "io.ByteScanner", "io.ByteWriter", "io.RuneReader", "io.RuneScanner", "io.RuneWriter", "io.RuneWriter", "io.StringReader", "io.StringWriter", "io.WriterTo", "io.WriterToReader", "io.Copy", "io.CopyBuffer", "io.CopyN", "io.MultiWriter", "io.MultiWriterAt", "io.MultiReader", "io.LimitReader", "io.SectionReader", "io.TeeReader", "io.NewSectionReader", "io.NewLimitReader", "io.NewMultiReader", "io.NewSectionReader", "io.NewLimitReader", "io.NewMultiReader", "io.NewSectionReader", "io.NewLimitReader", "io.NewMultiReader", "io.NewSectionReader", "io.NewLimitReader", "io.NewMultiReader", "io.NewSectionReader", "io.NewLimitReader", "io.NewMultiReader", "io.NewSectionReader", "io.NewLimitReader", "io"], "_raw_llm_output": "http.Request, http.Response, http.Client, io.Reader, io.ReadCloser, io.ReadSeeker, io.ReaderAt, io.Closer, io.Seeker, io.Writer, io.WriterAt, io.ByteReader, io.ByteScanner, io.ByteWriter, io.RuneReader, io.RuneScanner, io.RuneWriter, io.RuneWriter, io.StringReader, io.StringWriter, io.WriterTo, io.WriterToReader, io.Copy, io.CopyBuffer, io.CopyN, io.MultiWriter, io.MultiWriterAt, io.MultiReader, io.LimitReader, io.SectionReader, io.TeeReader, io.NewSectionReader, io.NewLimitReader, io.NewMultiReader, io.NewSectionReader, io.NewLimitReader, io.NewMultiReader, io.NewSectionReader, io.NewLimitReader, io.NewMultiReader, io.NewSectionReader, io.NewLimitReader, io.NewMultiReader, io.NewSectionReader, io.NewLimitReader, io.NewMultiReader, io.NewSectionReader, io.NewLimitReader, io"}
{"seed": "// SocialTypeGTE applies the GTE predicate on the \"social_type\" field.\nfunc SocialTypeGTE(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.GTE(s.C(FieldSocialType), v))\n\t})\n}", "id": 15709, "concepts": ["sql.Selector", "sql.GTE", "sql.C", "predicate.User"], "_raw_llm_output": "sql.Selector, sql.GTE, sql.C, predicate.User"}
{"seed": "// MakeUser creates User with passed values.\nfunc MakeUser(id int64, username string, fullname string) User {\n\treturn User{ID: id, UserName: username, FullName: fullname}\n}", "id": 15711, "concepts": ["struct definition", "struct field initialization"], "_raw_llm_output": "struct definition, struct field initialization"}
{"seed": "// BoolPointer generates bool pointer from bool\nfunc BoolPointer(b bool) *bool {\n\treturn &b\n}", "id": 15717, "concepts": ["pointer", "bool"], "_raw_llm_output": "pointer, bool"}
{"seed": "// BlobNotIn applies the NotIn predicate on the \"blob\" field.\nfunc BlobNotIn(vs ...[]byte) predicate.User {\n\treturn predicate.User(sql.FieldNotIn(FieldBlob, vs...))\n}", "id": 15718, "concepts": ["sql package usage", "predicate.User", "sql.FieldNotIn"], "_raw_llm_output": "sql package usage, predicate.User, sql.FieldNotIn"}
{"seed": "// NewPostDockerRegistriesSearchListParamsWithContext creates a new PostDockerRegistriesSearchListParams object\n// with the default values initialized, and the ability to set a context for a request\nfunc NewPostDockerRegistriesSearchListParamsWithContext(ctx context.Context) *PostDockerRegistriesSearchListParams {\n\tvar ()\n\treturn &PostDockerRegistriesSearchListParams{\n\n\t\tContext: ctx,\n\t}\n}", "id": 15729, "concepts": ["context package usage", "function definition"], "_raw_llm_output": "context package usage, function definition"}
{"seed": "// baseName returns the last path element of the name, with the last dotted suffix removed.\nfunc baseName(name string) string {\n\t// First, find the last element\n\tif i := strings.LastIndex(name, \"/\"); i >= 0 {\n\t\tname = name[i+1:]\n\t}\n\t// Now drop the suffix\n\tif i := strings.LastIndex(name, \".\"); i >= 0 {\n\t\tname = name[0:i]\n\t}\n\treturn name\n}", "id": 15731, "concepts": ["string manipulation", "string handling", "string search"], "_raw_llm_output": "string manipulation, string handling, string search"}
{"seed": "// NewWriter creates a new Writer writing to w.\nfunc NewWriter(w io.Writer) *Writer {\n\treturn &Writer{w: w}\n}", "id": 15734, "concepts": ["io.Writer interface", "struct composition", "method definition"], "_raw_llm_output": "io.Writer interface, struct composition, method definition"}
{"seed": "// PossibleAzureSkuTierValues returns an array of possible values for the AzureSkuTier const type.\nfunc PossibleAzureSkuTierValues() []AzureSkuTier {\n\treturn []AzureSkuTier{Basic, Standard}\n}", "id": 15738, "concepts": ["const declaration", "array declaration", "array iteration"], "_raw_llm_output": "const declaration, array declaration, array iteration"}
{"seed": "// DefaultExprsGTE applies the GTE predicate on the \"default_exprs\" field.\nfunc DefaultExprsGTE(v string) predicate.User {\n\treturn predicate.User(sql.FieldGTE(FieldDefaultExprs, v))\n}", "id": 15740, "concepts": ["predicate.User", "sql.FieldGTE", "sql.FieldLTE", "sql.FieldEQ", "sql.FieldNEQ", "sql.FieldGT", "sql.FieldLT", "sql.FieldIN", "sql.FieldNotIn", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql"], "_raw_llm_output": "predicate.User, sql.FieldGTE, sql.FieldLTE, sql.FieldEQ, sql.FieldNEQ, sql.FieldGT, sql.FieldLT, sql.FieldIN, sql.FieldNotIn, sql.FieldLike, sql.FieldNotLike, sql.FieldContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql"}
{"seed": "// NewRedisStore constructs a new RedisStore, using the provided client session duration.\n// If the 'client' is nil, it will be set to redis.NewClient() pointing at a local redis instance.\n// If 'sessionDuration' is negative it will be set to 'DefaultSessionDuration'\nfunc NewRedisStore(client *redis.Client, sessionDuration time.Duration) *RedisStore {\n\tif client == nil {\n\t\tclient = redis.NewClient(&redis.Options{\n\t\t\tAddr:     \"127.0.0.1:6379\",\n\t\t\tPassword: \"\",\n\t\t\tDB:       0,\n\t\t})\n\t}\n\n\tif sessionDuration < 0 {\n\t\tsessionDuration = DefaultSessionDuration\n\t}\n\n\treturn &RedisStore{\n\t\tClient:          client,\n\t\tSessionDuration: sessionDuration,\n\t}\n}", "id": 15746, "concepts": ["redis client", "redis.NewClient", "redis.Options", "redis.Client", "redis.Client.Set", "redis.Client.Get", "redis.Client.Del", "redis.Client.Expire", "redis.Client.TTL", "time.Duration", "time.Duration.Seconds", "time.Duration.Nanoseconds", "time.Duration.String", "time.Duration.Round", "time.Duration.Truncate", "time.Duration.Add", "time.Duration.Sub", "time.Duration.Equal", "time.Duration.Before", "time.Duration.After", "time.Duration.Format", "time.Duration.Parse", "time.Duration.String", "time.Duration.Nanosecond", "time.Duration.Microsecond", "time.Duration.Millisecond", "time.Duration.Second", "time.Duration.Minute", "time.Duration.Hour", "time.Duration.Truncate", "time.Duration.Round", "time.Duration.Add", "time.Duration.Sub", "time.Duration.Equal", "time.Duration.Before", "time.Duration.After", "time.Duration.Format", "time.Duration.Parse", "time.Duration.String", "time.Duration.Nanosecond", "time.Duration.Microsecond", "time.Duration.Millisecond", "time.Duration.Second", ""], "_raw_llm_output": "redis client, redis.NewClient, redis.Options, redis.Client, redis.Client.Set, redis.Client.Get, redis.Client.Del, redis.Client.Expire, redis.Client.TTL, time.Duration, time.Duration.Seconds, time.Duration.Nanoseconds, time.Duration.String, time.Duration.Round, time.Duration.Truncate, time.Duration.Add, time.Duration.Sub, time.Duration.Equal, time.Duration.Before, time.Duration.After, time.Duration.Format, time.Duration.Parse, time.Duration.String, time.Duration.Nanosecond, time.Duration.Microsecond, time.Duration.Millisecond, time.Duration.Second, time.Duration.Minute, time.Duration.Hour, time.Duration.Truncate, time.Duration.Round, time.Duration.Add, time.Duration.Sub, time.Duration.Equal, time.Duration.Before, time.Duration.After, time.Duration.Format, time.Duration.Parse, time.Duration.String, time.Duration.Nanosecond, time.Duration.Microsecond, time.Duration.Millisecond, time.Duration.Second,"}
{"seed": "// Strike represents the HTML element 'strike'.\n// For more information visit https://www.w3schools.com/tags/tag_strike.asp.\nfunc Strike(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"strike\", Attributes: attrs, Children: children}\n}", "id": 15757, "concepts": ["HTML generation", "HTML tree representation", "HTML element definition"], "_raw_llm_output": "HTML generation, HTML tree representation, HTML element definition"}
{"seed": "// NewPostAdminUsersParams creates a new PostAdminUsersParams object\n// with the default values initialized.\nfunc NewPostAdminUsersParams() *PostAdminUsersParams {\n\tvar ()\n\treturn &PostAdminUsersParams{\n\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 15758, "concepts": ["struct definition", "struct initialization", "default values"], "_raw_llm_output": "struct definition, struct initialization, default values"}
{"seed": "// PostServerSideEncryption is a PostOption to set x-oss-server-side-encryption\nfunc PostServerSideEncryption(value string) PostOption {\n\treturn setMultipartField(\"x-oss-server-side-encryption\", value)\n}", "id": 15761, "concepts": ["function definition", "function composition", "function option pattern", "function signature"], "_raw_llm_output": "function definition, function composition, function option pattern, function signature"}
{"seed": "// ExtractDicomFromZipReader consumes a zip reader of the UK Biobank format,\n// finds the dicom of the desired name, and returns that image, with or without\n// the overlay (if any is present) based on includeOverlay.\nfunc ExtractDicomFromZipReader(rc *zip.Reader, dicomName string, includeOverlay bool) (image.Image, error) {\n\n\tfor _, v := range rc.File {\n\t\t// Iterate over all of the dicoms in the zip til we find the one with\n\t\t// the desired name. This is reasonably efficient since we don't need to\n\t\t// read all of the data to find the right name.\n\t\tif v.Name != dicomName {\n\t\t\tcontinue\n\t\t}\n\n\t\tdicomReader, err := v.Open()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tdefer dicomReader.Close()\n\n\t\timg, err := ExtractDicomFromReader(dicomReader, int64(v.UncompressedSize64), includeOverlay)\n\n\t\treturn img, err\n\t}\n\n\treturn nil, fmt.Errorf(\"Did not find the requested Dicom %s\", dicomName)\n}", "id": 15765, "concepts": ["zip package usage", "file iteration", "error handling (fmt.Errorf)", "standard library usage"], "_raw_llm_output": "zip package usage, file iteration, error handling (fmt.Errorf), standard library usage"}
{"seed": "// PossibleProvisionStateValues returns the possible values for the ProvisionState const type.\nfunc PossibleProvisionStateValues() []ProvisionState {\n\treturn []ProvisionState{\n\t\tProvisionStateAccepted,\n\t\tProvisionStateCanceled,\n\t\tProvisionStateCreating,\n\t\tProvisionStateDeleted,\n\t\tProvisionStateDeleting,\n\t\tProvisionStateFailed,\n\t\tProvisionStateNotSpecified,\n\t\tProvisionStateSucceeded,\n\t\tProvisionStateUpdating,\n\t}\n}", "id": 15778, "concepts": ["const type", "type assertion", "type switch"], "_raw_llm_output": "const type, type assertion, type switch"}
{"seed": "// NewAccessGovernanceCPClientWithConfigurationProvider Creates a new default AccessGovernanceCP client with the given configuration provider.\n// the configuration provider will be used for the default signer as well as reading the region\nfunc NewAccessGovernanceCPClientWithConfigurationProvider(configProvider common.ConfigurationProvider) (client AccessGovernanceCPClient, err error) {\n\tif enabled := common.CheckForEnabledServices(\"accessgovernancecp\"); !enabled {\n\t\treturn client, fmt.Errorf(\"the Alloy configuration disabled this service, this behavior is controlled by OciSdkEnabledServicesMap variables. Please check if your local alloy_config file configured the service you're targeting or contact the cloud provider on the availability of this service\")\n\t}\n\tprovider, err := auth.GetGenericConfigurationProvider(configProvider)\n\tif err != nil {\n\t\treturn client, err\n\t}\n\tbaseClient, e := common.NewClientWithConfig(provider)\n\tif e != nil {\n\t\treturn client, e\n\t}\n\treturn newAccessGovernanceCPClientFromBaseClient(baseClient, provider)\n}", "id": 15785, "concepts": ["configuration provider", "client creation", "error handling"], "_raw_llm_output": "configuration provider, client creation, error handling"}
{"seed": "// GenerateID generates a unique ID that can be used as an identifier for an entity.\nfunc GenerateID() string {\n\treturn uuid.New().String()\n}", "id": 15793, "concepts": ["uuid package usage", "uuid generation"], "_raw_llm_output": "uuid package usage, uuid generation"}
{"seed": "// NewGetSubscriptionsParamsWithHTTPClient creates a new GetSubscriptionsParams object\n// with the default values initialized, and the ability to set a custom HTTPClient for a request\nfunc NewGetSubscriptionsParamsWithHTTPClient(client *http.Client) *GetSubscriptionsParams {\n\tvar ()\n\treturn &GetSubscriptionsParams{\n\t\tHTTPClient: client,\n\t}\n}", "id": 15800, "concepts": ["HTTP client creation", "HTTP client usage"], "_raw_llm_output": "HTTP client creation, HTTP client usage"}
{"seed": "// New returns the Hello World service.\nfunc New() *Service {\n\treturn &Service{}\n}", "id": 15802, "concepts": ["constructor pattern", "basic function definition"], "_raw_llm_output": "constructor pattern, basic function definition"}
{"seed": "// AssertDownlinkGatewayLock asserts that a downlink lock for the given gateway exists.\nfunc AssertDownlinkGatewayLock(gatewayID lorawan.EUI64) Assertion {\n\treturn func(assert *require.Assertions, ts *IntegrationTestSuite) {\n\t\tkey := storage.GetRedisKey(\"lora:ns:gw:%s:down:lock\", gatewayID)\n\t\terr := storage.RedisClient().Get(context.Background(), key).Err()\n\t\tassert.NoError(err)\n\t}\n}", "id": 15803, "concepts": ["redis usage", "redis client usage", "redis key generation", "redis string operations", "redis set operations", "redis hash operations", "redis list operations", "redis sorted set operations", "redis transaction", "redis pipeline", "redis pub/sub", "redis pub/sub pattern matching", "redis pub/sub channel", "redis pub/sub channel pattern matching", "redis pub/sub channel subscription", "redis pub/sub channel unsubscription", "redis pub/sub channel message handling", "redis pub/sub channel message handling", "redis pub/sub channel message handling", "redis pub/sub channel message handling", "redis pub/sub channel message handling", "redis pub/sub channel message handling", "redis pub/sub channel message handling", "redis pub/sub channel message handling", "redis pub/sub channel message handling", "redis pub/sub channel message handling", "redis pub/sub channel message handling", "redis pub/sub channel message handling", "redis pub/sub channel message handling", "redis pub/sub channel message handling", "redis pub/sub channel message handling", "redis pub/sub channel message handling", "redis pub/sub channel message handling", "redis pub/sub channel message handling", "redis pub/sub channel message handling", "redis pub/sub channel message handling", "redis pub/sub channel message handling", "redis pub/sub channel message handling", ""], "_raw_llm_output": "redis usage, redis client usage, redis key generation, redis string operations, redis set operations, redis hash operations, redis list operations, redis sorted set operations, redis transaction, redis pipeline, redis pub/sub, redis pub/sub pattern matching, redis pub/sub channel, redis pub/sub channel pattern matching, redis pub/sub channel subscription, redis pub/sub channel unsubscription, redis pub/sub channel message handling, redis pub/sub channel message handling, redis pub/sub channel message handling, redis pub/sub channel message handling, redis pub/sub channel message handling, redis pub/sub channel message handling, redis pub/sub channel message handling, redis pub/sub channel message handling, redis pub/sub channel message handling, redis pub/sub channel message handling, redis pub/sub channel message handling, redis pub/sub channel message handling, redis pub/sub channel message handling, redis pub/sub channel message handling, redis pub/sub channel message handling, redis pub/sub channel message handling, redis pub/sub channel message handling, redis pub/sub channel message handling, redis pub/sub channel message handling, redis pub/sub channel message handling, redis pub/sub channel message handling, redis pub/sub channel message handling,"}
{"seed": "// NicknameIn applies the In predicate on the \"nickname\" field.\nfunc NicknameIn(vs ...string) predicate.User {\n\treturn predicate.User(sql.FieldIn(FieldNickname, vs...))\n}", "id": 15824, "concepts": ["sql.FieldIn", "predicate.User", "sql.Field", "sql.Query"], "_raw_llm_output": "sql.FieldIn, predicate.User, sql.Field, sql.Query"}
{"seed": "// WorkplaceGT applies the GT predicate on the \"workplace\" field.\nfunc WorkplaceGT(v string) predicate.User {\n\treturn predicate.User(sql.FieldGT(FieldWorkplace, v))\n}", "id": 15831, "concepts": ["sql package usage", "predicate.User", "sql.FieldGT"], "_raw_llm_output": "sql package usage, predicate.User, sql.FieldGT"}
{"seed": "// PossibleRulesEngineOperatorValues returns an array of possible values for the RulesEngineOperator const type.\nfunc PossibleRulesEngineOperatorValues() []RulesEngineOperator {\n\treturn []RulesEngineOperator{RulesEngineOperatorAny, RulesEngineOperatorBeginsWith, RulesEngineOperatorContains, RulesEngineOperatorEndsWith, RulesEngineOperatorEqual, RulesEngineOperatorGeoMatch, RulesEngineOperatorGreaterThan, RulesEngineOperatorGreaterThanOrEqual, RulesEngineOperatorIPMatch, RulesEngineOperatorLessThan, RulesEngineOperatorLessThanOrEqual}\n}", "id": 15833, "concepts": ["const type", "array", "array iteration"], "_raw_llm_output": "const type, array, array iteration"}
{"seed": "// PossibleKeySourceValues returns an array of possible values for the KeySource const type.\nfunc PossibleKeySourceValues() []KeySource {\n\treturn []KeySource{MicrosoftKeyVault}\n}", "id": 15837, "concepts": ["array", "const", "array iteration"], "_raw_llm_output": "array, const, array iteration"}
{"seed": "// New creates a new one-to-one bidirectional map of key <-> value strings\n// It is safe for concurrent use by multiple goroutines\nfunc New() BiMap {\n\treturn &bimap{\n\t\tkeyToVal: map[string]string{},\n\t\tvalToKey: map[string]string{},\n\t}\n}", "id": 15842, "concepts": ["map", "concurrency", "standard library usage"], "_raw_llm_output": "map, concurrency, standard library usage"}
{"seed": "// NewOpenAPISchema returns an empty instance of an OpenAPISchema object.\nfunc NewOpenAPISchema() *OpenAPISchema {\n\treturn &OpenAPISchema{\n\t\tEnum:       []interface{}{},\n\t\tMetadata:   map[string]string{},\n\t\tProperties: map[string]*OpenAPISchema{},\n\t\tRequired:   []string{},\n\t}\n}", "id": 15849, "concepts": ["struct definition", "map definition", "slice definition", "map iteration", "struct field access", "map iteration"], "_raw_llm_output": "struct definition, map definition, slice definition, map iteration, struct field access, map iteration"}
{"seed": "// ParseDeleteSnapshotResponse parses an HTTP response from a DeleteSnapshotWithResponse call\nfunc ParseDeleteSnapshotResponse(rsp *http.Response) (*DeleteSnapshotResponse, error) {\n\tbodyBytes, err := ioutil.ReadAll(rsp.Body)\n\tdefer rsp.Body.Close()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse := &DeleteSnapshotResponse{\n\t\tBody:         bodyBytes,\n\t\tHTTPResponse: rsp,\n\t}\n\n\tswitch {\n\tcase strings.Contains(rsp.Header.Get(\"Content-Type\"), \"json\") && rsp.StatusCode == 200:\n\t\tvar dest Operation\n\t\tif err := json.Unmarshal(bodyBytes, &dest); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresponse.JSON200 = &dest\n\n\t}\n\n\treturn response, nil\n}", "id": 15856, "concepts": ["http package usage", "json package usage", "string manipulation", "error handling (idiomatic if err != nil)", "switch statement"], "_raw_llm_output": "http package usage, json package usage, string manipulation, error handling (idiomatic if err != nil), switch statement"}
{"seed": "// UpdatedAtIn applies the In predicate on the \"updated_at\" field.\nfunc UpdatedAtIn(vs ...time.Time) predicate.User {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.User(func(s *sql.Selector) {\n\t\t// if not arguments were provided, append the FALSE constants,\n\t\t// since we can't apply \"IN ()\". This will make this predicate falsy.\n\t\tif len(vs) == 0 {\n\t\t\ts.Where(sql.False())\n\t\t\treturn\n\t\t}\n\t\ts.Where(sql.In(s.C(FieldUpdatedAt), v...))\n\t})\n}", "id": 15859, "concepts": ["sql.Selector", "sql.In", "sql.False", "sql.C", "predicate.User", "predicate.User"], "_raw_llm_output": "sql.Selector, sql.In, sql.False, sql.C, predicate.User, predicate.User"}
{"seed": "// SocialNameContains applies the Contains predicate on the \"social_name\" field.\nfunc SocialNameContains(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.Contains(s.C(FieldSocialName), v))\n\t})\n}", "id": 15861, "concepts": ["sql.Selector", "sql.Contains", "sql.C", "predicate.User", "sql.Where", "sql.Contains"], "_raw_llm_output": "sql.Selector, sql.Contains, sql.C, predicate.User, sql.Where, sql.Contains"}
{"seed": "// NewMultipleMetricsParamsWithHTTPClient creates a new MultipleMetricsParams object\n// with the default values initialized, and the ability to set a custom HTTPClient for a request\nfunc NewMultipleMetricsParamsWithHTTPClient(client *http.Client) *MultipleMetricsParams {\n\tvar ()\n\treturn &MultipleMetricsParams{\n\t\tHTTPClient: client,\n\t}\n}", "id": 15868, "concepts": ["struct initialization", "struct field initialization", "anonymous struct field", "function definition", "function call", "pointer", "standard library usage"], "_raw_llm_output": "struct initialization, struct field initialization, anonymous struct field, function definition, function call, pointer, standard library usage"}
{"seed": "// IsUnknownBlockError returns whether the error is a UnknownBlockError.\nfunc IsUnknownBlockError(err error) bool {\n\t_, ok := err.(*UnknownBlockError)\n\treturn ok\n}", "id": 15880, "concepts": ["error handling (type assertion)", "error handling (errors.As)"], "_raw_llm_output": "error handling (type assertion), error handling (errors.As)"}
{"seed": "// NewGetNotificationsParams creates a new GetNotificationsParams object\n// with the default values initialized.\nfunc NewGetNotificationsParams() *GetNotificationsParams {\n\treturn &GetNotificationsParams{}\n}", "id": 15881, "concepts": ["struct initialization", "basic function definition"], "_raw_llm_output": "struct initialization, basic function definition"}
{"seed": "// ExecAndWait execs cmd, reports the stdout & stderr and waits for cmd to complete.\nfunc ExecAndWait(r *report.Reporter, cmd *exec.Cmd) error {\n\tstdout, err := cmd.StdoutPipe()\n\tif err != nil {\n\t\treturn err\n\t}\n\tstderr, err := cmd.StderrPipe()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := cmd.Start(); err != nil {\n\t\treturn err\n\t}\n\t// Report progress log periodically to stdout/db\n\tgo r.ReportLog(stdout)\n\tgo r.ReportLog(stderr)\n\n\treturn cmd.Wait()\n}", "id": 15898, "concepts": ["exec package usage", "goroutine", "channel", "error handling", "standard library usage"], "_raw_llm_output": "exec package usage, goroutine, channel, error handling, standard library usage"}
{"seed": "// InitZap creates a zap logger with the provided verbosity level\n// and sets it as the package logger.\n// 0 is the least verbose and 10 the most verbose.\n// The package logger can only be init once, so subsequent calls to this method\n// won't have any effect\nfunc InitZap(level int, opts ...LoggerOpt) error {\n\tcfg := zap.NewDevelopmentConfig()\n\tcfg.Level = zap.NewAtomicLevelAt(zapcore.Level(-1 * level))\n\tcfg.EncoderConfig.EncodeLevel = nil\n\tcfg.EncoderConfig.EncodeTime = NullTimeEncoder\n\tcfg.DisableCaller = true\n\tcfg.DisableStacktrace = true\n\n\t// Only enabling this at level 4 because that's when\n\t// our debugging levels start. Ref: doc.go\n\tif level >= 4 {\n\t\tcfg.EncoderConfig.EncodeLevel = VLevelEncoder\n\t\tcfg.EncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder\n\t}\n\n\tzapLog, err := cfg.Build()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error creating zap logger: %v\", err)\n\t}\n\n\tlogr := zapr.NewLogger(zapLog)\n\tfor _, opt := range opts {\n\t\topt(&logr)\n\t}\n\n\tset(logr)\n\tl.V(4).Info(\"Logger init completed\", \"vlevel\", level)\n\n\treturn nil\n}", "id": 15914, "concepts": ["zap package usage", "zap.NewDevelopmentConfig", "zap.NewAtomicLevelAt", "zap.NewAtomicLevel", "zap.NewLogger", "zapr.NewLogger", "zapcore.Level", "zapcore.ISO8601TimeEncoder", "zapcore.NullTimeEncoder", "zapcore.LevelEncoder", "zapcore.VLevelEncoder", "zap.Config", "zap.Config.Build", "zap.Config.DisableCaller", "zap.Config.DisableStacktrace", "zap.Config.EncoderConfig.EncodeLevel", "zap.Config.EncoderConfig.EncodeTime", "zap.Config.Level", "zap.Config.OutputPaths", "zap.Config.OutputPaths.Add", "zap.Config.OutputPaths.Add", "zap.Config.OutputPaths.Add", "zap.Config.OutputPaths.Add", "zap.Config.OutputPaths.Add", "zap.Config.OutputPaths.Add", "zap.Config.OutputPaths.Add", "zap.Config.OutputPaths.Add", "zap.Config.OutputPaths.Add", "zap.Config.OutputPaths.Add", "zap.Config.OutputPaths.Add", "zap.Config.OutputPaths.Add", "zap.Config.OutputPaths.Add", "zap.Config.OutputPaths.Add", "zap"], "_raw_llm_output": "zap package usage, zap.NewDevelopmentConfig, zap.NewAtomicLevelAt, zap.NewAtomicLevel, zap.NewLogger, zapr.NewLogger, zapcore.Level, zapcore.ISO8601TimeEncoder, zapcore.NullTimeEncoder, zapcore.LevelEncoder, zapcore.VLevelEncoder, zap.Config, zap.Config.Build, zap.Config.DisableCaller, zap.Config.DisableStacktrace, zap.Config.EncoderConfig.EncodeLevel, zap.Config.EncoderConfig.EncodeTime, zap.Config.Level, zap.Config.OutputPaths, zap.Config.OutputPaths.Add, zap.Config.OutputPaths.Add, zap.Config.OutputPaths.Add, zap.Config.OutputPaths.Add, zap.Config.OutputPaths.Add, zap.Config.OutputPaths.Add, zap.Config.OutputPaths.Add, zap.Config.OutputPaths.Add, zap.Config.OutputPaths.Add, zap.Config.OutputPaths.Add, zap.Config.OutputPaths.Add, zap.Config.OutputPaths.Add, zap.Config.OutputPaths.Add, zap.Config.OutputPaths.Add, zap"}
{"seed": "// SocialPayloadIn applies the In predicate on the \"social_payload\" field.\nfunc SocialPayloadIn(vs ...string) predicate.User {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.User(func(s *sql.Selector) {\n\t\t// if not arguments were provided, append the FALSE constants,\n\t\t// since we can't apply \"IN ()\". This will make this predicate falsy.\n\t\tif len(vs) == 0 {\n\t\t\ts.Where(sql.False())\n\t\t\treturn\n\t\t}\n\t\ts.Where(sql.In(s.C(FieldSocialPayload), v...))\n\t})\n}", "id": 15948, "concepts": ["sql.Selector", "sql.In", "sql.False", "predicate.User", "predicate.FieldSocialPayload"], "_raw_llm_output": "sql.Selector, sql.In, sql.False, predicate.User, predicate.FieldSocialPayload"}
{"seed": "// RequireFromPathf is similar to FromPathf except that instead of returning an\n// error on malformed input, it panics. It should only be used when the input\n// is statically verifiable.\nfunc RequireFromPathf(td TrustDomain, format string, args ...interface{}) ID {\n\tid, err := FromPathf(td, format, args...)\n\tpanicOnErr(err)\n\treturn id\n}", "id": 15954, "concepts": ["panic", "error handling (panicOnErr)", "string formatting", "string manipulation"], "_raw_llm_output": "panic, error handling (panicOnErr), string formatting, string manipulation"}
{"seed": "// GetSparseBlockDeviceUUID returns a fixed UUID for the sparse\n// disk on a given node.\nfunc GetSparseBlockDeviceUUID(hostname, sparseFile string) string {\n\treturn SparseBlockDevicePrefix + util.Hash(hostname+sparseFile)\n}", "id": 15956, "concepts": ["string concatenation", "string hashing", "string manipulation", "string comparison"], "_raw_llm_output": "string concatenation, string hashing, string manipulation, string comparison"}
{"seed": "// WithEKS is used to specify that the tags builder will be targeting EKS.\nfunc WithEKS(eksclient eksiface.EKSAPI) BuilderOption {\n\treturn func(b *Builder) {\n\t\tb.applyFunc = func(params *infrav1.BuildParams) error {\n\t\t\ttags := infrav1.Build(*params)\n\n\t\t\teksTags := make(map[string]*string, len(tags))\n\t\t\tfor k, v := range tags {\n\t\t\t\teksTags[k] = aws.String(v)\n\t\t\t}\n\n\t\t\ttagResourcesInput := &eks.TagResourceInput{\n\t\t\t\tResourceArn: aws.String(params.ResourceID),\n\t\t\t\tTags:        eksTags,\n\t\t\t}\n\n\t\t\t_, err := eksclient.TagResource(tagResourcesInput)\n\t\t\tif err != nil {\n\t\t\t\treturn errors.Wrapf(err, \"failed to tag eks cluster %q in cluster %q\", params.ResourceID, params.ClusterName)\n\t\t\t}\n\n\t\t\treturn nil\n\t\t}\n\t}\n}", "id": 15957, "concepts": ["eksiface.EKSAPI", "aws.String", "map iteration", "map key/value assignment", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue", "aws.StringValue"], "_raw_llm_output": "eksiface.EKSAPI, aws.String, map iteration, map key/value assignment, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue, aws.StringValue"}
{"seed": "// TitleContainsFold applies the ContainsFold predicate on the \"title\" field.\nfunc TitleContainsFold(v string) predicate.User {\n\treturn predicate.User(sql.FieldContainsFold(FieldTitle, v))\n}", "id": 15966, "concepts": ["predicate.User", "sql.FieldContainsFold", "sql.FieldContainsFold", "sql.FieldContainsFold"], "_raw_llm_output": "predicate.User, sql.FieldContainsFold, sql.FieldContainsFold, sql.FieldContainsFold"}
{"seed": "// SiginAuthenticationPath computes a request path to the sigin action of authentication.\nfunc SiginAuthenticationPath() string {\n\n\treturn fmt.Sprintf(\"/v1/signin\")\n}", "id": 15985, "concepts": ["string formatting", "fmt package usage"], "_raw_llm_output": "string formatting, fmt package usage"}
{"seed": "// max returns the larger of 2 impact amounts\nfunc max(a, b ImpactAmount) ImpactAmount {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}", "id": 15986, "concepts": ["function definition", "function return", "basic function definition"], "_raw_llm_output": "function definition, function return, basic function definition"}
{"seed": "// Menu_ is a convenience wrapper for Menu without the attrs argument.\nfunc Menu_(children ...HTML) HTML {\n  return Menu(nil, children...)\n}", "id": 15989, "concepts": ["function definition", "variadic function definition", "function argument", "function return value"], "_raw_llm_output": "function definition, variadic function definition, function argument, function return value"}
{"seed": "// CountOpenFiles returns how many entries are currently in the table\n// in a threadsafe manner.\nfunc CountOpenFiles() int {\n\tt.Lock()\n\tdefer t.Unlock()\n\treturn len(t.entries)\n}", "id": 15994, "concepts": ["mutex", "thread-safe programming", "sync.Mutex", "sync.RWMutex"], "_raw_llm_output": "mutex, thread-safe programming, sync.Mutex, sync.RWMutex"}
{"seed": "// AddOrReplaceReadGroup returns a filter for adding or replacing the\n// read group both in the Header and in each Alignment.\nfunc AddOrReplaceReadGroup(readGroup utils.StringMap) sam.Filter {\n\treturn func(header *sam.Header) sam.AlignmentFilter {\n\t\theader.RG = []utils.StringMap{readGroup}\n\t\tid := readGroup[\"ID\"]\n\t\treturn func(aln *sam.Alignment) bool { aln.SetRG(id); return true }\n\t}\n}", "id": 15998, "concepts": ["structs", "interfaces", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition"], "_raw_llm_output": "structs, interfaces, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition"}
{"seed": "// parseApp configures the \"events\" global option from Caddyfile to set up the events app.\n// Syntax:\n//\n//\tevents {\n//\t\ton <event> <handler_module...>\n//\t}\n//\n// If <event> is *, then it will bind to all events.\nfunc parseApp(d *caddyfile.Dispenser, _ any) (any, error) {\n\tapp := new(caddyevents.App)\n\n\t// consume the option name\n\tif !d.Next() {\n\t\treturn nil, d.ArgErr()\n\t}\n\n\t// handle the block\n\tfor d.NextBlock(0) {\n\t\tswitch d.Val() {\n\t\tcase \"on\":\n\t\t\tif !d.NextArg() {\n\t\t\t\treturn nil, d.ArgErr()\n\t\t\t}\n\t\t\teventName := d.Val()\n\t\t\tif eventName == \"*\" {\n\t\t\t\teventName = \"\"\n\t\t\t}\n\n\t\t\tif !d.NextArg() {\n\t\t\t\treturn nil, d.ArgErr()\n\t\t\t}\n\t\t\thandlerName := d.Val()\n\t\t\tmodID := \"events.handlers.\" + handlerName\n\t\t\tunm, err := caddyfile.UnmarshalModule(d, modID)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tapp.Subscriptions = append(app.Subscriptions, &caddyevents.Subscription{\n\t\t\t\tEvents: []string{eventName},\n\t\t\t\tHandlersRaw: []json.RawMessage{\n\t\t\t\t\tcaddyconfig.JSONModuleObject(unm, \"handler\", handlerName, nil),\n\t\t\t\t},\n\t\t\t})\n\n\t\tdefault:\n\t\t\treturn nil, d.ArgErr()\n\t\t}\n\t}\n\n\treturn httpcaddyfile.App{\n\t\tName:  \"events\",\n\t\tValue: caddyconfig.JSON(app, nil),\n\t}, nil\n}", "id": 16011, "concepts": ["caddyfile parsing", "caddyfile unmarshaling", "caddyfile unmarshaling with modules", "caddyfile unmarshaling with modules", "caddyfile unmarshaling with modules", "caddyfile unmarshaling with modules", "caddyfile unmarshaling with modules", "caddyfile unmarshaling with modules", "caddyfile unmarshaling with modules", "caddyfile unmarshaling with modules", "caddyfile unmarshaling with modules", "caddyfile unmarshaling with modules", "caddyfile unmarshaling with modules", "caddyfile unmarshaling with modules", "caddyfile unmarshaling with modules", "caddyfile unmarshaling with modules", "caddyfile unmarshaling with modules", "caddyfile unmarshaling with modules", "caddyfile unmarshaling with modules", "caddyfile unmarshaling with modules", "caddyfile unmarshaling with modules", "caddyfile unmarshaling with modules", "caddyfile unmarshaling with modules", "caddyfile unmarshaling with modules", "caddyfile unmarshaling with modules", "caddyfile unmarshaling with modules", "caddyfile unmarshaling with modules", "caddyfile unmarshaling with modules", "caddyfile unmarshaling with modules", "caddyfile unmarshaling with modules", "caddyfile unmarshaling with modules", "caddyfile unmarshaling with modules", "caddyfile unmarshal"], "_raw_llm_output": "caddyfile parsing, caddyfile unmarshaling, caddyfile unmarshaling with modules, caddyfile unmarshaling with modules, caddyfile unmarshaling with modules, caddyfile unmarshaling with modules, caddyfile unmarshaling with modules, caddyfile unmarshaling with modules, caddyfile unmarshaling with modules, caddyfile unmarshaling with modules, caddyfile unmarshaling with modules, caddyfile unmarshaling with modules, caddyfile unmarshaling with modules, caddyfile unmarshaling with modules, caddyfile unmarshaling with modules, caddyfile unmarshaling with modules, caddyfile unmarshaling with modules, caddyfile unmarshaling with modules, caddyfile unmarshaling with modules, caddyfile unmarshaling with modules, caddyfile unmarshaling with modules, caddyfile unmarshaling with modules, caddyfile unmarshaling with modules, caddyfile unmarshaling with modules, caddyfile unmarshaling with modules, caddyfile unmarshaling with modules, caddyfile unmarshaling with modules, caddyfile unmarshaling with modules, caddyfile unmarshaling with modules, caddyfile unmarshaling with modules, caddyfile unmarshaling with modules, caddyfile unmarshaling with modules, caddyfile unmarshal"}
{"seed": "// Int32ToBytes converts uint32 to bytes.\nfunc Int32ToBytes(n uint32) []byte {\n\tvar res [4]byte\n\tbinary.LittleEndian.PutUint32(res[:], n)\n\treturn res[:]\n}", "id": 16012, "concepts": ["byte conversion", "binary.LittleEndian", "byte slice"], "_raw_llm_output": "byte conversion, binary.LittleEndian, byte slice"}
{"seed": "// MarshalErrors writes a JSON API response using the given `[]error`.\n//\n// For more information on JSON API error payloads, see the spec here:\n// http://jsonapi.org/format/#document-top-level\n// and here: http://jsonapi.org/format/#error-objects.\nfunc MarshalErrors(w io.Writer, errorObjects []*ErrorObject) error {\n\treturn json.NewEncoder(w).Encode(&ErrorsPayload{Errors: errorObjects})\n}", "id": 16023, "concepts": ["JSON encoding", "JSON API error payloads", "error handling (idiomatic `if err != nil`)", "standard library usage"], "_raw_llm_output": "JSON encoding, JSON API error payloads, error handling (idiomatic `if err != nil`), standard library usage"}
{"seed": "// FindPhenotypeprop retrieves a single record by ID with an executor.\n// If selectCols is empty Find will return all columns.\nfunc FindPhenotypeprop(exec boil.Executor, phenotypepropID int, selectCols ...string) (*Phenotypeprop, error) {\n\tphenotypepropObj := &Phenotypeprop{}\n\n\tsel := \"*\"\n\tif len(selectCols) > 0 {\n\t\tsel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), \",\")\n\t}\n\tquery := fmt.Sprintf(\n\t\t\"select %s from \\\"phenotypeprop\\\" where \\\"phenotypeprop_id\\\"=$1\", sel,\n\t)\n\n\tq := queries.Raw(exec, query, phenotypepropID)\n\n\terr := q.Bind(phenotypepropObj)\n\tif err != nil {\n\t\tif errors.Cause(err) == sql.ErrNoRows {\n\t\t\treturn nil, sql.ErrNoRows\n\t\t}\n\t\treturn nil, errors.Wrap(err, \"chado: unable to select from phenotypeprop\")\n\t}\n\n\treturn phenotypepropObj, nil\n}", "id": 16027, "concepts": ["string formatting", "fmt package usage", "sql.ErrNoRows", "boil.Executor", "sql.Rows.Scan", "string manipulation", "sql.ErrNoRows", "error handling (errors.Cause)", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows"], "_raw_llm_output": "string formatting, fmt package usage, sql.ErrNoRows, boil.Executor, sql.Rows.Scan, string manipulation, sql.ErrNoRows, error handling (errors.Cause), sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows"}
{"seed": "// NewTemplate parses the given template using the given startTag and endTag\n// as tag start and tag end.\n//\n// The returned template can be executed by concurrently running goroutines\n// using Execute* methods.\nfunc NewTemplate(template, startTag, endTag string) (*Template, error) {\n\tvar t Template\n\terr := t.Reset(template, startTag, endTag)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &t, nil\n}", "id": 16035, "concepts": ["struct definition", "function definition", "concurrency", "standard library usage"], "_raw_llm_output": "struct definition, function definition, concurrency, standard library usage"}
{"seed": "// NewListHetznerSizesParamsWithContext creates a new ListHetznerSizesParams object\n// with the ability to set a context for a request.\nfunc NewListHetznerSizesParamsWithContext(ctx context.Context) *ListHetznerSizesParams {\n\treturn &ListHetznerSizesParams{\n\t\tContext: ctx,\n\t}\n}", "id": 16043, "concepts": ["context package usage", "context.Context", "context.WithValue"], "_raw_llm_output": "context package usage, context.Context, context.WithValue"}
{"seed": "// IsBlockNotReadyError returns whether the error is a BlockNotReadyError.\nfunc IsBlockNotReadyError(err error) bool {\n\t_, ok := err.(*BlockNotReadyError)\n\treturn ok\n}", "id": 16050, "concepts": ["error handling (error type assertion)", "error handling (error type assertion)"], "_raw_llm_output": "error handling (error type assertion), error handling (error type assertion)"}
{"seed": "// loadAWSConfig loads the AWS API credentials and sets the region and HTTPClient returning an aws.Config.\nfunc loadAWSConfig(cl *http.Client, arn arn.ARN) (aws.Config, error) {\n\tcfg, err := external.LoadDefaultAWSConfig()\n\tif err != nil {\n\t\treturn aws.Config{}, fmt.Errorf(\"unable to load AWS SDK config: %v\", err)\n\t}\n\tcfg.Region = arn.Region\n\tcfg.HTTPClient = cl\n\treturn cfg, nil\n}", "id": 16051, "concepts": ["AWS SDK usage", "external package usage", "AWS SDK configuration", "AWS SDK client configuration"], "_raw_llm_output": "AWS SDK usage, external package usage, AWS SDK configuration, AWS SDK client configuration"}
{"seed": "// BulkCreditSamedayFeeEQ applies the EQ predicate on the \"bulkCreditSamedayFee\" field.\nfunc BulkCreditSamedayFeeEQ(v float64) predicate.Bulk {\n\treturn predicate.Bulk(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldBulkCreditSamedayFee), v))\n\t})\n}", "id": 16069, "concepts": ["sql.Selector", "sql.EQ", "sql.C", "sql.Where", "sql.Predicate", "sql.Field", "sql.Bulk", "sql.Predicate.Bulk", "sql.Predicate.Bulk.sql.Selector.Where", "sql.Predicate.Bulk.sql.Selector.Where.sql.EQ", "sql.Predicate.Bulk.sql.Selector.Where.sql.EQ.sql.C", "sql.Predicate.Bulk.sql.Selector.Where.sql.EQ.sql.C.sql.Field", "sql.Predicate.Bulk.sql.Selector.Where.sql.EQ.sql.C.sql.Field.sql.Predicate.Bulk.sql.Selector.Where.sql.EQ.sql.C.sql.Field.sql.Predicate.Bulk.sql.Selector.Where.sql.EQ.sql.C.sql.Field.sql.Predicate.Bulk.sql.Selector.Where.sql.EQ.sql.C.sql.Field.sql.Predicate.Bulk.sql.Selector.Where.sql.EQ.sql.C.sql.Field.sql.Predicate.Bulk.sql.Selector.Where.sql.EQ.sql.C.sql.Field.sql.Predicate.Bulk"], "_raw_llm_output": "sql.Selector, sql.EQ, sql.C, sql.Where, sql.Predicate, sql.Field, sql.Bulk, sql.Predicate.Bulk, sql.Predicate.Bulk.sql.Selector.Where, sql.Predicate.Bulk.sql.Selector.Where.sql.EQ, sql.Predicate.Bulk.sql.Selector.Where.sql.EQ.sql.C, sql.Predicate.Bulk.sql.Selector.Where.sql.EQ.sql.C.sql.Field, sql.Predicate.Bulk.sql.Selector.Where.sql.EQ.sql.C.sql.Field.sql.Predicate.Bulk.sql.Selector.Where.sql.EQ.sql.C.sql.Field.sql.Predicate.Bulk.sql.Selector.Where.sql.EQ.sql.C.sql.Field.sql.Predicate.Bulk.sql.Selector.Where.sql.EQ.sql.C.sql.Field.sql.Predicate.Bulk.sql.Selector.Where.sql.EQ.sql.C.sql.Field.sql.Predicate.Bulk.sql.Selector.Where.sql.EQ.sql.C.sql.Field.sql.Predicate.Bulk"}
{"seed": "// IsTiKVStable checks if cluster is stable by quering PD and checking status of all stores\n// we check PD directly instead of checking the same information already available in the CR status to get the most up to data\n// stores status in PD could be up to 20 seconds stale https://docs.pingcap.com/tidb/stable/tidb-scheduling#information-collection\nfunc IsTiKVStable(pdClient PDClient) string {\n\tstoresInfo, err := pdClient.GetStores()\n\tif err != nil {\n\t\treturn fmt.Sprintf(\"can't access PD: %s\", err)\n\t}\n\n\tfor _, store := range storesInfo.Stores {\n\t\tif store.Store == nil {\n\t\t\treturn \"missing data for one of its stores\"\n\t\t}\n\t\tif store.Store.StateName != v1alpha1.TiKVStateUp && store.Store.StateName != v1alpha1.TiKVStateTombstone {\n\t\t\treturn fmt.Sprintf(\"Strore %d is not up: %s\", store.Store.GetId(), store.Store.StateName)\n\t\t}\n\t}\n\n\treturn \"\"\n}", "id": 16075, "concepts": ["PDClient", "PD API usage", "store state handling"], "_raw_llm_output": "PDClient, PD API usage, store state handling"}
{"seed": "// BetterHeroScoreGT applies the GT predicate on the \"better_hero_score\" field.\nfunc BetterHeroScoreGT(v int) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.GT(s.C(FieldBetterHeroScore), v))\n\t})\n}", "id": 16079, "concepts": ["sql.Selector", "sql.Where", "sql.GT", "sql.C", "predicate.User", "anonymous function"], "_raw_llm_output": "sql.Selector, sql.Where, sql.GT, sql.C, predicate.User, anonymous function"}
{"seed": "// PossibleHealthProbeEnabledValues returns an array of possible values for the HealthProbeEnabled const type.\nfunc PossibleHealthProbeEnabledValues() []HealthProbeEnabled {\n\treturn []HealthProbeEnabled{HealthProbeEnabledDisabled, HealthProbeEnabledEnabled}\n}", "id": 16081, "concepts": ["const type", "array definition", "array iteration"], "_raw_llm_output": "const type, array definition, array iteration"}
{"seed": "// CreatedAtEQ applies the EQ predicate on the \"created_at\" field.\nfunc CreatedAtEQ(v time.Time) predicate.User {\n\treturn predicate.User(sql.FieldEQ(FieldCreatedAt, v))\n}", "id": 16092, "concepts": ["struct field access", "predicate.User", "sql.FieldEQ"], "_raw_llm_output": "struct field access, predicate.User, sql.FieldEQ"}
{"seed": "// NewStyle returns Style having values filled from s.\nfunc NewStyle(s tcell.Style) Style {\n\tf, b, a := s.Decompose()\n\treturn Style{f, b, a}\n}", "id": 16094, "concepts": ["struct definition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", "struct composition", ""], "_raw_llm_output": "struct definition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition, struct composition,"}
{"seed": "// ValidateYesNo is a validation function that ensures that a yes/no question\n// receives a valid response.  Use IsYes or IsNo to test for a particular\n// yes or no response.\nfunc ValidateYesNo() ValidationFunc {\n\treturn func(s string) (bool, error) {\n\t\toptions := []string{\"yes\", \"y\", \"no\", \"n\"}\n\t\treturn validateOptions(strings.ToLower(s), options)\n\t}\n}", "id": 16095, "concepts": ["validation function", "string manipulation", "array iteration", "standard library usage"], "_raw_llm_output": "validation function, string manipulation, array iteration, standard library usage"}
{"seed": "// Img represents the HTML void element 'img'.\n// For more information visit https://www.w3schools.com/tags/tag_img.asp.\nfunc Img(attrs []htmlgo.Attribute) HTML {\n\treturn &htmlgo.Tree{Tag: \"img\", Attributes: attrs, SelfClosing: true}\n}", "id": 16099, "concepts": ["HTML tree building", "HTML void element", "HTML attribute"], "_raw_llm_output": "HTML tree building, HTML void element, HTML attribute"}
{"seed": "// NewPlugins plugins creates a new instance of Plugins with both maps\n// initialized but empty.\nfunc NewPlugins() Plugins {\n\treturn Plugins{\n\t\tHTTPPluginsByID: map[string]http.Plugin{},\n\t\tTCPPluginsByID:  map[string]tcp.Plugin{},\n\t}\n}", "id": 16101, "concepts": ["map initialization", "map iteration (range loop)", "map key lookup"], "_raw_llm_output": "map initialization, map iteration (range loop), map key lookup"}
{"seed": "// CalculateBtcMDLValue returns the amount of MDL (in droplets) to give for an\n// amount of BTC (in satoshis).\n// Rate is measured in MDL per BTC. It should be a decimal string.\n// MaxDecimals is the number of decimal places to truncate to.\nfunc CalculateBtcMDLValue(satoshis int64, mdlPerBTC string, maxDecimals int) (uint64, error) {\n\tif satoshis < 0 {\n\t\treturn 0, errors.New(\"satoshis must be greater than or equal to 0\")\n\t}\n\tif maxDecimals < 0 {\n\t\treturn 0, errors.New(\"maxDecimals can't be negative\")\n\t}\n\n\trate, err := mathutil.ParseRate(mdlPerBTC)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tbtc := decimal.New(satoshis, 0)\n\tbtcToSatoshi := decimal.New(SatoshisPerBTC, 0)\n\tbtc = btc.DivRound(btcToSatoshi, 8)\n\n\tmdl := btc.Mul(rate)\n\tmdl = mdl.Truncate(int32(maxDecimals))\n\n\tmdlToDroplets := decimal.New(droplet.Multiplier, 0)\n\tdroplets := mdl.Mul(mdlToDroplets)\n\n\tamt := droplets.IntPart()\n\tif amt < 0 {\n\t\t// This should never occur, but double check before we convert to uint64,\n\t\t// otherwise we would send all the coins due to integer wrapping.\n\t\treturn 0, errors.New(\"calculated mdl amount is negative\")\n\t}\n\n\treturn uint64(amt), nil\n}", "id": 16104, "concepts": ["math", "decimal", "mathutil package usage", "error handling", "integer conversion", "integer wrapping"], "_raw_llm_output": "math, decimal, mathutil package usage, error handling, integer conversion, integer wrapping"}
{"seed": "// GetNameServersFromResolveConfig parses a file in the format of /etc/resolv.conf\n// The resolve.conf format is described in resolv.conf(5):\n//\n//    https://man7.org/linux/man-pages/man5/resolv.conf.5.html\n//\n// This function looks up at the lines starting with `nameserver`.\n// There can be a single nameserver each line and maximum 3 (defined\n// my MAXNS in resolv.h) in the file.\nfunc GetNameServersFromResolveConfig(filePath string) ([]string, error) {\n\tcontent, err := ioutil.ReadFile(filePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tnameservers := ParseNameServers(content)\n\treturn nameservers, nil\n}", "id": 16107, "concepts": ["ioutil.ReadFile", "string manipulation", "string parsing", "file handling", "basic function definition"], "_raw_llm_output": "ioutil.ReadFile, string manipulation, string parsing, file handling, basic function definition"}
{"seed": "// Q_ is a convenience wrapper for Q without the attrs argument.\nfunc Q_(children ...HTML) HTML {\n  return Q(nil, children...)\n}", "id": 16114, "concepts": ["basic function definition", "variadic function definition", "function return value"], "_raw_llm_output": "basic function definition, variadic function definition, function return value"}
{"seed": "// PossibleOperatorValues returns an array of possible values for the Operator const type.\nfunc PossibleOperatorValues() []Operator {\n\treturn []Operator{OperatorAny, OperatorBeginsWith, OperatorContains, OperatorEndsWith, OperatorEqual, OperatorGeoMatch, OperatorGreaterThan, OperatorGreaterThanOrEqual, OperatorIPMatch, OperatorLessThan, OperatorLessThanOrEqual, OperatorRegEx}\n}", "id": 16142, "concepts": ["const type", "array", "basic function definition"], "_raw_llm_output": "const type, array, basic function definition"}
{"seed": "// DropOptionalHasSuffix applies the HasSuffix predicate on the \"drop_optional\" field.\nfunc DropOptionalHasSuffix(v string) predicate.User {\n\treturn predicate.User(sql.FieldHasSuffix(FieldDropOptional, v))\n}", "id": 16155, "concepts": ["sql.FieldHasSuffix", "predicate.User", "sql.FieldHasSuffix usage"], "_raw_llm_output": "sql.FieldHasSuffix, predicate.User, sql.FieldHasSuffix usage"}
{"seed": "// Td represents the HTML element 'td'.\n// For more information visit https://www.w3schools.com/tags/tag_td.asp.\nfunc Td(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"td\", Attributes: attrs, Children: children}\n}", "id": 16183, "concepts": ["HTML generation", "HTML tree representation", "HTML element definition"], "_raw_llm_output": "HTML generation, HTML tree representation, HTML element definition"}
{"seed": "// NewLineRouteParams creates a new LineRouteParams object\n// with the default values initialized.\nfunc NewLineRouteParams() *LineRouteParams {\n\tvar ()\n\treturn &LineRouteParams{\n\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 16194, "concepts": ["struct initialization", "struct field initialization"], "_raw_llm_output": "struct initialization, struct field initialization"}
{"seed": "// SocialUserIDGT applies the GT predicate on the \"social_user_id\" field.\nfunc SocialUserIDGT(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.GT(s.C(FieldSocialUserID), v))\n\t})\n}", "id": 16211, "concepts": ["sql package usage", "predicate definition", "predicate usage"], "_raw_llm_output": "sql package usage, predicate definition, predicate usage"}
{"seed": "// Build kubeconfig for use with clients.\n// The kubeconfig file can either be passed in as a param, or attempted to be\n// retrieved from the in-cluster ServiceAccount.\nfunc BuildKubeConfig(kubeconfig string) (*rest.Config, error) {\n\tif kubeconfig != \"\" {\n\t\tglog.V(2).Infof(\"kubeconfig file: %s\", kubeconfig)\n\t\treturn clientcmd.BuildConfigFromFlags(\"\", kubeconfig)\n\t}\n\tglog.V(2).Info(\"kubeconfig file: using InClusterConfig.\")\n\treturn rest.InClusterConfig()\n}", "id": 16214, "concepts": ["client-go", "client-go usage", "client-go configuration", "client-go authentication"], "_raw_llm_output": "client-go, client-go usage, client-go configuration, client-go authentication"}
{"seed": "// NoDurable changes the durability of an Exchange from the true default.\nfunc NoDurable() Option {\n\treturn func(e Exchange) Exchange {\n\t\te.Durable = false\n\t\treturn e\n\t}\n}", "id": 16216, "concepts": ["function composition", "function options", "function composition"], "_raw_llm_output": "function composition, function options, function composition"}
{"seed": "// WithOtherValue adds a value based on a key to the Other setting.\n//\n// See `Configuration`.\nfunc WithOtherValue(key string, val interface{}) Configurator {\n\treturn func(app *Application) {\n\t\tif app.config.Other == nil {\n\t\t\tapp.config.Other = make(map[string]interface{})\n\t\t}\n\t\tapp.config.Other[key] = val\n\t}\n}", "id": 16242, "concepts": ["function composition", "function definition", "function composition", "function composition", "function composition"], "_raw_llm_output": "function composition, function definition, function composition, function composition, function composition"}
{"seed": "// ByRelativeID orders the results by the relative_id field.\nfunc ByRelativeID(opts ...sql.OrderTermOption) OrderOption {\n\treturn sql.OrderByField(FieldRelativeID, opts...).ToFunc()\n}", "id": 16245, "concepts": ["sql.OrderTermOption", "sql.OrderByField", "sql.OrderOption", "sql.OrderTerm", "sql.OrderTermOption.ToFunc"], "_raw_llm_output": "sql.OrderTermOption, sql.OrderByField, sql.OrderOption, sql.OrderTerm, sql.OrderTermOption.ToFunc"}
{"seed": "// newS3ToSQSPolicyStatement returns an IAM Policy Statement that allows a S3\n// bucket to publish event notifications to the given SQS queue.\n// Ref. https://docs.aws.amazon.com/AmazonS3/latest/userguide/grant-destinations-permissions-to-s3.html#grant-sns-sqs-permission-for-s3\nfunc newS3ToSQSPolicyStatement(queueARN, bucketARN, accID string) iam.PolicyStatement {\n\treturn iam.NewPolicyStatement(iam.EffectAllow,\n\t\tiam.PrincipalService(\"s3.amazonaws.com\"),\n\t\tiam.ConditionArnEquals(\"aws:SourceArn\", bucketARN),\n\t\tiam.ConditionStringEquals(\"aws:SourceAccount\", accID),\n\t\tiam.Action(\"sqs:SendMessage\"),\n\t\tiam.Resource(queueARN),\n\t)\n}", "id": 16249, "concepts": ["string formatting", "IAM Policy Statement", "AWS S3", "AWS SQS"], "_raw_llm_output": "string formatting, IAM Policy Statement, AWS S3, AWS SQS"}
{"seed": "// UsersShopTraceByID retrieves a row from 'aypcddg.users_shop_trace' as a UsersShopTrace.\n//\n// Generated from index 'users_shop_trace_id_pkey'.\nfunc UsersShopTraceByID(ctx context.Context, id int, key ...interface{}) (*UsersShopTrace, error) {\n\tvar err error\n\tvar dbConn *sql.DB\n\n\ttableName, err := GetUsersShopTraceTableName(key...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// sql query\n\tsqlstr := `SELECT ` +\n\t\t`id, openid, unionid, appid, uid, fid, sid, updated ` +\n\t\t`FROM ` + tableName +\n\t\t` WHERE id = ?`\n\n\t// run query\n\tutils.GetTraceLog(ctx).Debug(\"DB\", zap.String(\"SQL\", fmt.Sprint(sqlstr, id)))\n\n\ttx, err := components.M.GetConnFromCtx(ctx)\n\tif err != nil {\n\t\tdbConn, err = components.M.GetSlaveConn()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tust := UsersShopTrace{\n\t\t_exists: true,\n\t}\n\n\tif tx != nil {\n\t\terr = tx.QueryRow(sqlstr, id).Scan(&ust.ID, &ust.Openid, &ust.Unionid, &ust.Appid, &ust.UID, &ust.Fid, &ust.Sid, &ust.Updated)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\terr = dbConn.QueryRow(sqlstr, id).Scan(&ust.ID, &ust.Openid, &ust.Unionid, &ust.Appid, &ust.UID, &ust.Fid, &ust.Sid, &ust.Updated)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn &ust, nil\n}", "id": 16250, "concepts": ["sql query", "sql query execution", "sql query execution with context", "sql query execution with context and transaction", "sql query execution with context and transaction and connection", "sql query execution with context and transaction and connection and result scanning", "sql query execution with context and transaction and connection and result scanning and error handling", "sql query execution with context and transaction and connection and result scanning and error handling and result scanning", "sql query execution with context and transaction and connection and result scanning and error handling and result scanning and error handling", "sql query execution with context and transaction and connection and result scanning and error handling and result scanning and error handling and result scanning", "sql query execution with context and transaction and connection and result scanning and error handling and result scanning and error handling and result scanning and error handling", "sql query execution with context and transaction and connection and result scanning and error handling and result scanning and error handling and result scanning and error handling and result scanning", "sql query execution with context and transaction and connection and result scanning and error handling and result scanning and error handling and result scanning and error handling and result scanning and error handling", "sql query execution with context and transaction and connection and result scanning and error handling and result scanning and error handling and result scanning and error handling and result scanning and error handling and result scanning"], "_raw_llm_output": "sql query, sql query execution, sql query execution with context, sql query execution with context and transaction, sql query execution with context and transaction and connection, sql query execution with context and transaction and connection and result scanning, sql query execution with context and transaction and connection and result scanning and error handling, sql query execution with context and transaction and connection and result scanning and error handling and result scanning, sql query execution with context and transaction and connection and result scanning and error handling and result scanning and error handling, sql query execution with context and transaction and connection and result scanning and error handling and result scanning and error handling and result scanning, sql query execution with context and transaction and connection and result scanning and error handling and result scanning and error handling and result scanning and error handling, sql query execution with context and transaction and connection and result scanning and error handling and result scanning and error handling and result scanning and error handling and result scanning, sql query execution with context and transaction and connection and result scanning and error handling and result scanning and error handling and result scanning and error handling and result scanning and error handling, sql query execution with context and transaction and connection and result scanning and error handling and result scanning and error handling and result scanning and error handling and result scanning and error handling and result scanning"}
{"seed": "// requestWithNewContextValue returns a new request identitcal to the input but with a context\n//  that includes the given key-value mapping.\nfunc requestWithNewContextValue(r *http.Request, key ltiContextKey, value interface{}) *http.Request {\n\tnewRequest := r.WithContext(context.WithValue(r.Context(), key, value))\n\treturn newRequest\n}", "id": 16271, "concepts": ["http.Request", "context.WithValue", "context.Context", "context.Context interface", "http.ResponseWriter", "http.Request interface", "http.Handler interface", "http.HandlerFunc interface", "http.Handler interface", "http.Handler interface", "http.Handler interface", "http.Handler interface", "http.Handler interface", "http.Handler interface", "http.Handler interface", "http.Handler interface", "http.Handler interface", "http.Handler interface", "http.Handler interface", "http.Handler interface", "http.Handler interface", "http.Handler interface", "http.Handler interface", "http.Handler interface", "http.Handler interface", "http.Handler interface", "http.Handler interface", "http.Handler interface", "http.Handler interface", "http.Handler interface", "http.Handler interface", "http.Handler interface", "http.Handler interface", "http.Handler interface", "http.Handler interface", "http.Handler interface", "http.Handler interface", "http.Handler interface", "http.Handler interface", "http.Handler interface", "http.Handler interface", "http.Handler interface", "http.Handler interface", "http.Handler interface", "http.Handler interface", "http.Handler interface", "http.Handler interface", "http.Handler interface", "http.Handler interface", "http.Handler interface", "http.Handler interface", "http.Handler interface"], "_raw_llm_output": "http.Request, context.WithValue, context.Context, context.Context interface, http.ResponseWriter, http.Request interface, http.Handler interface, http.HandlerFunc interface, http.Handler interface, http.Handler interface, http.Handler interface, http.Handler interface, http.Handler interface, http.Handler interface, http.Handler interface, http.Handler interface, http.Handler interface, http.Handler interface, http.Handler interface, http.Handler interface, http.Handler interface, http.Handler interface, http.Handler interface, http.Handler interface, http.Handler interface, http.Handler interface, http.Handler interface, http.Handler interface, http.Handler interface, http.Handler interface, http.Handler interface, http.Handler interface, http.Handler interface, http.Handler interface, http.Handler interface, http.Handler interface, http.Handler interface, http.Handler interface, http.Handler interface, http.Handler interface, http.Handler interface, http.Handler interface, http.Handler interface, http.Handler interface, http.Handler interface, http.Handler interface, http.Handler interface, http.Handler interface, http.Handler interface, http.Handler interface, http.Handler interface, http.Handler interface"}
{"seed": "// NewTimerTimersResponse instantiates a new TimerTimersResponse object\n// This constructor will assign default values to properties that have it defined,\n// and makes sure properties required by API are set, but the set of arguments\n// will change when the set of required properties is changed\nfunc NewTimerTimersResponse() *TimerTimersResponse {\n\tthis := TimerTimersResponse{}\n\treturn &this\n}", "id": 16273, "concepts": ["constructor", "struct definition", "struct initialization"], "_raw_llm_output": "constructor, struct definition, struct initialization"}
{"seed": "// DefaultExprLTE applies the LTE predicate on the \"default_expr\" field.\nfunc DefaultExprLTE(v string) predicate.User {\n\treturn predicate.User(sql.FieldLTE(FieldDefaultExpr, v))\n}", "id": 16277, "concepts": ["predicate.User", "sql.FieldLTE", "sql.FieldGT", "sql.FieldGTE", "sql.FieldEQ", "sql.FieldNEQ", "sql.FieldLT", "sql.FieldLTE", "sql.FieldGT", "sql.FieldGTE", "sql.FieldIN", "sql.FieldNotIn", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldILike", "sql.FieldNotILike", "sql.FieldContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldIs", "sql.FieldIsNot", "sql.FieldIsNull", "sql.FieldIsNotNull", "sql.FieldBetween", "sql.FieldNotBetween", "sql.FieldExists", "sql.FieldNotExists", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldIs", "sql.FieldIsNot", "sql.FieldIsNull", "sql.FieldIsNotNull", "sql.FieldBetween", "sql.FieldNotBetween", "sql.FieldExists", "sql.FieldNotExists", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldIs", "sql.FieldIsNot", "sql.FieldIsNull", "sql.FieldIsNotNull", "sql.FieldBetween", "sql.FieldNotBetween", "sql.FieldExists", "sql.FieldNotExists", ""], "_raw_llm_output": "predicate.User, sql.FieldLTE, sql.FieldGT, sql.FieldGTE, sql.FieldEQ, sql.FieldNEQ, sql.FieldLT, sql.FieldLTE, sql.FieldGT, sql.FieldGTE, sql.FieldIN, sql.FieldNotIn, sql.FieldLike, sql.FieldNotLike, sql.FieldILike, sql.FieldNotILike, sql.FieldContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldIs, sql.FieldIsNot, sql.FieldIsNull, sql.FieldIsNotNull, sql.FieldBetween, sql.FieldNotBetween, sql.FieldExists, sql.FieldNotExists, sql.FieldIn, sql.FieldNotIn, sql.FieldIs, sql.FieldIsNot, sql.FieldIsNull, sql.FieldIsNotNull, sql.FieldBetween, sql.FieldNotBetween, sql.FieldExists, sql.FieldNotExists, sql.FieldIn, sql.FieldNotIn, sql.FieldIs, sql.FieldIsNot, sql.FieldIsNull, sql.FieldIsNotNull, sql.FieldBetween, sql.FieldNotBetween, sql.FieldExists, sql.FieldNotExists,"}
{"seed": "// withDatabaseService sets up the databases service to watch for discovered\n// database resources in the AWS account.\nfunc withDatabaseService(t *testing.T, matchers ...services.ResourceMatcher) testOptionsFunc {\n\tt.Helper()\n\treturn func(options *testOptions) {\n\t\toptions.serviceConfigFuncs = append(options.serviceConfigFuncs, func(cfg *servicecfg.Config) {\n\t\t\tcfg.Databases.Enabled = true\n\t\t\tcfg.Databases.ResourceMatchers = matchers\n\t\t})\n\t}\n}", "id": 16281, "concepts": ["testing", "testing.T", "testing.Helper", "testing.T.Helper", "testing.T.Run", "testing.T.Parallel", "testing.T.Cleanup", "testing.T.Errorf", "testing.T.Log", "testing.T.Run", "testing.T.Parallel", "testing.T.Cleanup", "testing.T.Errorf", "testing.T.Log", "testing.T.Run", "testing.T.Parallel", "testing.T.Cleanup", "testing.T.Errorf", "testing.T.Log", "testing.T.Run", "testing.T.Parallel", "testing.T.Cleanup", "testing.T.Errorf", "testing.T.Log", "testing.T.Run", "testing.T.Parallel", "testing.T.Cleanup", "testing.T.Errorf", "testing.T.Log", "testing.T.Run", "testing.T.Parallel", "testing.T.Cleanup", "testing.T.Errorf", "testing.T.Log", "testing.T.Run", "testing.T.Parallel", "testing.T.Cleanup", "testing.T.Errorf", "testing.T.Log", "testing.T.Run", "testing.T.Parallel", "testing.T.Cleanup", "testing.T.Errorf", "testing.T.Log"], "_raw_llm_output": "testing, testing.T, testing.Helper, testing.T.Helper, testing.T.Run, testing.T.Parallel, testing.T.Cleanup, testing.T.Errorf, testing.T.Log, testing.T.Run, testing.T.Parallel, testing.T.Cleanup, testing.T.Errorf, testing.T.Log, testing.T.Run, testing.T.Parallel, testing.T.Cleanup, testing.T.Errorf, testing.T.Log, testing.T.Run, testing.T.Parallel, testing.T.Cleanup, testing.T.Errorf, testing.T.Log, testing.T.Run, testing.T.Parallel, testing.T.Cleanup, testing.T.Errorf, testing.T.Log, testing.T.Run, testing.T.Parallel, testing.T.Cleanup, testing.T.Errorf, testing.T.Log, testing.T.Run, testing.T.Parallel, testing.T.Cleanup, testing.T.Errorf, testing.T.Log, testing.T.Run, testing.T.Parallel, testing.T.Cleanup, testing.T.Errorf, testing.T.Log"}
{"seed": "// PossibleTransformValues returns an array of possible values for the Transform const type.\nfunc PossibleTransformValues() []Transform {\n\treturn []Transform{TransformLowercase, TransformRemoveNulls, TransformTrim, TransformUppercase, TransformURLDecode, TransformURLEncode}\n}", "id": 16296, "concepts": ["type definition", "type conversion", "type assertion", "type switch", "interface", "method definition"], "_raw_llm_output": "type definition, type conversion, type assertion, type switch, interface, method definition"}
{"seed": "// Here's a function that takes two `int`s and returns\n// their sum as an `int`.\nfunc plus(a int, b int) int {\n\n\t// Go requires explicit returns, i.e. it won't\n\t// automatically return the value of the last\n\t// expression.\n\treturn a + b\n}", "id": 16303, "concepts": ["function definition", "integer summation"], "_raw_llm_output": "function definition, integer summation"}
{"seed": "// NewPutMeAccessRestrictionSmsIDParamsWithHTTPClient creates a new PutMeAccessRestrictionSmsIDParams object\n// with the default values initialized, and the ability to set a custom HTTPClient for a request\nfunc NewPutMeAccessRestrictionSmsIDParamsWithHTTPClient(client *http.Client) *PutMeAccessRestrictionSmsIDParams {\n\tvar ()\n\treturn &PutMeAccessRestrictionSmsIDParams{\n\t\tHTTPClient: client,\n\t}\n}", "id": 16307, "concepts": ["http.Client", "function definition", "parameter passing"], "_raw_llm_output": "http.Client, function definition, parameter passing"}
{"seed": "// NewListTaskNexusParams creates a new ListTaskNexusParams object\n// with the default values initialized.\nfunc NewListTaskNexusParams() *ListTaskNexusParams {\n\n\treturn &ListTaskNexusParams{\n\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 16313, "concepts": ["struct definition", "struct initialization", "default value assignment"], "_raw_llm_output": "struct definition, struct initialization, default value assignment"}
{"seed": "// CanonicalURLPath returns the canonical url path for p, which follows the rules:\r\n// 1. the path always starts with \"/\"\r\n// 2. replace multiple slashes with a single slash\r\n// 3. replace each '.' '..' path name element with equivalent one\r\n// 4. keep the trailing slash\r\n// The function is borrowed from stdlib http.cleanPath in server.go.\r\nfunc CanonicalURLPath(p string) string {\r\n\tif p == \"\" {\r\n\t\treturn \"/\"\r\n\t}\r\n\tif p[0] != '/' {\r\n\t\tp = \"/\" + p\r\n\t}\r\n\tnp := path.Clean(p)\r\n\t// path.Clean removes trailing slash except for root,\r\n\t// put the trailing slash back if necessary.\r\n\tif p[len(p)-1] == '/' && np != \"/\" {\r\n\t\tnp += \"/\"\r\n\t}\r\n\treturn np\r\n}", "id": 16319, "concepts": ["path manipulation", "path.Clean", "string manipulation", "string concatenation", "string comparison", "string handling", "string iteration", "string length", "string manipulation", "string replacement", "string slice", "string slicing", "string split", "string trimming", "string type conversion"], "_raw_llm_output": "path manipulation, path.Clean, string manipulation, string concatenation, string comparison, string handling, string iteration, string length, string manipulation, string replacement, string slice, string slicing, string split, string trimming, string type conversion"}
{"seed": "// IsSliceInterfacePtr reports whether v is a slice ptr type.\nfunc IsSliceInterfacePtr(v interface{}) bool {\n\t// Must use ValueOf because Elem().Elem() type resolves dynamically.\n\tvv := reflect.ValueOf(v)\n\treturn vv.Kind() == reflect.Ptr && vv.Elem().Kind() == reflect.Interface && vv.Elem().Elem().Kind() == reflect.Slice\n}", "id": 16321, "concepts": ["reflection", "interface", "slice", "pointer", "dynamic type resolution"], "_raw_llm_output": "reflection, interface, slice, pointer, dynamic type resolution"}
{"seed": "// BulkCreditSamedayFeeLTE applies the LTE predicate on the \"bulkCreditSamedayFee\" field.\nfunc BulkCreditSamedayFeeLTE(v float64) predicate.Bulk {\n\treturn predicate.Bulk(func(s *sql.Selector) {\n\t\ts.Where(sql.LTE(s.C(FieldBulkCreditSamedayFee), v))\n\t})\n}", "id": 16330, "concepts": ["SQL query building", "SQL query building with predicate", "SQL query building with predicate with anonymous function", "SQL query building with predicate with anonymous function with field access", "SQL query building with predicate with anonymous function with field access with comparison", "SQL query building with predicate with anonymous function with field access with comparison with LTE", "SQL query building with predicate with anonymous function with field access with comparison with LTE with float64"], "_raw_llm_output": "SQL query building, SQL query building with predicate, SQL query building with predicate with anonymous function, SQL query building with predicate with anonymous function with field access, SQL query building with predicate with anonymous function with field access with comparison, SQL query building with predicate with anonymous function with field access with comparison with LTE, SQL query building with predicate with anonymous function with field access with comparison with LTE with float64"}
{"seed": "// Generators returns all the various Chrome DevTools Protocol generators.\nfunc Generators() map[string]Generator {\n\treturn map[string]Generator{\n\t\t\"go\": NewGoGenerator,\n\t}\n}", "id": 16331, "concepts": ["map iteration (range loop)", "map creation", "function definition"], "_raw_llm_output": "map iteration (range loop), map creation, function definition"}
{"seed": "// Details_ is a convenience wrapper for Details without the attrs argument.\nfunc Details_(children ...HTML) HTML {\n  return Details(nil, children...)\n}", "id": 16338, "concepts": ["function definition", "variadic argument", "function composition"], "_raw_llm_output": "function definition, variadic argument, function composition"}
{"seed": "// variableSetFromTerms returns a variableSet of the terms that are just Variables.\n// 't' is expected to be the 4 Terms in the order id, subject, predicate, object.\nfunc variableSetFromTerms(t []plandef.Term) variableSet {\n\tvar r variableSet\n\tfor i, t := range t {\n\t\tswitch vt := t.(type) {\n\t\tcase *plandef.Variable:\n\t\t\tr[i] = vt\n\t\tcase *plandef.Binding:\n\t\t\tr[i] = vt.Var\n\t\t}\n\t}\n\treturn r\n}", "id": 16339, "concepts": ["type assertion", "type switch", "type casting", "map iteration"], "_raw_llm_output": "type assertion, type switch, type casting, map iteration"}
{"seed": "// NewNodeList returns a new, empty NodeList\nfunc NewNodeList() *NodeList {\n\treturn &NodeList{\n\t\tNodes: map[string]*Node{},\n\t}\n}", "id": 16340, "concepts": ["map", "struct", "pointer", "basic function definition"], "_raw_llm_output": "map, struct, pointer, basic function definition"}
{"seed": "// SocialTypeLT applies the LT predicate on the \"social_type\" field.\nfunc SocialTypeLT(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.LT(s.C(FieldSocialType), v))\n\t})\n}", "id": 16346, "concepts": ["sql package usage", "predicate definition", "predicate usage"], "_raw_llm_output": "sql package usage, predicate definition, predicate usage"}
{"seed": "// Workplace applies equality check predicate on the \"workplace\" field. It's identical to WorkplaceEQ.\nfunc Workplace(v string) predicate.User {\n\treturn predicate.User(sql.FieldEQ(FieldWorkplace, v))\n}", "id": 16351, "concepts": ["predicate", "sql.FieldEQ"], "_raw_llm_output": "predicate, sql.FieldEQ"}
{"seed": "// SetupLogger sets configuration for the default logger\nfunc SetupLogger() (err error) {\n\tvar (\n\t\tlf = strings.ToLower(viper.GetString(\"output\"))\n\t)\n\n\t// Set log format\n\tswitch lf {\n\tcase \"json\":\n\t\tlog.SetFormatter(&log.JSONFormatter{})\n\tdefault:\n\t\tlog.SetFormatter(&log.TextFormatter{\n\t\t\tDisableLevelTruncation: true,\n\t\t})\n\t}\n\treturn nil\n}", "id": 16362, "concepts": ["viper package usage", "log package usage", "string formatting", "string manipulation", "string comparison"], "_raw_llm_output": "viper package usage, log package usage, string formatting, string manipulation, string comparison"}
{"seed": "// LogResponse inspect the response received from Azure API, process metrics and writes it to the logger.\nfunc LogResponse(logger log.Logger) autorest.RespondDecorator {\n\treturn func(r autorest.Responder) autorest.Responder {\n\t\treturn autorest.ResponderFunc(func(resp *http.Response) error {\n\t\t\tif resp != nil {\n\t\t\t\tprovider, resource := parseServiceURL(resp.Request.URL.Path)\n\t\t\t\tapiRequestCounter.WithLabelValues(provider, resource, strconv.Itoa(resp.StatusCode)).Inc()\n\n\t\t\t\tif logger.GetLogLevel() == log.DebugLevel {\n\t\t\t\t\tif start, ok := resp.Request.Context().Value(timeKey).(time.Time); ok {\n\t\t\t\t\t\tlogger.\n\t\t\t\t\t\t\tWith(\"path\", resp.Request.URL.Path).\n\t\t\t\t\t\t\tWith(\"status\", resp.StatusCode).\n\t\t\t\t\t\t\tWith(\"time\", time.Since(start)).\n\t\t\t\t\t\t\tDebug(\"request\")\n\t\t\t\t\t}\n\n\t\t\t\t\tif dump, e := httputil.DumpResponse(resp, false); e == nil {\n\t\t\t\t\t\tlogger.Debug(string(dump))\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn r.Respond(resp)\n\t\t})\n\t}\n}", "id": 16367, "concepts": ["httputil package usage", "logging", "context", "time", "time.Since", "http.Request.Context", "http.Request.URL", "http.Response.Request.URL", "http.Response.StatusCode", "http.Response.Request.Context", "http.Response.Request.Context", "http.Response.Request.Context", "http.Response.Request.Context", "http.Response.Request.Context", "http.Response.Request.Context", "http.Response.Request.Context", "http.Response.Request.Context", "http.Response.Request.Context", "http.Response.Request.Context", "http.Response.Request.Context", "http.Response.Request.Context", "http.Response.Request.Context", "http.Response.Request.Context", "http.Response.Request.Context", "http.Response.Request.Context", "http.Response.Request.Context", "http.Response.Request.Context", "http.Response.Request.Context", "http.Response.Request.Context", "http.Response.Request.Context", "http.Response.Request.Context", "http.Response.Request.Context", "http.Response.Request.Context", "http.Response.Request.Context", "http.Response.Request.Context", "http.Response.Request."], "_raw_llm_output": "httputil package usage, logging, context, time, time.Since, http.Request.Context, http.Request.URL, http.Response.Request.URL, http.Response.StatusCode, http.Response.Request.Context, http.Response.Request.Context, http.Response.Request.Context, http.Response.Request.Context, http.Response.Request.Context, http.Response.Request.Context, http.Response.Request.Context, http.Response.Request.Context, http.Response.Request.Context, http.Response.Request.Context, http.Response.Request.Context, http.Response.Request.Context, http.Response.Request.Context, http.Response.Request.Context, http.Response.Request.Context, http.Response.Request.Context, http.Response.Request.Context, http.Response.Request.Context, http.Response.Request.Context, http.Response.Request.Context, http.Response.Request.Context, http.Response.Request.Context, http.Response.Request.Context, http.Response.Request.Context, http.Response.Request.Context, http.Response.Request.Context, http.Response.Request."}
{"seed": "// GetLetterCount returns a struct containing letter count of a-z and space.\r\n// Params:\r\n//      textBytes: []byte containing the input string\r\n// Return: A map[string]int where key is character and value is count\r\nfunc getLetterCount(textBytes []byte) map[string]int {\r\n\r\n\tcounts := make(map[string]int)\r\n\r\n\t// Convert to lowercase for counting\r\n\tlowercase := bytesToLowerCase(textBytes)\r\n\tfor _, char := range lowercase {\r\n\t\t// If character is space or [a-z]\r\n\t\tif (char == 0x20) || ((0x61 <= char) && (char <= 0x7A)) {\r\n\t\t\tcounts[string(char)] += 1\r\n\t\t}\r\n\t}\r\n\treturn counts\r\n}", "id": 16369, "concepts": ["string manipulation", "map usage", "character comparison", "byte handling"], "_raw_llm_output": "string manipulation, map usage, character comparison, byte handling"}
{"seed": "// GetDataViewBuilder returns the builder registered for the given scheme.\n// Returns nil if not found.\nfunc GetDataViewBuilder(scheme annotatedvalue.Scheme) DataViewBuilder {\n\treturn registeredDataViewBuilders[scheme]\n}", "id": 16392, "concepts": ["map lookup", "nil value handling"], "_raw_llm_output": "map lookup, nil value handling"}
{"seed": "// l10nTrans returns a translation of a given text\n// according to the chosen language code.\n// Errors are logged.\nfunc l10nTrans(key, lang string) (value string) {\n\tfncname := \"l10nTrans\"\n\n\tpairs, ok := l10nMap[key]\n\tif !ok {\n\t\tlog.Print(fncname+\": no entry for key: \", key)\n\t\treturn key\n\t}\n\tfor _, v := range pairs {\n\t\tif v.Lang == lang {\n\t\t\treturn v.Value\n\t\t}\n\t}\n\t//log.Print(\"l10nTrans: language: \", lang, \" not defined for key: \", key)\n\treturn key\n}", "id": 16397, "concepts": ["map iteration (range loop)", "map lookup", "basic function definition"], "_raw_llm_output": "map iteration (range loop), map lookup, basic function definition"}
{"seed": "// Summary represents the HTML element 'summary'.\n// For more information visit https://www.w3schools.com/tags/tag_summary.asp.\nfunc Summary(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"summary\", Attributes: attrs, Children: children}\n}", "id": 16398, "concepts": ["HTML generation", "HTML tree traversal", "HTML element definition"], "_raw_llm_output": "HTML generation, HTML tree traversal, HTML element definition"}
{"seed": "// MapUint8Int32Ptr takes two inputs -\n// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list\nfunc MapUint8Int32Ptr(f func(*uint8) *int32, list []*uint8) []*int32 {\n\tif f == nil {\n\t\treturn []*int32{}\n\t}\n\tnewList := make([]*int32, len(list))\n\tfor i, v := range list {\n\t\tnewList[i] = f(v)\n\t}\n\treturn newList\n}", "id": 16420, "concepts": ["function definition", "function pointer", "function composition", "function composition with function pointer", "function composition with function pointer and function definition"], "_raw_llm_output": "function definition, function pointer, function composition, function composition with function pointer, function composition with function pointer and function definition"}
{"seed": "// PossibleLoggingDetailsValues returns the possible values for the LoggingDetails const type.\nfunc PossibleLoggingDetailsValues() []LoggingDetails {\n\treturn []LoggingDetails{\n\t\tLoggingDetailsBody,\n\t\tLoggingDetailsNone,\n\t}\n}", "id": 16432, "concepts": ["const declaration", "type conversion", "type assertion"], "_raw_llm_output": "const declaration, type conversion, type assertion"}
{"seed": "// SocialUserIDIn applies the In predicate on the \"social_user_id\" field.\nfunc SocialUserIDIn(vs ...string) predicate.User {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.User(func(s *sql.Selector) {\n\t\t// if not arguments were provided, append the FALSE constants,\n\t\t// since we can't apply \"IN ()\". This will make this predicate falsy.\n\t\tif len(vs) == 0 {\n\t\t\ts.Where(sql.False())\n\t\t\treturn\n\t\t}\n\t\ts.Where(sql.In(s.C(FieldSocialUserID), v...))\n\t})\n}", "id": 16443, "concepts": ["SQL query building", "SQL query execution", "SQL query composition", "SQL query filtering", "SQL query ordering", "SQL query pagination", "SQL query grouping", "SQL query aggregation", "SQL query joining", "SQL query subqueries", "SQL query unions", "SQL query filtering", "SQL query ordering", "SQL query pagination", "SQL query grouping", "SQL query aggregation", "SQL query joining", "SQL query subqueries", "SQL query unions", "SQL query filtering", "SQL query ordering", "SQL query pagination", "SQL query grouping", "SQL query aggregation", "SQL query joining", "SQL query subqueries", "SQL query unions", "SQL query filtering", "SQL query ordering", "SQL query pagination", "SQL query grouping", "SQL query aggregation", "SQL query joining", "SQL query subqueries", "SQL query unions", "SQL query filtering", "SQL query ordering", "SQL query pagination", "SQL query grouping", "SQL query aggregation", "SQL query joining", "SQL query subqueries", "SQL query unions", "SQL query filtering", "SQL query ordering", "SQL query pagination", "SQL query grouping", "SQL query aggregation", "SQL query joining", "SQL query subqueries", "SQL query unions", "SQL query filtering", "SQL query ordering", "SQL query pagination", "SQL query grouping", "SQL query aggregation", "SQL query joining", "SQL query subqueries", "SQL query unions", "SQL query filtering", "SQL"], "_raw_llm_output": "SQL query building, SQL query execution, SQL query composition, SQL query filtering, SQL query ordering, SQL query pagination, SQL query grouping, SQL query aggregation, SQL query joining, SQL query subqueries, SQL query unions, SQL query filtering, SQL query ordering, SQL query pagination, SQL query grouping, SQL query aggregation, SQL query joining, SQL query subqueries, SQL query unions, SQL query filtering, SQL query ordering, SQL query pagination, SQL query grouping, SQL query aggregation, SQL query joining, SQL query subqueries, SQL query unions, SQL query filtering, SQL query ordering, SQL query pagination, SQL query grouping, SQL query aggregation, SQL query joining, SQL query subqueries, SQL query unions, SQL query filtering, SQL query ordering, SQL query pagination, SQL query grouping, SQL query aggregation, SQL query joining, SQL query subqueries, SQL query unions, SQL query filtering, SQL query ordering, SQL query pagination, SQL query grouping, SQL query aggregation, SQL query joining, SQL query subqueries, SQL query unions, SQL query filtering, SQL query ordering, SQL query pagination, SQL query grouping, SQL query aggregation, SQL query joining, SQL query subqueries, SQL query unions, SQL query filtering, SQL"}
{"seed": "// FindProjectConfigFilePath traverses directory structure looking for an outrigger project config file.\nfunc FindProjectConfigFilePath() (string, error) {\n\tif cwd, err := os.Getwd(); err == nil {\n\t\tvar configFilePath string\n\t\tfor cwd != \".\" && cwd != string(filepath.Separator) {\n\t\t\tfor _, filename := range [2]string{\"outrigger.yml\", \".outrigger.yml\"} {\n\t\t\t\tconfigFilePath = filepath.Join(cwd, filename)\n\t\t\t\tif _, e := os.Stat(configFilePath); !os.IsNotExist(e) {\n\t\t\t\t\treturn configFilePath, nil\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcwd = filepath.Dir(cwd)\n\t\t}\n\t} else {\n\t\treturn \"\", err\n\t}\n\n\treturn \"\", errors.New(\"no outrigger configuration file found\")\n}", "id": 16444, "concepts": ["os.Getwd", "filepath.Join", "filepath.Dir", "os.Stat", "errors.New", "error handling"], "_raw_llm_output": "os.Getwd, filepath.Join, filepath.Dir, os.Stat, errors.New, error handling"}
{"seed": "// NewModuleProxy builds a module database backed by the module proxy API at the\n// supplied base URL, using the given HTTP client for requests.\nfunc NewModuleProxy(c *http.Client, u *url.URL) ModuleDatabase {\n\treturn &modproxy{\n\t\tc:   c,\n\t\turl: u,\n\t}\n}", "id": 16445, "concepts": ["module proxy", "HTTP client", "URL parsing"], "_raw_llm_output": "module proxy, HTTP client, URL parsing"}
{"seed": "// MigrateGenState accepts exported v0.43 x/bank genesis state and migrates it to\n// v0.47 x/bank genesis state. The migration includes:\n// - Move the SendEnabled entries from Params to the new GenesisState.SendEnabled field.\nfunc MigrateGenState(oldState *types.GenesisState) *types.GenesisState {\n\tnewState := *oldState\n\tnewState.MigrateSendEnabled()\n\treturn &newState\n}", "id": 16449, "concepts": ["struct field access", "struct field assignment", "struct field initialization", "struct field migration"], "_raw_llm_output": "struct field access, struct field assignment, struct field initialization, struct field migration"}
{"seed": "// PrivateKeyToKeysetHandle converts privKey into a *keyset.Handle where privKey could be either a sender or a\n// recipient key. The resulting handle cannot be directly used for primitive execution as the cek is not set. This\n// function serves as a helper to get a senderKH to be used as an option for ECDH execution (for ECDH-1PU/authcrypt).\n// The keyset handle will be set with either AES256-GCM, AES128CBC+SHA256, AES192CBC+SHA384, AES256CBC+SHA384 or\n// AES256CBC+SHA512 AEAD key template for content encryption. With:\n// - privKey the private key to convert.\n// - aeadAlg the content encryption algorithm to use along the ECDH primitive.\nfunc PrivateKeyToKeysetHandle(privKey *cryptoapi.PrivateKey, aeadAlg ecdh.AEADAlg) (*keyset.Handle, error) {\n\treturn keyio.PrivateKeyToKeysetHandle(privKey, aeadAlg)\n}", "id": 16450, "concepts": ["crypto/ed25519", "crypto/aes", "crypto/sha256", "crypto/sha384", "crypto/sha512", "crypto/rand", "crypto/subtle", "crypto/cipher", "crypto/subtle", "crypto/subtle", "crypto/subtle", "crypto/subtle", "crypto/subtle", "crypto/subtle", "crypto/subtle", "crypto/subtle", "crypto/subtle", "crypto/subtle", "crypto/subtle", "crypto/subtle", "crypto/subtle", "crypto/subtle", "crypto/subtle", "crypto/subtle", "crypto/subtle", "crypto/subtle", "crypto/subtle", "crypto/subtle", "crypto/subtle", "crypto/subtle", "crypto/subtle", "crypto/subtle", "crypto/subtle", "crypto/subtle", "crypto/subtle", "crypto/subtle", "crypto/subtle", "crypto/subtle", "crypto/subtle", "crypto/subtle", "crypto/subtle", "crypto/subtle", "crypto/subtle", "crypto/subtle", "crypto/subtle", "crypto/subtle", "crypto/subtle", "crypto/subtle", "crypto/subtle", "crypto/sub"], "_raw_llm_output": "crypto/ed25519, crypto/aes, crypto/sha256, crypto/sha384, crypto/sha512, crypto/rand, crypto/subtle, crypto/cipher, crypto/subtle, crypto/subtle, crypto/subtle, crypto/subtle, crypto/subtle, crypto/subtle, crypto/subtle, crypto/subtle, crypto/subtle, crypto/subtle, crypto/subtle, crypto/subtle, crypto/subtle, crypto/subtle, crypto/subtle, crypto/subtle, crypto/subtle, crypto/subtle, crypto/subtle, crypto/subtle, crypto/subtle, crypto/subtle, crypto/subtle, crypto/subtle, crypto/subtle, crypto/subtle, crypto/subtle, crypto/subtle, crypto/subtle, crypto/subtle, crypto/subtle, crypto/subtle, crypto/subtle, crypto/subtle, crypto/subtle, crypto/subtle, crypto/subtle, crypto/subtle, crypto/subtle, crypto/subtle, crypto/subtle, crypto/sub"}
{"seed": "// RecentTasksActivityNameASC function sorts data by Name field in ascending order\n// sorting layers: Name > LRStatus(ASC) > LRTime(DESC)\n// function chain according to sorting layers: RecentTasksActivityNameASC > NameSubsortingByLRStatusASC > LRStatusSubsortingByLRTimeDESC\nfunc RecentTasksActivityNameASC(p1, p2 interface{}) bool {\n\tp1Name := p1.(RecentTasksActivity).Task.Name\n\tp2Name := p2.(RecentTasksActivity).Task.Name\n\n\tif p1Name == p2Name {\n\t\treturn NameSubsortingByLRStatusASC(p1, p2)\n\t}\n\n\treturn Relay.StringLessOp(p1Name, p2Name)\n}", "id": 16451, "concepts": ["interface", "sorting", "sorting by multiple fields"], "_raw_llm_output": "interface, sorting, sorting by multiple fields"}
{"seed": "// RequireFromSegments is similar to FromSegments except that instead of\n// returning an error on malformed input, it panics. It should only be used\n// when the input is statically verifiable.\nfunc RequireFromSegments(td TrustDomain, segments ...string) ID {\n\tid, err := FromSegments(td, segments...)\n\tpanicOnErr(err)\n\treturn id\n}", "id": 16453, "concepts": ["panic", "error handling", "panicOnErr function definition"], "_raw_llm_output": "panic, error handling, panicOnErr function definition"}
{"seed": "// NewCatalogProductRepositoryV1SavePutParamsWithContext creates a new CatalogProductRepositoryV1SavePutParams object\n// with the default values initialized, and the ability to set a context for a request\nfunc NewCatalogProductRepositoryV1SavePutParamsWithContext(ctx context.Context) *CatalogProductRepositoryV1SavePutParams {\n\tvar ()\n\treturn &CatalogProductRepositoryV1SavePutParams{\n\n\t\tContext: ctx,\n\t}\n}", "id": 16455, "concepts": ["context package usage", "struct initialization", "anonymous function", "function definition"], "_raw_llm_output": "context package usage, struct initialization, anonymous function, function definition"}
{"seed": "// Int64 returns the first non-zero value in the argument list\nfunc Int64(values ...int64) int64 {\n\tfor index := range values {\n\t\tif values[index] != 0 {\n\t\t\treturn values[index]\n\t\t}\n\t}\n\treturn 0\n}", "id": 16458, "concepts": ["variadic function", "basic function definition"], "_raw_llm_output": "variadic function, basic function definition"}
{"seed": "// NewTooManyGlobalAdminsAssignedToTenantAlertConfiguration instantiates a new tooManyGlobalAdminsAssignedToTenantAlertConfiguration and sets the default values.\nfunc NewTooManyGlobalAdminsAssignedToTenantAlertConfiguration()(*TooManyGlobalAdminsAssignedToTenantAlertConfiguration) {\n    m := &TooManyGlobalAdminsAssignedToTenantAlertConfiguration{\n        UnifiedRoleManagementAlertConfiguration: *NewUnifiedRoleManagementAlertConfiguration(),\n    }\n    odataTypeValue := \"#microsoft.graph.tooManyGlobalAdminsAssignedToTenantAlertConfiguration\"\n    m.SetOdataType(&odataTypeValue)\n    return m\n}", "id": 16481, "concepts": ["struct definition", "pointer usage", "method definition", "method invocation", "method setters", "method getters"], "_raw_llm_output": "struct definition, pointer usage, method definition, method invocation, method setters, method getters"}
{"seed": "// CreatedAtGT applies the GT predicate on the \"created_at\" field.\nfunc CreatedAtGT(v time.Time) predicate.User {\n\treturn predicate.User(sql.FieldGT(FieldCreatedAt, v))\n}", "id": 16497, "concepts": ["struct composition", "interface composition", "struct field access", "predicate composition", "SQL field comparison"], "_raw_llm_output": "struct composition, interface composition, struct field access, predicate composition, SQL field comparison"}
{"seed": "// GetHorizontalPodAutoscalerList gets an existing HorizontalPodAutoscalerList resource's state with the given name, ID, and optional\n// state properties that are used to uniquely qualify the lookup (nil if not required).\nfunc GetHorizontalPodAutoscalerList(ctx *pulumi.Context,\n\tname string, id pulumi.IDInput, state *HorizontalPodAutoscalerListState, opts ...pulumi.ResourceOption) (*HorizontalPodAutoscalerList, error) {\n\tvar resource HorizontalPodAutoscalerList\n\terr := ctx.ReadResource(\"kubernetes:autoscaling/v1:HorizontalPodAutoscalerList\", name, id, state, &resource, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &resource, nil\n}", "id": 16498, "concepts": ["kubernetes provider usage", "resource creation", "resource state handling", "resource lookup"], "_raw_llm_output": "kubernetes provider usage, resource creation, resource state handling, resource lookup"}
{"seed": "// RejectPlain rejects any plain text encoded password.\n// Be careful: This matches any line, so it *must* be the last parser in you list.\nfunc RejectPlain(pw string) (EncodedPasswd, error) {\n\treturn nil, fmt.Errorf(\"plain password rejected: %s\", pw)\n}", "id": 16505, "concepts": ["error handling (fmt.Errorf)", "basic function definition"], "_raw_llm_output": "error handling (fmt.Errorf), basic function definition"}
{"seed": "//NewFile returns a new file with the function parameters as entries.\nfunc NewFile(name string, size uint64, metafilehash []byte) File {\n\treturn File{\n\t\tName:         name,\n\t\tSize:         size,\n\t\tMetafileHash: metafilehash,\n\t}\n}", "id": 16519, "concepts": ["struct definition", "struct field definition"], "_raw_llm_output": "struct definition, struct field definition"}
{"seed": "// Big_ is a convenience wrapper for Big without the attrs argument.\nfunc Big_(children ...HTML) HTML {\n  return Big(nil, children...)\n}", "id": 16520, "concepts": ["HTML package usage", "function definition", "basic function definition"], "_raw_llm_output": "HTML package usage, function definition, basic function definition"}
{"seed": "// NewDcimRacksListParamsWithContext creates a new DcimRacksListParams object\n// with the ability to set a context for a request.\nfunc NewDcimRacksListParamsWithContext(ctx context.Context) *DcimRacksListParams {\n\treturn &DcimRacksListParams{\n\t\tContext: ctx,\n\t}\n}", "id": 16521, "concepts": ["context package usage", "function definition"], "_raw_llm_output": "context package usage, function definition"}
{"seed": "// TitleContains applies the Contains predicate on the \"title\" field.\nfunc TitleContains(v string) predicate.User {\n\treturn predicate.User(sql.FieldContains(FieldTitle, v))\n}", "id": 16526, "concepts": ["predicate.User", "sql.FieldContains", "sql.Field"], "_raw_llm_output": "predicate.User, sql.FieldContains, sql.Field"}
{"seed": "// NewGetCwfNetworkIDGatewaysGatewayIDParamsWithTimeout creates a new GetCwfNetworkIDGatewaysGatewayIDParams object\n// with the default values initialized, and the ability to set a timeout on a request\nfunc NewGetCwfNetworkIDGatewaysGatewayIDParamsWithTimeout(timeout time.Duration) *GetCwfNetworkIDGatewaysGatewayIDParams {\n\tvar ()\n\treturn &GetCwfNetworkIDGatewaysGatewayIDParams{\n\n\t\ttimeout: timeout,\n\t}\n}", "id": 16534, "concepts": ["struct initialization", "timeout handling", "function definition"], "_raw_llm_output": "struct initialization, timeout handling, function definition"}
{"seed": "/*\nCreateUnit creates a new unit for converting arbitrary measurement units to\nengine units.\n*/\nfunc CreateUnit(aspect float32) *Unit {\n\treturn &Unit{aspect: aspect}\n}", "id": 16537, "concepts": ["struct definition", "basic function definition"], "_raw_llm_output": "struct definition, basic function definition"}
{"seed": "// WithChart is an Option that configures a Reconciler's helm chart.\n//\n// This option is required.\nfunc WithChart(chrt chart.Chart) Option {\n\treturn func(r *Reconciler) error {\n\t\tr.chrt = &chrt\n\t\treturn nil\n\t}\n}", "id": 16552, "concepts": ["struct", "interface", "function composition", "option pattern", "error handling"], "_raw_llm_output": "struct, interface, function composition, option pattern, error handling"}
{"seed": "// PossiblePolicyRequestBodyCheckValues returns an array of possible values for the PolicyRequestBodyCheck const type.\nfunc PossiblePolicyRequestBodyCheckValues() []PolicyRequestBodyCheck {\n\treturn []PolicyRequestBodyCheck{PolicyRequestBodyCheckDisabled, PolicyRequestBodyCheckEnabled}\n}", "id": 16553, "concepts": ["const", "array", "array iteration"], "_raw_llm_output": "const, array, array iteration"}
{"seed": "// SocialUserIDHasSuffix applies the HasSuffix predicate on the \"social_user_id\" field.\nfunc SocialUserIDHasSuffix(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.HasSuffix(s.C(FieldSocialUserID), v))\n\t})\n}", "id": 16579, "concepts": ["sql.Selector", "sql.HasSuffix", "predicate.User", "anonymous function"], "_raw_llm_output": "sql.Selector, sql.HasSuffix, predicate.User, anonymous function"}
{"seed": "// nclients cas to the same file. At the end the file should be any one clients' last write.\n// The only difference between this test and the ConcurrentWrite test above is that each\n// client loops around until each CAS succeeds. The number of concurrent clients has been\n// reduced to keep the testing time within limits.\nfunc PTestRPC_ConcurrentCas(t *testing.T) {\n\tnclients := 3\n\tniters := 3\n\n\tclients := make([]*Client, nclients)\n\tfor i := 0; i < nclients; i++ {\n\t\tcl := mkClientUrl(t, leaderUrl)\n\t\tif cl == nil {\n\t\t\tt.Fatalf(\"Unable to create client #%d\", i)\n\t\t}\n\t\tdefer cl.close()\n\t\tclients[i] = cl\n\t}\n\n\tvar sem sync.WaitGroup // Used as a semaphore to coordinate goroutines to *begin* concurrently\n\tsem.Add(1)\n\n\tm, _ := clients[0].write(\"concCas\", \"first\", 0)\n\tver := m.Version\n\tif m.Kind != 'O' || ver == 0 {\n\t\tt.Fatalf(\"Expected write to succeed and return version\")\n\t}\n\n\tvar wg sync.WaitGroup\n\twg.Add(nclients)\n\n\terrorCh := make(chan error, nclients)\n\n\tfor i := 0; i < nclients; i++ {\n\t\tgo func(i int, ver int, cl *Client) {\n\t\t\tsem.Wait()\n\t\t\tdefer wg.Done()\n\t\t\tfor j := 0; j < niters; j++ {\n\t\t\t\tstr := fmt.Sprintf(\"cl %d %d\", i, j)\n\t\t\t\tfor {\n\t\t\t\t\tm, err := cl.cas(\"concCas\", ver, str, 0)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\terrorCh <- err\n\t\t\t\t\t\treturn\n\t\t\t\t\t} else if m.Kind == 'O' {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t} else if m.Kind != 'V' {\n\t\t\t\t\t\terrorCh <- errors.New(fmt.Sprintf(\"Expected 'V' msg, got %c\", m.Kind))\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tver = m.Version // retry with latest version\n\t\t\t\t}\n\t\t\t}\n\t\t}(i, ver, clients[i])\n\t}\n\n\tsem.Done()                          // Start goroutines\n\ttime.Sleep(1000 * time.Millisecond) // give goroutines a chance\n\twg.Wait()                           // Wait for them to finish\n\ttime.Sleep(10 * time.Second)\n\n\tselect {\n\tcase e := <-errorCh:\n\t\tt.Fatalf(\"Error received while doing cas: %v\", e)\n\tdefault: // no errors\n\t}\n\tm, _ = clients[0].read(\"concCas\")\n\tif !(m.Kind == 'C' && strings.HasSuffix(string(m.Contents), \" 2\")) {\n\t\tt.Fatalf(\"Expected to be able to read after 1000 writes. Got msg.Kind = %d, msg.Contents=%s\", m.Kind, m.Contents)\n\t}\n}", "id": 16581, "concepts": ["concurrency", "sync.WaitGroup", "sync.Mutex", "sync.Once", "sync.Cond", "sync.Map", "sync.Pool", "sync.Once", "sync.WaitGroup", "sync.RWMutex", "sync.RWMutex", "sync.WaitGroup", "sync.WaitGroup", "sync.WaitGroup", "sync.WaitGroup", "sync.WaitGroup", "sync.WaitGroup", "sync.WaitGroup", "sync.WaitGroup", "sync.WaitGroup", "sync.WaitGroup", "sync.WaitGroup", "sync.WaitGroup", "sync.WaitGroup", "sync.WaitGroup", "sync.WaitGroup", "sync.WaitGroup", "sync.WaitGroup", "sync.WaitGroup", "sync.WaitGroup", "sync.WaitGroup", "sync.WaitGroup", "sync.WaitGroup", "sync.WaitGroup", "sync.WaitGroup", "sync.WaitGroup", "sync.WaitGroup", "sync.WaitGroup", "sync.WaitGroup", "sync.WaitGroup", "sync.WaitGroup", "sync.WaitGroup", "sync.WaitGroup", "sync.WaitGroup", "sync.WaitGroup", "sync.WaitGroup", "sync.WaitGroup", "sync.WaitGroup", "sync.WaitGroup", "sync.WaitGroup", "sync.WaitGroup", "sync.WaitGroup", "sync.WaitGroup"], "_raw_llm_output": "concurrency, sync.WaitGroup, sync.Mutex, sync.Once, sync.Cond, sync.Map, sync.Pool, sync.Once, sync.WaitGroup, sync.RWMutex, sync.RWMutex, sync.WaitGroup, sync.WaitGroup, sync.WaitGroup, sync.WaitGroup, sync.WaitGroup, sync.WaitGroup, sync.WaitGroup, sync.WaitGroup, sync.WaitGroup, sync.WaitGroup, sync.WaitGroup, sync.WaitGroup, sync.WaitGroup, sync.WaitGroup, sync.WaitGroup, sync.WaitGroup, sync.WaitGroup, sync.WaitGroup, sync.WaitGroup, sync.WaitGroup, sync.WaitGroup, sync.WaitGroup, sync.WaitGroup, sync.WaitGroup, sync.WaitGroup, sync.WaitGroup, sync.WaitGroup, sync.WaitGroup, sync.WaitGroup, sync.WaitGroup, sync.WaitGroup, sync.WaitGroup, sync.WaitGroup, sync.WaitGroup, sync.WaitGroup, sync.WaitGroup, sync.WaitGroup, sync.WaitGroup, sync.WaitGroup, sync.WaitGroup, sync.WaitGroup, sync.WaitGroup"}
{"seed": "// ApogeeParallax returns equatorial horizontal parallax of the Moon at the Apogee nearest the given date.\n//\n// Year is a decimal year specifying a date.\nfunc ApogeeParallax(year float64) unit.Angle {\n\treturn newLa(year, .5).ap()\n}", "id": 16585, "concepts": ["struct", "method definition", "method receiver", "method call", "method chaining", "method composition", "method composition with anonymous function", "method composition with anonymous function and method call", "method composition with anonymous function and method call", "method composition with anonymous function and method call", "method composition with anonymous function and method call", "method composition with anonymous function and method call", "method composition with anonymous function and method call", "method composition with anonymous function and method call", "method composition with anonymous function and method call", "method composition with anonymous function and method call", "method composition with anonymous function and method call", "method composition with anonymous function and method call", "method composition with anonymous function and method call", "method composition with anonymous function and method call", "method composition with anonymous function and method call", "method composition with anonymous function and method call", "method composition with anonymous function and method call", "method composition with anonymous function and method call", "method composition with anonymous function and method call", "method composition with anonymous function and method call", "method composition with anonymous function and method call", "method composition with anonymous function and method call", "method composition with anonymous function and method call", "method composition with anonymous function and method call", "method composition with anonymous function and method call", "method composition with anonymous function and method call", "method composition with anonymous function and method"], "_raw_llm_output": "struct, method definition, method receiver, method call, method chaining, method composition, method composition with anonymous function, method composition with anonymous function and method call, method composition with anonymous function and method call, method composition with anonymous function and method call, method composition with anonymous function and method call, method composition with anonymous function and method call, method composition with anonymous function and method call, method composition with anonymous function and method call, method composition with anonymous function and method call, method composition with anonymous function and method call, method composition with anonymous function and method call, method composition with anonymous function and method call, method composition with anonymous function and method call, method composition with anonymous function and method call, method composition with anonymous function and method call, method composition with anonymous function and method call, method composition with anonymous function and method call, method composition with anonymous function and method call, method composition with anonymous function and method call, method composition with anonymous function and method call, method composition with anonymous function and method call, method composition with anonymous function and method call, method composition with anonymous function and method call, method composition with anonymous function and method call, method composition with anonymous function and method call, method composition with anonymous function and method call, method composition with anonymous function and method"}
{"seed": "// NewConfigEudore \u521b\u5efa\u4e00\u4e2aConfigEudore\uff0c\u5982\u679c\u4f20\u5165\u53c2\u6570\u4e3a\u7a7a\uff0c\u4f7f\u7528\u7a7amap[string]interface{}\u4f5c\u4e3a\u521d\u59cb\u5316\u6570\u636e\u3002\n//\n// ConfigEduoew\u5141\u8bb8\u4f20\u5165\u4e00\u4e2amap\u6216struct\u4f5c\u4e3a\u914d\u7f6e\u5b58\u50a8\uff0c\u4f7f\u7528eudore.Set\u548ceudore.Get\u65b9\u6cd5\u53bb\u8bfb\u5199\u6570\u636e\u3002\n//\n// \u5982\u679c\u4f20\u5165\u7684\u914d\u7f6e\u5bf9\u8c61\u5b9e\u73b0sync.RLock\u4e00\u6837\u7684\u8bfb\u5199\u9501\uff0c\u5219\u4f7f\u7528\u914d\u7f6e\u7684\u8bfb\u5199\u9501\uff0c\u5426\u5219\u4f1a\u521b\u5efa\u4e00\u4e2async.RWMutex\u9501\u3002\n//\n// ConfigEduoe\u5df2\u5b9e\u73b0json.Marshaler\u548cjson.Unmarshaler\u63a5\u53e3.\nfunc NewConfigEudore(i interface{}) Config {\n\tif i == nil {\n\t\ti = make(map[string]interface{})\n\t}\n\tmu, ok := i.(configRLocker)\n\tif !ok {\n\t\tmu = new(sync.RWMutex)\n\t}\n\treturn &configEudore{\n\t\tKeys:          i,\n\t\tPrint:         printEmpty,\n\t\tfuncs:         ConfigAllParseFunc,\n\t\tconfigRLocker: mu,\n\t}\n}", "id": 16595, "concepts": ["interface", "map", "struct", "sync.RWMutex", "sync.Locker", "basic function definition"], "_raw_llm_output": "interface, map, struct, sync.RWMutex, sync.Locker, basic function definition"}
{"seed": "// bazelConversionRequested checks that the user is intending to convert\n// Blueprint to Bazel BUILD files.\nfunc bazelConversionRequested(configuration android.Config) bool {\n\treturn configuration.IsEnvTrue(\"CONVERT_TO_BAZEL\")\n}", "id": 16597, "concepts": ["environment variable handling", "boolean comparison"], "_raw_llm_output": "environment variable handling, boolean comparison"}
{"seed": "// readAllEntriesFromFile reads in all log entries from a given file that are\n// between the 'startTimestamp' and 'endTimestamp' and match the 'pattern' if it\n// exists. It returns the entries in the reverse chronological order. It also\n// returns a flag that denotes if any timestamp occurred before the\n// 'startTimestamp' to inform the caller that no more log files need to be\n// processed. If the number of entries returned exceeds 'maxEntries' then\n// processing of new entries is stopped immediately.\nfunc readAllEntriesFromFile(\n\tfile FileInfo, startTimestamp, endTimestamp int64, maxEntries int, pattern *regexp.Regexp,\n) ([]Entry, bool, error) {\n\treader, err := GetLogReader(file.Name, true /* restricted */)\n\tif reader == nil || err != nil {\n\t\treturn nil, false, err\n\t}\n\tdefer reader.Close()\n\tentries := []Entry{}\n\tdecoder := NewEntryDecoder(reader)\n\tentryBeforeStart := false\n\tfor {\n\t\tentry := Entry{}\n\t\tif err := decoder.Decode(&entry); err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn nil, false, err\n\t\t}\n\t\tvar match bool\n\t\tif pattern == nil {\n\t\t\tmatch = true\n\t\t} else {\n\t\t\tmatch = pattern.MatchString(entry.Message) ||\n\t\t\t\tpattern.MatchString(entry.File)\n\t\t}\n\t\tif match && entry.Time >= startTimestamp && entry.Time <= endTimestamp {\n\t\t\tentries = append([]Entry{entry}, entries...)\n\t\t\tif len(entries) >= maxEntries {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif entry.Time < startTimestamp {\n\t\t\tentryBeforeStart = true\n\t\t}\n\n\t}\n\treturn entries, entryBeforeStart, nil\n}", "id": 16605, "concepts": ["file reading", "io.Reader", "io.EOF", "io.ReadCloser", "io.Closer", "io.Writer", "io.WriterAt", "io.Seeker", "io.Seek", "io.SeekEnd", "io.SeekCurrent", "io.SeekStart", "io.ReadAtLeast", "io.ReadFull", "io.ReadAtMost", "io.ReadSlice", "io.ReadFrom", "io.Copy", "io.CopyBuffer", "io.CopyN", "io.TeeReader", "io.MultiReader", "io.LimitReader", "io.SectionReader", "io.ByteReader", "io.RuneReader", "io.ReaderFrom", "io.WriterTo", "io.Writer", "io.WriterAt", "io.Seeker", "io.Seek", "io.SeekEnd", "io.SeekCurrent", "io.SeekStart", "io.Reader", "io.ByteScanner", "io.RuneScanner", "io.ByteWriter", "io.RuneWriter", "io.ByteReader", "io.RuneReader", "io.ByteScanner", "io.RuneScanner", "io.ByteWriter", "io.RuneWriter", "io.ByteReader", "io.RuneReader", "io.ByteScanner", "io.RuneScanner", "io.ByteWriter", "io.RuneWriter", "io.Byte"], "_raw_llm_output": "file reading, io.Reader, io.EOF, io.ReadCloser, io.Closer, io.Writer, io.WriterAt, io.Seeker, io.Seek, io.SeekEnd, io.SeekCurrent, io.SeekStart, io.ReadAtLeast, io.ReadFull, io.ReadAtMost, io.ReadSlice, io.ReadFrom, io.Copy, io.CopyBuffer, io.CopyN, io.TeeReader, io.MultiReader, io.LimitReader, io.SectionReader, io.ByteReader, io.RuneReader, io.ReaderFrom, io.WriterTo, io.Writer, io.WriterAt, io.Seeker, io.Seek, io.SeekEnd, io.SeekCurrent, io.SeekStart, io.Reader, io.ByteScanner, io.RuneScanner, io.ByteWriter, io.RuneWriter, io.ByteReader, io.RuneReader, io.ByteScanner, io.RuneScanner, io.ByteWriter, io.RuneWriter, io.ByteReader, io.RuneReader, io.ByteScanner, io.RuneScanner, io.ByteWriter, io.RuneWriter, io.Byte"}
{"seed": "// Sum takes two integers, adds them together and returns int\nfunc Sum(i1 int, i2 int) int {\n\treturn i1 + i2\n}", "id": 16617, "concepts": ["integer addition", "basic function definition"], "_raw_llm_output": "integer addition, basic function definition"}
{"seed": "// NewFileMap creates a File Map, complete with pre-loaded line entries to\n// map from offset to (row,col) coordinates.\nfunc NewFileMap(filename string) (*FileMap, error) {\n\tbufb, err := ioutil.ReadFile(filename)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbuf := string(bufb)\n\tfm := FileMap{\n\t\tFilename:  filename,\n\t\tText:      buf,\n\t\tCheckText: createCheckText(buf),\n\t\tLines:     make([]lineEntry, 0, (len(buf)/32)+1),\n\t}\n\n\t// create lines\n\tbegin := 0\n\tfor idx, run := range fm.Text {\n\t\tif unicode.IsSpace(run) && string(run) == \"\\n\" {\n\t\t\tend := idx\n\t\t\tfm.Lines = append(fm.Lines, lineEntry{begin, end})\n\t\t\tbegin = end + 1\n\t\t}\n\t}\n\n\t// Anything left?\n\tend := len(fm.Text)\n\tif begin <= end {\n\t\tfm.Lines = append(fm.Lines, lineEntry{begin, end})\n\t}\n\n\treturn &fm, nil\n}", "id": 16619, "concepts": ["string manipulation", "string iteration", "rune handling", "unicode handling", "string comparison", "basic function definition", "basic struct definition", "basic slice definition"], "_raw_llm_output": "string manipulation, string iteration, rune handling, unicode handling, string comparison, basic function definition, basic struct definition, basic slice definition"}
{"seed": "// FindPhenotypepropP retrieves a single record by ID with an executor, and panics on error.\nfunc FindPhenotypepropP(exec boil.Executor, phenotypepropID int, selectCols ...string) *Phenotypeprop {\n\tretobj, err := FindPhenotypeprop(exec, phenotypepropID, selectCols...)\n\tif err != nil {\n\t\tpanic(boil.WrapErr(err))\n\t}\n\n\treturn retobj\n}", "id": 16622, "concepts": ["panic", "boil package usage"], "_raw_llm_output": "panic, boil package usage"}
{"seed": "// TitleHasSuffix applies the HasSuffix predicate on the \"title\" field.\nfunc TitleHasSuffix(v string) predicate.User {\n\treturn predicate.User(sql.FieldHasSuffix(FieldTitle, v))\n}", "id": 16637, "concepts": ["predicate", "sql.FieldHasSuffix", "sql.Field"], "_raw_llm_output": "predicate, sql.FieldHasSuffix, sql.Field"}
{"seed": "// NewNameHasSuffix applies the HasSuffix predicate on the \"new_name\" field.\nfunc NewNameHasSuffix(v string) predicate.User {\n\treturn predicate.User(sql.FieldHasSuffix(FieldNewName, v))\n}", "id": 16638, "concepts": ["predicate", "sql package usage"], "_raw_llm_output": "predicate, sql package usage"}
{"seed": "// convertValueTo converts the value to the specified type and returns the new\n// value. The value and type must differ only by pointer indirection. If the\n// specified type requires additional pointers new pointers will be created\n// pointing to the address of v. If fewer pointers are required the value will\n// be dereferenced the necessary amount. If a nil pointer is encountered that\n// requires dereferencing the types zero value will be returned.\nfunc convertValueTo(v reflect.Value, typ reflect.Type) (reflect.Value, error) {\n\tif v.Type() == typ {\n\t\treturn v, nil\n\t}\n\ttypBaseType := typ\n\ttypPtrDepth := 0\n\tfor typBaseType.Kind() == reflect.Ptr {\n\t\ttypPtrDepth++\n\t\ttypBaseType = typBaseType.Elem()\n\t}\n\tvBaseType := v.Type()\n\tvPtrDepth := 0\n\tfor vBaseType.Kind() == reflect.Ptr {\n\t\tvPtrDepth++\n\t\tvBaseType = vBaseType.Elem()\n\t}\n\tswitch {\n\tcase vBaseType != typBaseType:\n\t\treturn reflect.Zero(typ), fmt.Errorf(\"cannot convert between %v and %v: differ by more than pointer indirection\", v.Type(), typ)\n\tcase vPtrDepth == typPtrDepth:\n\t\treturn v, nil\n\tcase vPtrDepth < typPtrDepth:\n\t\tfor v.Type() != typ {\n\t\t\tx := reflect.New(v.Type())\n\t\t\tx.Elem().Set(v)\n\t\t\tv = x\n\t\t}\n\t\treturn v, nil\n\tcase vPtrDepth > typPtrDepth:\n\t\tfor v.Type() != typ {\n\t\t\tif v.IsNil() {\n\t\t\t\tv = reflect.Zero(v.Type().Elem())\n\t\t\t} else {\n\t\t\t\tv = v.Elem()\n\t\t\t}\n\t\t}\n\t\treturn v, nil\n\t}\n\treturn reflect.Zero(typ), errors.New(\"unreachable\")\n}", "id": 16643, "concepts": ["reflect package usage", "pointer indirection", "type comparison", "type conversion"], "_raw_llm_output": "reflect package usage, pointer indirection, type comparison, type conversion"}
{"seed": "// Canvas_ is a convenience wrapper for Canvas without the attrs argument.\nfunc Canvas_(children ...HTML) HTML {\n  return Canvas(nil, children...)\n}", "id": 16663, "concepts": ["function composition", "HTML rendering", "function argument handling"], "_raw_llm_output": "function composition, HTML rendering, function argument handling"}
{"seed": "// OutputJSON takes an object and prints it as a JSON string to the stdout.\n// If the pretty attribute is set to true, the JSON will be idented for easy reading.\nfunc OutputJSON(data interface{}, pretty bool) error {\n\tvar output []byte\n\tvar err error\n\n\tif pretty {\n\t\toutput, err = json.MarshalIndent(data, \"\", \"\\t\")\n\t} else {\n\t\toutput, err = json.Marshal(data)\n\t}\n\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Error outputting JSON: %s\", err)\n\t}\n\n\tif string(output) == \"null\" {\n\t\tfmt.Println(\"[]\")\n\t} else {\n\t\tfmt.Println(string(output))\n\t}\n\n\treturn nil\n}", "id": 16676, "concepts": ["JSON marshalling", "JSON unmarshalling", "fmt package usage"], "_raw_llm_output": "JSON marshalling, JSON unmarshalling, fmt package usage"}
{"seed": "// Patch sets the value pointed to by the given destination to the given\n// value, and returns a function to restore it to its original value.  The\n// value must be assignable to the element type of the destination.\nfunc Patch(dest, value interface{}) Restorer {\n\tdestv := reflect.ValueOf(dest).Elem()\n\toldv := reflect.New(destv.Type()).Elem()\n\toldv.Set(destv)\n\tvaluev := reflect.ValueOf(value)\n\tif !valuev.IsValid() {\n\t\t// This isn't quite right when the destination type is not\n\t\t// nilable, but it's better than the complex alternative.\n\t\tvaluev = reflect.Zero(destv.Type())\n\t}\n\tdestv.Set(valuev)\n\treturn func() {\n\t\tdestv.Set(oldv)\n\t}\n}", "id": 16681, "concepts": ["reflect package usage", "interface", "function definition", "function closure", "pointer", "reflection"], "_raw_llm_output": "reflect package usage, interface, function definition, function closure, pointer, reflection"}
{"seed": "// UpdatedAt applies equality check predicate on the \"updated_at\" field. It's identical to UpdatedAtEQ.\nfunc UpdatedAt(v time.Time) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldUpdatedAt), v))\n\t})\n}", "id": 16687, "concepts": ["sql.Selector", "sql.EQ", "sql.Where", "sql.C", "sql.Field", "time.Time", "predicate.User", "predicate.UserEQ"], "_raw_llm_output": "sql.Selector, sql.EQ, sql.Where, sql.C, sql.Field, time.Time, predicate.User, predicate.UserEQ"}
{"seed": "// ValidateCardInHand Determines if the request card is in the entities hand.\nfunc ValidateCardInHand(activeEntity *deviant.Entity, requestedPlayAction *deviant.EntityPlayAction, encounter *deviant.Encounter, logger *zap.SugaredLogger) bool {\n\tstatus := false\n\n\tfor _, card := range encounter.ActiveEntity.Hand.Cards {\n\t\tif card.InstanceId == requestedPlayAction.CardId {\n\t\t\tstatus = true\n\t\t}\n\t}\n\n\tlogger.Debug(\"ValidateCardInHand Card is not in hand\",\n\t\t\"actionID\", \"ValidatePlayApCost\",\n\t\t\"entityID\", encounter.ActiveEntity.Id,\n\t\t\"status\", status,\n\t)\n\n\treturn status\n}", "id": 16705, "concepts": ["slice iteration (range loop)", "basic function definition", "boolean return"], "_raw_llm_output": "slice iteration (range loop), basic function definition, boolean return"}
{"seed": "// BetterHeroScoreEQ applies the EQ predicate on the \"better_hero_score\" field.\nfunc BetterHeroScoreEQ(v int) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldBetterHeroScore), v))\n\t})\n}", "id": 16710, "concepts": ["sql.Selector", "sql.EQ", "sql.C", "sql.Where", "sql.Predicate", "sql.Field", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate", "sql.Predicate"], "_raw_llm_output": "sql.Selector, sql.EQ, sql.C, sql.Where, sql.Predicate, sql.Field, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate, sql.Predicate"}
{"seed": "// Calculate the Julian Century based on the formula: (julianDay - 2451545.0) / 36525.0\n// julianDay - Julian day vector calculated by the calcJulianDay function\n// Return Julian century slice\nfunc calcJulianCentury(julianDay []float64) (julianCentury []float64) {\n\tfor index := 0; index < len(julianDay); index++ {\n\t\ttemp := (julianDay[index] - 2451545.0) / 36525.0\n\t\tjulianCentury = append(julianCentury, temp)\n\t}\n\treturn\n}", "id": 16717, "concepts": ["slice", "slice iteration (range loop)", "slice append", "slice creation", "mathematical operations"], "_raw_llm_output": "slice, slice iteration (range loop), slice append, slice creation, mathematical operations"}
{"seed": "// Goid returns the current goroutine id.\n// It exactly matches goroutine id of the stack trace.\nfunc Goid() int64 {\n\treturn int64(goid())\n}", "id": 16731, "concepts": ["goroutine id", "stack trace"], "_raw_llm_output": "goroutine id, stack trace"}
{"seed": "// NewHealthHandler returns a new HealthHandler using the IsHealthy method from\n// an Empire instance.\nfunc NewHealthHandler(e *empire.Empire) *HealthHandler {\n\treturn &HealthHandler{\n\t\tIsHealthy: e.IsHealthy,\n\t}\n}", "id": 16738, "concepts": ["struct definition", "method definition", "method call", "pointer usage"], "_raw_llm_output": "struct definition, method definition, method call, pointer usage"}
{"seed": "// AddressCount returns the number of distinct host addresses within the given\n// CIDR range.\n//\n// Since the result is a uint64, this function returns meaningful information\n// only for IPv4 ranges and IPv6 ranges with a prefix size of at least 65.\nfunc AddressCount(network *net.IPNet) uint64 {\n\tprefixLen, bits := network.Mask.Size()\n\treturn 1 << (uint64(bits) - uint64(prefixLen))\n}", "id": 16741, "concepts": ["net/net package usage", "bit manipulation", "bit shifting", "bitwise AND", "bitwise OR", "bitwise XOR"], "_raw_llm_output": "net/net package usage, bit manipulation, bit shifting, bitwise AND, bitwise OR, bitwise XOR"}
{"seed": "// NewSubDescriptionDtoWithDefaults instantiates a new SubDescriptionDto object\n// This constructor will only assign default values to properties that have it defined,\n// but it doesn't guarantee that properties required by API are set\nfunc NewSubDescriptionDtoWithDefaults() *SubDescriptionDto {\n\tthis := SubDescriptionDto{}\n\treturn &this\n}", "id": 16744, "concepts": ["struct definition", "default value assignment"], "_raw_llm_output": "struct definition, default value assignment"}
{"seed": "// verifyTerraformAndKopsMatch looks at terraform output and verifies that the\n// given kops name matches. This should only catch errors where terraform output\n// was incorrectly created from kops or if the terraform client is targeting the\n// wrong directory, but should be used as a final sanity check before invoking\n// terraform commands.\nfunc verifyTerraformAndKopsMatch(kopsName string, terraformClient *terraform.Cmd, logger log.FieldLogger) error {\n\tout, ok, err := terraformClient.Output(\"cluster_name\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !ok {\n\t\tlogger.Warn(\"No cluster_name in terraform config, skipping check\")\n\t\treturn nil\n\t}\n\tif out != kopsName {\n\t\treturn errors.Errorf(\"terraform cluster_name (%s) does not match kops_name from provided ID (%s)\", out, kopsName)\n\t}\n\n\treturn nil\n}", "id": 16746, "concepts": ["string comparison", "error handling (errors.Errorf)", "standard library usage"], "_raw_llm_output": "string comparison, error handling (errors.Errorf), standard library usage"}
{"seed": "// Datalist_ is a convenience wrapper for Datalist without the attrs argument.\nfunc Datalist_(children ...HTML) HTML {\n  return Datalist(nil, children...)\n}", "id": 16756, "concepts": ["HTML struct", "HTML struct composition", "HTML struct embedding", "HTML struct composition"], "_raw_llm_output": "HTML struct, HTML struct composition, HTML struct embedding, HTML struct composition"}
{"seed": "// NewDataPlaneClusterUpdateStatusRequestConditionsWithDefaults instantiates a new DataPlaneClusterUpdateStatusRequestConditions object\n// This constructor will only assign default values to properties that have it defined,\n// but it doesn't guarantee that properties required by API are set\nfunc NewDataPlaneClusterUpdateStatusRequestConditionsWithDefaults() *DataPlaneClusterUpdateStatusRequestConditions {\n\tthis := DataPlaneClusterUpdateStatusRequestConditions{}\n\treturn &this\n}", "id": 16784, "concepts": ["struct definition", "struct instantiation", "struct property definition", "struct property assignment"], "_raw_llm_output": "struct definition, struct instantiation, struct property definition, struct property assignment"}
{"seed": "// HiRedString is a convenient helper function to return a string with hi-intensity red\n// foreground.\nfunc HiRedString(format string, a ...interface{}) (s string) {\n\ts = colorString(FgHiRed, format, a...)\n\treturn\n}", "id": 16785, "concepts": ["fmt package usage", "color formatting", "string formatting", "standard library usage"], "_raw_llm_output": "fmt package usage, color formatting, string formatting, standard library usage"}
{"seed": "// \u8fd4\u56de dir \u76ee\u5f55\u4e0b\u6587\u4ef6\u7c7b\u578b\u53ca\u5bf9\u5e94\u7684\u6587\u4ef6\u6570\u91cf\u7684\u4e00\u4e2a\u96c6\u5408\u3002\n// recursive \u8868\u793a\u662f\u5426\u67e5\u627e\u5b50\u76ee\u5f55\u3002\nfunc detectExts(dir string, recursive bool) (map[string]int, error) {\n\texts := map[string]int{}\n\n\twalk := func(path string, fi os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif fi.IsDir() {\n\t\t\tif !recursive && dir != path {\n\t\t\t\treturn filepath.SkipDir\n\t\t\t}\n\t\t} else {\n\t\t\text := strings.ToLower(filepath.Ext(path))\n\t\t\tif len(ext) > 0 {\n\t\t\t\texts[ext]++\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}\n\n\tif err := filepath.Walk(dir, walk); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn exts, nil\n}", "id": 16798, "concepts": ["filepath.Walk", "filepath.SkipDir", "filepath.Ext", "os.FileInfo", "map iteration", "basic function definition"], "_raw_llm_output": "filepath.Walk, filepath.SkipDir, filepath.Ext, os.FileInfo, map iteration, basic function definition"}
{"seed": "// NativeName returns the native name of a language / locale code. It returns\n// empty string if the language / locale is unknown or, very unlikely, it\n// has no native name.\nfunc NativeName(loc string) string {\n\tif n, ok := Names[loc]; ok {\n\t\treturn n.Native\n\t}\n\treturn \"\"\n}", "id": 16829, "concepts": ["map lookup", "string manipulation"], "_raw_llm_output": "map lookup, string manipulation"}
{"seed": "// these come from xor_amd64.go. that file replaces the for loop\n// below with a call to xorBytesSSE2. it's not clear to me how to\n// take advantage of that call in portable kind of way\n\n// xorBytes xors the bytes in a and b. The destination should have enough\n// space, otherwise xorBytes will panic. Returns the number of bytes xor'd.\nfunc xorBytes(dst, a, b []byte) int {\n\tn := len(a)\n\tif len(b) < n {\n\t\tn = len(b)\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\t_ = dst[n-1]\n\tfor i := 0; i < n; i++ {\n\t\tdst[i] = a[i] ^ b[i]\n\t}\n\treturn n\n}", "id": 16830, "concepts": ["byte manipulation", "xor operation", "SSE2 instruction set"], "_raw_llm_output": "byte manipulation, xor operation, SSE2 instruction set"}
{"seed": "// IsEndpointNotFound indicates if err is ErrEndpointNotFound.\nfunc IsEndpointNotFound(err error) bool {\n\treturn unwrapError(err) == ErrEndpointNotFound\n}", "id": 16845, "concepts": ["error handling (errors.Is)", "error wrapping"], "_raw_llm_output": "error handling (errors.Is), error wrapping"}
{"seed": "// PrivateEndpointIPConfigurationGenerator returns a generator of PrivateEndpointIPConfiguration instances for property testing.\nfunc PrivateEndpointIPConfigurationGenerator() gopter.Gen {\n\tif privateEndpointIPConfigurationGenerator != nil {\n\t\treturn privateEndpointIPConfigurationGenerator\n\t}\n\n\tgenerators := make(map[string]gopter.Gen)\n\tAddIndependentPropertyGeneratorsForPrivateEndpointIPConfiguration(generators)\n\tprivateEndpointIPConfigurationGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointIPConfiguration{}), generators)\n\n\treturn privateEndpointIPConfigurationGenerator\n}", "id": 16852, "concepts": ["struct definition", "map definition", "property testing", "generator definition"], "_raw_llm_output": "struct definition, map definition, property testing, generator definition"}
{"seed": "// ParseTransferDomainResponse parses an HTTP response from a TransferDomainWithResponse call\nfunc ParseTransferDomainResponse(rsp *http.Response) (*TransferDomainResponse, error) {\n\tbodyBytes, err := ioutil.ReadAll(rsp.Body)\n\tdefer rsp.Body.Close()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse := &TransferDomainResponse{\n\t\tBody:         bodyBytes,\n\t\tHTTPResponse: rsp,\n\t}\n\n\tswitch {\n\tcase strings.Contains(rsp.Header.Get(\"Content-Type\"), \"json\") && rsp.StatusCode == 200:\n\t\tvar dest ScalewayDomainV2alpha2Domain\n\t\tif err := json.Unmarshal(bodyBytes, &dest); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresponse.JSON200 = &dest\n\n\t}\n\n\treturn response, nil\n}", "id": 16859, "concepts": ["http.Response", "ioutil.ReadAll", "json.Unmarshal", "switch statement", "basic function definition"], "_raw_llm_output": "http.Response, ioutil.ReadAll, json.Unmarshal, switch statement, basic function definition"}
{"seed": "// WithPreExtension is an Option that configures the reconciler to run the given\n// extension before performing any reconciliation steps (including values translation).\n// An error returned from the extension will cause the reconciliation to fail.\n// This should be preferred to WithPreHook in most cases, except for when the logic\n// depends on the translated Helm values.\n// The extension will be invoked with the raw object state; meaning it needs to be careful\n// to check for existence of the deletionTimestamp field.\nfunc WithPreExtension(e extensions.ReconcileExtension) Option {\n\treturn func(r *Reconciler) error {\n\t\tr.preExtensions = append(r.preExtensions, e)\n\t\treturn nil\n\t}\n}", "id": 16863, "concepts": ["struct definition", "interface definition", "function definition", "option pattern"], "_raw_llm_output": "struct definition, interface definition, function definition, option pattern"}
{"seed": "// TestMode returns whether it is running in test mode.\nfunc TestMode() bool {\n\treturn mode&TestModeFlag == TestModeFlag\n}", "id": 16876, "concepts": ["bitwise operations", "boolean logic", "basic function definition"], "_raw_llm_output": "bitwise operations, boolean logic, basic function definition"}
{"seed": "// GetLeaderboardAroundEntity get the leaderboard around a specific entity.\n// https://api.playfab.com/Documentation/Leaderboards/method/GetLeaderboardAroundEntity\nfunc GetLeaderboardAroundEntity(settings *playfab.Settings, postData *GetLeaderboardAroundEntityRequestModel, entityToken string) (*GetEntityLeaderboardResponseModel, error) {\n    if entityToken == \"\" {\n        return nil, playfab.NewCustomError(\"entityToken should not be an empty string\", playfab.ErrorGeneric)\n    }\n    b, errMarshal := json.Marshal(postData)\n    if errMarshal != nil {\n        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)\n    }\n\n    sourceMap, err := playfab.Request(settings, b, \"/Leaderboard/GetLeaderboardAroundEntity\", \"X-EntityToken\", entityToken)\n    if err != nil {\n        return nil, err\n    }\n    \n    result := &GetEntityLeaderboardResponseModel{}\n\n    config := mapstructure.DecoderConfig{\n        DecodeHook: playfab.StringToDateTimeHook,\n        Result:     result,\n    }\n    \n    decoder, errDecoding := mapstructure.NewDecoder(&config)\n    if errDecoding != nil {\n        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)\n    }\n   \n    errDecoding = decoder.Decode(sourceMap)\n    if errDecoding != nil {\n        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)\n    }\n\n    return result, nil\n}", "id": 16879, "concepts": ["map", "map iteration", "map manipulation", "map decoding", "map encoding", "map structure", "map structure decoding", "map structure encoding", "map structure decoding", "map structure encoding", "map structure decoding", "map structure encoding", "map structure decoding", "map structure encoding", "map structure decoding", "map structure encoding", "map structure decoding", "map structure encoding", "map structure decoding", "map structure encoding", "map structure decoding", "map structure encoding", "map structure decoding", "map structure encoding", "map structure decoding", "map structure encoding", "map structure decoding", "map structure encoding", "map structure decoding", "map structure encoding", "map structure decoding", "map structure encoding", "map structure decoding", "map structure encoding", "map structure decoding", "map structure encoding", "map structure decoding", "map structure encoding", "map structure decoding", "map structure encoding", "map structure decoding", "map structure encoding", "map structure decoding", "map structure encoding", "map structure decoding", "map structure encoding", "map structure decoding", "map structure encoding", "map structure decoding", "map structure encoding", "map structure decoding", "map structure encoding", "map structure decoding", "map structure encoding", "map structure decoding", "map structure encoding", "map structure decoding", "map structure encoding", "map structure decoding", "map structure encoding", "map structure decoding", "map structure encoding", "map structure decoding", "map structure encoding", "map structure decoding", "map structure"], "_raw_llm_output": "map, map iteration, map manipulation, map decoding, map encoding, map structure, map structure decoding, map structure encoding, map structure decoding, map structure encoding, map structure decoding, map structure encoding, map structure decoding, map structure encoding, map structure decoding, map structure encoding, map structure decoding, map structure encoding, map structure decoding, map structure encoding, map structure decoding, map structure encoding, map structure decoding, map structure encoding, map structure decoding, map structure encoding, map structure decoding, map structure encoding, map structure decoding, map structure encoding, map structure decoding, map structure encoding, map structure decoding, map structure encoding, map structure decoding, map structure encoding, map structure decoding, map structure encoding, map structure decoding, map structure encoding, map structure decoding, map structure encoding, map structure decoding, map structure encoding, map structure decoding, map structure encoding, map structure decoding, map structure encoding, map structure decoding, map structure encoding, map structure decoding, map structure encoding, map structure decoding, map structure encoding, map structure decoding, map structure encoding, map structure decoding, map structure encoding, map structure decoding, map structure encoding, map structure decoding, map structure encoding, map structure decoding, map structure encoding, map structure decoding, map structure"}
{"seed": "// Ensure that user supplied name adheres to DNS subdomain name (RFC1123),\n// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#dns-subdomain-names\nfunc K8sName(userInput string) error {\n\terrStrings := validation.IsDNS1123Subdomain(userInput)\n\tif len(errStrings) > 0 {\n\t\treturn eris.New(strings.Join(errStrings, \". \"))\n\t}\n\treturn nil\n}", "id": 16884, "concepts": ["validation.IsDNS1123Subdomain", "error handling (eris.New)", "string manipulation"], "_raw_llm_output": "validation.IsDNS1123Subdomain, error handling (eris.New), string manipulation"}
{"seed": "// WithOriginalSrc returns a new context usable within the matcher package that\n// indicates the original source for a given matcher operation\nfunc WithOriginalSrc(parent context.Context, src string) context.Context {\n\treturn context.WithValue(parent, originalSrcCtxKey, src)\n}", "id": 16894, "concepts": ["context usage", "context.Context", "context.WithValue"], "_raw_llm_output": "context usage, context.Context, context.WithValue"}
{"seed": "// getRowFromMods returns a map[string]string filled with all mods passed as parameter.\n// It's used later for rendering a row in the csv output\nfunc getRowFromMods(alertName string, allMods *[]of_snmpv2.Mod) (map[string]string, error) {\n\tvar row map[string]string = map[string]string{\n\t\t\"alertname\": alertName,\n\t}\n\tfor _, mod := range *allMods {\n\t\tif mod.Type == of_snmpv2.Set {\n\t\t\trow[mod.Key] = mod.Value\n\t\t} else if mod.Type == of_snmpv2.Copy && len(mod.Map) == 0 {\n\t\t\trow[mod.ToKey] = \"*\"\n\t\t} else if mod.Type == of_snmpv2.Copy && len(mod.Map[alertName]) != 0 {\n\t\t\trow[mod.ToKey] = mod.Map[alertName]\n\t\t} else {\n\t\t\treturn nil, errors.New(fmt.Sprintf(\"Mod %v unsupported\", mod))\n\t\t}\n\t}\n\treturn row, nil\n}", "id": 16900, "concepts": ["map iteration", "map manipulation", "map lookup", "string formatting", "error handling"], "_raw_llm_output": "map iteration, map manipulation, map lookup, string formatting, error handling"}
{"seed": "// IDLT applies the LT predicate on the ID field.\nfunc IDLT(id int) predicate.User {\n\treturn predicate.User(sql.FieldLT(FieldID, id))\n}", "id": 16902, "concepts": ["sql package usage", "sql.FieldLT", "sql.FieldGT", "sql.FieldEQ", "sql.FieldNE", "sql.FieldIN", "sql.FieldNotIn", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldIsNull", "sql.FieldIsNotNull", "sql.FieldBetween", "sql.FieldNotBetween", "sql.FieldRegexp", "sql.FieldNotRegexp", "sql.FieldExists", "sql.FieldNotExists", "sql.FieldContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", "sql.FieldNotContains", ""], "_raw_llm_output": "sql package usage, sql.FieldLT, sql.FieldGT, sql.FieldEQ, sql.FieldNE, sql.FieldIN, sql.FieldNotIn, sql.FieldLike, sql.FieldNotLike, sql.FieldIsNull, sql.FieldIsNotNull, sql.FieldBetween, sql.FieldNotBetween, sql.FieldRegexp, sql.FieldNotRegexp, sql.FieldExists, sql.FieldNotExists, sql.FieldContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains, sql.FieldNotContains,"}
{"seed": "// NewPostAdminUsersParamsWithTimeout creates a new PostAdminUsersParams object\n// with the default values initialized, and the ability to set a timeout on a request\nfunc NewPostAdminUsersParamsWithTimeout(timeout time.Duration) *PostAdminUsersParams {\n\tvar ()\n\treturn &PostAdminUsersParams{\n\n\t\ttimeout: timeout,\n\t}\n}", "id": 16914, "concepts": ["timeout handling", "time package usage", "function definition", "function parameters"], "_raw_llm_output": "timeout handling, time package usage, function definition, function parameters"}
{"seed": "// PossibleTrafficRegionCategoryValues returns the possible values for the TrafficRegionCategory const type.\nfunc PossibleTrafficRegionCategoryValues() []TrafficRegionCategory {\n\treturn []TrafficRegionCategory{\n\t\tTrafficRegionCategoryCanary,\n\t\tTrafficRegionCategoryHighTraffic,\n\t\tTrafficRegionCategoryLowTraffic,\n\t\tTrafficRegionCategoryMediumTraffic,\n\t\tTrafficRegionCategoryNone,\n\t\tTrafficRegionCategoryNotSpecified,\n\t\tTrafficRegionCategoryRestOfTheWorldGroupOne,\n\t\tTrafficRegionCategoryRestOfTheWorldGroupTwo,\n\t}\n}", "id": 16922, "concepts": ["constants", "type definition", "array", "slice"], "_raw_llm_output": "constants, type definition, array, slice"}
{"seed": "// Spacer_ is a convenience wrapper for Spacer without the attrs argument.\nfunc Spacer_(children ...HTML) HTML {\n  return Spacer(nil, children...)\n}", "id": 16930, "concepts": ["HTML", "HTML tag definition", "HTML attribute definition", "HTML attribute value definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", "HTML tag definition", ""], "_raw_llm_output": "HTML, HTML tag definition, HTML attribute definition, HTML attribute value definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition, HTML tag definition,"}
{"seed": "// DiscardLog creates a Logger that discards all messages.\nfunc DiscardLog() Logger {\n\treturn &discardLog{}\n}", "id": 16932, "concepts": ["interface implementation", "interface definition", "struct definition", "pointer usage"], "_raw_llm_output": "interface implementation, interface definition, struct definition, pointer usage"}
{"seed": "// NewEditParamsWithTimeout creates a new EditParams object\n// with the ability to set a timeout on a request.\nfunc NewEditParamsWithTimeout(timeout time.Duration) *EditParams {\n\treturn &EditParams{\n\t\ttimeout: timeout,\n\t}\n}", "id": 16933, "concepts": ["struct definition", "function definition", "timeout handling"], "_raw_llm_output": "struct definition, function definition, timeout handling"}
{"seed": "// UpdateProtectBranch saves branch protection options.\n// If ID is 0, it creates a new record. Otherwise, updates existing record.\nfunc UpdateProtectBranch(protectBranch *ProtectBranch) (err error) {\n\tsess := x.NewSession()\n\tdefer sess.Close()\n\tif err = sess.Begin(); err != nil {\n\t\treturn err\n\t}\n\n\tif protectBranch.ID == 0 {\n\t\tif _, err = sess.Insert(protectBranch); err != nil {\n\t\t\treturn fmt.Errorf(\"Insert: %v\", err)\n\t\t}\n\t}\n\n\tif _, err = sess.ID(protectBranch.ID).AllCols().Update(protectBranch); err != nil {\n\t\treturn fmt.Errorf(\"Update: %v\", err)\n\t}\n\n\treturn sess.Commit()\n}", "id": 16938, "concepts": ["database usage (xorm)", "database transaction", "database query", "database update"], "_raw_llm_output": "database usage (xorm), database transaction, database query, database update"}
{"seed": "// Div_ is a convenience wrapper for Div without the attrs argument.\nfunc Div_(children ...HTML) HTML {\n  return Div(nil, children...)\n}", "id": 16960, "concepts": ["HTML type", "function definition", "function call", "function argument", "function return value", "function attribute"], "_raw_llm_output": "HTML type, function definition, function call, function argument, function return value, function attribute"}
{"seed": "// hasWriter is a helper function that returns true if at least one task is\n// using this volume not in read-only mode.\nfunc hasWriter(info volumeInfo) bool {\n\tfor _, usage := range info.tasks {\n\t\tif !usage.readOnly {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}", "id": 16970, "concepts": ["struct field access", "boolean logic"], "_raw_llm_output": "struct field access, boolean logic"}
{"seed": "// AccessScopePNotInOrganization returns a pointer to AccessScopeVNotInOrganization\nfunc AccessScopePNotInOrganization() *AccessScope {\n\tv := AccessScopeVNotInOrganization\n\treturn &v\n}", "id": 16972, "concepts": ["pointer", "pointer dereference", "pointer assignment"], "_raw_llm_output": "pointer, pointer dereference, pointer assignment"}
{"seed": "// WithActionClientGetter is an Option that configures a Reconciler's\n// ActionClientGetter.\n//\n// A default ActionClientGetter is used if this option is not configured.\nfunc WithActionClientGetter(actionClientGetter helmclient.ActionClientGetter) Option {\n\treturn func(r *Reconciler) error {\n\t\tr.actionClientGetter = actionClientGetter\n\t\treturn nil\n\t}\n}", "id": 16978, "concepts": ["struct", "method", "function", "interface", "option pattern", "option composition"], "_raw_llm_output": "struct, method, function, interface, option pattern, option composition"}
{"seed": "// NewExtrasGraphsReadParamsWithTimeout creates a new ExtrasGraphsReadParams object\n// with the default values initialized, and the ability to set a timeout on a request\nfunc NewExtrasGraphsReadParamsWithTimeout(timeout time.Duration) *ExtrasGraphsReadParams {\n\tvar ()\n\treturn &ExtrasGraphsReadParams{\n\n\t\ttimeout: timeout,\n\t}\n}", "id": 16990, "concepts": ["struct initialization", "timeout handling", "function definition"], "_raw_llm_output": "struct initialization, timeout handling, function definition"}
{"seed": "// New returns an instance of Bot with given name and classifier. If the classifier\n// is nil, a default dumb classifier will be used.\nfunc New(opts ...Option) *Bot {\n\tvar bot Bot\n\tfor _, opt := range withDefaults(opts) {\n\t\topt(&bot)\n\t}\n\treturn &bot\n}", "id": 16995, "concepts": ["struct definition", "function definition", "function options", "struct field definition", "struct field initialization", "struct field access", "struct field pointer access", "struct field pointer access with struct pointer", "function call with struct pointer", "function call with struct pointer and struct pointer", "function call with struct pointer and struct pointer and struct pointer", "function call with struct pointer and struct pointer and struct pointer and struct pointer", "function call with struct pointer and struct pointer and struct pointer and struct pointer and struct pointer", "function call with struct pointer and struct pointer and struct pointer and struct pointer and struct pointer and struct pointer", "function call with struct pointer and struct pointer and struct pointer and struct pointer and struct pointer and struct pointer and struct pointer", "function call with struct pointer and struct pointer and struct pointer and struct pointer and struct pointer and struct pointer and struct pointer and struct pointer", "function call with struct pointer and struct pointer and struct pointer and struct pointer and struct pointer and struct pointer and struct pointer and struct pointer and struct pointer", "function call with struct pointer and struct pointer and struct pointer and struct pointer and struct pointer and struct pointer and struct pointer and struct pointer and struct pointer and struct pointer", "function call with struct pointer and struct pointer and struct pointer and struct pointer and struct pointer and struct pointer and struct pointer and struct pointer"], "_raw_llm_output": "struct definition, function definition, function options, struct field definition, struct field initialization, struct field access, struct field pointer access, struct field pointer access with struct pointer, function call with struct pointer, function call with struct pointer and struct pointer, function call with struct pointer and struct pointer and struct pointer, function call with struct pointer and struct pointer and struct pointer and struct pointer, function call with struct pointer and struct pointer and struct pointer and struct pointer and struct pointer, function call with struct pointer and struct pointer and struct pointer and struct pointer and struct pointer and struct pointer, function call with struct pointer and struct pointer and struct pointer and struct pointer and struct pointer and struct pointer and struct pointer, function call with struct pointer and struct pointer and struct pointer and struct pointer and struct pointer and struct pointer and struct pointer and struct pointer, function call with struct pointer and struct pointer and struct pointer and struct pointer and struct pointer and struct pointer and struct pointer and struct pointer and struct pointer, function call with struct pointer and struct pointer and struct pointer and struct pointer and struct pointer and struct pointer and struct pointer and struct pointer and struct pointer and struct pointer, function call with struct pointer and struct pointer and struct pointer and struct pointer and struct pointer and struct pointer and struct pointer and struct pointer"}
{"seed": "// PossibleSkuNameValues returns an array of possible values for the SkuName const type.\nfunc PossibleSkuNameValues() []SkuName {\n\treturn []SkuName{Basic, Premium, Standard}\n}", "id": 17000, "concepts": ["const type", "array", "basic function definition"], "_raw_llm_output": "const type, array, basic function definition"}
{"seed": "// tableVersionAndCNI returns the table version_number and current_next_indicator\nfunc tableVersionAndCNI(psi []byte) (uint8, bool, error) {\n\tif len(psi) < 6 {\n\t\treturn 0, false, gots.ErrShortPayload\n\t}\n\n\t// extract the 3rd-7th bits for version and bit immediately following for\n\t// current_next_indicator\n\treturn uint8(psi[5]&0x3E) >> 1, (psi[5] & 0x1) == 0x01, nil\n}", "id": 17001, "concepts": ["bitwise operations", "byte manipulation", "error handling (errors.Is)", "bit shift"], "_raw_llm_output": "bitwise operations, byte manipulation, error handling (errors.Is), bit shift"}
{"seed": "// NewEdgeSearchEngineCustom instantiates a new EdgeSearchEngineCustom and sets the default values.\nfunc NewEdgeSearchEngineCustom()(*EdgeSearchEngineCustom) {\n    m := &EdgeSearchEngineCustom{\n        EdgeSearchEngineBase: *NewEdgeSearchEngineBase(),\n    }\n    odataTypeValue := \"#microsoft.graph.edgeSearchEngineCustom\";\n    m.SetOdataType(&odataTypeValue);\n    return m\n}", "id": 17003, "concepts": ["struct definition", "pointer usage", "basic function definition"], "_raw_llm_output": "struct definition, pointer usage, basic function definition"}
{"seed": "// S3ArnForBucket returns a CloudFormation-compatible Arn expression\n// (string or Ref) suitable for template reference.  The bucket\n// parameter may be either a string or an interface{} (\"Ref: \"myResource\")\n// value\nfunc S3ArnForBucket(bucket interface{}) *gocf.StringExpr {\n\tarnParts := []gocf.Stringable{gocf.String(\"arn:aws:s3:::\")}\n\n\tswitch bucket.(type) {\n\tcase string:\n\t\t// Don't be smart if the Arn value is a user supplied literal\n\t\tarnParts = append(arnParts, gocf.String(bucket.(string)))\n\tcase *gocf.StringExpr:\n\t\tarnParts = append(arnParts, bucket.(*gocf.StringExpr))\n\tcase gocf.RefFunc:\n\t\tarnParts = append(arnParts, bucket.(gocf.RefFunc).String())\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"Unsupported SourceArn value type: %+v\", bucket))\n\t}\n\treturn gocf.Join(\"\", arnParts...).String()\n}", "id": 17006, "concepts": ["string formatting", "interface{} type handling", "gocf package usage"], "_raw_llm_output": "string formatting, interface{} type handling, gocf package usage"}
{"seed": "// NicknameEQ applies the EQ predicate on the \"nickname\" field.\nfunc NicknameEQ(v string) predicate.User {\n\treturn predicate.User(sql.FieldEQ(FieldNickname, v))\n}", "id": 17021, "concepts": ["predicate composition", "predicate.User type", "sql.FieldEQ function"], "_raw_llm_output": "predicate composition, predicate.User type, sql.FieldEQ function"}
{"seed": "// IDGT applies the GT predicate on the ID field.\nfunc IDGT(id string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.GT(s.C(FieldID), id))\n\t})\n}", "id": 17032, "concepts": ["SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building", "SQL query building"], "_raw_llm_output": "SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building, SQL query building"}
{"seed": "// checkWord checks if a word is a valid English word by\n// looking at a dictionary of 3000 popular English words\nfunc checkWord(w string) (bool, error) {\n\t// format the word to be lower case\n\tw = strings.ToLower(w)\n\t// open the dictionary of popular English words\n\tf, err := os.Open(\"dictionary.txt\")\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tdefer f.Close()\n\n\t// Splits on newlines by default.\n\tscanner := bufio.NewScanner(f)\n\n\tline := 1\n\tfor scanner.Scan() {\n\t\tif scanner.Text() == w {\n\t\t\treturn true, nil\n\t\t}\n\t\tline++\n\t}\n\n\tif err := scanner.Err(); err != nil {\n\t\treturn false, err\n\t}\n\t// could not find any match, but no error is provided\n\treturn false, nil\n}", "id": 17040, "concepts": ["file handling", "file reading", "string manipulation", "string comparison", "string formatting", "error handling (idiomatic `if err != nil`", "`errors.Is`", "`errors.As`)", "concurrency patterns (goroutines", "channels", "mutexes)", "error handling (idiomatic `if err != nil`", "`errors.Is`", "`errors.As`)", "types (structs", "interfaces", "slices", "maps)", "common Go idioms (like `defer`)", "pointers", "and control flow."], "_raw_llm_output": "file handling, file reading, string manipulation, string comparison, string formatting, error handling (idiomatic `if err != nil`, `errors.Is`, `errors.As`), concurrency patterns (goroutines, channels, mutexes), error handling (idiomatic `if err != nil`, `errors.Is`, `errors.As`), types (structs, interfaces, slices, maps), common Go idioms (like `defer`), pointers, and control flow."}
{"seed": "// logFilterBlocksResp provides useful logging information when filtering\n// succeeded in finding relevant transactions.\nfunc logFilterBlocksResp(block wtxmgr.BlockMeta,\n\tresp *chain.FilterBlocksResponse) {\n\n\tif log.Level() < pktlog.LevelDebug {\n\t\t// Nothing here runs unless debug level logging\n\t\treturn\n\t}\n\n\t// Log the number of external addresses found in this block.\n\tvar nFoundExternal int\n\tfor _, indexes := range resp.FoundExternalAddrs {\n\t\tnFoundExternal += len(indexes)\n\t}\n\tif nFoundExternal > 0 {\n\t\tlog.Debugf(\"Recovered %d external addrs at height=%d hash=%v\",\n\t\t\tnFoundExternal, block.Height, block.Hash)\n\t}\n\n\t// Log the number of internal addresses found in this block.\n\tvar nFoundInternal int\n\tfor _, indexes := range resp.FoundInternalAddrs {\n\t\tnFoundInternal += len(indexes)\n\t}\n\tif nFoundInternal > 0 {\n\t\tlog.Debugf(\"Recovered %d internal addrs at height=%d hash=%v\",\n\t\t\tnFoundInternal, block.Height, block.Hash)\n\t}\n\n\t// Log the number of outpoints found in this block.\n\tnFoundOutPoints := len(resp.FoundOutPoints)\n\tif nFoundOutPoints > 0 {\n\t\tlog.Debugf(\"Found %d spends from watched outpoints at \"+\n\t\t\t\"height=%d hash=%v\",\n\t\t\tnFoundOutPoints, block.Height, block.Hash)\n\t}\n}", "id": 17047, "concepts": ["logging", "fmt package usage", "string formatting", "integer summation", "slice iteration (range loop)", "basic function definition", "standard library usage"], "_raw_llm_output": "logging, fmt package usage, string formatting, integer summation,\nslice iteration (range loop), basic function definition,\nstandard library usage"}
{"seed": "// getClientDetails will return the *iam.User associated with the provided client's credentials,\n// a boolean indicating whether the user is the 'root' account, and any error encountered\n// while trying to gather the info.\nfunc getClientDetails(awsClient Client) (*iam.User, bool, error) {\n\trootUser := false\n\n\tuser, err := awsClient.GetUser(nil)\n\tif err != nil {\n\t\treturn nil, rootUser, fmt.Errorf(\"error querying username: %v\", err)\n\t}\n\n\t// Detect whether the AWS account's root user is being used\n\tparsed, err := arn.Parse(*user.User.Arn)\n\tif err != nil {\n\t\treturn nil, rootUser, fmt.Errorf(\"error parsing user's ARN: %v\", err)\n\t}\n\tif parsed.AccountID == *user.User.UserId {\n\t\trootUser = true\n\t}\n\n\treturn user.User, rootUser, nil\n}", "id": 17050, "concepts": ["error handling (fmt.Errorf)", "string parsing", "AWS SDK usage"], "_raw_llm_output": "error handling (fmt.Errorf), string parsing, AWS SDK usage"}
{"seed": "// Asteroid returns semidiameter of an asteroid with a given diameter\n// at given distance.\n//\n// Argument d is diameter in km, \u0394 is distance in AU.\n//\n// Result is semidiameter.\nfunc Asteroid(d, \u0394 float64) unit.Angle {\n\treturn unit.AngleFromSec(.0013788).Mul(d / \u0394)\n}", "id": 17060, "concepts": ["float64 handling", "unit conversion", "basic function definition"], "_raw_llm_output": "float64 handling, unit conversion, basic function definition"}
{"seed": "// Convert retuns \"Pling\", \"Plang\" or \"Plong\" if the input is 3, 5 or 7 correspondingly.\n// In other cases, it returns the input integer converted into string.\nfunc Convert(num int) string {\n\n\tout := \"\"\n\n\tif num%3 == 0 {\n\t\tout += \"Pling\"\n\t}\n\tif num%5 == 0 {\n\t\tout += \"Plang\"\n\t}\n\tif num%7 == 0 {\n\t\tout += \"Plong\"\n\t}\n\n\tif out == \"\" {\n\t\tout = strconv.Itoa(num)\n\t}\n\n\treturn out\n}", "id": 17065, "concepts": ["integer division", "string conversion", "string concatenation", "string manipulation", "string comparison", "string formatting", "basic function definition"], "_raw_llm_output": "integer division, string conversion, string concatenation, string manipulation, string comparison, string formatting, basic function definition"}
{"seed": "// NewDNSProvider returns a new Vscale DNS challenge provider.\n// The credentials are interpreted as follows:\n//\n// len(0): use credentials from environment (https://godoc.org/github.com/go-acme/lego/providers/dns/vscale)\n// len(1): credentials[0] = Token\nfunc NewDNSProvider(credentials ...string) (caddytls.ChallengeProvider, error) {\n\tswitch len(credentials) {\n\tcase 0:\n\t\treturn vscale.NewDNSProvider()\n\tcase 1:\n\t\tconfig := vscale.NewDefaultConfig()\n\t\tconfig.Token = credentials[0]\n\t\treturn vscale.NewDNSProviderConfig(config)\n\tdefault:\n\t\treturn nil, errors.New(\"invalid credentials length\")\n\t}\n}", "id": 17068, "concepts": ["function definition", "function parameter", "function return value", "function call", "function scope", "function reassignment", "function definition", "function call", "function return value", "function parameter", "function call", "function return value", "function parameter", "function call", "function return value", "function parameter", "function call", "function return value", "function parameter", "function call", "function return value", "function parameter", "function call", "function return value", "function parameter", "function call", "function return value", "function parameter", "function call", "function return value", "function parameter", "function call", "function return value", "function parameter", "function call", "function return value", "function parameter", "function call", "function return value", "function parameter", "function call", "function return value", "function parameter", "function call", "function return value", "function parameter", "function call", "function return value", "function parameter", "function call", "function return value", "function parameter", "function call", "function return value", "function parameter", "function call", "function return value", "function parameter", "function call", "function return value", "function parameter", "function call", "function return value", "function parameter", "function call", "function return value", "function parameter", "function call", "function return value", "function parameter", "function call", "function return value", "function parameter", "function call", "function return value", "function parameter", "function call"], "_raw_llm_output": "function definition, function parameter, function return value, function call, function scope, function reassignment, function definition, function call, function return value, function parameter, function call, function return value, function parameter, function call, function return value, function parameter, function call, function return value, function parameter, function call, function return value, function parameter, function call, function return value, function parameter, function call, function return value, function parameter, function call, function return value, function parameter, function call, function return value, function parameter, function call, function return value, function parameter, function call, function return value, function parameter, function call, function return value, function parameter, function call, function return value, function parameter, function call, function return value, function parameter, function call, function return value, function parameter, function call, function return value, function parameter, function call, function return value, function parameter, function call, function return value, function parameter, function call, function return value, function parameter, function call, function return value, function parameter, function call, function return value, function parameter, function call, function return value, function parameter, function call, function return value, function parameter, function call"}
{"seed": "// transformFollowingviewsAvatarViewToAvatar builds a value of type *Avatar\n// from a value of type *followingviews.AvatarView.\nfunc transformFollowingviewsAvatarViewToAvatar(v *followingviews.AvatarView) *Avatar {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tres := &Avatar{\n\t\tURL: *v.URL,\n\t}\n\n\treturn res\n}", "id": 17080, "concepts": ["type conversion", "nil pointer handling", "pointer dereference", "pointer usage"], "_raw_llm_output": "type conversion, nil pointer handling, pointer dereference, pointer usage"}
{"seed": "// GoFmt reads all of src, applies \"gofmt\" to it, and then writes the result to dst.\nfunc GoFmt(dst io.Writer, src io.Reader) error {\n\tin, err := ioutil.ReadAll(src)\n\tif err != nil {\n\t\treturn err\n\t}\n\tout, err := format.Source(in)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = dst.Write(out)\n\treturn err\n}", "id": 17084, "concepts": ["ioutil.ReadAll", "format.Source", "io.Writer", "io.Reader", "standard library usage"], "_raw_llm_output": "ioutil.ReadAll, format.Source, io.Writer, io.Reader, standard library usage"}
{"seed": "// NewAttributeMap creates a AttributeMap with 0 elements.\nfunc NewAttributeMap() AttributeMap {\n\torig := []otlpcommon.KeyValue(nil)\n\treturn AttributeMap{&orig}\n}", "id": 17086, "concepts": ["slice initialization", "struct initialization", "pointer usage"], "_raw_llm_output": "slice initialization, struct initialization, pointer usage"}
{"seed": "// MeanApogee returns the jde of the mean apogee of the Moon nearest the given date.\n// \u5e73\u8fdc\u5730\u70b9\n//\n// Year is a decimal year specifying a date.\nfunc MeanApogee(year float64) float64 {\n\treturn mean(snap(year, .5) * ck)\n}", "id": 17099, "concepts": ["float handling", "snap function", "float division", "constant definition"], "_raw_llm_output": "float handling, snap function, float division, constant definition"}
{"seed": "// Checks if endpoints are either available through environment\n// or command line, returns false if both fails.\nfunc endpointsPresent(ctx *cli.Context) bool {\n\t_, ok := os.LookupEnv(\"MINIO_ENDPOINTS\")\n\tif !ok {\n\t\tok = ctx.Args().Present()\n\t}\n\treturn ok\n}", "id": 17104, "concepts": ["os.LookupEnv", "cli.Context", "cli.Args", "boolean logic"], "_raw_llm_output": "os.LookupEnv, cli.Context, cli.Args, boolean logic"}
{"seed": "// NewBranchingModelSettings instantiates a new BranchingModelSettings object\n// This constructor will assign default values to properties that have it defined,\n// and makes sure properties required by API are set, but the set of arguments\n// will change when the set of required properties is changed\nfunc NewBranchingModelSettings() *BranchingModelSettings {\n\tthis := BranchingModelSettings{}\n\treturn &this\n}", "id": 17107, "concepts": ["struct definition", "struct initialization", "struct field assignment", "struct field initialization", "struct field default value", "struct field required by API"], "_raw_llm_output": "struct definition, struct initialization, struct field assignment, struct field initialization, struct field default value, struct field required by API"}
{"seed": "// Menu represents the HTML element 'menu'.\n// For more information visit https://www.w3schools.com/tags/tag_menu.asp.\nfunc Menu(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"menu\", Attributes: attrs, Children: children}\n}", "id": 17110, "concepts": ["HTML generation", "HTML tree traversal", "HTML element definition", "HTML attribute definition"], "_raw_llm_output": "HTML generation, HTML tree traversal, HTML element definition, HTML attribute definition"}
{"seed": "// Algorithms returns all of the premade algorithm names\nfunc Algorithms() []string {\n\tnames := make([]string, len(algorithms))\n\n\ti := 0\n\tfor name := range algorithms {\n\t\tnames[i] = name\n\t\ti++\n\t}\n\n\treturn names\n}", "id": 17124, "concepts": ["map iteration (range loop)", "map key iteration (range loop)", "basic function definition"], "_raw_llm_output": "map iteration (range loop), map key iteration (range loop), basic function definition"}
{"seed": "// NewNegotiableQuoteCouponManagementV1RemoveDeleteParamsWithHTTPClient creates a new NegotiableQuoteCouponManagementV1RemoveDeleteParams object\n// with the default values initialized, and the ability to set a custom HTTPClient for a request\nfunc NewNegotiableQuoteCouponManagementV1RemoveDeleteParamsWithHTTPClient(client *http.Client) *NegotiableQuoteCouponManagementV1RemoveDeleteParams {\n\tvar ()\n\treturn &NegotiableQuoteCouponManagementV1RemoveDeleteParams{\n\t\tHTTPClient: client,\n\t}\n}", "id": 17127, "concepts": ["http.Client", "http.NewRequest", "http.Do", "http.Request", "http.Response", "http.Status", "http.StatusText", "http.Header", "http.Cookie", "http.CookieJar", "http.Transport", "http.ProxyFromEnvironment", "http.ProxyURL", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", "http.ProxyFromEnvironment", ""], "_raw_llm_output": "http.Client, http.NewRequest, http.Do, http.Request, http.Response, http.Status, http.StatusText, http.Header, http.Cookie, http.CookieJar, http.Transport, http.ProxyFromEnvironment, http.ProxyURL, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment, http.ProxyFromEnvironment,"}
{"seed": "// NewProjectTypeConnectionResolver creates new instance of the projectTypeConnectionResolver, setting up all dependencies and returns the instance\n// ctx: Mandatory. Reference to the context\n// resolverCreator: Mandatory. Reference to the resolver creator service that can create new instances of resolvers\n// projects: Mandatory. Reference the list of projects\n// hasPreviousPage: Mandatory. Indicates whether more edges exist prior to the set defined by the clients arguments\n// hasNextPage: Mandatory. Indicates whether more edges exist following the set defined by the clients arguments\n// totalCount: Mandatory. The total count of matched projects\n// Returns the new instance or error if something goes wrong\nfunc NewProjectTypeConnectionResolver(\n\tctx context.Context,\n\tresolverCreator types.ResolverCreatorContract,\n\tprojects []*projectGrpcContract.ProjectWithCursor,\n\thasPreviousPage bool,\n\thasNextPage bool,\n\ttotalCount int32) (project.ProjectTypeConnectionResolverContract, error) {\n\tif ctx == nil {\n\t\treturn nil, commonErrors.NewArgumentNilError(\"ctx\", \"ctx is required\")\n\t}\n\n\tif resolverCreator == nil {\n\t\treturn nil, commonErrors.NewArgumentNilError(\"resolverCreator\", \"resolverCreator is required\")\n\t}\n\n\treturn &projectTypeConnectionResolver{\n\t\tresolverCreator: resolverCreator,\n\t\tprojects:        projects,\n\t\thasPreviousPage: hasPreviousPage,\n\t\thasNextPage:     hasNextPage,\n\t\ttotalCount:      totalCount,\n\t}, nil\n}", "id": 17129, "concepts": ["struct definition", "pointer handling", "function definition", "interface definition", "error handling", "standard library usage"], "_raw_llm_output": "struct definition, pointer handling, function definition, interface definition, error handling, standard library usage"}
{"seed": "// NewKeyValue instantiates a new keyValue and sets the default values.\nfunc NewKeyValue()(*KeyValue) {\n    m := &KeyValue{\n    }\n    m.SetAdditionalData(make(map[string]interface{}));\n    odataTypeValue := \"#microsoft.graph.keyValue\";\n    m.SetOdataType(&odataTypeValue);\n    return m\n}", "id": 17134, "concepts": ["struct definition", "map definition", "map initialization", "map assignment", "struct initialization", "struct assignment", "map iteration", "struct iteration", "pointer assignment", "pointer dereference", "map key lookup", "struct key lookup", "struct field lookup", "map field lookup", "map value lookup", "struct value lookup", "map value assignment", "struct value assignment", "map value deletion", "struct value deletion", "map value deletion", "struct value deletion", "map value deletion", "struct value deletion", "map value deletion", "struct value deletion", "map value deletion", "struct value deletion", "map value deletion", "struct value deletion", "map value deletion", "struct value deletion", "map value deletion", "struct value deletion", "map value deletion", "struct value deletion", "map value deletion", "struct value deletion", "map value deletion", "struct value deletion", "map value deletion", "struct value deletion", "map value deletion", "struct value deletion", "map value deletion", "struct value deletion", "map value deletion", "struct value deletion", "map value deletion", "struct value deletion", "map value deletion", "struct value deletion", "map value deletion", "struct value deletion", "map value deletion", "struct value deletion", "map value deletion", "struct value deletion", "map value deletion", "struct value deletion", "map value deletion", "struct value deletion", "map value deletion", "struct value deletion", "map value deletion", "struct value deletion", ""], "_raw_llm_output": "struct definition, map definition, map initialization, map assignment, struct initialization, struct assignment, map iteration, struct iteration, pointer assignment, pointer dereference, map key lookup, struct key lookup, struct field lookup, map field lookup, map value lookup, struct value lookup, map value assignment, struct value assignment, map value deletion, struct value deletion, map value deletion, struct value deletion, map value deletion, struct value deletion, map value deletion, struct value deletion, map value deletion, struct value deletion, map value deletion, struct value deletion, map value deletion, struct value deletion, map value deletion, struct value deletion, map value deletion, struct value deletion, map value deletion, struct value deletion, map value deletion, struct value deletion, map value deletion, struct value deletion, map value deletion, struct value deletion, map value deletion, struct value deletion, map value deletion, struct value deletion, map value deletion, struct value deletion, map value deletion, struct value deletion, map value deletion, struct value deletion, map value deletion, struct value deletion, map value deletion, struct value deletion, map value deletion, struct value deletion, map value deletion, struct value deletion, map value deletion, struct value deletion, map value deletion, struct value deletion,"}
{"seed": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\n\n// \u89e3\u6cd5\u4e00: \u8fed\u4ee3\u7248\u672c\nfunc inorderTraversal1(root *cig.TreeNode) []int {\n\tres := make([]int, 0)\n\tif root == nil {\n\t\treturn res\n\t}\n\n\tstack := make([]*cig.TreeNode, 0)\n\n\tfor len(stack) > 0 || root != nil {\n\t\tfor root != nil {\n\t\t\tstack = append(stack, root)\n\t\t\troot = root.Left\n\t\t}\n\t\tnode := stack[len(stack) - 1]\n\t\tstack = stack[:len(stack) - 1]\n\t\tres = append(res, node.Val)\n\t\troot = node.Right\n\t}\n\n\treturn res\n}", "id": 17135, "concepts": ["binary tree traversal", "stack", "recursion"], "_raw_llm_output": "binary tree traversal, stack, recursion"}
{"seed": "// \u5fae\u4fe1\u6d88\u606f\u52a0\u89e3\u5bc6\n// http://mp.weixin.qq.com/wiki/6/90f7259c0d0739bbb41d9f4c4c8e59a2.html\n// \u53c2\u8003 https://github.com/heroicyang/wechat-crypter\n\n// PKCS7Decode \u65b9\u6cd5\u7528\u4e8e\u5220\u9664\u89e3\u5bc6\u540e\u660e\u6587\u7684\u8865\u4f4d\u5b57\u7b26\nfunc PKCS7Decode(text []byte) []byte {\n\tpad := int(text[len(text)-1])\n\tif pad < 1 || pad > 32 {\n\t\tpad = 0\n\t}\n\treturn text[:len(text)-pad]\n}", "id": 17145, "concepts": ["byte array manipulation", "PKCS7 padding"], "_raw_llm_output": "byte array manipulation, PKCS7 padding"}
{"seed": "// TestCreateRetryConflictTagDiff ensures that attempts to create a mapping\n// that result in resource conflicts that DO contain tag diffs causes the\n// conflict error to be returned.\nfunc TestCreateRetryConflictTagDiff(t *testing.T) {\n\tfirstGet := true\n\tfirstUpdate := true\n\trestInstance := &REST{\n\t\tstrategy: NewStrategy(registryhostname.TestingRegistryHostnameRetriever(nil, \"\", testDefaultRegistryURL)),\n\t\timageRegistry: &fakeImageRegistry{\n\t\t\tcreateImage: func(ctx context.Context, image *imageapi.Image) error {\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\timageStreamRegistry: &fakeImageStreamRegistry{\n\t\t\tgetImageStream: func(ctx context.Context, id string, options *metav1.GetOptions) (*imageapi.ImageStream, error) {\n\t\t\t\t// For the first get, return a stream with a latest tag pointing to \"original\"\n\t\t\t\tif firstGet {\n\t\t\t\t\tfirstGet = false\n\t\t\t\t\tstream := validImageStream()\n\t\t\t\t\tstream.Status = imageapi.ImageStreamStatus{\n\t\t\t\t\t\tTags: map[string]imageapi.TagEventList{\n\t\t\t\t\t\t\t\"latest\": {Items: []imageapi.TagEvent{{DockerImageReference: \"localhost:5000/someproject/somerepo:original\"}}},\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t\treturn stream, nil\n\t\t\t\t}\n\t\t\t\t// For subsequent gets, return a stream with the latest tag changed to \"newer\"\n\t\t\t\tstream := validImageStream()\n\t\t\t\tstream.Status = imageapi.ImageStreamStatus{\n\t\t\t\t\tTags: map[string]imageapi.TagEventList{\n\t\t\t\t\t\t\"latest\": {Items: []imageapi.TagEvent{{DockerImageReference: \"localhost:5000/someproject/somerepo:newer\"}}},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn stream, nil\n\t\t\t},\n\t\t\tupdateImageStreamStatus: func(ctx context.Context, repo *imageapi.ImageStream) (*imageapi.ImageStream, error) {\n\t\t\t\t// For the first update, return a conflict so that the stream\n\t\t\t\t// get/compare is retried.\n\t\t\t\tif firstUpdate {\n\t\t\t\t\tfirstUpdate = false\n\t\t\t\t\treturn nil, errors.NewConflict(imagegroup.Resource(\"imagestreams\"), repo.Name, fmt.Errorf(\"resource modified\"))\n\t\t\t\t}\n\t\t\t\treturn repo, nil\n\t\t\t},\n\t\t},\n\t}\n\tobj, err := restInstance.Create(apirequest.NewDefaultContext(), validNewMappingWithName(), rest.ValidateAllObjectFunc, false)\n\tif err == nil {\n\t\tt.Fatalf(\"expected an error\")\n\t}\n\tif !errors.IsConflict(err) {\n\t\tt.Errorf(\"expected a conflict error, got %v\", err)\n\t}\n\tif obj != nil {\n\t\tt.Fatalf(\"expected a nil result\")\n\t}\n}", "id": 17153, "concepts": ["error handling (errors.Is)", "error handling (errors.New)", "error handling (errors.As)", "error handling (errors.NewConflict)", "error handling (errors.IsConflict)", "error handling (errors.As)", "error handling (errors.NewConflict)", "error handling (errors.IsConflict)", "error handling (errors.As)", "error handling (errors.NewConflict)", "error handling (errors.IsConflict)", "error handling (errors.As)", "error handling (errors.NewConflict)", "error handling (errors.IsConflict)", "error handling (errors.As)", "error handling (errors.NewConflict)", "error handling (errors.IsConflict)", "error handling (errors.As)", "error handling (errors.NewConflict)", "error handling (errors.IsConflict)", "error handling (errors.As)", "error handling (errors.NewConflict)", "error handling (errors.IsConflict)", "error handling (errors.As)", "error handling (errors.NewConflict)", "error handling (errors.IsConflict)", "error handling (errors.As)", "error handling (errors.NewConflict)", "error handling (errors.IsConflict)", "error handling (errors.As)", "error handling (errors.NewConflict)", "error handling (errors.IsConflict)", "error handling (errors.As)", "error handling (errors"], "_raw_llm_output": "error handling (errors.Is), error handling (errors.New), error handling (errors.As), error handling (errors.NewConflict), error handling (errors.IsConflict), error handling (errors.As), error handling (errors.NewConflict), error handling (errors.IsConflict), error handling (errors.As), error handling (errors.NewConflict), error handling (errors.IsConflict), error handling (errors.As), error handling (errors.NewConflict), error handling (errors.IsConflict), error handling (errors.As), error handling (errors.NewConflict), error handling (errors.IsConflict), error handling (errors.As), error handling (errors.NewConflict), error handling (errors.IsConflict), error handling (errors.As), error handling (errors.NewConflict), error handling (errors.IsConflict), error handling (errors.As), error handling (errors.NewConflict), error handling (errors.IsConflict), error handling (errors.As), error handling (errors.NewConflict), error handling (errors.IsConflict), error handling (errors.As), error handling (errors.NewConflict), error handling (errors.IsConflict), error handling (errors.As), error handling (errors"}
{"seed": "// IsNoNode returns true if the err parameter is a Zookeeper error representing a missing node\nfunc IsNoNode(err error) bool {\n\tze := filterErr(err)\n\tif ze == nil {\n\t\treturn false\n\t}\n\treturn ze.Code == zookeeper.ZNONODE\n}", "id": 17156, "concepts": ["error handling (errors.Is)", "error wrapping", "error filtering"], "_raw_llm_output": "error handling (errors.Is), error wrapping, error filtering"}
{"seed": "// validateCardinality checks the member count specified for a role in the\n// cluster CR against the cardinality value from the app CR. It can also\n// return a list of PATCH specs that will populate default members values as\n// necessary.\nfunc validateCardinality(\n\tcr *kdv1.KubeDirectorCluster,\n\tappCR *kdv1.KubeDirectorApp,\n) (string, []membersPatchSpec) {\n\n\tvar errorMessages []string\n\tvar patches []membersPatchSpec\n\n\tnumRoles := len(cr.Spec.Roles)\n\tfor i := 0; i < numRoles; i++ {\n\t\trole := &(cr.Spec.Roles[i])\n\t\tappRole := catalog.GetRoleFromID(appCR, role.Name)\n\t\tif appRole == nil {\n\t\t\t// Do nothing; this error will be reported from validateRoles.\n\t\t\tcontinue\n\t\t}\n\t\tcardinality, isScaleOut := catalog.GetRoleCardinality(appRole)\n\t\tif role.Members != nil {\n\t\t\tvar invalidMemberCount = false\n\t\t\tif isScaleOut {\n\t\t\t\tif *(role.Members) < cardinality {\n\t\t\t\t\tinvalidMemberCount = true\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif *(role.Members) != cardinality {\n\t\t\t\t\tinvalidMemberCount = true\n\t\t\t\t}\n\t\t\t}\n\t\t\tif invalidMemberCount {\n\t\t\t\terrorMessages = append(\n\t\t\t\t\terrorMessages,\n\t\t\t\t\tfmt.Sprintf(\n\t\t\t\t\t\tinvalidCardinality,\n\t\t\t\t\t\trole.Name,\n\t\t\t\t\t\t*(role.Members),\n\t\t\t\t\t\tappRole.Cardinality,\n\t\t\t\t\t),\n\t\t\t\t)\n\t\t\t}\n\t\t} else {\n\t\t\tpatches = append(\n\t\t\t\tpatches,\n\t\t\t\tmembersPatchSpec{\n\t\t\t\t\tOp:    \"add\",\n\t\t\t\t\tPath:  \"/spec/roles/\" + strconv.Itoa(i) + \"/members\",\n\t\t\t\t\tValue: cardinality,\n\t\t\t\t},\n\t\t\t)\n\t\t}\n\t}\n\n\tif len(errorMessages) == 0 {\n\t\treturn \"\", patches\n\t}\n\treturn strings.Join(errorMessages, \"\\n\"), nil\n}", "id": 17168, "concepts": ["string formatting", "integer comparison", "string concatenation", "string iteration", "string manipulation", "string concatenation", "string manipulation", "string concatenation", "string manipulation", "string concatenation", "string manipulation", "string concatenation", "string manipulation", "string concatenation", "string manipulation", "string concatenation", "string manipulation", "string concatenation", "string manipulation", "string concatenation", "string manipulation", "string concatenation", "string manipulation", "string concatenation", "string manipulation", "string concatenation", "string manipulation", "string concatenation", "string manipulation", "string concatenation", "string manipulation", "string concatenation", "string manipulation", "string concatenation", "string manipulation", "string concatenation", "string manipulation", "string concatenation", "string manipulation", "string concatenation", "string manipulation", "string concatenation", "string manipulation", "string concatenation", "string manipulation", "string concatenation", "string manipulation", "string concatenation", "string manipulation", "string concatenation", "string manipulation", "string concatenation", "string manipulation", "string concatenation", "string manipulation", "string concatenation", "string manipulation", "string concatenation", "string manipulation", "string concatenation", "string manipulation", "string concatenation", "string manipulation", "string concatenation", "string manipulation", "string concatenation", "string manipulation", "string concatenation", "string manipulation", "string concatenation", "string manipulation", "string concatenation", "string manipulation", "string"], "_raw_llm_output": "string formatting, integer comparison, string concatenation, string iteration, string manipulation, string concatenation, string manipulation, string concatenation, string manipulation, string concatenation, string manipulation, string concatenation, string manipulation, string concatenation, string manipulation, string concatenation, string manipulation, string concatenation, string manipulation, string concatenation, string manipulation, string concatenation, string manipulation, string concatenation, string manipulation, string concatenation, string manipulation, string concatenation, string manipulation, string concatenation, string manipulation, string concatenation, string manipulation, string concatenation, string manipulation, string concatenation, string manipulation, string concatenation, string manipulation, string concatenation, string manipulation, string concatenation, string manipulation, string concatenation, string manipulation, string concatenation, string manipulation, string concatenation, string manipulation, string concatenation, string manipulation, string concatenation, string manipulation, string concatenation, string manipulation, string concatenation, string manipulation, string concatenation, string manipulation, string concatenation, string manipulation, string concatenation, string manipulation, string concatenation, string manipulation, string concatenation, string manipulation, string concatenation, string manipulation, string concatenation, string manipulation, string concatenation, string manipulation, string"}
{"seed": "// Gbit16 reads a 16-bit little-endian binary number from b and returns it\n// with the remaining slice of b.\n//go:nosplit\nfunc gbit16(b []byte) (int, []byte) {\n\treturn int(b[0]) | int(b[1])<<8, b[2:]\n}", "id": 17187, "concepts": ["byte manipulation", "bitwise operations", "nosplit"], "_raw_llm_output": "byte manipulation, bitwise operations, nosplit"}
{"seed": "// ServiceWantPath returns the systemd default.target want symlink path for the\n// given app name.\nfunc ServiceWantPath(root string, appName types.ACName) string {\n\treturn filepath.Join(common.Stage1RootfsPath(root), defaultWantsDir, ServiceUnitName(appName))\n}", "id": 17191, "concepts": ["filepath package usage", "string manipulation", "common Go idioms"], "_raw_llm_output": "filepath package usage, string manipulation, common Go idioms"}
{"seed": "// NewAttributeValueInt creates a new AttributeValue with the given int64 value.\nfunc NewAttributeValueInt(v int64) AttributeValue {\n\torig := &otlpcommon.AnyValue{Value: &otlpcommon.AnyValue_IntValue{IntValue: v}}\n\treturn AttributeValue{orig: orig}\n}", "id": 17192, "concepts": ["struct definition", "pointer usage", "interface implementation"], "_raw_llm_output": "struct definition, pointer usage, interface implementation"}
{"seed": "// WithMaxConcurrentReconciles is an Option that configures the number of\n// concurrent reconciles that the controller will run.\n//\n// The default is 1.\nfunc WithMaxConcurrentReconciles(max int) Option {\n\treturn func(r *Reconciler) error {\n\t\tif max < 1 {\n\t\t\treturn errors.New(\"maxConcurrentReconciles must be at least 1\")\n\t\t}\n\t\tr.maxConcurrentReconciles = max\n\t\treturn nil\n\t}\n}", "id": 17205, "concepts": ["Option pattern", "function composition", "error handling"], "_raw_llm_output": "Option pattern, function composition, error handling"}
{"seed": "// B_ is a convenience wrapper for B without the attrs argument.\nfunc B_(children ...HTML) HTML {\n  return B(nil, children...)\n}", "id": 17206, "concepts": ["function definition", "function argument", "function return value", "function argument type", "function argument default value", "function argument variadic", "function argument named return value", "function argument named return value type", "function argument named return value default value", "function argument named return value default value type", "function argument named return value default value type", "function argument named return value default value type", "function argument named return value default value type", "function argument named return value default value type", "function argument named return value default value type", "function argument named return value default value type", "function argument named return value default value type", "function argument named return value default value type", "function argument named return value default value type", "function argument named return value default value type", "function argument named return value default value type", "function argument named return value default value type", "function argument named return value default value type", "function argument named return value default value type", "function argument named return value default value type", "function argument named return value default value type", "function argument named return value default value type", "function argument named return value default value type", "function argument named return value default value type", "function argument named return value default value type", "function argument named return value default value type", "function argument named return value default value type", "function argument named"], "_raw_llm_output": "function definition, function argument, function return value, function argument type, function argument default value, function argument variadic, function argument named return value, function argument named return value type, function argument named return value default value, function argument named return value default value type, function argument named return value default value type, function argument named return value default value type, function argument named return value default value type, function argument named return value default value type, function argument named return value default value type, function argument named return value default value type, function argument named return value default value type, function argument named return value default value type, function argument named return value default value type, function argument named return value default value type, function argument named return value default value type, function argument named return value default value type, function argument named return value default value type, function argument named return value default value type, function argument named return value default value type, function argument named return value default value type, function argument named return value default value type, function argument named return value default value type, function argument named return value default value type, function argument named return value default value type, function argument named return value default value type, function argument named return value default value type, function argument named"}
{"seed": "// DefaultExprHasPrefix applies the HasPrefix predicate on the \"default_expr\" field.\nfunc DefaultExprHasPrefix(v string) predicate.User {\n\treturn predicate.User(sql.FieldHasPrefix(FieldDefaultExpr, v))\n}", "id": 17208, "concepts": ["sql.FieldHasPrefix", "predicate.User", "sql.Field"], "_raw_llm_output": "sql.FieldHasPrefix, predicate.User, sql.Field"}
{"seed": "// WithBattle middleware sets the battle corresponding to the :battleID URL parameter into\n// ctx.Locals under the key \"battle\"\nfunc WithBattle(r battles.Reader) func(*fiber.Ctx) error {\n\treturn func(ctx *fiber.Ctx) error {\n\t\tid, err := uuid.FromString(ctx.Params(\"battleID\"))\n\t\tif err != nil {\n\t\t\treturn newErrBadRequest(\"Invalid BattleID\")\n\t\t}\n\t\tbattle, err := r.FindOne(battles.FindOneQuery{ID: id})\n\t\tif err != nil {\n\t\t\treturn handleFindOneError(err, \"Battle\")\n\t\t}\n\t\tctx.Locals(\"battle\", battle)\n\t\treturn ctx.Next()\n\t}\n}", "id": 17229, "concepts": ["middleware", "uuid package usage", "error handling (idiomatic `if err != nil`", "`errors.Is`", "`errors.As`)", "type conversion (uuid.FromString)", "function composition", "function definition"], "_raw_llm_output": "middleware, uuid package usage, error handling (idiomatic `if err != nil`, `errors.Is`, `errors.As`), type conversion (uuid.FromString), function composition, function definition"}
{"seed": "// StatusNotIn applies the NotIn predicate on the \"status\" field.\nfunc StatusNotIn(vs ...Status) predicate.User {\n\treturn predicate.User(sql.FieldNotIn(FieldStatus, vs...))\n}", "id": 17243, "concepts": ["sql.FieldNotIn", "sql.FieldIn", "sql.FieldEq", "sql.FieldGt", "sql.FieldLt", "sql.FieldGte", "sql.FieldLte", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldIsNull", "sql.FieldIsNotNull", "sql.FieldBetween", "sql.FieldNotBetween", "sql.FieldIs", "sql.FieldIsNot", "sql.FieldIsOneOf", "sql.FieldIsNotOneOf", "sql.FieldIsOneOf", "sql.FieldIsNotOneOf", "sql.FieldIsOneOf", "sql.FieldIsNotOneOf", "sql.FieldIsOneOf", "sql.FieldIsNotOneOf", "sql.FieldIsOneOf", "sql.FieldIsNotOneOf", "sql.FieldIsOneOf", "sql.FieldIsNotOneOf", "sql.FieldIsOneOf", "sql.FieldIsNotOneOf", "sql.FieldIsOneOf", "sql.FieldIsNotOneOf", "sql.FieldIsOneOf", "sql.FieldIsNotOneOf", "sql.FieldIsOneOf", "sql.FieldIsNotOneOf", "sql.FieldIsOneOf", "sql.FieldIsNotOneOf", "sql.FieldIsOneOf", "sql.FieldIsNotOneOf", "sql.FieldIsOneOf", "sql.FieldIsNotOneOf", "sql.FieldIsOneOf", "sql.FieldIsNot"], "_raw_llm_output": "sql.FieldNotIn, sql.FieldIn, sql.FieldEq, sql.FieldGt, sql.FieldLt, sql.FieldGte, sql.FieldLte, sql.FieldLike, sql.FieldNotLike, sql.FieldIn, sql.FieldNotIn, sql.FieldIsNull, sql.FieldIsNotNull, sql.FieldBetween, sql.FieldNotBetween, sql.FieldIs, sql.FieldIsNot, sql.FieldIsOneOf, sql.FieldIsNotOneOf, sql.FieldIsOneOf, sql.FieldIsNotOneOf, sql.FieldIsOneOf, sql.FieldIsNotOneOf, sql.FieldIsOneOf, sql.FieldIsNotOneOf, sql.FieldIsOneOf, sql.FieldIsNotOneOf, sql.FieldIsOneOf, sql.FieldIsNotOneOf, sql.FieldIsOneOf, sql.FieldIsNotOneOf, sql.FieldIsOneOf, sql.FieldIsNotOneOf, sql.FieldIsOneOf, sql.FieldIsNotOneOf, sql.FieldIsOneOf, sql.FieldIsNotOneOf, sql.FieldIsOneOf, sql.FieldIsNotOneOf, sql.FieldIsOneOf, sql.FieldIsNotOneOf, sql.FieldIsOneOf, sql.FieldIsNotOneOf, sql.FieldIsOneOf, sql.FieldIsNot"}
{"seed": "// WithValueMapper is an Option that configures a function that maps values\n// from a custom resource spec to the values passed to Helm.\n// Use this if you want to apply a transformation on the values obtained from your custom resource, before\n// they are passed to Helm.\nfunc WithValueMapper(m values.Mapper) Option {\n\treturn func(r *Reconciler) error {\n\t\tr.valueMapper = m\n\t\treturn nil\n\t}\n}", "id": 17247, "concepts": ["function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition"], "_raw_llm_output": "function composition, function composition, function composition, function composition, function composition, function composition, function composition"}
{"seed": "// NewUpdateMedicineUnauthorized creates UpdateMedicineUnauthorized with default headers values\nfunc NewUpdateMedicineUnauthorized() *UpdateMedicineUnauthorized {\n\n\treturn &UpdateMedicineUnauthorized{}\n}", "id": 17256, "concepts": ["struct definition", "anonymous struct definition", "default header values"], "_raw_llm_output": "struct definition, anonymous struct definition, default header values"}
{"seed": "// HeroPlayedGTE applies the GTE predicate on the \"hero_played\" field.\nfunc HeroPlayedGTE(v uint) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.GTE(s.C(FieldHeroPlayed), v))\n\t})\n}", "id": 17257, "concepts": ["sql.Selector", "sql.GTE", "sql.C", "sql.Where", "sql.Predicate"], "_raw_llm_output": "sql.Selector, sql.GTE, sql.C, sql.Where, sql.Predicate"}
{"seed": "// IsWithSimulation returns true if transaction context is configured to enable\n// pre-execution simulation.\nfunc IsWithSimulation(ctx context.Context) bool {\n\t_, withSimulation := ctx.Value(txnSimulationCtxKey).(*txnSimulationOpt)\n\treturn withSimulation\n}", "id": 17260, "concepts": ["context", "context.Value", "context.WithValue", "context.Context", "basic function definition"], "_raw_llm_output": "context, context.Value, context.WithValue, context.Context, basic function definition"}
{"seed": "// TransformOnlyId is a `Transformer`. It receives an answer value and returns\n// a copy of the answer with only the first word, which expected to be the ID of\n// the resource.\nfunc TransformOnlyId(answer interface{}) interface{} {\n\tswitch ans := answer.(type) {\n\n\t// Select.\n\tcase core.OptionAnswer:\n\t\treturn core.OptionAnswer{\n\t\t\tIndex: ans.Index,\n\t\t\tValue: strings.Fields(ans.Value)[0],\n\t\t}\n\n\t// Multi-select.\n\tcase []core.OptionAnswer:\n\t\tout := make([]core.OptionAnswer, len(ans))\n\t\tfor i, o := range ans {\n\t\t\tout[i] = core.OptionAnswer{\n\t\t\t\tIndex: o.Index,\n\t\t\t\tValue: strings.Fields(o.Value)[0],\n\t\t\t}\n\t\t}\n\t\treturn out\n\t}\n\n\treturn answer\n}", "id": 17279, "concepts": ["type assertion", "type switch", "type assertion", "type switch", "type assertion", "type switch", "type assertion", "type switch", "type assertion", "type switch", "type assertion", "type switch", "type assertion", "type switch", "type assertion", "type switch", "type assertion", "type switch", "type assertion", "type switch", "type assertion", "type switch", "type assertion", "type switch", "type assertion", "type switch", "type assertion", "type switch", "type assertion", "type switch", "type assertion", "type switch", "type assertion", "type switch", "type assertion", "type switch", "type assertion", "type switch", "type assertion", "type switch", "type assertion", "type switch", "type assertion", "type switch", "type assertion", "type switch", "type assertion", "type switch", "type assertion", "type switch", "type assertion", "type switch", "type assertion", "type switch", "type assertion", "type switch", "type assertion", "type switch", "type assertion", "type switch", "type assertion", "type switch", "type assertion", "type switch", "type assertion", "type switch", "type assertion", "type switch", "type assertion", "type switch", "type assertion", "type switch", "type assertion", "type switch", "type assertion", "type switch", "type assertion", "type switch", "type assertion", "type switch", "type assertion", "type switch", "type assertion", "type switch", "type assertion", ""], "_raw_llm_output": "type assertion, type switch, type assertion, type switch, type assertion, type switch, type assertion, type switch, type assertion, type switch, type assertion, type switch, type assertion, type switch, type assertion, type switch, type assertion, type switch, type assertion, type switch, type assertion, type switch, type assertion, type switch, type assertion, type switch, type assertion, type switch, type assertion, type switch, type assertion, type switch, type assertion, type switch, type assertion, type switch, type assertion, type switch, type assertion, type switch, type assertion, type switch, type assertion, type switch, type assertion, type switch, type assertion, type switch, type assertion, type switch, type assertion, type switch, type assertion, type switch, type assertion, type switch, type assertion, type switch, type assertion, type switch, type assertion, type switch, type assertion, type switch, type assertion, type switch, type assertion, type switch, type assertion, type switch, type assertion, type switch, type assertion, type switch, type assertion, type switch, type assertion, type switch, type assertion, type switch, type assertion, type switch, type assertion, type switch, type assertion,"}
{"seed": "// ZookeeperString returns the list of Zookeeper hosts ss in the form of a single string in Zookeeper config format\nfunc ZookeeperString(ss []string) string {\n\tvar w bytes.Buffer\n\tfor i, z := range ss {\n\t\tw.WriteString(z)\n\t\tif i+1 < len(ss) {\n\t\t\tw.WriteByte(',')\n\t\t}\n\t}\n\treturn string(w.Bytes())\n}", "id": 17283, "concepts": ["bytes.Buffer", "string concatenation", "string iteration"], "_raw_llm_output": "bytes.Buffer, string concatenation, string iteration"}
{"seed": "// NewTSConnectionService creates a new TSConnectionService instance\nfunc NewTSConnectionService() TSConnectionService {\n\treturn &defaultTSConnectionService{}\n}", "id": 17297, "concepts": ["interface", "struct", "function definition", "method definition", "constructor"], "_raw_llm_output": "interface, struct, function definition, method definition, constructor"}
{"seed": "// Validation_Values returns all elements of the Validation enum\nfunc Validation_Values() []string {\n\treturn []string{\n\t\tValidationEnable,\n\t\tValidationDisable,\n\t\tValidationUseLocalResourceSetting,\n\t}\n}", "id": 17303, "concepts": ["enum", "string concatenation", "array iteration"], "_raw_llm_output": "enum, string concatenation, array iteration"}
{"seed": "// NewMessageCardSectionFact creates an empty message card section fact\nfunc NewMessageCardSectionFact() MessageCardSectionFact {\n\tmsgCardSectionFact := MessageCardSectionFact{}\n\treturn msgCardSectionFact\n}", "id": 17305, "concepts": ["struct definition", "struct initialization", "struct field definition", "struct field initialization"], "_raw_llm_output": "struct definition, struct initialization, struct field definition, struct field initialization"}
{"seed": "// NewLineRouteParamsWithHTTPClient creates a new LineRouteParams object\n// with the default values initialized, and the ability to set a custom HTTPClient for a request\nfunc NewLineRouteParamsWithHTTPClient(client *http.Client) *LineRouteParams {\n\tvar ()\n\treturn &LineRouteParams{\n\t\tHTTPClient: client,\n\t}\n}", "id": 17329, "concepts": ["struct initialization", "pointer usage", "http.Client usage"], "_raw_llm_output": "struct initialization, pointer usage, http.Client usage"}
{"seed": "// readLinesFromFile \u4ece\u6587\u4ef6\u8bfb\u53d6\u6240\u6709\u6587\u672c\u884c\n// \u6240\u6709\u5236\u8868\u7b26\u4f1a\u88ab\u66ff\u6362\u4e3a\u7a7a\u683c\n// \u9996\u5c3e\u7684\u7a7a\u683c\u4f1a\u88ab\u53bb\u9664\n// # \u4f1a\u6ce8\u91ca\u6389\u6240\u6709\u6240\u5728\u884c\u5269\u4e0b\u7684\u5185\u5bb9\nfunc readLinesFromFile(filePath string) ([]string, error) {\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\tlogger.Error(err)\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\n\tvar lines []string\n\tscanner := bufio.NewScanner(file)\n\tfor scanner.Scan() {\n\t\tline := scanner.Text()\n\t\titems := strings.Split(line, \"#\")\n\t\tline = strings.TrimSpace(items[0])\n\t\tif line != \"\" {\n\t\t\tline = strings.Replace(line, \"\\t\", \" \", -1)\n\t\t\tlines = append(lines, line)\n\t\t}\n\t}\n\treturn lines, scanner.Err()\n}", "id": 17337, "concepts": ["file reading", "bufio.Scanner", "string manipulation", "os.Open", "os.File", "os.Close", "string.Split", "string.TrimSpace", "string.Replace", "string.Join", "errors.New", "errors.Is", "errors.As", "errors.Unwrap", "errors.Errorf", "errors.Wrap", "errors.Cause", "errors.Is", "errors.As", "errors.Unwrap", "errors.Errorf", "errors.Wrap", "errors.Cause", "errors.Is", "errors.As", "errors.Unwrap", "errors.Errorf", "errors.Wrap", "errors.Cause", "errors.Is", "errors.As", "errors.Unwrap", "errors.Errorf", "errors.Wrap", "errors.Cause", "errors.Is", "errors.As", "errors.Unwrap", "errors.Errorf", "errors.Wrap", "errors.Cause", "errors.Is", "errors.As", "errors.Unwrap", "errors.Errorf", "errors.Wrap", "errors.Cause", "errors.Is", "errors.As", "errors.Unwrap", "errors.Errorf", "errors.Wrap", "errors.Cause", "errors.Is", "errors.As", "errors.Unwrap", "errors.Errorf", "errors.Wrap", "errors.Cause", "errors.Is", "errors.As", "errors.Un"], "_raw_llm_output": "file reading, bufio.Scanner, string manipulation, os.Open, os.File, os.Close, string.Split, string.TrimSpace, string.Replace, string.Join, errors.New, errors.Is, errors.As, errors.Unwrap, errors.Errorf, errors.Wrap, errors.Cause, errors.Is, errors.As, errors.Unwrap, errors.Errorf, errors.Wrap, errors.Cause, errors.Is, errors.As, errors.Unwrap, errors.Errorf, errors.Wrap, errors.Cause, errors.Is, errors.As, errors.Unwrap, errors.Errorf, errors.Wrap, errors.Cause, errors.Is, errors.As, errors.Unwrap, errors.Errorf, errors.Wrap, errors.Cause, errors.Is, errors.As, errors.Unwrap, errors.Errorf, errors.Wrap, errors.Cause, errors.Is, errors.As, errors.Unwrap, errors.Errorf, errors.Wrap, errors.Cause, errors.Is, errors.As, errors.Unwrap, errors.Errorf, errors.Wrap, errors.Cause, errors.Is, errors.As, errors.Un"}
{"seed": "// HeroRepeatLTE applies the LTE predicate on the \"hero_repeat\" field.\nfunc HeroRepeatLTE(v uint) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.LTE(s.C(FieldHeroRepeat), v))\n\t})\n}", "id": 17342, "concepts": ["sql.Selector", "sql.C", "sql.LTE", "sql.Where", "predicate.User"], "_raw_llm_output": "sql.Selector, sql.C, sql.LTE, sql.Where, predicate.User"}
{"seed": "// copyOwnership copies the permissions and uid:gid of the source file\n// into the destination file\nfunc copyOwnership(source, destination string) error {\n\tstat, err := system.Stat(source)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := os.Chown(destination, int(stat.Uid()), int(stat.Gid())); err != nil {\n\t\treturn err\n\t}\n\n\treturn os.Chmod(destination, os.FileMode(stat.Mode()))\n}", "id": 17346, "concepts": ["os.Stat", "os.Chown", "os.Chmod", "os.FileMode", "system package usage"], "_raw_llm_output": "os.Stat, os.Chown, os.Chmod, os.FileMode, system package usage"}
{"seed": "// ParseUpdateSksNodepoolResponse parses an HTTP response from a UpdateSksNodepoolWithResponse call\nfunc ParseUpdateSksNodepoolResponse(rsp *http.Response) (*UpdateSksNodepoolResponse, error) {\n\tbodyBytes, err := ioutil.ReadAll(rsp.Body)\n\tdefer rsp.Body.Close()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse := &UpdateSksNodepoolResponse{\n\t\tBody:         bodyBytes,\n\t\tHTTPResponse: rsp,\n\t}\n\n\tswitch {\n\tcase strings.Contains(rsp.Header.Get(\"Content-Type\"), \"json\") && rsp.StatusCode == 200:\n\t\tvar dest Operation\n\t\tif err := json.Unmarshal(bodyBytes, &dest); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresponse.JSON200 = &dest\n\n\t}\n\n\treturn response, nil\n}", "id": 17352, "concepts": ["HTTP response parsing", "JSON parsing", "error handling (json.Unmarshal)", "switch statement"], "_raw_llm_output": "HTTP response parsing, JSON parsing, error handling (json.Unmarshal), switch statement"}
{"seed": "// checkNoArguments checks that there are no arguments.\nfunc checkNoArguments(_ *cobra.Command, args []string) error {\n\tif len(args) > 0 {\n\t\treturn errors.New(\"this command doesn't support any arguments\")\n\t}\n\n\treturn nil\n}", "id": 17358, "concepts": ["command-line argument handling", "error handling (errors.New)", "cobra package usage"], "_raw_llm_output": "command-line argument handling, error handling (errors.New), cobra package usage"}
{"seed": "// Font_ is a convenience wrapper for Font without the attrs argument.\nfunc Font_(children ...HTML) HTML {\n  return Font(nil, children...)\n}", "id": 17359, "concepts": ["function composition", "function definition", "function call", "function return"], "_raw_llm_output": "function composition, function definition, function call, function return"}
{"seed": "// ExpandAsColumns expand columns with alias AS\n// query := ExpandAsColumns(\"table.foo\", \"bar\")\n// // []string{\"table.foo AS table_foo\", \"bar AS bar\"}\nfunc ExpandAsColumns(cols ...string) []string {\n\tcols = strings_.SliceTrimEmpty(cols...)\n\tvar params []string\n\tfor _, col := range cols {\n\t\tparams = append(params, fmt.Sprintf(\"%[1]s AS %[2]s\", col, CompliantName(col)))\n\t}\n\treturn params\n}", "id": 17368, "concepts": ["string manipulation", "strings.TrimSpace", "string formatting", "string composition"], "_raw_llm_output": "string manipulation, strings.TrimSpace, string formatting, string composition"}
{"seed": "// AbsoluteBazelTarget converts a ruleName to an absolute target string (//foo/bar:bar).\n// It interprets ruleName relative to the given build file's package. It\n// supports plain names, names starting with colons, absolute paths, and\n// absolute paths with shorthand target syntax (i.e. \"bar\", \":bar\", \"//foo/bar\",\n// \"//foo/bar:bar\").\nfunc AbsoluteBazelTarget(bld *build.File, ruleName string) string {\n\tif strings.HasPrefix(ruleName, \"//\") {\n\t\t// already absolute\n\t\tif colonIdx := strings.LastIndex(ruleName, \":\"); colonIdx == -1 {\n\t\t\t// expand shorthand syntax\n\t\t\treturn ruleName + \":\" + ruleName[strings.LastIndex(ruleName, \"/\")+1:]\n\t\t}\n\t\treturn ruleName\n\t}\n\tpkg := platform.Normalize(filepath.Dir(bld.Path))\n\treturn fmt.Sprintf(\"//%s:%s\", pkg, strings.TrimPrefix(ruleName, \":\"))\n}", "id": 17401, "concepts": ["string manipulation", "filepath handling", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", "string manipulation", ""], "_raw_llm_output": "string manipulation, filepath handling, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation, string manipulation,"}
{"seed": "// ExternalLoadBalancer instruct create to add an external loadbalancer to the cluster.\n// NB. this happens automatically when there are more than two control plane instances, but with this flag\n// it is possible to override the default behaviour\nfunc ExternalLoadBalancer(externalLoadBalancer bool) CreateOption {\n\treturn func(c *CreateOptions) {\n\t\tc.externalLoadBalancer = externalLoadBalancer\n\t}\n}", "id": 17420, "concepts": ["function composition", "function definition", "function options", "function parameters"], "_raw_llm_output": "function composition, function definition, function options, function parameters"}
{"seed": "// NewAPIServiceMissedBlocksParamsWithContext creates a new APIServiceMissedBlocksParams object\n// with the default values initialized, and the ability to set a context for a request\nfunc NewAPIServiceMissedBlocksParamsWithContext(ctx context.Context) *APIServiceMissedBlocksParams {\n\tvar ()\n\treturn &APIServiceMissedBlocksParams{\n\n\t\tContext: ctx,\n\t}\n}", "id": 17423, "concepts": ["context package usage", "function definition", "method definition"], "_raw_llm_output": "context package usage, function definition, method definition"}
{"seed": "// PossibleForwardingProtocolValues returns an array of possible values for the ForwardingProtocol const type.\nfunc PossibleForwardingProtocolValues() []ForwardingProtocol {\n\treturn []ForwardingProtocol{ForwardingProtocolHTTPOnly, ForwardingProtocolHTTPSOnly, ForwardingProtocolMatchRequest}\n}", "id": 17440, "concepts": ["enumerations", "constants", "type definition"], "_raw_llm_output": "enumerations, constants, type definition"}
{"seed": "// GetAuthCredentialsFromBroker returns the auth credentials, if any,\n// contained in the secret referenced in the Broker's AuthSecret field, or\n// returns an error. If the AuthSecret field is nil, empty values are\n// returned.\nfunc GetAuthCredentialsFromBroker(client kubernetes.Interface, broker *servicecatalog.Broker) (username, password string, err error) {\n\tif broker.Spec.AuthSecret == nil {\n\t\treturn \"\", \"\", nil\n\t}\n\n\tauthSecret, err := client.Core().Secrets(broker.Spec.AuthSecret.Namespace).Get(broker.Spec.AuthSecret.Name)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\tusernameBytes, ok := authSecret.Data[\"username\"]\n\tif !ok {\n\t\treturn \"\", \"\", fmt.Errorf(\"auth secret didn't contain username\")\n\t}\n\n\tpasswordBytes, ok := authSecret.Data[\"password\"]\n\tif !ok {\n\t\treturn \"\", \"\", fmt.Errorf(\"auth secret didn't contain password\")\n\t}\n\n\treturn string(usernameBytes), string(passwordBytes), nil\n}", "id": 17449, "concepts": ["kubernetes API usage", "secret handling", "string manipulation", "basic function definition"], "_raw_llm_output": "kubernetes API usage, secret handling, string manipulation, basic function definition"}
{"seed": "// GroupNameNotFound returns a NotFoundError for a missing group searched by\n// name.\nfunc GroupNameNotFound(name string) error {\n\treturn &NotFoundError{\n\t\thasDetails:     true,\n\t\tentityName:     \"group\",\n\t\tidentifierName: \"name\",\n\t\tidentifier:     fmt.Sprintf(\"\\\"%v\\\"\", name),\n\t}\n}", "id": 17467, "concepts": ["error handling (error wrapping)", "error details"], "_raw_llm_output": "error handling (error wrapping), error details"}
{"seed": "// AzureADLicenseTypePFree returns a pointer to AzureADLicenseTypeVFree\nfunc AzureADLicenseTypePFree() *AzureADLicenseType {\n\tv := AzureADLicenseTypeVFree\n\treturn &v\n}", "id": 17472, "concepts": ["pointer usage", "pointer dereference", "pointer assignment"], "_raw_llm_output": "pointer usage, pointer dereference, pointer assignment"}
{"seed": "// HeroPlayedGT applies the GT predicate on the \"hero_played\" field.\nfunc HeroPlayedGT(v uint) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.GT(s.C(FieldHeroPlayed), v))\n\t})\n}", "id": 17482, "concepts": ["sql.Selector", "sql.Where", "sql.GT", "sql.C", "predicate.User"], "_raw_llm_output": "sql.Selector, sql.Where, sql.GT, sql.C, predicate.User"}
{"seed": "// LessThanOrEqualTo creates an Constraint which an instance will be\n// declared as valid if its value is less than or equal to refValue.\nfunc LessThanOrEqualTo[\n\tValueT typecons.Ordered,\n](refValue ValueT) OrderedConstraint[ValueT] {\n\treturn &relOpConstraint[ValueT]{ref: refValue, op: relOpLessOrEqual}\n}", "id": 17484, "concepts": ["type constraints", "type parameters", "type constraints", "type assertions"], "_raw_llm_output": "type constraints, type parameters, type constraints, type assertions"}
{"seed": "// getTestArch returns architecture of the cluster where test suites will be executed.\n// default value is similar to build architecture, TEST_RUNTIME_ARCH is used when test target cluster has another architecture\nfunc getTestArch() string {\n\tval, ok := os.LookupEnv(\"TEST_RUNTIME_ARCH\")\n\tif ok {\n\t\treturn val\n\t}\n\treturn runtime.GOARCH\n}", "id": 17486, "concepts": ["os.LookupEnv", "runtime.GOARCH"], "_raw_llm_output": "os.LookupEnv, runtime.GOARCH"}
{"seed": "// parseUIDs returns the list of UIDs for a character given the JSON\n// response\nfunc parseUIDs(jsonData []byte) ([]string, error) {\n\tvar uids []string\n\n\ttype character struct {\n\t\tUID string `json:\"uid\"`\n\t}\n\tvar data struct {\n\t\tCharacters []character `json:\"characters\"`\n\t}\n\n\tif err := json.Unmarshal(jsonData, &data); err != nil {\n\t\treturn uids, err\n\t}\n\n\tfor _, character := range data.Characters {\n\t\tuids = append(uids, character.UID)\n\t}\n\n\treturn uids, nil\n}", "id": 17490, "concepts": ["JSON parsing", "JSON unmarshaling", "JSON struct definition", "basic function definition"], "_raw_llm_output": "JSON parsing, JSON unmarshaling, JSON struct definition, basic function definition"}
{"seed": "// BetterHeroScoreAtNotIn applies the NotIn predicate on the \"better_hero_score_at\" field.\nfunc BetterHeroScoreAtNotIn(vs ...time.Time) predicate.User {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.User(func(s *sql.Selector) {\n\t\t// if not arguments were provided, append the FALSE constants,\n\t\t// since we can't apply \"IN ()\". This will make this predicate falsy.\n\t\tif len(vs) == 0 {\n\t\t\ts.Where(sql.False())\n\t\t\treturn\n\t\t}\n\t\ts.Where(sql.NotIn(s.C(FieldBetterHeroScoreAt), v...))\n\t})\n}", "id": 17492, "concepts": ["sql.Selector", "sql.NotIn", "sql.False", "sql.C", "sql.Where", "sql.NotIn", "sql.Where", "sql.NotIn", "sql.Where", "sql.NotIn", "sql.Where", "sql.NotIn", "sql.Where", "sql.NotIn", "sql.Where", "sql.NotIn", "sql.Where", "sql.NotIn", "sql.Where", "sql.NotIn", "sql.Where", "sql.NotIn", "sql.Where", "sql.NotIn", "sql.Where", "sql.NotIn", "sql.Where", "sql.NotIn", "sql.Where", "sql.NotIn", "sql.Where", "sql.NotIn", "sql.Where", "sql.NotIn", "sql.Where", "sql.NotIn", "sql.Where", "sql.NotIn", "sql.Where", "sql.NotIn", "sql.Where", "sql.NotIn", "sql.Where", "sql.NotIn", "sql.Where", "sql.NotIn", "sql.Where", "sql.NotIn", "sql.Where", "sql.NotIn", "sql.Where", "sql.NotIn", "sql.Where", "sql.NotIn", "sql.Where", "sql.NotIn", "sql.Where", "sql.NotIn", "sql.Where", "sql.NotIn", "sql.Where", "sql.NotIn", "sql.Where", "sql.NotIn"], "_raw_llm_output": "sql.Selector, sql.NotIn, sql.False, sql.C, sql.Where, sql.NotIn, sql.Where, sql.NotIn, sql.Where, sql.NotIn, sql.Where, sql.NotIn, sql.Where, sql.NotIn, sql.Where, sql.NotIn, sql.Where, sql.NotIn, sql.Where, sql.NotIn, sql.Where, sql.NotIn, sql.Where, sql.NotIn, sql.Where, sql.NotIn, sql.Where, sql.NotIn, sql.Where, sql.NotIn, sql.Where, sql.NotIn, sql.Where, sql.NotIn, sql.Where, sql.NotIn, sql.Where, sql.NotIn, sql.Where, sql.NotIn, sql.Where, sql.NotIn, sql.Where, sql.NotIn, sql.Where, sql.NotIn, sql.Where, sql.NotIn, sql.Where, sql.NotIn, sql.Where, sql.NotIn, sql.Where, sql.NotIn, sql.Where, sql.NotIn, sql.Where, sql.NotIn, sql.Where, sql.NotIn, sql.Where, sql.NotIn, sql.Where, sql.NotIn"}
{"seed": "// DescriptionGT applies the GT predicate on the \"description\" field.\nfunc DescriptionGT(v string) predicate.User {\n\treturn predicate.User(sql.FieldGT(FieldDescription, v))\n}", "id": 17500, "concepts": ["sql.FieldGT", "sql.FieldLT", "sql.FieldEQ", "sql.FieldNE", "sql.FieldIN", "sql.FieldNotIn", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldContains", "sql.FieldNotContains", "sql.FieldIContains", "sql.FieldINotContains", "sql.FieldILike", "sql.FieldINotLike", "sql.FieldILike", "sql.FieldINotLike", "sql.FieldILike", "sql.FieldINotLike", "sql.FieldILike", "sql.FieldINotLike", "sql.FieldILike", "sql.FieldINotLike", "sql.FieldILike", "sql.FieldINotLike", "sql.FieldILike", "sql.FieldINotLike", "sql.FieldILike", "sql.FieldINotLike", "sql.FieldILike", "sql.FieldINotLike", "sql.FieldILike", "sql.FieldINotLike", "sql.FieldILike", "sql.FieldINotLike", "sql.FieldILike", "sql.FieldINotLike", "sql.FieldILike", "sql.FieldINotLike", "sql.FieldILike", "sql.FieldINotLike", "sql.FieldILike", "sql."], "_raw_llm_output": "sql.FieldGT, sql.FieldLT, sql.FieldEQ, sql.FieldNE, sql.FieldIN, sql.FieldNotIn, sql.FieldLike, sql.FieldNotLike, sql.FieldContains, sql.FieldNotContains, sql.FieldIContains, sql.FieldINotContains, sql.FieldILike, sql.FieldINotLike, sql.FieldILike, sql.FieldINotLike, sql.FieldILike, sql.FieldINotLike, sql.FieldILike, sql.FieldINotLike, sql.FieldILike, sql.FieldINotLike, sql.FieldILike, sql.FieldINotLike, sql.FieldILike, sql.FieldINotLike, sql.FieldILike, sql.FieldINotLike, sql.FieldILike, sql.FieldINotLike, sql.FieldILike, sql.FieldINotLike, sql.FieldILike, sql.FieldINotLike, sql.FieldILike, sql.FieldINotLike, sql.FieldILike, sql.FieldINotLike, sql.FieldILike, sql.FieldINotLike, sql.FieldILike, sql."}
{"seed": "// NewMockLSIFStoreFrom creates a new mock of the MockLSIFStore interface.\n// All methods delegate to the given implementation, unless overwritten.\nfunc NewMockLSIFStoreFrom(i LSIFStore) *MockLSIFStore {\n\treturn &MockLSIFStore{\n\t\tClearFunc: &LSIFStoreClearFunc{\n\t\t\tdefaultHook: i.Clear,\n\t\t},\n\t\tDoneFunc: &LSIFStoreDoneFunc{\n\t\t\tdefaultHook: i.Done,\n\t\t},\n\t\tTransactFunc: &LSIFStoreTransactFunc{\n\t\t\tdefaultHook: i.Transact,\n\t\t},\n\t}\n}", "id": 17509, "concepts": ["interface", "function composition", "mocking", "function composition"], "_raw_llm_output": "interface, function composition, mocking, function composition"}
{"seed": "// CorrectionLT applies the LT predicate on the \"correction\" field.\nfunc CorrectionLT(v string) predicate.TradeCorrection {\n\treturn predicate.TradeCorrection(sql.FieldLT(FieldCorrection, v))\n}", "id": 17519, "concepts": ["sql.FieldLT", "sql.FieldGT", "sql.FieldEQ", "sql.FieldNE", "sql.FieldIN", "sql.FieldNotIn", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldIs", "sql.FieldIsNot", "sql.FieldIsNull", "sql.FieldIsNotNull", "sql.FieldBetween", "sql.FieldNotBetween", "sql.FieldContains", "sql.FieldNotContains", "sql.FieldStartsWith", "sql.FieldNotStartsWith", "sql.FieldEndsWith", "sql.FieldNotEndsWith", "sql.FieldContainsAny", "sql.FieldNotContainsAny", "sql.FieldContainsAll", "sql.FieldNotContainsAll", "sql.FieldContainsAll", "sql.FieldNotContainsAll", "sql.FieldContainsAny", "sql.FieldNotContainsAny", "sql.FieldContainsAll", "sql.FieldNotContainsAll", "sql.FieldContainsAny", "sql.FieldNotContainsAny", "sql.FieldContainsAll", "sql.FieldNotContainsAll", "sql.FieldContainsAny", "sql.FieldNotContainsAny", "sql.FieldContainsAll", "sql.FieldNotContainsAll", "sql.FieldContainsAny", "sql.FieldNotContainsAny", "sql.FieldContainsAll", "sql.FieldNotContainsAll", "sql.FieldContainsAny", "sql"], "_raw_llm_output": "sql.FieldLT, sql.FieldGT, sql.FieldEQ, sql.FieldNE, sql.FieldIN, sql.FieldNotIn, sql.FieldLike, sql.FieldNotLike, sql.FieldIs, sql.FieldIsNot, sql.FieldIsNull, sql.FieldIsNotNull, sql.FieldBetween, sql.FieldNotBetween, sql.FieldContains, sql.FieldNotContains, sql.FieldStartsWith, sql.FieldNotStartsWith, sql.FieldEndsWith, sql.FieldNotEndsWith, sql.FieldContainsAny, sql.FieldNotContainsAny, sql.FieldContainsAll, sql.FieldNotContainsAll, sql.FieldContainsAll, sql.FieldNotContainsAll, sql.FieldContainsAny, sql.FieldNotContainsAny, sql.FieldContainsAll, sql.FieldNotContainsAll, sql.FieldContainsAny, sql.FieldNotContainsAny, sql.FieldContainsAll, sql.FieldNotContainsAll, sql.FieldContainsAny, sql.FieldNotContainsAny, sql.FieldContainsAll, sql.FieldNotContainsAll, sql.FieldContainsAny, sql.FieldNotContainsAny, sql.FieldContainsAll, sql.FieldNotContainsAll, sql.FieldContainsAny, sql"}
{"seed": "// RequireFromStringf is similar to FromStringf except that instead of\n// returning an error on malformed input, it panics. It should only be used\n// when the input is statically verifiable.\nfunc RequireFromStringf(format string, args ...interface{}) ID {\n\tid, err := FromStringf(format, args...)\n\tpanicOnErr(err)\n\treturn id\n}", "id": 17520, "concepts": ["panicOnErr", "panic", "error handling"], "_raw_llm_output": "panicOnErr, panic, error handling"}
{"seed": "// IsWithRevert returns true if the transaction context is configured\n// to revert transaction if any of its operations fails.\nfunc IsWithRevert(ctx context.Context) bool {\n\t_, isWithRevert := ctx.Value(revertCtxKey).(*revertOpt)\n\treturn isWithRevert\n}", "id": 17538, "concepts": ["context", "context.Value", "context.WithValue", "context.Background", "context.TODO"], "_raw_llm_output": "context, context.Value, context.WithValue, context.Background, context.TODO"}
{"seed": "// NewUpdatePrivateNetworkRequest calls the generic UpdatePrivateNetwork builder with application/json body\nfunc NewUpdatePrivateNetworkRequest(server string, id string, body UpdatePrivateNetworkJSONRequestBody) (*http.Request, error) {\n\tvar bodyReader io.Reader\n\tbuf, err := json.Marshal(body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tbodyReader = bytes.NewReader(buf)\n\treturn NewUpdatePrivateNetworkRequestWithBody(server, id, \"application/json\", bodyReader)\n}", "id": 17541, "concepts": ["http.Request", "http.NewRequest", "http.Client", "http.Do", "io.Reader", "json.Marshal", "json.Unmarshal", "io.Copy", "http.StatusCreated", "http.StatusNoContent", "http.StatusNotFound", "http.StatusConflict", "http.StatusBadRequest", "http.StatusUnprocessableEntity", "http.StatusMethodNotAllowed", "http.StatusNotAcceptable", "http.StatusUnsupportedMediaType", "http.StatusRequestTimeout", "http.StatusTooManyRequests", "http.StatusInternalServerError", "http.StatusServiceUnavailable", "http.StatusGatewayTimeout", "http.StatusBadGateway", "http.StatusProxyAuthRequired", "http.StatusRequestURITooLong", "http.StatusNotImplemented", "http.StatusHTTPVersionNotSupported", "http.StatusNetworkAuthenticationRequired", "http.StatusInsufficientStorage", "http.StatusLoopDetected", "http.StatusNotExtended", "http.StatusNetworkAuthenticationRequired", "http.StatusNetworkAuthenticationRequired", "http.StatusNetworkAuthenticationRequired", "http.StatusNetworkAuthenticationRequired", "http.StatusNetworkAuthenticationRequired", "http.StatusNetworkAuthenticationRequired", "http.StatusNetworkAuthenticationRequired", "http.StatusNetworkAuthenticationRequired", "http.StatusNetworkAuthenticationRequired", "http.StatusNetworkAuthenticationRequired", "http.StatusNetworkAuthenticationRequired", "http.StatusNetwork"], "_raw_llm_output": "http.Request, http.NewRequest, http.Client, http.Do, io.Reader, json.Marshal, json.Unmarshal, io.Copy, http.StatusCreated, http.StatusNoContent, http.StatusNotFound, http.StatusConflict, http.StatusBadRequest, http.StatusUnprocessableEntity, http.StatusMethodNotAllowed, http.StatusNotAcceptable, http.StatusUnsupportedMediaType, http.StatusRequestTimeout, http.StatusTooManyRequests, http.StatusInternalServerError, http.StatusServiceUnavailable, http.StatusGatewayTimeout, http.StatusBadGateway, http.StatusProxyAuthRequired, http.StatusRequestURITooLong, http.StatusNotImplemented, http.StatusHTTPVersionNotSupported, http.StatusNetworkAuthenticationRequired, http.StatusInsufficientStorage, http.StatusLoopDetected, http.StatusNotExtended, http.StatusNetworkAuthenticationRequired, http.StatusNetworkAuthenticationRequired, http.StatusNetworkAuthenticationRequired, http.StatusNetworkAuthenticationRequired, http.StatusNetworkAuthenticationRequired, http.StatusNetworkAuthenticationRequired, http.StatusNetworkAuthenticationRequired, http.StatusNetworkAuthenticationRequired, http.StatusNetworkAuthenticationRequired, http.StatusNetworkAuthenticationRequired, http.StatusNetworkAuthenticationRequired, http.StatusNetwork"}
{"seed": "// AssetDir returns the file names below a certain\n// directory embedded in the file by go-bindata.\n// For example if you run go-bindata on data/... and data contains the\n// following hierarchy:\n//     data/\n//       foo.txt\n//       img/\n//         a.png\n//         b.png\n// then AssetDir(\"data\") would return []string{\"foo.txt\", \"img\"},\n// AssetDir(\"data/img\") would return []string{\"a.png\", \"b.png\"},\n// AssetDir(\"foo.txt\") and AssetDir(\"notexist\") would return an error, and\n// AssetDir(\"\") will return []string{\"data\"}.\nfunc AssetDir(name string) ([]string, error) {\n\tnode := _bintree\n\tif len(name) != 0 {\n\t\tcanonicalName := strings.Replace(name, \"\\\\\", \"/\", -1)\n\t\tpathList := strings.Split(canonicalName, \"/\")\n\t\tfor _, p := range pathList {\n\t\t\tnode = node.Children[p]\n\t\t\tif node == nil {\n\t\t\t\treturn nil, fmt.Errorf(\"Asset %s not found\", name)\n\t\t\t}\n\t\t}\n\t}\n\tif node.Func != nil {\n\t\treturn nil, fmt.Errorf(\"Asset %s not found\", name)\n\t}\n\trv := make([]string, 0, len(node.Children))\n\tfor childName := range node.Children {\n\t\trv = append(rv, childName)\n\t}\n\treturn rv, nil\n}", "id": 17550, "concepts": ["string manipulation", "map iteration", "map usage", "string splitting", "error handling", "anonymous function", "standard library usage"], "_raw_llm_output": "string manipulation, map iteration, map usage, string splitting, error handling, anonymous function, standard library usage"}
{"seed": "// GetBundleByLinkIdOrSlug retrieves a BundleData object linked to by a\n// BundleLink with a particular id or slug. Id is tried first, slug if id\n// doesn't exist.\n// Note: This can fail if the bundle is deleted between fetching BundleLink\n// and BundleData. However, it is highly unlikely, costly to mitigate (using\n// a serializable transaction), and unimportant (error 500 instead of 404).\nfunc GetBundleByLinkIdOrSlug(idOrSlug string) (*BundleLink, *BundleData, error) {\n\tbLink, err := getBundleLinkById(dbRead, idOrSlug)\n\tif err == ErrNotFound {\n\t\tbLink, err = getDefaultBundleLinkBySlug(dbRead, idOrSlug)\n\t}\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tbData, err := getBundleDataByHash(dbRead, bLink.Hash)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\treturn bLink, bData, nil\n}", "id": 17554, "concepts": ["error handling (idiomatic if err != nil)", "error handling (errors.Is)", "error handling (errors.As)", "error handling (ErrNotFound)", "error handling (error types)", "error handling (error wrapping)", "error handling (error chaining)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling"], "_raw_llm_output": "error handling (idiomatic if err != nil), error handling (errors.Is), error handling (errors.As), error handling (ErrNotFound), error handling (error types), error handling (error wrapping), error handling (error chaining), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling"}
{"seed": "// AddTask saves Task in taskBucket under key\n// equal to its id in form of JSON.\nfunc AddTask(t *Task) error {\n\treturn db.Update(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket(taskBucket)\n\n\t\tid, err := b.NextSequence()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tt.ID = int(id)\n\n\t\tbuf, err := t.ToJSON()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treturn b.Put(itob(t.ID), buf)\n\t})\n}", "id": 17561, "concepts": ["BoltDB", "BoltDB usage", "JSON encoding", "BoltDB bucket", "BoltDB sequence", "BoltDB Put", "BoltDB NextSequence"], "_raw_llm_output": "BoltDB, BoltDB usage, JSON encoding, BoltDB bucket, BoltDB sequence, BoltDB Put, BoltDB NextSequence"}
{"seed": "// New creates a new cache of given capacity.\n//\n// If client is non-nil, the cache will prefetch expired entries in an effort to serve results faster.\n//\n// If backend is non-nil:\n//\n// - All cache write operations will be forward to the backend.\n// - The backed will be used to pre-populate the cache.\nfunc New(capacity int, client dnsutil.Client) *Cache {\n\treturn NewWithBackend(capacity, client, nil)\n}", "id": 17565, "concepts": ["struct definition", "function definition", "function call", "function return", "function signature", "function parameter", "function return value", "function return value type", "function return value name", "function return value assignment", "function return value assignment to variable", "function return value assignment to variable with type", "function return value assignment to variable with type and name", "function return value assignment to variable with type and name and value", "function return value assignment to variable with type and name and value and type", "function return value assignment to variable with type and name and value and type and value", "function return value assignment to variable with type and name and value and type and value and type", "function return value assignment to variable with type and name and value and type and value and type and value", "function return value assignment to variable with type and name and value and type and value and type and value and type", "function return value assignment to variable with type and name and value and type and value and type and value and type and value", "function return value assignment to variable with type and name and value and type and value and type and value and type and value and type", "function return value assignment to variable with type and name and value and type and value and type and value and type and value and type and value", "function return"], "_raw_llm_output": "struct definition, function definition, function call, function return, function signature, function parameter, function return value, function return value type, function return value name, function return value assignment, function return value assignment to variable, function return value assignment to variable with type, function return value assignment to variable with type and name, function return value assignment to variable with type and name and value, function return value assignment to variable with type and name and value and type, function return value assignment to variable with type and name and value and type and value, function return value assignment to variable with type and name and value and type and value and type, function return value assignment to variable with type and name and value and type and value and type and value, function return value assignment to variable with type and name and value and type and value and type and value and type, function return value assignment to variable with type and name and value and type and value and type and value and type and value, function return value assignment to variable with type and name and value and type and value and type and value and type and value and type, function return value assignment to variable with type and name and value and type and value and type and value and type and value and type and value, function return"}
{"seed": "// RolesNotNil applies the NotNil predicate on the \"roles\" field.\nfunc RolesNotNil() predicate.User {\n\treturn predicate.User(sql.FieldNotNull(FieldRoles))\n}", "id": 17573, "concepts": ["predicate", "sql.FieldNotNull"], "_raw_llm_output": "predicate, sql.FieldNotNull"}
{"seed": "// AWSStatusCode returns the HTTP status code from an AWS client error as a string.\n// It's used for labels in Prometheus metrics. The err parameter can be of\n// type *http.Response, awserr.RequestFailure, awserr.BatchedErrors (containing at least one awserr.RequestFailure),\n// or int (indicating the HTTP status code).\n// Returns 0 if err is not one of those types.\nfunc AWSStatusCode(err interface{}) string {\n\tvar code int\n\tswitch e := err.(type) {\n\tcase *http.Response:\n\t\tcode = e.StatusCode\n\tcase awserr.RequestFailure:\n\t\tcode = e.StatusCode()\n\tcase awserr.BatchedErrors:\n\t\tfor _, berr := range e.OrigErrs() {\n\t\t\tif rerr, ok := berr.(awserr.RequestFailure); ok {\n\t\t\t\tcode = rerr.StatusCode()\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\tcase int:\n\t\tcode = e\n\t}\n\tif code == 0 {\n\t\treturn \"\"\n\t}\n\treturn strconv.Itoa(code)\n}", "id": 17594, "concepts": ["type casting", "type assertion", "error handling (awserr.RequestFailure", "awserr.BatchedErrors)", "integer conversion"], "_raw_llm_output": "type casting, type assertion, error handling (awserr.RequestFailure, awserr.BatchedErrors), integer conversion"}
{"seed": "// NewCreateScopedUserRoleSpacesParams creates a new CreateScopedUserRoleSpacesParams object\n// with the default values initialized.\nfunc NewCreateScopedUserRoleSpacesParams() *CreateScopedUserRoleSpacesParams {\n\tvar ()\n\treturn &CreateScopedUserRoleSpacesParams{\n\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 17601, "concepts": ["struct initialization", "struct field initialization", "struct field default values", "struct field pointer types"], "_raw_llm_output": "struct initialization, struct field initialization, struct field default values, struct field pointer types"}
{"seed": "// Version returns a valid `Option` that can be passed to the `Application.Handle` method.\n// It requires a specific \"version\" constraint for a Controller,\n// e.g. \">1.0.0 <=2.0.0\".\n//\n// Usage:\n//\n//\tm := mvc.New(dataRouter)\n//\tm.Handle(new(v1Controller), mvc.Version(\"1.0.0\"), mvc.Deprecated(mvc.DeprecationOptions{}))\n//\tm.Handle(new(v2Controller), mvc.Version(\"2.3.0\"))\n//\tm.Handle(new(v3Controller), mvc.Version(\">=3.0.0 <4.0.0\"))\n//\tm.Handle(new(noVersionController))\n//\n// See the `versioning` package's documentation for more information on\n// how the version is extracted from incoming requests.\n//\n// Note that this Option will set the route register rule to `RouteOverlap`.\nfunc Version(version string) OptionFunc {\n\treturn func(c *ControllerActivator) {\n\t\tc.Router().SetRegisterRule(router.RouteOverlap) // required for this feature.\n\t\t// Note: Do not use a group, we need c.Use for the specific controller's routes.\n\t\tc.Use(versioning.Handler(version))\n\t}\n}", "id": 17604, "concepts": ["versioning", "versioning package usage", "versioning package's documentation", "versioning package's Handler function", "versioning package's RouteOverlap register rule", "versioning package's Handler function", "versioning package's Handler function", "versioning package's Handler function", "versioning package's Handler function", "versioning package's Handler function", "versioning package's Handler function", "versioning package's Handler function", "versioning package's Handler function", "versioning package's Handler function", "versioning package's Handler function", "versioning package's Handler function", "versioning package's Handler function", "versioning package's Handler function", "versioning package's Handler function", "versioning package's Handler function", "versioning package's Handler function", "versioning package's Handler function", "versioning package's Handler function", "versioning package's Handler function", "versioning package's Handler function", "versioning package's Handler function", "versioning package's Handler function", "versioning package's Handler function", "versioning package's Handler function", "versioning package's Handler function", "versioning package's Handler function", "versioning package's Handler function", "versioning package's Handler function", "versioning package's Handler function", "versioning package's Handler function", "versioning package's Handler function", "versioning package's Handler function", "versioning package's Handler function", "versioning package's Handler function", "versioning package's Handler function", "versioning package's Handler function", "versioning package's Handler function", "versioning package's Handler function", "versioning"], "_raw_llm_output": "versioning, versioning package usage, versioning package's documentation, versioning package's Handler function, versioning package's RouteOverlap register rule, versioning package's Handler function, versioning package's Handler function, versioning package's Handler function, versioning package's Handler function, versioning package's Handler function, versioning package's Handler function, versioning package's Handler function, versioning package's Handler function, versioning package's Handler function, versioning package's Handler function, versioning package's Handler function, versioning package's Handler function, versioning package's Handler function, versioning package's Handler function, versioning package's Handler function, versioning package's Handler function, versioning package's Handler function, versioning package's Handler function, versioning package's Handler function, versioning package's Handler function, versioning package's Handler function, versioning package's Handler function, versioning package's Handler function, versioning package's Handler function, versioning package's Handler function, versioning package's Handler function, versioning package's Handler function, versioning package's Handler function, versioning package's Handler function, versioning package's Handler function, versioning package's Handler function, versioning package's Handler function, versioning package's Handler function, versioning package's Handler function, versioning package's Handler function, versioning package's Handler function, versioning package's Handler function, versioning package's Handler function, versioning"}
{"seed": "// Hashes a UTF-8 plaintext password using the default context and produces a\n// password hash. Chooses the preferred password hashing scheme based on the\n// configured policy. The default policy is sensible.\nfunc Hash(password string) (hash string, err error) {\n\treturn DefaultContext.Hash(password)\n}", "id": 17624, "concepts": ["crypto/sha256", "crypto/sha512", "crypto/sha1", "crypto/hmac", "crypto/md5", "crypto/rand", "crypto/subtle", "crypto/aes", "crypto/cipher", "crypto/x509", "crypto/rsa", "crypto/ecdsa", "crypto/elliptic", "crypto/ed25519", "crypto/ed25519", "crypto/ed25519", "crypto/ed25519", "crypto/ed25519", "crypto/ed25519", "crypto/ed25519", "crypto/ed25519", "crypto/ed25519", "crypto/ed25519", "crypto/ed25519", "crypto/ed25519", "crypto/ed25519", "crypto/ed25519", "crypto/ed25519", "crypto/ed25519", "crypto/ed25519", "crypto/ed25519", "crypto/ed25519", "crypto/ed25519", "crypto/ed25519", ""], "_raw_llm_output": "crypto/sha256, crypto/sha512, crypto/sha1, crypto/hmac, crypto/md5, crypto/rand, crypto/subtle, crypto/aes, crypto/cipher, crypto/x509, crypto/rsa, crypto/ecdsa, crypto/elliptic, crypto/ed25519, crypto/ed25519, crypto/ed25519, crypto/ed25519, crypto/ed25519, crypto/ed25519, crypto/ed25519, crypto/ed25519, crypto/ed25519, crypto/ed25519, crypto/ed25519, crypto/ed25519, crypto/ed25519, crypto/ed25519, crypto/ed25519, crypto/ed25519, crypto/ed25519, crypto/ed25519, crypto/ed25519, crypto/ed25519, crypto/ed25519,"}
{"seed": "// Abbr represents the HTML element 'abbr'.\n// For more information visit https://www.w3schools.com/tags/tag_abbr.asp.\nfunc Abbr(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"abbr\", Attributes: attrs, Children: children}\n}", "id": 17637, "concepts": ["HTML generation", "HTML element definition", "HTML attribute definition", "HTML element children definition"], "_raw_llm_output": "HTML generation, HTML element definition, HTML attribute definition, HTML element children definition"}
{"seed": "// NewActionWithFixtures creates a new ActionSuite with passed box for fixtures.\nfunc NewActionWithFixtures(app *buffalo.App, fsys fs.FS) (*Action, error) {\n\tm, err := NewModelWithFixtures(fsys)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tas := &Action{\n\t\tApp:   app,\n\t\tModel: m,\n\t}\n\treturn as, nil\n}", "id": 17642, "concepts": ["buffalo.App", "fs.FS", "fs.File", "fs.ReadDir", "fs.ReadDirEntry", "fs.FileInfo", "fs.Stat", "fs.Read", "fs.ReadAt", "fs.Seek", "fs.Readdir", "fs.Readdirnames", "fs.Readdirnames", "fs.Readdirnames", "fs.Readdirnames", "fs.Readdirnames", "fs.Readdirnames", "fs.Readdirnames", "fs.Readdirnames", "fs.Readdirnames", "fs.Readdirnames", "fs.Readdirnames", "fs.Readdirnames", "fs.Readdirnames", "fs.Readdirnames", "fs.Readdirnames", "fs.Readdirnames", "fs.Readdirnames", "fs.Readdirnames", "fs.Readdirnames", "fs.Readdirnames", "fs.Readdirnames", "fs.Readdirnames", "fs.Readdirnames", "fs.Readdirnames", "fs.Readdirnames", "fs.Readdirnames", "fs.Readdirnames", "fs.Readdirnames", "fs.Readdirnames", "fs.Readdirnames", "fs.Readdirnames", "fs.Readdirnames", "fs.Readdirnames", "fs.Readdirnames", "fs"], "_raw_llm_output": "buffalo.App, fs.FS, fs.File, fs.ReadDir, fs.ReadDirEntry, fs.FileInfo, fs.Stat, fs.Read, fs.ReadAt, fs.Seek, fs.Readdir, fs.Readdirnames, fs.Readdirnames, fs.Readdirnames, fs.Readdirnames, fs.Readdirnames, fs.Readdirnames, fs.Readdirnames, fs.Readdirnames, fs.Readdirnames, fs.Readdirnames, fs.Readdirnames, fs.Readdirnames, fs.Readdirnames, fs.Readdirnames, fs.Readdirnames, fs.Readdirnames, fs.Readdirnames, fs.Readdirnames, fs.Readdirnames, fs.Readdirnames, fs.Readdirnames, fs.Readdirnames, fs.Readdirnames, fs.Readdirnames, fs.Readdirnames, fs.Readdirnames, fs.Readdirnames, fs.Readdirnames, fs.Readdirnames, fs.Readdirnames, fs.Readdirnames, fs.Readdirnames, fs.Readdirnames, fs.Readdirnames, fs"}
{"seed": "// metricsToPoints converts statboard Metrics to chart.js points\nfunc metricsToPoints(metrics []statboard.Metric) []chartjs.Point {\n\tvar data []chartjs.Point\n\n\tfor _, met := range metrics {\n\t\tpoint := chartjs.Point{X: met.Date.Format(\"02-Jan-2006\"), Y: met.Value}\n\t\tdata = append(data, point)\n\t}\n\n\treturn data\n}", "id": 17649, "concepts": ["slice iteration (range loop)", "chart.js", "date formatting"], "_raw_llm_output": "slice iteration (range loop), chart.js, date formatting"}
{"seed": "// mkReport generates reports with a single error with the specified context, line, col and kind\nfunc mkReport(err error, c path.ContextPath, k report.Kind, line, col int64) (r report.Report) {\n\tr.AddOn(c, err, k)\n\tif line == 0 {\n\t\treturn\n\t}\n\tr.Entries[0].Marker.StartP = &tree.Pos{Line: line, Column: col}\n\treturn\n}", "id": 17652, "concepts": ["error handling (error type assertion)", "path.ContextPath", "report.Kind", "report.Report", "tree.Pos"], "_raw_llm_output": "error handling (error type assertion), path.ContextPath, report.Kind, report.Report, tree.Pos"}
{"seed": "// Col represents the HTML void element 'col'.\n// For more information visit https://www.w3schools.com/tags/tag_col.asp.\nfunc Col(attrs []htmlgo.Attribute) HTML {\n\treturn &htmlgo.Tree{Tag: \"col\", Attributes: attrs, SelfClosing: true}\n}", "id": 17653, "concepts": ["HTML generation", "HTML tree traversal", "HTML tree manipulation", "HTML void element"], "_raw_llm_output": "HTML generation, HTML tree traversal, HTML tree manipulation, HTML void element"}
{"seed": "// UUIDNextKey returns an UUID Version 4, without hyphens.\nfunc UUIDNextKey() string {\n\tk, err := uuid.NewRandom()\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\tkb, err := k.MarshalBinary()\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\treturn hex.EncodeToString(kb)\n}", "id": 17655, "concepts": ["UUID generation", "uuid package usage", "hex encoding"], "_raw_llm_output": "UUID generation, uuid package usage, hex encoding"}
{"seed": "// Workers sets the number of worker nodes for create\nfunc Workers(workers int) CreateOption {\n\treturn func(c *CreateOptions) {\n\t\tc.workers = workers\n\t}\n}", "id": 17659, "concepts": ["function composition", "function options", "functional options", "function definition"], "_raw_llm_output": "function composition, function options, functional options, function definition"}
{"seed": "// PossibleManagedRuleExclusionMatchVariableValues returns an array of possible values for the ManagedRuleExclusionMatchVariable const type.\nfunc PossibleManagedRuleExclusionMatchVariableValues() []ManagedRuleExclusionMatchVariable {\n\treturn []ManagedRuleExclusionMatchVariable{ManagedRuleExclusionMatchVariableQueryStringArgNames, ManagedRuleExclusionMatchVariableRequestBodyJSONArgNames, ManagedRuleExclusionMatchVariableRequestBodyPostArgNames, ManagedRuleExclusionMatchVariableRequestCookieNames, ManagedRuleExclusionMatchVariableRequestHeaderNames}\n}", "id": 17680, "concepts": ["type definition", "const definition", "array definition", "array iteration", "array access"], "_raw_llm_output": "type definition, const definition, array definition, array iteration, array access"}
{"seed": "// InitLogger sets the internal logger instance to the given level and log file.\n// This function should be called exactly once and subsequent calls return an error.\n// Logs to stdout if logFile is an empty string.\n//\n// It also initializes the logger in the go-perun library.\nfunc InitLogger(levelStr, logFile string) error {\n\tif logger != nil {\n\t\treturn errors.New(\"logger already initialized\")\n\t}\n\n\tnewLogger := logrus.New()\n\tlevel, err := logrus.ParseLevel(levelStr)\n\tif err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\tnewLogger.SetLevel(level)\n\tif logFile == \"\" {\n\t\tnewLogger.SetOutput(os.Stdout)\n\t} else {\n\t\tf, err := os.OpenFile(filepath.Clean(logFile), os.O_WRONLY|os.O_APPEND|os.O_CREATE, 0o600)\n\t\tif err != nil {\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t\tnewLogger.SetOutput(f)\n\t}\n\n\tnewLogger.SetFormatter(&customTextFormatter{logrus.TextFormatter{\n\t\tFullTimestamp:          true,\n\t\tTimestampFormat:        \"2006-01-02 15:04:05 Z0700\",\n\t\tDisableLevelTruncation: true,\n\t}})\n\tlogger = newLogger\n\tplog.Set(plogrus.FromLogrus(logger))\n\treturn nil\n}", "id": 17681, "concepts": ["logrus package usage", "file handling", "logging", "error handling"], "_raw_llm_output": "logrus package usage, file handling, logging, error handling"}
{"seed": "// NewAttributeValueString creates a new AttributeValue with the given string value.\nfunc NewAttributeValueString(v string) AttributeValue {\n\torig := &otlpcommon.AnyValue{Value: &otlpcommon.AnyValue_StringValue{StringValue: v}}\n\treturn AttributeValue{orig: orig}\n}", "id": 17695, "concepts": ["struct definition", "pointer usage", "interface implementation"], "_raw_llm_output": "struct definition, pointer usage, interface implementation"}
{"seed": "// NewValidateCreateServiceRequestNamingParamsWithTimeout creates a new ValidateCreateServiceRequestNamingParams object\n// with the default values initialized, and the ability to set a timeout on a request\nfunc NewValidateCreateServiceRequestNamingParamsWithTimeout(timeout time.Duration) *ValidateCreateServiceRequestNamingParams {\n\tvar ()\n\treturn &ValidateCreateServiceRequestNamingParams{\n\n\t\ttimeout: timeout,\n\t}\n}", "id": 17707, "concepts": ["function definition", "timeout handling", "time package usage"], "_raw_llm_output": "function definition, timeout handling, time package usage"}
{"seed": "// HeroPlayedIn applies the In predicate on the \"hero_played\" field.\nfunc HeroPlayedIn(vs ...uint) predicate.User {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.User(func(s *sql.Selector) {\n\t\t// if not arguments were provided, append the FALSE constants,\n\t\t// since we can't apply \"IN ()\". This will make this predicate falsy.\n\t\tif len(vs) == 0 {\n\t\t\ts.Where(sql.False())\n\t\t\treturn\n\t\t}\n\t\ts.Where(sql.In(s.C(FieldHeroPlayed), v...))\n\t})\n}", "id": 17721, "concepts": ["sql.Selector", "sql.In", "sql.False", "sql.C", "sql.Where", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In"], "_raw_llm_output": "sql.Selector, sql.In, sql.False, sql.C, sql.Where, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In"}
{"seed": "// ResolverEndpointStatus_Values returns all elements of the ResolverEndpointStatus enum\nfunc ResolverEndpointStatus_Values() []string {\n\treturn []string{\n\t\tResolverEndpointStatusCreating,\n\t\tResolverEndpointStatusOperational,\n\t\tResolverEndpointStatusUpdating,\n\t\tResolverEndpointStatusAutoRecovering,\n\t\tResolverEndpointStatusActionNeeded,\n\t\tResolverEndpointStatusDeleting,\n\t}\n}", "id": 17722, "concepts": ["enum usage", "basic function definition"], "_raw_llm_output": "enum usage, basic function definition"}
{"seed": "// NetworkInterfaceIPConfigurationPropertiesFormat_ARMGenerator returns a generator of NetworkInterfaceIPConfigurationPropertiesFormat_ARM instances for property testing.\n// We first initialize networkInterfaceIPConfigurationPropertiesFormat_ARMGenerator with a simplified generator based on the\n// fields with primitive types then replacing it with a more complex one that also handles complex fields\n// to ensure any cycles in the object graph properly terminate.\nfunc NetworkInterfaceIPConfigurationPropertiesFormat_ARMGenerator() gopter.Gen {\n\tif networkInterfaceIPConfigurationPropertiesFormat_ARMGenerator != nil {\n\t\treturn networkInterfaceIPConfigurationPropertiesFormat_ARMGenerator\n\t}\n\n\tgenerators := make(map[string]gopter.Gen)\n\tAddIndependentPropertyGeneratorsForNetworkInterfaceIPConfigurationPropertiesFormat_ARM(generators)\n\tnetworkInterfaceIPConfigurationPropertiesFormat_ARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceIPConfigurationPropertiesFormat_ARM{}), generators)\n\n\t// The above call to gen.Struct() captures the map, so create a new one\n\tgenerators = make(map[string]gopter.Gen)\n\tAddIndependentPropertyGeneratorsForNetworkInterfaceIPConfigurationPropertiesFormat_ARM(generators)\n\tAddRelatedPropertyGeneratorsForNetworkInterfaceIPConfigurationPropertiesFormat_ARM(generators)\n\tnetworkInterfaceIPConfigurationPropertiesFormat_ARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceIPConfigurationPropertiesFormat_ARM{}), generators)\n\n\treturn networkInterfaceIPConfigurationPropertiesFormat_ARMGenerator\n}", "id": 17729, "concepts": ["struct", "map", "reflection", "generator", "property testing", "cyclic object graph"], "_raw_llm_output": "struct, map, reflection, generator, property testing, cyclic object graph"}
{"seed": "// CreatedAtGT applies the GT predicate on the \"created_at\" field.\nfunc CreatedAtGT(v time.Time) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.GT(s.C(FieldCreatedAt), v))\n\t})\n}", "id": 17732, "concepts": ["sql.Selector", "sql.Where", "sql.GT", "sql.C", "predicate.User"], "_raw_llm_output": "sql.Selector, sql.Where, sql.GT, sql.C, predicate.User"}
{"seed": "// NewGetCwfNetworkIDGatewaysGatewayIDParamsWithContext creates a new GetCwfNetworkIDGatewaysGatewayIDParams object\n// with the default values initialized, and the ability to set a context for a request\nfunc NewGetCwfNetworkIDGatewaysGatewayIDParamsWithContext(ctx context.Context) *GetCwfNetworkIDGatewaysGatewayIDParams {\n\tvar ()\n\treturn &GetCwfNetworkIDGatewaysGatewayIDParams{\n\n\t\tContext: ctx,\n\t}\n}", "id": 17747, "concepts": ["context package usage", "function definition", "context.Context"], "_raw_llm_output": "context package usage, function definition, context.Context"}
{"seed": "// HandlerWithPluginPath returns a new HandlerOption that sets the path to the plugin binary.\n//\n// The default is to do exec.LookPath on \"protoc-gen-\" + pluginName.\nfunc HandlerWithPluginPath(pluginPath string) HandlerOption {\n\treturn func(handlerOptions *handlerOptions) {\n\t\thandlerOptions.pluginPath = pluginPath\n\t}\n}", "id": 17754, "concepts": ["function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", ""], "_raw_llm_output": "function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition,"}
{"seed": "// NewSelectorFilter creates a new selector filter (apache.org:selector-filter:string) with the specified filter value.\n// Any preexisting selector filter will be updated with the new filter value.\nfunc NewSelectorFilter(filter string) LinkFilter {\n\treturn NewLinkFilter(selectorFilter, selectorFilterCode, filter)\n}", "id": 17756, "concepts": ["struct definition", "interface definition", "function definition", "method definition", "method receiver", "method call", "interface implementation", "method call with receiver", "method call with pointer receiver", "method call with value receiver", "method call with pointer receiver", "method call with value receiver", "method call with pointer receiver", "method call with value receiver", "method call with pointer receiver", "method call with value receiver", "method call with pointer receiver", "method call with value receiver", "method call with pointer receiver", "method call with value receiver", "method call with pointer receiver", "method call with value receiver", "method call with pointer receiver", "method call with value receiver", "method call with pointer receiver", "method call with value receiver", "method call with pointer receiver", "method call with value receiver", "method call with pointer receiver", "method call with value receiver", "method call with pointer receiver", "method call with value receiver", "method call with pointer receiver", "method call with value receiver", "method call with pointer receiver", "method call with value receiver", "method call with pointer receiver", "method call with value receiver", "method call with pointer receiver", "method call with value receiver", "method call with pointer receiver", "method call with value receiver", "method call with pointer receiver", "method call with value receiver", "method call with pointer receiver", "method call with value receiver", "method"], "_raw_llm_output": "struct definition, interface definition, function definition, method definition, method receiver, method call, interface implementation, method call with receiver, method call with pointer receiver, method call with value receiver, method call with pointer receiver, method call with value receiver, method call with pointer receiver, method call with value receiver, method call with pointer receiver, method call with value receiver, method call with pointer receiver, method call with value receiver, method call with pointer receiver, method call with value receiver, method call with pointer receiver, method call with value receiver, method call with pointer receiver, method call with value receiver, method call with pointer receiver, method call with value receiver, method call with pointer receiver, method call with value receiver, method call with pointer receiver, method call with value receiver, method call with pointer receiver, method call with value receiver, method call with pointer receiver, method call with value receiver, method call with pointer receiver, method call with value receiver, method call with pointer receiver, method call with value receiver, method call with pointer receiver, method call with value receiver, method call with pointer receiver, method call with value receiver, method call with pointer receiver, method call with value receiver, method call with pointer receiver, method call with value receiver, method"}
{"seed": "// requestWithLaunchIDContext returns a request with a context that contains the launchID\nfunc requestWithLaunchIDContext(r *http.Request, launchID string) *http.Request {\n\treturn requestWithNewContextValue(r, launchIDKey, launchID)\n}", "id": 17760, "concepts": ["http.Request", "context.Context", "context.WithValue", "context.Background", "context.TODO"], "_raw_llm_output": "http.Request, context.Context, context.WithValue, context.Background, context.TODO"}
{"seed": "// initGlfw initializes windowing by initializing GLFW. The current goroutine\n// will be locked to the OS thread since most GLFW functions are not\n// thread-safe.\nfunc initGlfw() error {\n\truntime.LockOSThread()\n\terr := C.initGlfw()\n\tif err != 1 {\n\t\treturn errors.New(\"GLFW init failed\")\n\t}\n\treturn nil\n}", "id": 17763, "concepts": ["runtime.LockOSThread", "GLFW initialization", "CGO usage"], "_raw_llm_output": "runtime.LockOSThread, GLFW initialization, CGO usage"}
{"seed": "// New creates a new Reconciler that reconciles custom resources that define a\n// Helm release. New takes variadic Option arguments that are used to configure\n// the Reconciler.\n//\n// Required options are:\n//   - WithGroupVersionKind\n//   - WithChart\n//\n// Other options are defaulted to sane defaults when SetupWithManager is called.\n//\n// If an error occurs configuring or validating the Reconciler, it is returned.\nfunc New(opts ...Option) (*Reconciler, error) {\n\tr := &Reconciler{}\n\tr.annotSetupOnce.Do(r.setupAnnotationMaps)\n\tfor _, o := range opts {\n\t\tif err := o(r); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif err := r.validate(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn r, nil\n}", "id": 17798, "concepts": ["function definition", "variadic arguments", "struct definition", "function composition"], "_raw_llm_output": "function definition, variadic arguments, struct definition, function composition"}
{"seed": "// NewNameNEQ applies the NEQ predicate on the \"new_name\" field.\nfunc NewNameNEQ(v string) predicate.User {\n\treturn predicate.User(sql.FieldNEQ(FieldNewName, v))\n}", "id": 17800, "concepts": ["predicate.User", "sql.FieldNEQ", "sql.FieldEQ"], "_raw_llm_output": "predicate.User, sql.FieldNEQ, sql.FieldEQ"}
{"seed": "// AzureADLicenseTypePUnknownFutureValue returns a pointer to AzureADLicenseTypeVUnknownFutureValue\nfunc AzureADLicenseTypePUnknownFutureValue() *AzureADLicenseType {\n\tv := AzureADLicenseTypeVUnknownFutureValue\n\treturn &v\n}", "id": 17801, "concepts": ["pointer", "pointer dereference", "pointer assignment"], "_raw_llm_output": "pointer, pointer dereference, pointer assignment"}
{"seed": "// Validates the signature of a parsed JWT token via jwt.SigningMethod.Verify,\n// where the token's specific jwt.SigningMethod is derived from the 'alg' header\n// returns\n//  nil for successful validation\n//  error otherwise\nfunc validateSignatureAgainstKey(token *jwt.Token, tokenParts []string, key interface{}) error {\n\t// jwt.SigningMethod.Verify requires signing string and signature as separate inputs\n\treturn token.Method.Verify(strings.Join(tokenParts[0:2], \".\"), token.Signature, key)\n}", "id": 17804, "concepts": ["jwt.SigningMethod.Verify", "jwt.SigningMethod", "jwt.Token", "string manipulation", "slice manipulation"], "_raw_llm_output": "jwt.SigningMethod.Verify, jwt.SigningMethod, jwt.Token, string manipulation, slice manipulation"}
{"seed": "// NewShortlist returns a shortlist of k entires given an initial list of\n// k (or less) candidates.\n//\n// NewShortlist assumes that the supplied candidates are sorted such that\n// the first candidate is the closest to the key\nfunc NewShortlist(target *kademliaid.KademliaID, candidates []contact.Contact) *Shortlist {\n\tshortlist := &Shortlist{}\n\tshortlist.Closest = &candidates[0]\n\tshortlist.target = target\n\tfor i, contact := range candidates {\n\t\tshortlist.Entries[i] = &Entry{contact, false, false, false}\n\t}\n\treturn shortlist\n}", "id": 17807, "concepts": ["array indexing", "map initialization", "slice initialization", "struct initialization", "pointer usage", "method definition", "method invocation", "method call", "method receiver", "method receiver type", "method receiver type definition", "method receiver type definition", "method receiver type definition", "method receiver type definition", "method receiver type definition", "method receiver type definition", "method receiver type definition", "method receiver type definition", "method receiver type definition", "method receiver type definition", "method receiver type definition", "method receiver type definition", "method receiver type definition", "method receiver type definition", "method receiver type definition", "method receiver type definition", "method receiver type definition", "method receiver type definition", "method receiver type definition", "method receiver type definition", "method receiver type definition", "method receiver type definition", "method receiver type definition", "method receiver type definition", "method receiver type definition", "method receiver type definition", "method receiver type definition", "method receiver type definition", "method receiver type definition", "method receiver type definition", "method receiver type definition", "method receiver type definition", "method receiver type definition", "method receiver type definition", "method receiver type definition", "method receiver type definition", "method receiver type definition", "method receiver type definition", "method receiver type definition", "method receiver type definition", "method receiver type definition", "method receiver type definition", "method receiver type definition", "method receiver type definition", "method receiver type definition"], "_raw_llm_output": "array indexing, map initialization, slice initialization, struct initialization, pointer usage, method definition, method invocation, method call, method receiver, method receiver type, method receiver type definition, method receiver type definition, method receiver type definition, method receiver type definition, method receiver type definition, method receiver type definition, method receiver type definition, method receiver type definition, method receiver type definition, method receiver type definition, method receiver type definition, method receiver type definition, method receiver type definition, method receiver type definition, method receiver type definition, method receiver type definition, method receiver type definition, method receiver type definition, method receiver type definition, method receiver type definition, method receiver type definition, method receiver type definition, method receiver type definition, method receiver type definition, method receiver type definition, method receiver type definition, method receiver type definition, method receiver type definition, method receiver type definition, method receiver type definition, method receiver type definition, method receiver type definition, method receiver type definition, method receiver type definition, method receiver type definition, method receiver type definition, method receiver type definition, method receiver type definition, method receiver type definition, method receiver type definition, method receiver type definition, method receiver type definition, method receiver type definition, method receiver type definition, method receiver type definition"}
{"seed": "// Ol represents the HTML element 'ol'.\n// For more information visit https://www.w3schools.com/tags/tag_ol.asp.\nfunc Ol(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"ol\", Attributes: attrs, Children: children}\n}", "id": 17812, "concepts": ["HTML generation", "HTML element definition", "HTML attribute definition", "HTML element children definition"], "_raw_llm_output": "HTML generation, HTML element definition, HTML attribute definition, HTML element children definition"}
{"seed": "// ResolverAutodefinedReverseStatus_Values returns all elements of the ResolverAutodefinedReverseStatus enum\nfunc ResolverAutodefinedReverseStatus_Values() []string {\n\treturn []string{\n\t\tResolverAutodefinedReverseStatusEnabling,\n\t\tResolverAutodefinedReverseStatusEnabled,\n\t\tResolverAutodefinedReverseStatusDisabling,\n\t\tResolverAutodefinedReverseStatusDisabled,\n\t\tResolverAutodefinedReverseStatusUpdatingToUseLocalResourceSetting,\n\t\tResolverAutodefinedReverseStatusUseLocalResourceSetting,\n\t}\n}", "id": 17815, "concepts": ["enum", "string formatting", "fmt package usage"], "_raw_llm_output": "enum, string formatting, fmt package usage"}
{"seed": "// GetUserById \u6839\u636e\u7528\u6237ID\u67e5\u8be2\u7528\u6237\u4fe1\u606f\n// sql.ErrNoRows \u6b64\u67e5\u8be2\u65b9\u6cd5\u65e0\u8bba\u67e5\u8be2\u5230\u7528\u6237\u4fe1\u606f\u6216\u8005\u67e5\u8be2\u4e0d\u5230\uff0c\u90fd\u662f\u67e5\u8be2\u7ed3\u679c\uff0c\u4e0d\u5e94\u8be5\u662f\u5f02\u5e38\uff0c\u56e0\u6b64\u6b64\u65b9\u6cd5\u9700\u8981\u5904\u7406\u6389\u6b64error\n// \u5bf9\u4e8e\u5176\u4ed6\u9519\u8bef\uff0c\u4e00\u822c\u662f\u5199\u6cd5\u6709bug\u6216\u8005db\u5f02\u5e38\u5f15\u8d77\u7684\uff0c\u56e0\u6b64\u9700\u8981wrap\u4e4b\u540e\u629b\u7ed9\u8c03\u7528\u65b9\u5904\u7406\nfunc GetUserById(db *sql.DB, id int64) (*model.User, error) {\n\trow := db.QueryRow(\"SELECT id, name, age FROM func_base.t_user where id=?\", id)\n\tuser := &model.User{}\n\terr := row.Scan(user.Id, user.Name, user.Age)\n\tif errors.Is(err, sql.ErrNoRows) {\n\t\treturn nil, nil\n\t}\n\treturn user, errors.Wrap(err, \"get user by id fail\")\n}", "id": 17845, "concepts": ["sql.ErrNoRows", "error handling (errors.Is)", "sql.DB.QueryRow", "sql.DB.Scan", "error wrapping"], "_raw_llm_output": "sql.ErrNoRows, error handling (errors.Is), sql.DB.QueryRow, sql.DB.Scan, error wrapping"}
{"seed": "// Ruby represents the HTML element 'ruby'.\n// For more information visit https://www.w3schools.com/tags/tag_ruby.asp.\nfunc Ruby(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"ruby\", Attributes: attrs, Children: children}\n}", "id": 17850, "concepts": ["HTML generation", "HTML element definition", "HTML attribute definition", "HTML element nesting"], "_raw_llm_output": "HTML generation, HTML element definition, HTML attribute definition, HTML element nesting"}
{"seed": "// SocialPayloadGTE applies the GTE predicate on the \"social_payload\" field.\nfunc SocialPayloadGTE(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.GTE(s.C(FieldSocialPayload), v))\n\t})\n}", "id": 17852, "concepts": ["sql.Selector", "sql.GTE", "sql.C", "sql.Where", "sql.Predicate"], "_raw_llm_output": "sql.Selector, sql.GTE, sql.C, sql.Where, sql.Predicate"}
{"seed": "// fieldByIndexErr returns the nested field corresponding to index.\n// It returns an error if evaluation requires stepping through a nil\n// pointer, but panics if it must step through a field that\n// is not a struct.\nfunc fieldByIndexErr(v reflect.Value, index []int) (reflect.Value, error) {\n\tif len(index) == 1 {\n\t\treturn v.Field(index[0]), nil\n\t}\n\n\tmustBe(v, reflect.Struct)\n\tfor i, x := range index {\n\t\tif i > 0 {\n\t\t\tif v.Kind() == reflect.Ptr && v.Type().Elem().Kind() == reflect.Struct {\n\t\t\t\tif v.IsNil() {\n\t\t\t\t\treturn reflect.Value{}, errors.New(\"reflect: indirection through nil pointer to embedded struct field \" + v.Type().Elem().Name())\n\t\t\t\t}\n\t\t\t\tv = v.Elem()\n\t\t\t}\n\t\t}\n\t\tv = v.Field(x)\n\t}\n\n\treturn v, nil\n}", "id": 17855, "concepts": ["reflect.Value", "reflect.Kind", "reflect.Struct", "reflect.Ptr", "reflect.Field", "reflect.Value.Field", "reflect.Value.Elem", "reflect.Value.IsNil", "reflect.Value.Type", "reflect.Value.Kind", "reflect.Value.Elem", "reflect.Value.Type.Elem", "reflect.Value.Type.Elem.Kind", "reflect.Value.Type.Elem.Name", "errors.New", "panic"], "_raw_llm_output": "reflect.Value, reflect.Kind, reflect.Struct, reflect.Ptr, reflect.Field, reflect.Value.Field, reflect.Value.Elem, reflect.Value.IsNil, reflect.Value.Type, reflect.Value.Kind, reflect.Value.Elem, reflect.Value.Type.Elem, reflect.Value.Type.Elem.Kind, reflect.Value.Type.Elem.Name, errors.New, panic"}
{"seed": "// chdirOrAbort changes to the directory containing the Go Server Page.  It\n// aborts on error.\nfunc chdirOrAbort(fn string) {\n\tif fn == \"\" {\n\t\treturn\n\t}\n\terr := os.Chdir(filepath.Dir(fn))\n\tif err != nil {\n\t\tnotify.Fatal(err)\n\t}\n}", "id": 17857, "concepts": ["filepath.Dir", "os.Chdir", "error handling"], "_raw_llm_output": "filepath.Dir, os.Chdir, error handling"}
{"seed": "// TitleIn applies the In predicate on the \"title\" field.\nfunc TitleIn(vs ...string) predicate.User {\n\treturn predicate.User(sql.FieldIn(FieldTitle, vs...))\n}", "id": 17859, "concepts": ["sql.FieldIn", "sql.FieldNotIn", "sql.FieldEq", "sql.FieldNotEq", "sql.FieldGt", "sql.FieldGte", "sql.FieldLt", "sql.FieldLte", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldEq", "sql.FieldNotEq", "sql.FieldGt", "sql.FieldGte", "sql.FieldLt", "sql.FieldLte", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldEq", "sql.FieldNotEq", "sql.FieldGt", "sql.FieldGte", "sql.FieldLt", "sql.FieldLte", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldEq", "sql.FieldNotEq", "sql.FieldGt", "sql.FieldGte", "sql.FieldLt", "sql.FieldLte", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldEq", "sql.FieldNotEq", "sql.FieldGt", "sql.FieldGte", "sql.FieldLt", "sql."], "_raw_llm_output": "sql.FieldIn, sql.FieldNotIn, sql.FieldEq, sql.FieldNotEq, sql.FieldGt, sql.FieldGte, sql.FieldLt, sql.FieldLte, sql.FieldLike, sql.FieldNotLike, sql.FieldIn, sql.FieldNotIn, sql.FieldEq, sql.FieldNotEq, sql.FieldGt, sql.FieldGte, sql.FieldLt, sql.FieldLte, sql.FieldLike, sql.FieldNotLike, sql.FieldIn, sql.FieldNotIn, sql.FieldEq, sql.FieldNotEq, sql.FieldGt, sql.FieldGte, sql.FieldLt, sql.FieldLte, sql.FieldLike, sql.FieldNotLike, sql.FieldIn, sql.FieldNotIn, sql.FieldEq, sql.FieldNotEq, sql.FieldGt, sql.FieldGte, sql.FieldLt, sql.FieldLte, sql.FieldLike, sql.FieldNotLike, sql.FieldIn, sql.FieldNotIn, sql.FieldEq, sql.FieldNotEq, sql.FieldGt, sql.FieldGte, sql.FieldLt, sql."}
{"seed": "// DescriptionEqualFold applies the EqualFold predicate on the \"description\" field.\nfunc DescriptionEqualFold(v string) predicate.User {\n\treturn predicate.User(sql.FieldEqualFold(FieldDescription, v))\n}", "id": 17866, "concepts": ["struct field access", "predicate.User", "sql.FieldEqualFold"], "_raw_llm_output": "struct field access, predicate.User, sql.FieldEqualFold"}
{"seed": "// ParseCommandArguments takes a discord command and splits into its action and arguments.\n// The command is assumed to not include any bot prefix.\nfunc ParseCommandArguments(command string) CommandArguments {\n\tvar cleanArgs []string\n\n\tparts := strings.Split(strings.TrimSpace(command), \" \")\n\n\t// Spliting for spaces is not enough to get the clean arguments, since\n\t// two or more consecutive spaces will create an empty argument.\n\t// This cycle gets rid of \"empty\" arguments.\n\tfor _, part := range parts {\n\t\tif part != \"\" {\n\t\t\tcleanArgs = append(cleanArgs, part)\n\t\t}\n\t}\n\n\tif len(cleanArgs) == 0 {\n\t\treturn CommandArguments{}\n\t}\n\n\treturn CommandArguments{\n\t\tCommand:   cleanArgs[0],\n\t\tArguments: cleanArgs[1:],\n\t}\n}", "id": 17872, "concepts": ["string manipulation", "string splitting", "string trimming", "slice iteration", "slice creation"], "_raw_llm_output": "string manipulation, string splitting, string trimming, slice iteration, slice creation"}
{"seed": "// ChooseWorkerID returns a random worker ID.\nfunc ChooseWorkerID() WorkerID {\n\treturn Int64WorkerID(rand.Int63())\n}", "id": 17876, "concepts": ["random number generation", "integer type conversion", "basic function definition"], "_raw_llm_output": "random number generation, integer type conversion, basic function definition"}
{"seed": "// ModelDerivedPower computes motor power from model-derived force, velocity, and drivetrain efficiency\nfunc ModelDerivedPower(fRes, dxdt, effDt float64) float64 {\n\treturn fRes * dxdt / effDt\n}", "id": 17883, "concepts": ["basic function definition", "function return value", "float64 type"], "_raw_llm_output": "basic function definition, function return value, float64 type"}
{"seed": "// Alias fetches a connection by its alias.\n//\n//\tspiffy.Alias(\"logging\").Create(&object)\n//\nfunc Alias(alias string) *Connection {\n\treturn aliases[alias]\n}", "id": 17886, "concepts": ["struct field access", "function definition", "function call", "map iteration"], "_raw_llm_output": "struct field access, function definition, function call, map iteration"}
{"seed": "// PlatformMenuModifier returns the platform's standard menu command key\n// modifier.\nfunc PlatformMenuModifier() Modifiers {\n\tif runtime.GOOS == toolbox.MacOS {\n\t\treturn CommandModifier\n\t}\n\treturn ControlModifier\n}", "id": 17892, "concepts": ["runtime package usage", "switch statement", "platform detection"], "_raw_llm_output": "runtime package usage, switch statement, platform detection"}
{"seed": "// DefaultExprContainsFold applies the ContainsFold predicate on the \"default_expr\" field.\nfunc DefaultExprContainsFold(v string) predicate.User {\n\treturn predicate.User(sql.FieldContainsFold(FieldDefaultExpr, v))\n}", "id": 17901, "concepts": ["sql.FieldContainsFold", "predicate.User", "sql.Field"], "_raw_llm_output": "sql.FieldContainsFold, predicate.User, sql.Field"}
{"seed": "// ExtendedLocation_STATUSGenerator returns a generator of ExtendedLocation_STATUS instances for property testing.\nfunc ExtendedLocation_STATUSGenerator() gopter.Gen {\n\tif extendedLocation_STATUSGenerator != nil {\n\t\treturn extendedLocation_STATUSGenerator\n\t}\n\n\tgenerators := make(map[string]gopter.Gen)\n\tAddIndependentPropertyGeneratorsForExtendedLocation_STATUS(generators)\n\textendedLocation_STATUSGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation_STATUS{}), generators)\n\n\treturn extendedLocation_STATUSGenerator\n}", "id": 17906, "concepts": ["struct generation", "property testing", "gopter package usage"], "_raw_llm_output": "struct generation, property testing, gopter package usage"}
{"seed": "// _escFSMustByte is the same as _escFSByte, but panics if name is not present.\nfunc _escFSMustByte(useLocal bool, name string) []byte {\n\tb, err := _escFSByte(useLocal, name)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn b\n}", "id": 17922, "concepts": ["panic", "byte handling", "string manipulation"], "_raw_llm_output": "panic, byte handling, string manipulation"}
{"seed": "// NewEmptyMethodArg will return a pointer to an empty\n// initialized MethodArg. This is primarily used in\n// conjunction with MethodBindPtrCall.\nfunc NewEmptyMethodArg() Pointer {\n\tvar obj C.godot_method_arg\n\treturn Pointer{base: unsafe.Pointer(&obj)}\n}", "id": 17929, "concepts": ["C.godot_method_arg", "unsafe.Pointer", "pointer"], "_raw_llm_output": "C.godot_method_arg, unsafe.Pointer, pointer"}
{"seed": "// We define a markdown block as having two EOF characters in a row (one line spacing)\nfunc splitFileFunction(data []byte, atEOF bool) (advanceBy int, block []byte, err error) {\n\tif atEOF && len(data) == 0 {\n\t\treturn 0, nil, nil\n\t}\n\n\tif atEOF {\n\t\treturn len(data), data, nil\n\t}\n\n\tindex := strings.Index(string(data), \"\\n\\n\")\n\tif index != -1 {\n\t\treturn index + 1, data[0:index], nil\n\t}\n\treturn\n}", "id": 17930, "concepts": ["string manipulation", "string search", "string iteration", "string concatenation", "string formatting", "string comparison", "string length", "string index", "string slice", "string iteration", "string search", "string concatenation", "string formatting", "string comparison", "string length", "string index", "string slice", "string iteration", "string search", "string concatenation", "string formatting", "string comparison", "string length", "string index", "string slice", "string iteration", "string search", "string concatenation", "string formatting", "string comparison", "string length", "string index", "string slice", "string iteration", "string search", "string concatenation", "string formatting", "string comparison", "string length", "string index", "string slice", "string iteration", "string search", "string concatenation", "string formatting", "string comparison", "string length", "string index", "string slice", "string iteration", "string search", "string concatenation", "string formatting", "string comparison", "string length", "string index", "string slice", "string iteration", "string search", "string concatenation", "string formatting", "string comparison", "string length", "string index", "string slice", "string iteration", "string search", "string concatenation", "string formatting", "string comparison", "string length", "string index", "string slice", "string iteration", "string search", "string concatenation", "string formatting", "string comparison", "string length", "string index", "string slice", "string iteration"], "_raw_llm_output": "string manipulation, string search, string iteration, string concatenation, string formatting, string comparison, string length, string index, string slice, string iteration, string search, string concatenation, string formatting, string comparison, string length, string index, string slice, string iteration, string search, string concatenation, string formatting, string comparison, string length, string index, string slice, string iteration, string search, string concatenation, string formatting, string comparison, string length, string index, string slice, string iteration, string search, string concatenation, string formatting, string comparison, string length, string index, string slice, string iteration, string search, string concatenation, string formatting, string comparison, string length, string index, string slice, string iteration, string search, string concatenation, string formatting, string comparison, string length, string index, string slice, string iteration, string search, string concatenation, string formatting, string comparison, string length, string index, string slice, string iteration, string search, string concatenation, string formatting, string comparison, string length, string index, string slice, string iteration, string search, string concatenation, string formatting, string comparison, string length, string index, string slice, string iteration"}
{"seed": "// Figcaption represents the HTML element 'figcaption'.\n// For more information visit https://www.w3schools.com/tags/tag_figcaption.asp.\nfunc Figcaption(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"figcaption\", Attributes: attrs, Children: children}\n}", "id": 17931, "concepts": ["HTML tree building", "HTML element definition", "HTML attribute definition"], "_raw_llm_output": "HTML tree building, HTML element definition, HTML attribute definition"}
{"seed": "// TestSeekPathrunDialogCase6 tests seekPath. The same as TestSeekPathrunDialogCase5, but checks return nil for seek function\n// see saveConfigFile return change\nfunc TestSeekPathrunDialogCase6(t *testing.T) {\n\tcfg := &config.Config{\n\t\tProjectFile: confgFile,\n\t}\n\n\tcfg.Init()\n\n\texpectedName := \"added project name\"\n\texpectedPath := \"/added/path/to/project\"\n\texpectedContainer := \"\"\n\n\tvar name, path, container string\n\n\ttfs := &testFileSystem{\n\t\tgetUserDirectory: func() (string, error) {\n\t\t\treturn \"/user/path/\", nil\n\t\t},\n\t\tsaveConfigFile: func(data interface{}, fileName string) error {\n\t\t\tif fileName == \"/added/path/to/project/\"+cfg.ProjectFile {\n\t\t\t\t// expected data type conifg.ProjectConfig\n\t\t\t\tmethodPath := reflect.ValueOf(data).MethodByName(\"GetPath\")\n\t\t\t\tmethodName := reflect.ValueOf(data).MethodByName(\"GetName\")\n\t\t\t\tmethodContainer := reflect.ValueOf(data).MethodByName(\"GetMainContainer\")\n\n\t\t\t\tname = methodName.Call(nil)[0].Interface().(string)\n\t\t\t\tpath = methodPath.Call(nil)[0].Interface().(string)\n\t\t\t\tcontainer = methodContainer.Call(nil)[0].Interface().(string)\n\t\t\t}\n\n\t\t\treturn nil\n\t\t},\n\t\tgetWd: func() (string, error) {\n\t\t\treturn \"\", nil\n\t\t},\n\t\treadConfigFile: func(filename string, configuration interface{}) error {\n\t\t\tif filename == cfg.GetUserFile() {\n\t\t\t\treturn json.Unmarshal([]byte(\"{}\"), &configuration)\n\t\t\t} else if filename == cfg.ProjectFile {\n\t\t\t\treturn errors.New(\"Error: no such file or directory\")\n\t\t\t}\n\t\t\treturn errors.New(\"Wrong test file\")\n\t\t},\n\t\tgoToProjectPath: func(path string) error {\n\t\t\tif path == \"/added/path/to/project\" {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn errors.New(\"Project project2 was not found \")\n\t\t},\n\t\tdirExists: func(path string) (bool, error) {\n\t\t\treturn true, nil\n\t\t},\n\t}\n\n\tcfg.SetFileSystem(tfs)\n\n\tdialog := &testDialog{\n\t\tsetSelectProject: func(projects []string) (int, string, error) {\n\t\t\treturn -1, \"\", nil\n\t\t},\n\t\tsetAddProjectName: func() (string, error) {\n\t\t\treturn \"added project name\", nil\n\t\t},\n\t\tsetAddProjectPath: func(path string) (string, error) {\n\t\t\treturn \"/added/path/to/project\", nil\n\t\t},\n\t}\n\n\terr := seekPath(cfg, dialog, tfs, true)\n\n\tassert.Equal(t, expectedName, name)\n\tassert.Equal(t, expectedPath, path)\n\tassert.Equal(t, expectedContainer, container)\n\tassert.Nil(t, err)\n}", "id": 17933, "concepts": ["testing", "test doubles", "mocking", "testing with mocks", "testing with test doubles", "testing with test doubles", "testing with test doubles", "testing with test doubles", "testing with test doubles", "testing with test doubles", "testing with test doubles", "testing with test doubles", "testing with test doubles", "testing with test doubles", "testing with test doubles", "testing with test doubles", "testing with test doubles", "testing with test doubles", "testing with test doubles", "testing with test doubles", "testing with test doubles", "testing with test doubles", "testing with test doubles", "testing with test doubles", "testing with test doubles", "testing with test doubles", "testing with test doubles", "testing with test doubles", "testing with test doubles", "testing with test doubles", "testing with test doubles", "testing with test doubles", "testing with test doubles", "testing with test doubles", "testing with test doubles", "testing with test doubles", "testing with test doubles", "testing with test doubles", "testing with test doubles", "testing with test doubles", "testing with test doubles", "testing with test doubles", "testing with test doubles", "testing with test doubles", "testing with"], "_raw_llm_output": "testing, test doubles, mocking, testing with mocks, testing with test doubles, testing with test doubles, testing with test doubles, testing with test doubles, testing with test doubles, testing with test doubles, testing with test doubles, testing with test doubles, testing with test doubles, testing with test doubles, testing with test doubles, testing with test doubles, testing with test doubles, testing with test doubles, testing with test doubles, testing with test doubles, testing with test doubles, testing with test doubles, testing with test doubles, testing with test doubles, testing with test doubles, testing with test doubles, testing with test doubles, testing with test doubles, testing with test doubles, testing with test doubles, testing with test doubles, testing with test doubles, testing with test doubles, testing with test doubles, testing with test doubles, testing with test doubles, testing with test doubles, testing with test doubles, testing with test doubles, testing with test doubles, testing with test doubles, testing with test doubles, testing with test doubles, testing with test doubles, testing with"}
{"seed": "// NewGetDevicesApsProfilesParamsWithContext creates a new GetDevicesApsProfilesParams object\n// with the ability to set a context for a request.\nfunc NewGetDevicesApsProfilesParamsWithContext(ctx context.Context) *GetDevicesApsProfilesParams {\n\treturn &GetDevicesApsProfilesParams{\n\t\tContext: ctx,\n\t}\n}", "id": 17939, "concepts": ["context package usage", "standard library usage"], "_raw_llm_output": "context package usage, standard library usage"}
{"seed": "// NewPoint returns a new Point.\nfunc NewPoint(x, y int) Point {\n\treturn Point{x, y}\n}", "id": 17940, "concepts": ["struct definition", "struct field initialization"], "_raw_llm_output": "struct definition, struct field initialization"}
{"seed": "// ShareWith will take a value as a string and return a string\n// value of \"One for [name], one for me\". If name == \"\", the default\n// value will be \"you\".\nfunc ShareWith(name string) string {\n\n\tif name == \"\" {\n\t\treturn \"One for you, one for me.\"\n\t} else {\n\t\treturn fmt.Sprintf(\"One for %v, one for me.\", name)\n\t}\n}", "id": 17953, "concepts": ["string formatting", "if-else statement", "basic function definition"], "_raw_llm_output": "string formatting, if-else statement, basic function definition"}
{"seed": "// NewCreateScopedUserRoleSpacesParamsWithContext creates a new CreateScopedUserRoleSpacesParams object\n// with the default values initialized, and the ability to set a context for a request\nfunc NewCreateScopedUserRoleSpacesParamsWithContext(ctx context.Context) *CreateScopedUserRoleSpacesParams {\n\tvar ()\n\treturn &CreateScopedUserRoleSpacesParams{\n\n\t\tContext: ctx,\n\t}\n}", "id": 17967, "concepts": ["context package usage", "function definition", "default values"], "_raw_llm_output": "context package usage, function definition, default values"}
{"seed": "// itob returns an 8-byte big endian representation of v.\nfunc itob(v int) []byte {\n\tb := make([]byte, 8)\n\tbinary.BigEndian.PutUint64(b, uint64(v))\n\treturn b\n}", "id": 17975, "concepts": ["endianness", "binary.BigEndian usage", "byte array creation"], "_raw_llm_output": "endianness, binary.BigEndian usage, byte array creation"}
{"seed": "// goPackageOption interprets the file's go_package option.\n// If there is no go_package, it returns (\"\", \"\", false).\n// If there's a simple name, it returns (\"\", pkg, true).\n// If the option implies an import path, it returns (impPath, pkg, true).\nfunc goPackageOption(d *descriptor.FileDescriptorProto) (impPath, pkg string, ok bool) {\n\tpkg = d.GetOptions().GetGoPackage()\n\tif pkg == \"\" {\n\t\treturn\n\t}\n\tok = true\n\t// The presence of a slash implies there's an import path.\n\tslash := strings.LastIndex(pkg, \"/\")\n\tif slash < 0 {\n\t\treturn\n\t}\n\timpPath, pkg = pkg, pkg[slash+1:]\n\t// A semicolon-delimited suffix overrides the package name.\n\tsc := strings.IndexByte(impPath, ';')\n\tif sc < 0 {\n\t\treturn\n\t}\n\timpPath, pkg = impPath[:sc], impPath[sc+1:]\n\treturn\n}", "id": 17982, "concepts": ["string manipulation", "string search", "string splitting", "string indexing", "string concatenation", "string comparison", "string formatting", "string length", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search", "string search"], "_raw_llm_output": "string manipulation, string search, string splitting, string indexing, string concatenation, string comparison, string formatting, string length, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search, string search"}
{"seed": "// NewDataExportQueryWithDefaults instantiates a new DataExportQuery object\n// This constructor will only assign default values to properties that have it defined,\n// but it doesn't guarantee that properties required by API are set\nfunc NewDataExportQueryWithDefaults() *DataExportQuery {\n\tthis := DataExportQuery{}\n\treturn &this\n}", "id": 17994, "concepts": ["constructor", "default values", "API usage"], "_raw_llm_output": "constructor, default values, API usage"}
{"seed": "// NewMinMaxRange creates a range with min set to +infinity and max set to -infinity\nfunc NewMinMaxRange() *MinMaxRange {\n\tr := new(MinMaxRange)\n\tr.Reset()\n\treturn r\n}", "id": 18012, "concepts": ["struct definition", "struct field initialization", "struct method definition", "struct method call", "struct field access"], "_raw_llm_output": "struct definition, struct field initialization, struct method definition, struct method call, struct field access"}
{"seed": "// goPackageName returns the Go package name to use in the\n// generated Go file.  The result explicit reports whether the name\n// came from an option go_package statement.  If explicit is false,\n// the name was derived from the protocol buffer's package statement\n// or the input file name.\nfunc goPackageName(d *descriptor.FileDescriptorProto) (name string, explicit bool) {\n\t// Does the file have a \"go_package\" option?\n\tif _, pkg, ok := goPackageOption(d); ok {\n\t\treturn pkg, true\n\t}\n\n\t// Does the file have a package clause?\n\tif pkg := d.GetPackage(); pkg != \"\" {\n\t\treturn pkg, false\n\t}\n\t// Use the file base name.\n\treturn baseName(d.GetName()), false\n}", "id": 18027, "concepts": ["option handling", "package statement", "file name handling"], "_raw_llm_output": "option handling, package statement, file name handling"}
{"seed": "// OnesCount8Before counts the number of \"1\"(population count) in a uint8 before specified bit position `iBit`.\nfunc OnesCount8Before(n uint8, iBit uint) int {\n\treturn gobits.OnesCount8(n & ((uint8(1) << iBit) - 1))\n}", "id": 18033, "concepts": ["bit manipulation", "bitwise operations", "bitwise AND", "bitwise OR", "bitwise XOR", "bitwise NOT", "bitwise left shift", "bitwise right shift", "bitwise AND with mask", "bitwise OR with mask", "bitwise XOR with mask", "bitwise NOT with mask", "bitwise left shift with mask", "bitwise right shift with mask", "bitwise AND with mask", "bitwise OR with mask", "bitwise XOR with mask", "bitwise NOT with mask", "bitwise left shift with mask", "bitwise right shift with mask", "bitwise AND with mask", "bitwise OR with mask", "bitwise XOR with mask", "bitwise NOT with mask", "bitwise left shift with mask", "bitwise right shift with mask", "bitwise AND with mask", "bitwise OR with mask", "bitwise XOR with mask", "bitwise NOT with mask", "bitwise left shift with mask", "bitwise right shift with mask", "bitwise AND with mask", "bitwise OR with mask", "bitwise XOR with mask", "bitwise NOT with mask", "bitwise left shift with mask", "bitwise right shift with mask", "bitwise AND with mask", "bitwise OR with mask", "bitwise XOR with mask", "bitwise NOT with mask", "bitwise left shift with mask", "bit"], "_raw_llm_output": "bit manipulation, bitwise operations, bitwise AND, bitwise OR, bitwise XOR, bitwise NOT, bitwise left shift, bitwise right shift, bitwise AND with mask, bitwise OR with mask, bitwise XOR with mask, bitwise NOT with mask, bitwise left shift with mask, bitwise right shift with mask, bitwise AND with mask, bitwise OR with mask, bitwise XOR with mask, bitwise NOT with mask, bitwise left shift with mask, bitwise right shift with mask, bitwise AND with mask, bitwise OR with mask, bitwise XOR with mask, bitwise NOT with mask, bitwise left shift with mask, bitwise right shift with mask, bitwise AND with mask, bitwise OR with mask, bitwise XOR with mask, bitwise NOT with mask, bitwise left shift with mask, bitwise right shift with mask, bitwise AND with mask, bitwise OR with mask, bitwise XOR with mask, bitwise NOT with mask, bitwise left shift with mask, bitwise right shift with mask, bitwise AND with mask, bitwise OR with mask, bitwise XOR with mask, bitwise NOT with mask, bitwise left shift with mask, bit"}
{"seed": "// MixedEnumEQ applies the EQ predicate on the \"mixed_enum\" field.\nfunc MixedEnumEQ(v MixedEnum) predicate.User {\n\treturn predicate.User(sql.FieldEQ(FieldMixedEnum, v))\n}", "id": 18037, "concepts": ["sql package usage", "predicate.User", "FieldEQ"], "_raw_llm_output": "sql package usage, predicate.User, FieldEQ"}
{"seed": "// WithDisconnectionCallback sets the callback function which is invoked if\n// the backing client disconnects after the election has unblocked.\nfunc WithDisconnectionCallback(onDisconnect func(error)) ElectorConfigFunc {\n\treturn func(e *elector) { e.onDisconnect = onDisconnect }\n}", "id": 18052, "concepts": ["function composition", "function definition", "function composition", "function composition", "function composition"], "_raw_llm_output": "function composition, function definition, function composition, function composition, function composition"}
{"seed": "// NewAPIClient creates a new APIClient that delegates to the AWS SDK using the default\n// AWS credentials provider.\nfunc NewAPIClient() (APIClient, error) {\n\tsession, err := session.NewSession(&aws.Config{})\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to create AWS root session: %v\", err)\n\t}\n\n\treturn &sdkAPIClient{\n\t\tsession: session,\n\t\tiamSvc:  iam.New(session),\n\t\tstsSvc:  sts.New(session),\n\t}, nil\n}", "id": 18055, "concepts": ["AWS SDK usage", "AWS SDK initialization", "AWS SDK configuration", "AWS SDK session creation", "AWS SDK service creation"], "_raw_llm_output": "AWS SDK usage, AWS SDK initialization, AWS SDK configuration, AWS SDK session creation, AWS SDK service creation"}
{"seed": "// robustOrientation finds the orientation using the accurate big/Rat type.\n//\n// It computes the determinant of the matrix and returns the orientation based\n// on the value of the determinant.\n//\n//\t| x1 y1 1 |\n//\t| x2 y2 1 |\n//\t| x  y  1 |\nfunc robustOrientation(x1, y1, x2, y2, x, y *big.Rat) OrientationKind {\n\t// Compute the determinant of the matrix\n\t// det := x1*y2 + x2*y + x*y1 - x1*y - x2*y1 - x*y2\n\tdet := bigSub(\n\t\tbigAdd(bigAdd(bigMul(x1, y2), bigMul(x2, y)), bigMul(x, y1)),\n\t\tbigAdd(bigAdd(bigMul(x1, y), bigMul(x2, y1)), bigMul(x, y2)),\n\t)\n\tsign := det.Sign()\n\tswitch sign {\n\tcase 1:\n\t\treturn CCW\n\tcase -1:\n\t\treturn CW\n\tcase 0:\n\t\treturn Colinear\n\t}\n\treturn IndeterminateOrientation\n}", "id": 18059, "concepts": ["big.Rat type", "integer arithmetic", "big.Int type", "big.Float type", "big.Rat type", "big.Int type", "big.Float type", "big.Rat type", "big.Int type", "big.Float type", "big.Rat type", "big.Int type", "big.Float type", "big.Rat type", "big.Int type", "big.Float type", "big.Rat type", "big.Int type", "big.Float type", "big.Rat type", "big.Int type", "big.Float type", "big.Rat type", "big.Int type", "big.Float type", "big.Rat type", "big.Int type", "big.Float type", "big.Rat type", "big.Int type", "big.Float type", "big.Rat type", "big.Int type", "big.Float type", "big.Rat type", "big.Int type", "big.Float type", "big.Rat type", "big.Int type", "big.Float type", "big.Rat type", "big.Int type", "big.Float type", "big.Rat type", "big.Int type", "big.Float type", "big.Rat type", "big.Int type", "big.Float type", "big.Rat type", "big.Int type", "big."], "_raw_llm_output": "big.Rat type, integer arithmetic, big.Int type, big.Float type, big.Rat type, big.Int type, big.Float type, big.Rat type, big.Int type, big.Float type, big.Rat type, big.Int type, big.Float type, big.Rat type, big.Int type, big.Float type, big.Rat type, big.Int type, big.Float type, big.Rat type, big.Int type, big.Float type, big.Rat type, big.Int type, big.Float type, big.Rat type, big.Int type, big.Float type, big.Rat type, big.Int type, big.Float type, big.Rat type, big.Int type, big.Float type, big.Rat type, big.Int type, big.Float type, big.Rat type, big.Int type, big.Float type, big.Rat type, big.Int type, big.Float type, big.Rat type, big.Int type, big.Float type, big.Rat type, big.Int type, big.Float type, big.Rat type, big.Int type, big."}
{"seed": "// Return *lumina.ClientSession extracted from a given context.Context.\nfunc getUpstream(ctx context.Context) *lumina.ClientSession {\n\treturn ctx.Value(upstreamContextKey).(*lumina.ClientSession)\n}", "id": 18067, "concepts": ["context.Context", "context.Context.Value", "type assertion"], "_raw_llm_output": "context.Context, context.Context.Value, type assertion"}
{"seed": "// Br represents the HTML void element 'br'.\n// For more information visit https://www.w3schools.com/tags/tag_br.asp.\nfunc Br(attrs []htmlgo.Attribute) HTML {\n\treturn &htmlgo.Tree{Tag: \"br\", Attributes: attrs, SelfClosing: true}\n}", "id": 18080, "concepts": ["HTML generation", "HTML tree representation", "HTML tag definition", "HTML attribute definition"], "_raw_llm_output": "HTML generation, HTML tree representation, HTML tag definition, HTML attribute definition"}
{"seed": "// DefaultArgoRolloutsRateLimiter is the default queue rate limiter.\n// Similar to workqueue.DefaultControllerRateLimiter() but the max limit is 10 seconds instead of 16 minutes\nfunc DefaultArgoRolloutsRateLimiter() workqueue.RateLimiter {\n\treturn workqueue.NewItemExponentialFailureRateLimiter(time.Millisecond, 10*time.Second)\n}", "id": 18083, "concepts": ["workqueue.RateLimiter", "time.Millisecond", "time.Second", "time.Duration", "workqueue.NewItemExponentialFailureRateLimiter"], "_raw_llm_output": "workqueue.RateLimiter, time.Millisecond, time.Second, time.Duration, workqueue.NewItemExponentialFailureRateLimiter"}
{"seed": "// Asset loads and returns the asset for the given name.\n// It returns an error if the asset could not be found or\n// could not be loaded.\nfunc Asset(name string) ([]byte, error) {\n\tcanonicalName := strings.Replace(name, \"\\\\\", \"/\", -1)\n\tif f, ok := _bindata[canonicalName]; ok {\n\t\ta, err := f()\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"Asset %s can't read by error: %v\", name, err)\n\t\t}\n\t\treturn a.bytes, nil\n\t}\n\treturn nil, fmt.Errorf(\"Asset %s not found\", name)\n}", "id": 18092, "concepts": ["bindata usage", "string manipulation", "error handling"], "_raw_llm_output": "bindata usage, string manipulation, error handling"}
{"seed": "// Legend_ is a convenience wrapper for Legend without the attrs argument.\nfunc Legend_(children ...HTML) HTML {\n  return Legend(nil, children...)\n}", "id": 18100, "concepts": ["function composition", "function argument handling", "variadic function argument"], "_raw_llm_output": "function composition, function argument handling, variadic function argument"}
{"seed": "// MixedEnumNEQ applies the NEQ predicate on the \"mixed_enum\" field.\nfunc MixedEnumNEQ(v MixedEnum) predicate.User {\n\treturn predicate.User(sql.FieldNEQ(FieldMixedEnum, v))\n}", "id": 18101, "concepts": ["sql.FieldNEQ", "predicate.User", "MixedEnum", "sql package usage"], "_raw_llm_output": "sql.FieldNEQ, predicate.User, MixedEnum, sql package usage"}
{"seed": "// NewListHetznerSizesParams creates a new ListHetznerSizesParams object,\n// with the default timeout for this client.\n//\n// Default values are not hydrated, since defaults are normally applied by the API server side.\n//\n// To enforce default values in parameter, use SetDefaults or WithDefaults.\nfunc NewListHetznerSizesParams() *ListHetznerSizesParams {\n\treturn &ListHetznerSizesParams{\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 18104, "concepts": ["default values", "timeout", "client-side default values"], "_raw_llm_output": "default values, timeout, client-side default values"}
{"seed": "// AssertDownlinkDeviceLock asserts that a downlink lock for the given device exists.\nfunc AssertDownlinkDeviceLock(devEUI lorawan.EUI64) Assertion {\n\treturn func(assert *require.Assertions, ts *IntegrationTestSuite) {\n\t\tkey := storage.GetRedisKey(\"lora:ns:device:%s:down:lock\", devEUI)\n\t\terr := storage.RedisClient().Get(context.Background(), key).Err()\n\t\tassert.NoError(err)\n\t}\n}", "id": 18106, "concepts": ["redis", "redis client usage", "redis key generation", "redis key expiration", "redis lock", "redis transaction", "redis pipeline", "redis connection pool", "redis client configuration", "redis key expiration", "redis key generation", "redis key expiration", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", "redis key generation", ""], "_raw_llm_output": "redis, redis client usage, redis key generation, redis key expiration, redis lock, redis transaction, redis pipeline, redis connection pool, redis client configuration, redis key expiration, redis key generation, redis key expiration, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation, redis key generation,"}
{"seed": "// NewGetStoresParamsWithTimeout creates a new GetStoresParams object\n// with the default values initialized, and the ability to set a timeout on a request\nfunc NewGetStoresParamsWithTimeout(timeout time.Duration) *GetStoresParams {\n\tvar ()\n\treturn &GetStoresParams{\n\n\t\ttimeout: timeout,\n\t}\n}", "id": 18111, "concepts": ["timeout handling", "struct definition", "method definition"], "_raw_llm_output": "timeout handling, struct definition, method definition"}
{"seed": "// NewAlertGetMonitorGroupAlertsParamsWithHTTPClient creates a new AlertGetMonitorGroupAlertsParams object\n// with the default values initialized, and the ability to set a custom HTTPClient for a request\nfunc NewAlertGetMonitorGroupAlertsParamsWithHTTPClient(client *http.Client) *AlertGetMonitorGroupAlertsParams {\n\tvar (\n\t\tincludeRemindersDefault = bool(false)\n\t\tpresetPeriodDefault     = string(\"Last24Hours\")\n\t\tsortingDefault          = string(\"Descending\")\n\t\ttakeDefault             = int32(100)\n\t)\n\treturn &AlertGetMonitorGroupAlertsParams{\n\t\tIncludeReminders: &includeRemindersDefault,\n\t\tPresetPeriod:     &presetPeriodDefault,\n\t\tSorting:          &sortingDefault,\n\t\tTake:             &takeDefault,\n\t\tHTTPClient:       client,\n\t}\n}", "id": 18119, "concepts": ["http.Client usage", "function definition", "default values", "pointer usage"], "_raw_llm_output": "http.Client usage, function definition, default values, pointer usage"}
{"seed": "// New creates a new lazy template, delaying the parsing work until it is first\n// needed. If the code is being run as part of tests, the template parsing will\n// happen immediately.\nfunc New(name, text string) *Template {\n\tlt := &Template{name: name, text: text}\n\tif inTest {\n\t\t// In tests, always parse the templates early.\n\t\tlt.tp()\n\t}\n\treturn lt\n}", "id": 18132, "concepts": ["defer", "function definition", "function call", "package definition", "package initialization"], "_raw_llm_output": "defer, function definition, function call, package definition, package initialization"}
{"seed": "// NewPostDockerRegistriesUUIDSearchListParams creates a new PostDockerRegistriesUUIDSearchListParams object\n// with the default values initialized.\nfunc NewPostDockerRegistriesUUIDSearchListParams() *PostDockerRegistriesUUIDSearchListParams {\n\tvar ()\n\treturn &PostDockerRegistriesUUIDSearchListParams{\n\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 18134, "concepts": ["struct initialization", "basic function definition"], "_raw_llm_output": "struct initialization, basic function definition"}
{"seed": "// NewCreateNetworkingV1beta1NamespacedIngressAccepted creates CreateNetworkingV1beta1NamespacedIngressAccepted with default headers values\nfunc NewCreateNetworkingV1beta1NamespacedIngressAccepted() *CreateNetworkingV1beta1NamespacedIngressAccepted {\n\n\treturn &CreateNetworkingV1beta1NamespacedIngressAccepted{}\n}", "id": 18137, "concepts": ["struct definition", "struct field definition", "struct field initialization", "struct field assignment", "struct field access", "struct field type conversion", "struct field type assertion", "struct field method definition", "struct field method call", "struct field method call with receiver", "struct field method call with receiver and arguments", "struct field method call with receiver and arguments and return value", "struct field method call with receiver and arguments and return value and error", "struct field method call with receiver and arguments and return value and error and error", "struct field method call with receiver and arguments and return value and error and error and error", "struct field method call with receiver and arguments and return value and error and error and error and error", "struct field method call with receiver and arguments and return value and error and error and error and error and error", "struct field method call with receiver and arguments and return value and error and error and error and error and error and error", "struct field method call with receiver and arguments and return value and error and error and error and error and error and error and error", "struct field method call with receiver and arguments and return value and error and error and error and error and error and error and error and error", "struct field method call with receiver and arguments and return value and error and error and error and error and"], "_raw_llm_output": "struct definition, struct field definition, struct field initialization, struct field assignment, struct field access, struct field type conversion, struct field type assertion, struct field method definition, struct field method call, struct field method call with receiver, struct field method call with receiver and arguments, struct field method call with receiver and arguments and return value, struct field method call with receiver and arguments and return value and error, struct field method call with receiver and arguments and return value and error and error, struct field method call with receiver and arguments and return value and error and error and error, struct field method call with receiver and arguments and return value and error and error and error and error, struct field method call with receiver and arguments and return value and error and error and error and error and error, struct field method call with receiver and arguments and return value and error and error and error and error and error and error, struct field method call with receiver and arguments and return value and error and error and error and error and error and error and error, struct field method call with receiver and arguments and return value and error and error and error and error and error and error and error and error, struct field method call with receiver and arguments and return value and error and error and error and error and"}
{"seed": "// WithAllowMissingConfigFile tells Parse to permit the case where a config file\n// is specified but doesn't exist. By default, missing config files result in an\n// error.\nfunc WithAllowMissingConfigFile(allow bool) Option {\n\treturn func(c *Context) {\n\t\tc.allowMissingConfigFile = allow\n\t}\n}", "id": 18146, "concepts": ["function composition", "function composition", "function composition"], "_raw_llm_output": "function composition, function composition, function composition"}
{"seed": "// Version is the current release version.\nfunc Version() string {\n\treturn \"1.0.6\"\n}", "id": 18148, "concepts": ["constant definition", "string concatenation"], "_raw_llm_output": "constant definition, string concatenation"}
{"seed": "// NewEntryServiceDeleteParamsWithTimeout creates a new EntryServiceDeleteParams object\n// with the default values initialized, and the ability to set a timeout on a request\nfunc NewEntryServiceDeleteParamsWithTimeout(timeout time.Duration) *EntryServiceDeleteParams {\n\tvar ()\n\treturn &EntryServiceDeleteParams{\n\n\t\ttimeout: timeout,\n\t}\n}", "id": 18150, "concepts": ["timeout handling", "function definition", "struct definition", "struct initialization"], "_raw_llm_output": "timeout handling, function definition, struct definition, struct initialization"}
{"seed": "// DateTimeNotNil applies the NotNil predicate on the \"dateTime\" field.\nfunc DateTimeNotNil() predicate.Bulk {\n\treturn predicate.Bulk(func(s *sql.Selector) {\n\t\ts.Where(sql.NotNull(s.C(FieldDateTime)))\n\t})\n}", "id": 18167, "concepts": ["sql.Selector", "sql.NotNull", "sql.C", "sql.Bulk", "predicate.Bulk", "sql.Where"], "_raw_llm_output": "sql.Selector, sql.NotNull, sql.C, sql.Bulk, predicate.Bulk, sql.Where"}
{"seed": "// RegisterUnlockFulfillmentType is used to register a fulfillment type, by linking it to\n// a constructor which constructs a fresh MarshalableUnlockFulfillment each time it is called.\n//\n// RegisterUnlockFulfillmentType can also used to unregister a fulfillment type,\n// by calling this function with nil as the MarshalableUnlockFulfillmentConstructor.\nfunc RegisterUnlockFulfillmentType(ft FulfillmentType, fc MarshalableUnlockFulfillmentConstructor) {\n\tif fc == nil {\n\t\tdelete(_RegisteredUnlockFulfillmentTypes, ft)\n\t\treturn\n\t}\n\t_RegisteredUnlockFulfillmentTypes[ft] = fc\n}", "id": 18171, "concepts": ["map", "map iteration", "map deletion", "map lookup"], "_raw_llm_output": "map, map iteration, map deletion, map lookup"}
{"seed": "// countIslands counts number of islands in given grid\n// of land (represented in 1) and water (represented by 0).\n// Island is a group of 1 that are surrounded by 0.\nfunc countIslands(grid [][]int) int {\n\tif len(grid) == 0 {\n\t\treturn 0\n\t}\n\n\tcount := 0\n\tfor i := 0; i < len(grid); i++ {\n\t\tfor j := 0; j < len(grid[0]); j++ {\n\t\t\tif grid[i][j] != 1 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tdfs(grid, i, j)\n\t\t\tcount += 1\n\t\t}\n\t}\n\n\treturn count\n}", "id": 18186, "concepts": ["DFS", "grid traversal", "2D array traversal"], "_raw_llm_output": "DFS, grid traversal, 2D array traversal"}
{"seed": "// Meta_ is a convenience wrapper for Meta without the attrs argument.\nfunc Meta_() HTML {\n  return Meta(nil)\n}", "id": 18189, "concepts": ["anonymous function", "function definition", "function call", "function return"], "_raw_llm_output": "anonymous function, function definition, function call, function return"}
{"seed": "// DecodeUpdateResponse returns a decoder for responses returned by the user\n// update endpoint. restoreBody controls whether the response body should be\n// restored after having been read.\n// DecodeUpdateResponse may return the following errors:\n//\t- \"invalide_token\" (type *goa.ServiceError): http.StatusBadRequest\n//\t- \"not_found\" (type *goa.ServiceError): http.StatusNotFound\n//\t- error: internal error\nfunc DecodeUpdateResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {\n\treturn func(resp *http.Response) (interface{}, error) {\n\t\tif restoreBody {\n\t\t\tb, err := ioutil.ReadAll(resp.Body)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tresp.Body = ioutil.NopCloser(bytes.NewBuffer(b))\n\t\t\tdefer func() {\n\t\t\t\tresp.Body = ioutil.NopCloser(bytes.NewBuffer(b))\n\t\t\t}()\n\t\t} else {\n\t\t\tdefer resp.Body.Close()\n\t\t}\n\t\tswitch resp.StatusCode {\n\t\tcase http.StatusNoContent:\n\t\t\treturn nil, nil\n\t\tcase http.StatusBadRequest:\n\t\t\tvar (\n\t\t\t\tbody UpdateInvalideTokenResponseBody\n\t\t\t\terr  error\n\t\t\t)\n\t\t\terr = decoder(resp).Decode(&body)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, goahttp.ErrDecodingError(\"user\", \"update\", err)\n\t\t\t}\n\t\t\terr = ValidateUpdateInvalideTokenResponseBody(&body)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, goahttp.ErrValidationError(\"user\", \"update\", err)\n\t\t\t}\n\t\t\treturn nil, NewUpdateInvalideToken(&body)\n\t\tcase http.StatusNotFound:\n\t\t\tvar (\n\t\t\t\tbody UpdateNotFoundResponseBody\n\t\t\t\terr  error\n\t\t\t)\n\t\t\terr = decoder(resp).Decode(&body)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, goahttp.ErrDecodingError(\"user\", \"update\", err)\n\t\t\t}\n\t\t\terr = ValidateUpdateNotFoundResponseBody(&body)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, goahttp.ErrValidationError(\"user\", \"update\", err)\n\t\t\t}\n\t\t\treturn nil, NewUpdateNotFound(&body)\n\t\tdefault:\n\t\t\tbody, _ := ioutil.ReadAll(resp.Body)\n\t\t\treturn nil, goahttp.ErrInvalidResponse(\"user\", \"update\", resp.StatusCode, string(body))\n\t\t}\n\t}\n}", "id": 18193, "concepts": ["error handling (goa.ServiceError)", "http.StatusBadRequest", "http.StatusNotFound", "http.StatusNoContent", "error handling (goahttp.ErrDecodingError", "goahttp.ErrValidationError", "goahttp.ErrInvalidResponse)", "error handling (NewUpdateInvalideToken", "NewUpdateNotFound)", "error handling (ValidateUpdateInvalideTokenResponseBody", "ValidateUpdateNotFoundResponseBody)", "error handling (ioutil.ReadAll)", "error handling (ioutil.NopCloser)", "error handling (bytes.NewBuffer)", "error handling (defer)", "error handling (func(*http.Response) (interface{}", "error))", "error handling (switch statement)", "error handling (case statement)", "error handling (default statement)", "error handling (return statement)", "error handling (if statement)", "error handling (else statement)", "error handling (if statement)", "error handling (else statement)", "error handling (if statement)", "error handling (else statement)", "error handling (if statement)", "error handling (else statement)", "error handling (if statement)", "error handling (else statement)", "error handling (if statement)", "error handling (else statement)", "error handling (if statement)", "error handling (else statement)", "error handling (if statement)", "error handling (else statement)", "error handling (if statement)", "error handling (else statement"], "_raw_llm_output": "error handling (goa.ServiceError), http.StatusBadRequest, http.StatusNotFound, http.StatusNoContent, error handling (goahttp.ErrDecodingError, goahttp.ErrValidationError, goahttp.ErrInvalidResponse), error handling (NewUpdateInvalideToken, NewUpdateNotFound), error handling (ValidateUpdateInvalideTokenResponseBody, ValidateUpdateNotFoundResponseBody), error handling (ioutil.ReadAll), error handling (ioutil.NopCloser), error handling (bytes.NewBuffer), error handling (defer), error handling (func(*http.Response) (interface{}, error)), error handling (switch statement), error handling (case statement), error handling (default statement), error handling (return statement), error handling (if statement), error handling (else statement), error handling (if statement), error handling (else statement), error handling (if statement), error handling (else statement), error handling (if statement), error handling (else statement), error handling (if statement), error handling (else statement), error handling (if statement), error handling (else statement), error handling (if statement), error handling (else statement), error handling (if statement), error handling (else statement), error handling (if statement), error handling (else statement"}
{"seed": "// KinToQuarks converts a string representation of kin\n// the quark value.\n//\n// An error is returned if the value string is invalid, or\n// it cannot be accurately represented as quarks. For example,\n// a value smaller than quarks, or a value _far_ greater than\n// the supply.\nfunc KinToQuarks(val string) (int64, error) {\n\tx, _, err := big.ParseFloat(val, 10, 64, big.ToZero)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tr, accuracy := new(big.Float).Mul(x, quarkCoeff).Int64()\n\tif accuracy != big.Exact {\n\t\treturn 0, errors.New(\"value cannot be represented with quarks\")\n\t}\n\n\treturn r, nil\n}", "id": 18198, "concepts": ["big.Float", "big.Int", "big.ParseFloat", "big.ToZero", "big.Exact", "big.Int64", "big.Float.Mul", "big.Float.Int64", "big.Float.Int64", "big.Float.Int64", "big.Float.Int64", "big.Float.Int64", "big.Float.Int64", "big.Float.Int64", "big.Float.Int64", "big.Float.Int64", "big.Float.Int64", "big.Float.Int64", "big.Float.Int64", "big.Float.Int64", "big.Float.Int64", "big.Float.Int64", "big.Float.Int64", "big.Float.Int64", "big.Float.Int64", "big.Float.Int64", "big.Float.Int64", "big.Float.Int64", "big.Float.Int64", "big.Float.Int64", "big.Float.Int64", "big.Float.Int64", "big.Float.Int64", "big.Float.Int64", "big.Float.Int"], "_raw_llm_output": "big.Float, big.Int, big.ParseFloat, big.ToZero, big.Exact, big.Int64, big.Float.Mul, big.Float.Int64, big.Float.Int64, big.Float.Int64, big.Float.Int64, big.Float.Int64, big.Float.Int64, big.Float.Int64, big.Float.Int64, big.Float.Int64, big.Float.Int64, big.Float.Int64, big.Float.Int64, big.Float.Int64, big.Float.Int64, big.Float.Int64, big.Float.Int64, big.Float.Int64, big.Float.Int64, big.Float.Int64, big.Float.Int64, big.Float.Int64, big.Float.Int64, big.Float.Int64, big.Float.Int64, big.Float.Int64, big.Float.Int64, big.Float.Int64, big.Float.Int"}
{"seed": "// AnyResolver returns a jsonpb.AnyResolver that uses the given file descriptors\n// to resolve message names. It uses the given factory, which may be nil, to\n// instantiate messages. The messages that it returns when resolving a type name\n// may often be dynamic messages.\nfunc AnyResolver(mf *MessageFactory, files ...*desc.FileDescriptor) jsonpb.AnyResolver {\n\treturn &anyResolver{mf: mf, files: files}\n}", "id": 18201, "concepts": ["jsonpb package usage", "descriptor package usage", "dynamic message instantiation", "type name resolution"], "_raw_llm_output": "jsonpb package usage, descriptor package usage, dynamic message instantiation, type name resolution"}
{"seed": "// CurrentAdmin returns migration extension admin address as currently\n// configured.\n//\n// This function is useful for the `gconf` package users to provide a one time\n// authentication address during configuration initialization. See\n// `gconf.NewUpdateConfigurationHandler` for more details.\nfunc CurrentAdmin(db weave.ReadOnlyKVStore) (weave.Address, error) {\n\tconf, err := loadConf(db)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"load configuration\")\n\t}\n\treturn conf.Admin, nil\n}", "id": 18218, "concepts": ["error handling (errors.Wrap)", "error wrapping", "function definition", "package usage"], "_raw_llm_output": "error handling (errors.Wrap), error wrapping, function definition, package usage"}
{"seed": "// NewUpdateZoneProjectsUsingPUTParams creates a new UpdateZoneProjectsUsingPUTParams object,\n// with the default timeout for this client.\n//\n// Default values are not hydrated, since defaults are normally applied by the API server side.\n//\n// To enforce default values in parameter, use SetDefaults or WithDefaults.\nfunc NewUpdateZoneProjectsUsingPUTParams() *UpdateZoneProjectsUsingPUTParams {\n\treturn &UpdateZoneProjectsUsingPUTParams{\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 18227, "concepts": ["struct definition", "timeout handling", "default values"], "_raw_llm_output": "struct definition, timeout handling, default values"}
{"seed": "// AlignmentPCenter returns a pointer to AlignmentVCenter\nfunc AlignmentPCenter() *Alignment {\n\tv := AlignmentVCenter\n\treturn &v\n}", "id": 18256, "concepts": ["pointer usage", "pointer dereference"], "_raw_llm_output": "pointer usage, pointer dereference"}
{"seed": "/*\nhttps://leetcode.com/problems/bitwise-and-of-numbers-range/\n\nGiven a range [m, n] where 0 <= m <= n <= 2147483647, return the bitwise AND of all numbers in this range, inclusive.\n\nExample 1:\n\nInput: [5,7]\nOutput: 4\n\nExample 2:\n\nInput: [0,1]\nOutput: 0\n*/\n\nfunc rangeBitwiseAnd(m int, n int) int {\n\tshiftCounter := 0\n\n\t// shift right until both numbers are equal, which means that they have common prefix, which is a bases for an answer\n\t// to get an answer we need to shift the basis left as many times as we shifted original number to the right\n\tfor m != n {\n\t\tm >>= 1\n\t\tn >>= 1\n\t\tshiftCounter++\n\t}\n\n\treturn n << shiftCounter\n}", "id": 18257, "concepts": ["bitwise AND", "bitwise OR", "bitwise XOR", "bitwise NOT", "bitwise shift", "integer division"], "_raw_llm_output": "bitwise AND, bitwise OR, bitwise XOR, bitwise NOT, bitwise shift, integer division"}
{"seed": "// Bdi_ is a convenience wrapper for Bdi without the attrs argument.\nfunc Bdi_(children ...HTML) HTML {\n  return Bdi(nil, children...)\n}", "id": 18263, "concepts": ["basic function definition", "variadic function definition", "HTML type definition"], "_raw_llm_output": "basic function definition, variadic function definition, HTML type definition"}
{"seed": "// Scan reads rows to a given pointer to slice v.\n// The \"db\" tag in the struct type definition is used to map\n// database columns to struct fields.\n//\n// v must be a pointer to a slice of structs.\nfunc Scan(v interface{}, rows *sql.Rows) error {\n\tdefer rows.Close()\n\n\tcols, err := rows.Columns()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsliceValue, itemType, itemIsPtr, err := resolveReflection(v)\n\n\t// column name to field name\n\tfieldMap := map[string]string{}\n\n\tvisitStructFields(itemType, func(f reflect.StructField) {\n\t\tcolName := f.Tag.Get(\"db\")\n\t\tif colName == \"\" {\n\t\t\tcolName = toSnakeCase(f.Name)\n\t\t}\n\n\t\tfieldMap[colName] = f.Name\n\t})\n\n\tfor rows.Next() {\n\t\t// type: *elem\n\t\titem := reflect.New(itemType)\n\n\t\tdests := make([]interface{}, 0, len(cols))\n\t\tfor _, col := range cols {\n\t\t\tif fn, ok := fieldMap[col]; ok {\n\t\t\t\tdest := item.Elem().FieldByName(fn).Addr().Interface()\n\t\t\t\tdests = append(dests, dest)\n\t\t\t} else {\n\t\t\t\tdests = append(dests, emptyScanner{})\n\t\t\t}\n\t\t}\n\n\t\terr := rows.Scan(dests...)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif itemIsPtr == false {\n\t\t\t// type: elem\n\t\t\titem = reflect.Indirect(item)\n\t\t}\n\t\tsliceValue.Set(reflect.Append(sliceValue, item))\n\t}\n\n\treturn nil\n}", "id": 18266, "concepts": ["reflection", "sql package usage", "database column mapping"], "_raw_llm_output": "reflection, sql package usage, database column mapping"}
{"seed": "// queueTags returns a set of tags containing information from the given source\n// instance to set on a SQS queue.\nfunc queueTags(src *v1alpha1.AWSS3Source) map[string]string {\n\treturn map[string]string{\n\t\t\"bucket-arn\":    s3.RealBucketARN(src.Spec.ARN),\n\t\t\"bucket-region\": src.Spec.ARN.Region,\n\t\t\"owned-by\":      sourceID(src),\n\t}\n}", "id": 18271, "concepts": ["map iteration", "map creation", "string formatting", "string concatenation", "string manipulation", "string comparison"], "_raw_llm_output": "map iteration, map creation, string formatting, string concatenation, string manipulation, string comparison"}
{"seed": "// NewPostAdminUsersParamsWithContext creates a new PostAdminUsersParams object\n// with the default values initialized, and the ability to set a context for a request\nfunc NewPostAdminUsersParamsWithContext(ctx context.Context) *PostAdminUsersParams {\n\tvar ()\n\treturn &PostAdminUsersParams{\n\n\t\tContext: ctx,\n\t}\n}", "id": 18279, "concepts": ["context package usage", "function definition", "method definition"], "_raw_llm_output": "context package usage, function definition, method definition"}
{"seed": "// MakeAddToUserAgentHandler will add the name/version pair to the User-Agent request\n// header. If the extra parameters are provided they will be added as metadata to the\n// name/version pair resulting in the following format.\n// \"name/version (extra0; extra1; ...)\"\n// The user agent part will be concatenated with this current request's user agent string.\nfunc MakeAddToUserAgentHandler(name, version string, extra ...string) func(*Request) {\n\tua := fmt.Sprintf(\"%s/%s\", name, version)\n\tif len(extra) > 0 {\n\t\tua += fmt.Sprintf(\" (%s)\", strings.Join(extra, \"; \"))\n\t}\n\treturn func(r *Request) {\n\t\tAddToUserAgent(r, ua)\n\t}\n}", "id": 18300, "concepts": ["function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", ""], "_raw_llm_output": "function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition,"}
{"seed": "// getDockerClient returns a client capable of communicating with the local\n// docker daemon.  If an error occurs (such as no local daemon being available),\n// it will return nil.\nfunc getDockerClient() (*docker.Client, error) {\n\tdockerClient, _, err := dockerutil.NewHelper().GetClient()\n\tif err == nil {\n\t\tif err = dockerClient.Ping(); err != nil {\n\t\t\tklog.V(4).Infof(\"Container service did not respond to a ping: %v\", err)\n\t\t\treturn nil, err\n\t\t}\n\t\treturn dockerClient, nil\n\t}\n\tklog.V(2).Infof(\"No local container engine detected: %v\", err)\n\treturn nil, err\n}", "id": 18307, "concepts": ["error handling (idiomatic if err != nil)", "error handling (errors.As)", "error handling (errors.Is)", "error handling (errors.New)", "error handling (errors.Errorf)", "error handling (errors.Wrap)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error handling (errors.Wrapf)", "error"], "_raw_llm_output": "error handling (idiomatic if err != nil), error handling (errors.As), error handling (errors.Is), error handling (errors.New), error handling (errors.Errorf), error handling (errors.Wrap), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error handling (errors.Wrapf), error"}
{"seed": "// MustString does the same as the String function, but generates panic in case of an error.\nfunc MustString(key string) (value string) {\n\tvalue, err := String(key)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn\n}", "id": 18328, "concepts": ["error handling (panic)", "error handling (idiomatic if err != nil)", "error handling (errors.Is)", "error handling (errors.As)"], "_raw_llm_output": "error handling (panic), error handling (idiomatic if err != nil), error handling (errors.Is), error handling (errors.As)"}
{"seed": "// Unmarshal a CTE document from a byte slice, creating an object of the same type as the template.\n// If template is nil, an interface type will be returned.\n// If opts is nil, default options will be used.\nfunc UnmarshalCTEFromDocument(document []byte, template interface{}, opts *options.CTEUnmarshalerOptions) (decoded interface{}, err error) {\n\treturn NewCTEUnmarshaler(opts).UnmarshalFromDocument(document, template)\n}", "id": 18339, "concepts": ["interface", "struct", "interface conversion", "error handling", "standard library usage"], "_raw_llm_output": "interface, struct, interface conversion, error handling, standard library usage"}
{"seed": "// isCNforProxy returns true if the given CN for the workload certificate matches the given proxy's identity.\n// Proxy identity corresponds to the k8s service account, while the workload certificate is of the form\n// <svc-account>.<namespace>.<trust-domain>.\nfunc isCNforProxy(proxy *envoy.Proxy, cn certificate.CommonName) bool {\n\tproxyIdentity, err := catalog.GetServiceAccountFromProxyCertificate(proxy.GetCertificateCommonName())\n\tif err != nil {\n\t\tlog.Error().Err(err).Msgf(\"Error looking up proxy identity for proxy with SerialNumber=%s on Pod with UID=%s\",\n\t\t\tproxy.GetCertificateSerialNumber(), proxy.GetPodUID())\n\t\treturn false\n\t}\n\n\t// Workload certificate CN is of the form <svc-account>.<namespace>.<trust-domain>\n\tchunks := strings.Split(cn.String(), constants.DomainDelimiter)\n\tif len(chunks) < 3 {\n\t\treturn false\n\t}\n\n\tidentityForCN := identity.K8sServiceAccount{Name: chunks[0], Namespace: chunks[1]}\n\treturn identityForCN == proxyIdentity\n}", "id": 18340, "concepts": ["string manipulation", "certificate parsing", "string comparison", "string formatting", "standard library usage"], "_raw_llm_output": "string manipulation, certificate parsing, string comparison, string formatting, standard library usage"}
{"seed": "// RandomColorTheme returns a random ColorTheme.\nfunc RandomColorTheme() ColorTheme {\n\tvar themes = []ColorTheme{\n\t\tSpring, Autumn, Winter,\n\t\tRose, Valentine,\n\t}\n\n\treturn themes[rand.Intn(len(themes))]\n}", "id": 18354, "concepts": ["random number generation", "slice iteration (range loop)", "array indexing", "basic function definition"], "_raw_llm_output": "random number generation, slice iteration (range loop), array indexing, basic function definition"}
{"seed": "// NewCreateSksClusterRequestWithBody generates requests for CreateSksCluster with any type of body\nfunc NewCreateSksClusterRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {\n\tvar err error\n\n\tqueryUrl, err := url.Parse(server)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbasePath := fmt.Sprintf(\"/sks-cluster\")\n\tif basePath[0] == '/' {\n\t\tbasePath = basePath[1:]\n\t}\n\n\tqueryUrl, err = queryUrl.Parse(basePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq, err := http.NewRequest(\"POST\", queryUrl.String(), body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Add(\"Content-Type\", contentType)\n\treturn req, nil\n}", "id": 18366, "concepts": ["url parsing", "http request generation", "io.Reader"], "_raw_llm_output": "url parsing, http request generation, io.Reader"}
{"seed": "// NewPositionIsolateMarginOK creates a PositionIsolateMarginOK with default headers values\nfunc NewPositionIsolateMarginOK() *PositionIsolateMarginOK {\n\treturn &PositionIsolateMarginOK{}\n}", "id": 18372, "concepts": ["struct definition", "struct field definition", "struct initialization", "struct pointer definition"], "_raw_llm_output": "struct definition, struct field definition, struct initialization, struct pointer definition"}
{"seed": "// Body_ is a convenience wrapper for Body without the attrs argument.\nfunc Body_(children ...HTML) HTML {\n  return Body(nil, children...)\n}", "id": 18380, "concepts": ["HTML struct definition", "HTML struct field definition", "HTML struct field initialization", "HTML struct field access"], "_raw_llm_output": "HTML struct definition, HTML struct field definition, HTML struct field initialization, HTML struct field access"}
{"seed": "// VerifySenderJWSSignature verifies if a message is JWS signed. If signed then the signature is verified\n// using the 'Sender' or 'Address' attributes to determine the public key to verify with.\n// To verify correctly, the sender has to be a known publisher and verified with the DSS.\n//  object MUST be a pointer to the type otherwise unmarshal fails.\n//\n// getPublicKey is a lookup function for providing the public key from the given sender address.\n//  it should only provide a public key if the publisher is known and verified by the DSS, or\n//  if this zone does not use a DSS (publisher are protected through message bus ACLs)\n//  If not provided then signature verification will succeed.\n//\n// The rawMessage is json unmarshalled into the given object.\n//\n// This returns a flag if the message was signed and if so, an error if the verification failed\nfunc VerifySenderJWSSignature(rawMessage string, object interface{}, getPublicKey func(address string) *ecdsa.PublicKey) (isSigned bool, err error) {\n\n\tjwsSignature, err := jose.ParseSigned(rawMessage)\n\tif err != nil {\n\t\t// message is (probably) not signed, try to unmarshal it directly\n\t\terr = json.Unmarshal([]byte(rawMessage), object)\n\t\treturn false, err\n\t}\n\tpayload := jwsSignature.UnsafePayloadWithoutVerification()\n\terr = json.Unmarshal([]byte(payload), object)\n\tif err != nil {\n\t\t// message doesn't have a json payload\n\t\terrTxt := fmt.Sprintf(\"VerifySenderSignature: Signature okay but message unmarshal failed: %s\", err)\n\t\treturn true, errors.New(errTxt)\n\t}\n\t// determine who the sender is\n\treflObject := reflect.ValueOf(object).Elem()\n\treflSender := reflObject.FieldByName(\"Sender\")\n\tif !reflSender.IsValid() {\n\t\treflSender = reflObject.FieldByName(\"Address\")\n\t\tif !reflSender.IsValid() {\n\t\t\terr = errors.New(\"VerifySenderJWSSignature: object doesn't have a Sender or Address field\")\n\t\t\treturn true, err\n\t\t}\n\t}\n\tsender := reflSender.String()\n\tif sender == \"\" {\n\t\terr := errors.New(\"VerifySenderJWSSignature: Missing sender or address information in message\")\n\t\treturn true, err\n\t}\n\t// verify the message signature using the sender's public key\n\tif getPublicKey == nil {\n\t\treturn true, nil\n\t}\n\tpublicKey := getPublicKey(sender)\n\tif publicKey == nil {\n\t\terr := errors.New(\"VerifySenderJWSSignature: No public key available for sender \" + sender)\n\t\treturn true, err\n\t}\n\n\t_, err = jwsSignature.Verify(publicKey)\n\tif err != nil {\n\t\tmsg := fmt.Sprintf(\"VerifySenderJWSSignature: message signature from %s fails to verify with its public key\", sender)\n\t\terr := errors.New(msg)\n\t\treturn true, err\n\t}\n\treturn true, err\n}", "id": 18387, "concepts": ["json unmarshaling", "json marshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling", "json unmarshaling"], "_raw_llm_output": "json unmarshaling, json marshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling, json unmarshaling"}
{"seed": "// PossibleFirewallAllowAzureIpsStateValues returns an array of possible values for the FirewallAllowAzureIpsState const type.\nfunc PossibleFirewallAllowAzureIpsStateValues() []FirewallAllowAzureIpsState {\n\treturn []FirewallAllowAzureIpsState{Disabled, Enabled}\n}", "id": 18389, "concepts": ["const declaration", "array declaration", "array iteration"], "_raw_llm_output": "const declaration, array declaration, array iteration"}
{"seed": "// LoadEnv loads a .env file to os.Environ()\nfunc LoadEnv() error {\n\treturn godotenv.Load()\n}", "id": 18390, "concepts": ["os.Environ", "godotenv package usage"], "_raw_llm_output": "os.Environ, godotenv package usage"}
{"seed": "// SupportedActivationFunctions returns the list of activation functions supported by GoMind.\nfunc SupportedActivationFunctions() []string {\n\treturn activationFunctions\n}", "id": 18400, "concepts": ["array", "slice", "function definition", "return statement", "basic function definition"], "_raw_llm_output": "array, slice, function definition, return statement, basic function definition"}
{"seed": "// Kind changes the kind of an Exchange from the \"direct\" default.\nfunc Kind(k string) Option {\n\treturn func(e Exchange) Exchange {\n\t\te.Kind = k\n\t\treturn e\n\t}\n}", "id": 18402, "concepts": ["function composition", "functional options", "function definition", "function return"], "_raw_llm_output": "function composition, functional options, function definition, function return"}
{"seed": "// NewGetCountersParamsWithTimeout creates a new GetCountersParams object\n// with the ability to set a timeout on a request.\nfunc NewGetCountersParamsWithTimeout(timeout time.Duration) *GetCountersParams {\n\treturn &GetCountersParams{\n\t\ttimeout: timeout,\n\t}\n}", "id": 18406, "concepts": ["timeout handling", "function definition", "function parameters"], "_raw_llm_output": "timeout handling, function definition, function parameters"}
{"seed": "// isInvalidTriggerError returns true if the given error is\n// a validation error that contains 'invalid trigger type' in its\n// error message. This error is returned from older servers that\n// consider the presence of unknown trigger types to be an error.\nfunc isInvalidTriggerError(err error) bool {\n\tif !kapierrors.IsInvalid(err) {\n\t\treturn false\n\t}\n\tstatusErr, ok := err.(*kapierrors.StatusError)\n\tif !ok {\n\t\treturn false\n\t}\n\treturn strings.Contains(statusErr.Status().Message, \"invalid trigger type\")\n}", "id": 18407, "concepts": ["error handling (kapierrors.IsInvalid)", "string comparison", "error message handling"], "_raw_llm_output": "error handling (kapierrors.IsInvalid), string comparison, error message handling"}
{"seed": "// Returns a suited java modifier (public, ...) for the (globally visible) definition of ident. E.g.:\n// \tx -> NONE   (package private)\n// \tX -> PUBLIC (exported)\n// Modifier is also final for struct types (implemented as final java references)\nfunc GlobalModifierFor(ident string, typ JType) JModifier {\n\tmod := NONE\n\tif ast.IsExported(ident) {\n\t\tmod |= PUBLIC\n\t}\n\tif typ.NeedsFinal() {\n\t\tmod |= FINAL\n\t}\n\treturn mod\n}", "id": 18408, "concepts": ["string manipulation", "string comparison", "string conversion", "string formatting", "string concatenation", "string length", "string index access", "string range loop", "string slice", "string subslice", "string slicing", "string concatenation", "string formatting", "string conversion", "string length", "string index access", "string range loop", "string slice", "string subslice", "string slicing", "string concatenation", "string formatting", "string conversion", "string length", "string index access", "string range loop", "string slice", "string subslice", "string slicing", "string concatenation", "string formatting", "string conversion", "string length", "string index access", "string range loop", "string slice", "string subslice", "string slicing", "string concatenation", "string formatting", "string conversion", "string length", "string index access", "string range loop", "string slice", "string subslice", "string slicing", "string concatenation", "string formatting", "string conversion", "string length", "string index access", "string range loop", "string slice", "string subslice", "string slicing", "string concatenation", "string formatting", "string conversion", "string length", "string index access", "string range loop", "string slice", "string subslice", "string slicing", "string concatenation", "string formatting", "string conversion", "string length", "string index access", "string range loop", "string slice", "string"], "_raw_llm_output": "string manipulation, string comparison, string conversion, string formatting, string concatenation, string length, string index access, string range loop, string slice, string subslice, string slicing, string concatenation, string formatting, string conversion, string length, string index access, string range loop, string slice, string subslice, string slicing, string concatenation, string formatting, string conversion, string length, string index access, string range loop, string slice, string subslice, string slicing, string concatenation, string formatting, string conversion, string length, string index access, string range loop, string slice, string subslice, string slicing, string concatenation, string formatting, string conversion, string length, string index access, string range loop, string slice, string subslice, string slicing, string concatenation, string formatting, string conversion, string length, string index access, string range loop, string slice, string subslice, string slicing, string concatenation, string formatting, string conversion, string length, string index access, string range loop, string slice, string subslice, string slicing, string concatenation, string formatting, string conversion, string length, string index access, string range loop, string slice, string"}
{"seed": "// NewUpdateBuilder creates a new UPDATE builder.\nfunc NewUpdateBuilder() *UpdateBuilder {\n\treturn DefaultFlavor.NewUpdateBuilder()\n}", "id": 18413, "concepts": ["struct definition", "struct initialization", "struct method definition"], "_raw_llm_output": "struct definition, struct initialization, struct method definition"}
{"seed": "// GetVersion returns application version.\nfunc GetVersion() *Version {\n\treturn &Version{\n\t\tVersion:   appVersion,\n\t\tGitCommit: GitSha,\n\t\tBuildDate: time.Now().UTC().String(),\n\t\tGoVersion: runtime.Version(),\n\t\tGOOS:      runtime.GOOS,\n\t\tGOArch:    runtime.GOARCH,\n\t}\n}", "id": 18416, "concepts": ["struct definition", "pointer usage", "runtime package usage"], "_raw_llm_output": "struct definition, pointer usage, runtime package usage"}
{"seed": "// New creates a new Pool of workers that starts with n workers. You must\n// provide a constructor function that creates new Worker types and when you\n// change the size of the pool the constructor will be called to create each new\n// Worker.\nfunc New(n int, ctor func() Worker) *Pool {\n\tp := &Pool{\n\t\tctor:    ctor,\n\t\treqChan: make(chan workRequest),\n\t}\n\tp.SetSize(n)\n\n\treturn p\n}", "id": 18419, "concepts": ["constructor function", "function definition", "function call", "function closure", "function return", "function parameter", "function return value", "function parameter value", "function parameter type", "function parameter name", "function parameter type name", "function parameter type name", "function parameter type name", "function parameter type name", "function parameter type name", "function parameter type name", "function parameter type name", "function parameter type name", "function parameter type name", "function parameter type name", "function parameter type name", "function parameter type name", "function parameter type name", "function parameter type name", "function parameter type name", "function parameter type name", "function parameter type name", "function parameter type name", "function parameter type name", "function parameter type name", "function parameter type name", "function parameter type name", "function parameter type name", "function parameter type name", "function parameter type name", "function parameter type name", "function parameter type name", "function parameter type name", "function parameter type name", "function parameter type name", "function parameter type name", "function parameter type name", "function parameter type name", "function parameter type name", "function parameter type name", "function parameter type name", "function parameter type name", "function parameter type name", "function parameter type name", "function parameter type name", "function parameter type name", "function parameter type name", "function parameter type name", "function parameter type name", "function"], "_raw_llm_output": "constructor function, function definition, function call, function closure, function return, function parameter, function return value, function parameter value, function parameter type, function parameter name, function parameter type name, function parameter type name, function parameter type name, function parameter type name, function parameter type name, function parameter type name, function parameter type name, function parameter type name, function parameter type name, function parameter type name, function parameter type name, function parameter type name, function parameter type name, function parameter type name, function parameter type name, function parameter type name, function parameter type name, function parameter type name, function parameter type name, function parameter type name, function parameter type name, function parameter type name, function parameter type name, function parameter type name, function parameter type name, function parameter type name, function parameter type name, function parameter type name, function parameter type name, function parameter type name, function parameter type name, function parameter type name, function parameter type name, function parameter type name, function parameter type name, function parameter type name, function parameter type name, function parameter type name, function parameter type name, function parameter type name, function parameter type name, function parameter type name, function parameter type name, function parameter type name, function"}
{"seed": "// NewRateWindowBehavior creates an event rate window behavior. It checks\n// if an event matches the passed criterion. If count events match during\n// duration the process function is called. Its returned payload is\n// emitted as new event with topic \"rate-window\". A received \"reset\" as\n// topic resets the collected matches.\nfunc NewRateWindowBehavior(\n\tid string,\n\tmatches RateWindowCriterion,\n\tcount int,\n\tduration time.Duration,\n\tprocess event.SinkProcessor) mesh.Behavior {\n\treturn &rateWindowBehavior{\n\t\tid:       id,\n\t\tsink:     event.NewSink(count),\n\t\tmatches:  matches,\n\t\tcount:    count,\n\t\tduration: duration,\n\t\tprocess:  process,\n\t}\n}", "id": 18420, "concepts": ["struct definition", "interface implementation", "anonymous function", "method definition", "method invocation", "method chaining", "method composition", "method delegation", "method composition", "method chaining", "method delegation", "method composition", "method chaining", "method delegation", "method composition", "method chaining", "method delegation", "method composition", "method chaining", "method delegation", "method composition", "method chaining", "method delegation", "method composition", "method chaining", "method delegation", "method composition", "method chaining", "method delegation", "method composition", "method chaining", "method delegation", "method composition", "method chaining", "method delegation", "method composition", "method chaining", "method delegation", "method composition", "method chaining", "method delegation", "method composition", "method chaining", "method delegation", "method composition", "method chaining", "method delegation", "method composition", "method chaining", "method delegation", "method composition", "method chaining", "method delegation", "method composition", "method chaining", "method delegation", "method composition", "method chaining", "method delegation", "method composition", "method chaining", "method delegation", "method composition", "method chaining", "method delegation", "method composition", "method chaining", "method delegation", "method composition", "method chaining", "method delegation", "method composition", "method chaining", "method delegation", "method composition", "method chaining", "method delegation", ""], "_raw_llm_output": "struct definition, interface implementation, anonymous function, method definition, method invocation, method chaining, method composition, method delegation, method composition, method chaining, method delegation, method composition, method chaining, method delegation, method composition, method chaining, method delegation, method composition, method chaining, method delegation, method composition, method chaining, method delegation, method composition, method chaining, method delegation, method composition, method chaining, method delegation, method composition, method chaining, method delegation, method composition, method chaining, method delegation, method composition, method chaining, method delegation, method composition, method chaining, method delegation, method composition, method chaining, method delegation, method composition, method chaining, method delegation, method composition, method chaining, method delegation, method composition, method chaining, method delegation, method composition, method chaining, method delegation, method composition, method chaining, method delegation, method composition, method chaining, method delegation, method composition, method chaining, method delegation, method composition, method chaining, method delegation, method composition, method chaining, method delegation, method composition, method chaining, method delegation, method composition, method chaining, method delegation,"}
{"seed": "// successResult is a convenience function for creating a success objectResult\nfunc successResult(namespacedName string, timeToDeploy time.Duration, inSync bool) objectResult {\n\treturn objectResult{NamespacedName: namespacedName, TimeToDeploy: timeToDeploy, InSync: inSync}\n}", "id": 18431, "concepts": ["struct definition", "struct field access", "basic function definition"], "_raw_llm_output": "struct definition, struct field access, basic function definition"}
{"seed": "// setupSignalHandler registered for SIGTERM and SIGINT. A stop channel is returned\n// which is closed on one of these signals. If a second signal is caught, the program\n// is terminated with exit code 1.\nfunc setupSignalHandler() (stopCh <-chan struct{}) {\n\tclose(onlyOneSignalHandler) // panics when called twice\n\n\tstop := make(chan struct{})\n\tc := make(chan os.Signal, 2)\n\tsignal.Notify(c, shutdownSignals...)\n\tgo func() {\n\t\t<-c\n\t\tclose(stop)\n\t\t<-c\n\t\tos.Exit(1) // second signal. Exit directly.\n\t}()\n\n\treturn stop\n}", "id": 18435, "concepts": ["signal handling", "channel close", "channel blocking", "channel buffering", "channel range loop", "channel iteration", "channel blocking", "channel buffering", "channel range loop", "channel iteration", "channel blocking", "channel buffering", "channel range loop", "channel iteration", "channel blocking", "channel buffering", "channel range loop", "channel iteration", "channel blocking", "channel buffering", "channel range loop", "channel iteration", "channel blocking", "channel buffering", "channel range loop", "channel iteration", "channel blocking", "channel buffering", "channel range loop", "channel iteration", "channel blocking", "channel buffering", "channel range loop", "channel iteration", "channel blocking", "channel buffering", "channel range loop", "channel iteration", "channel blocking", "channel buffering", "channel range loop", "channel iteration", "channel blocking", "channel buffering", "channel range loop", "channel iteration", "channel blocking", "channel buffering", "channel range loop", "channel iteration", "channel blocking", "channel buffering", "channel range loop", "channel iteration", "channel blocking", "channel buffering", "channel range loop", "channel iteration", "channel blocking", "channel buffering", "channel range loop", "channel iteration", "channel blocking", "channel buffering", "channel range loop", "channel iteration", "channel blocking", "channel buffering", "channel range loop", "channel iteration", "channel blocking", "channel buffering", "channel range loop", ""], "_raw_llm_output": "signal handling, channel close, channel blocking, channel buffering, channel range loop, channel iteration, channel blocking, channel buffering, channel range loop, channel iteration, channel blocking, channel buffering, channel range loop, channel iteration, channel blocking, channel buffering, channel range loop, channel iteration, channel blocking, channel buffering, channel range loop, channel iteration, channel blocking, channel buffering, channel range loop, channel iteration, channel blocking, channel buffering, channel range loop, channel iteration, channel blocking, channel buffering, channel range loop, channel iteration, channel blocking, channel buffering, channel range loop, channel iteration, channel blocking, channel buffering, channel range loop, channel iteration, channel blocking, channel buffering, channel range loop, channel iteration, channel blocking, channel buffering, channel range loop, channel iteration, channel blocking, channel buffering, channel range loop, channel iteration, channel blocking, channel buffering, channel range loop, channel iteration, channel blocking, channel buffering, channel range loop, channel iteration, channel blocking, channel buffering, channel range loop, channel iteration, channel blocking, channel buffering, channel range loop, channel iteration, channel blocking, channel buffering, channel range loop,"}
{"seed": "// ListRolesPath computes a request path to the list action of roles.\nfunc ListRolesPath() string {\n\n\treturn fmt.Sprintf(\"/api/roles\")\n}", "id": 18441, "concepts": ["string formatting", "fmt package usage"], "_raw_llm_output": "string formatting, fmt package usage"}
{"seed": "// WithRequestEditorFn allows setting up a callback function, which will be\n// called right before sending the request. This can be used to mutate the request.\nfunc WithRequestEditorFn(fn RequestEditorFn) ClientOption {\n\treturn func(c *Client) error {\n\t\tc.RequestEditor = fn\n\t\treturn nil\n\t}\n}", "id": 18447, "concepts": ["function definition", "function composition", "function option", "function composition"], "_raw_llm_output": "function definition, function composition, function option, function composition"}
{"seed": "// MaskDigits masks all digits (replaces them with .)\nfunc MaskDigits(input string) string {\n\ts := []byte(input)\n\tfor i, b := range s {\n\t\tif '0' <= b && b <= '9' {\n\t\t\ts[i] = '.'\n\t\t}\n\t}\n\treturn string(s)\n}", "id": 18450, "concepts": ["string manipulation", "byte handling"], "_raw_llm_output": "string manipulation, byte handling"}
{"seed": "// AssertNCNoHandleDownlinkMetaDataRequest asserts that no meta-data request was sent.\nfunc AssertNCNoHandleDownlinkMetaDataRequest() Assertion {\n\treturn func(assert *require.Assertions, ts *IntegrationTestSuite) {\n\t\ttime.Sleep(100 * time.Millisecond)\n\t\tselect {\n\t\tcase <-ts.NCClient.HandleDownlinkMetaDataChan:\n\t\t\tassert.Fail(\"unexpected downlink meta-data request\")\n\t\tdefault:\n\t\t}\n\t}\n}", "id": 18481, "concepts": ["assertion", "channel", "select statement", "sleep", "time.Sleep"], "_raw_llm_output": "assertion, channel, select statement, sleep, time.Sleep"}
{"seed": "// FirewallRuleGroupStatus_Values returns all elements of the FirewallRuleGroupStatus enum\nfunc FirewallRuleGroupStatus_Values() []string {\n\treturn []string{\n\t\tFirewallRuleGroupStatusComplete,\n\t\tFirewallRuleGroupStatusDeleting,\n\t\tFirewallRuleGroupStatusUpdating,\n\t}\n}", "id": 18483, "concepts": ["enum", "string formatting", "standard library usage"], "_raw_llm_output": "enum, string formatting, standard library usage"}
{"seed": "// NewIamServiceProviderAllOfWithDefaults instantiates a new IamServiceProviderAllOf object\n// This constructor will only assign default values to properties that have it defined,\n// but it doesn't guarantee that properties required by API are set\nfunc NewIamServiceProviderAllOfWithDefaults() *IamServiceProviderAllOf {\n\tthis := IamServiceProviderAllOf{}\n\tvar classId string = \"iam.ServiceProvider\"\n\tthis.ClassId = classId\n\tvar objectType string = \"iam.ServiceProvider\"\n\tthis.ObjectType = objectType\n\treturn &this\n}", "id": 18492, "concepts": ["constructor", "default value assignment", "basic function definition"], "_raw_llm_output": "constructor, default value assignment, basic function definition"}
{"seed": "// processNamePrometheus returns the name of the current binary (e.g. \"frontend\", \"gitserver\", \"github_proxy\"), with some\n// additional normalization so that it can be used as a Prometheus namespace.\nfunc processNamePrometheus() string {\n\tbase := env.MyName\n\tbase = strings.ReplaceAll(base, \"-\", \"_\")\n\tbase = strings.ReplaceAll(base, \".\", \"_\")\n\n\treturn base\n}", "id": 18493, "concepts": ["string manipulation", "string replacement", "string normalization", "environment variable usage"], "_raw_llm_output": "string manipulation, string replacement, string normalization, environment variable usage"}
{"seed": "// StringFromImmutableBytes is equivalent to string(bs), except that it uses\n// the same memory backing bs instead of making a heap-allocated copy. This is\n// only valid if bs is never mutated after StringFromImmutableBytes returns.\nfunc StringFromImmutableBytes(bs []byte) string {\n\tif len(bs) == 0 {\n\t\treturn \"\"\n\t}\n\treturn unsafe.String(&bs[0], len(bs))\n}", "id": 18496, "concepts": ["unsafe package usage", "string conversion", "byte slice manipulation"], "_raw_llm_output": "unsafe package usage, string conversion, byte slice manipulation"}
{"seed": "// TransfertobankaccountEQ applies the EQ predicate on the \"transfertobankaccount\" field.\nfunc TransfertobankaccountEQ(v float64) predicate.Bulk {\n\treturn predicate.Bulk(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldTransfertobankaccount), v))\n\t})\n}", "id": 18508, "concepts": ["sql.Selector", "sql.EQ", "predicate.Bulk"], "_raw_llm_output": "sql.Selector, sql.EQ, predicate.Bulk"}
{"seed": "// WithResync prepares context for transaction that, based on the resync type,\n// will trigger resync between the configuration states of NB, the agent and SB.\n// For DownstreamResync the transaction should be empty, otherwise it should\n// carry non-NIL values - existing NB values not included in the transaction\n// are automatically removed.\n// When <verboseSBRefresh> is enabled, the refreshed state of SB will be printed\n// into stdout. The argument is irrelevant for UpstreamResync, where SB state is\n// not refreshed.\nfunc WithResync(ctx context.Context, resyncType ResyncType, verboseSBRefresh bool) context.Context {\n\treturn context.WithValue(ctx, resyncCtxKey, &resyncOpt{\n\t\tresyncType:       resyncType,\n\t\tverboseSBRefresh: verboseSBRefresh,\n\t})\n}", "id": 18515, "concepts": ["context", "context.WithValue", "context.Context", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", "context.Context interface", ""], "_raw_llm_output": "context, context.WithValue, context.Context, context.Context interface,\ncontext.Context interface, context.Context interface, context.Context interface,\ncontext.Context interface, context.Context interface, context.Context interface,\ncontext.Context interface, context.Context interface, context.Context interface,\ncontext.Context interface, context.Context interface, context.Context interface,\ncontext.Context interface, context.Context interface, context.Context interface,\ncontext.Context interface, context.Context interface, context.Context interface,\ncontext.Context interface, context.Context interface, context.Context interface,\ncontext.Context interface, context.Context interface, context.Context interface,\ncontext.Context interface, context.Context interface, context.Context interface,\ncontext.Context interface, context.Context interface, context.Context interface,\ncontext.Context interface, context.Context interface, context.Context interface,\ncontext.Context interface, context.Context interface, context.Context interface,\ncontext.Context interface, context.Context interface, context.Context interface,\ncontext.Context interface, context.Context interface, context.Context interface,\ncontext.Context interface, context.Context interface, context.Context interface,"}
{"seed": "// Caption represents the HTML element 'caption'.\n// For more information visit https://www.w3schools.com/tags/tag_caption.asp.\nfunc Caption(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"caption\", Attributes: attrs, Children: children}\n}", "id": 18537, "concepts": ["HTML generation", "HTML element definition", "HTML attribute definition", "HTML element children definition"], "_raw_llm_output": "HTML generation, HTML element definition, HTML attribute definition, HTML element children definition"}
{"seed": "// NewPayRatesGetParamsWithTimeout creates a new PayRatesGetParams object\n// with the default values initialized, and the ability to set a timeout on a request\nfunc NewPayRatesGetParamsWithTimeout(timeout time.Duration) *PayRatesGetParams {\n\tvar ()\n\treturn &PayRatesGetParams{\n\n\t\ttimeout: timeout,\n\t}\n}", "id": 18549, "concepts": ["timeout handling", "time package usage", "function definition", "struct definition"], "_raw_llm_output": "timeout handling, time package usage, function definition, struct definition"}
{"seed": "// RequireTrustDomainFromString is similar to TrustDomainFromString except that\n// instead of returning an error on malformed input, it panics. It should only\n// be used when the input is statically verifiable.\nfunc RequireTrustDomainFromString(s string) TrustDomain {\n\ttd, err := TrustDomainFromString(s)\n\tpanicOnErr(err)\n\treturn td\n}", "id": 18564, "concepts": ["panic", "error handling", "TrustDomainFromString"], "_raw_llm_output": "panic, error handling, TrustDomainFromString"}
{"seed": "// IsUintKind reports whether k is an unsigned integer kind of any size.\nfunc IsUintKind(k reflect.Kind) bool {\n\tswitch k {\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\treturn true\n\t}\n\treturn false\n}", "id": 18566, "concepts": ["reflect package usage", "type comparison"], "_raw_llm_output": "reflect package usage, type comparison"}
{"seed": "// Th_ is a convenience wrapper for Th without the attrs argument.\nfunc Th_(children ...HTML) HTML {\n  return Th(nil, children...)\n}", "id": 18573, "concepts": ["function definition", "function argument", "function return value", "function call", "function call with arguments", "function call with variadic arguments"], "_raw_llm_output": "function definition, function argument, function return value, function call, function call with arguments, function call with variadic arguments"}
{"seed": "// NewResolver creates a New Resolver.\n//\n// If the input slice is empty, this returns nil\n// The given FileDescriptorProtos must be self-contained, that is they must contain all imports.\n// This can NOT be guaranteed for FileDescriptorSets given over the wire, and can only be guaranteed from builds.\nfunc NewResolver(fileDescriptorProtos ...*descriptorpb.FileDescriptorProto) (Resolver, error) {\n\treturn newResolver(fileDescriptorProtos...)\n}", "id": 18577, "concepts": ["package definition", "function definition", "error handling", "standard library usage"], "_raw_llm_output": "package definition, function definition, error handling, standard library usage"}
{"seed": "// S224 returns a Curve which implements secp224k1 (see SEC 2 section 2.6.1)\nfunc S224() *Curve {\n\tinitonce.Do(initAll)\n\treturn secp224k1\n}", "id": 18584, "concepts": ["struct definition", "pointer usage", "initialization", "mutex usage"], "_raw_llm_output": "struct definition, pointer usage, initialization, mutex usage"}
{"seed": "/*\n\tUsing Brute Force : For every element check for another element if it exist in the array such that sum of\n\t\t\t\t\t\tboth the element is equals to the target\n\tTime Complexity   : O(n^2)\n*/\nfunc twoSum(arr []int, target int) []int {\n\tfor i := 0; i < len(arr); i++ {\n\t\tfor j := i + 1; j < len(arr); j++ {\n\t\t\tif arr[i]+arr[j] == target {\n\t\t\t\treturn []int{i, j}\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}", "id": 18597, "concepts": ["array iteration (range loop)", "array element access", "integer summation", "basic function definition"], "_raw_llm_output": "array iteration (range loop), array element access, integer summation, basic function definition"}
{"seed": "// NewNotebookNotebooksResponseWithDefaults instantiates a new NotebookNotebooksResponse object\n// This constructor will only assign default values to properties that have it defined,\n// but it doesn't guarantee that properties required by API are set\nfunc NewNotebookNotebooksResponseWithDefaults() *NotebookNotebooksResponse {\n\tthis := NotebookNotebooksResponse{}\n\treturn &this\n}", "id": 18600, "concepts": ["constructor", "default value assignment", "object instantiation"], "_raw_llm_output": "constructor, default value assignment, object instantiation"}
{"seed": "// search implements the same algorithm as sort.Search().\n//\n// It was extracted to to not depend on sort, which depends on reflect.\nfunc search(n int, f func(int) bool) int {\n\tlo := 0\n\tfor hi := n; lo < hi; {\n\t\tif i := int(uint(lo+hi) >> 1); !f(i) {\n\t\t\tlo = i + 1\n\t\t} else {\n\t\t\thi = i\n\t\t}\n\t}\n\treturn lo\n}", "id": 18608, "concepts": ["integer comparison", "integer division", "bitwise operations", "function definition", "function call"], "_raw_llm_output": "integer comparison, integer division, bitwise operations, function definition, function call"}
{"seed": "// OkNodeVisitor specifies a visitor function to perform some test at each node\n// and return a boolean result.\n//\n// As long as v return a result of true, the search progresses to traverse all\n// nodes.\n//\n// If v returns false, the search terminates immediately.\n//\n// See also NodeVisitor.\nfunc OkNodeVisitor(v graph.OkNodeVisitor) func(*config) {\n\treturn func(c *config) {\n\t\tc.okNodeVisitor = v\n\t}\n}", "id": 18609, "concepts": ["function composition", "function composition", "function composition"], "_raw_llm_output": "function composition, function composition, function composition"}
{"seed": "// Begin starts a chain, reading the files located in the source directory as input.\nfunc Begin(sourceDir string) *Goldsmith {\n\tgoldsmith := &Goldsmith{\n\t\tsourceDir:     sourceDir,\n\t\tcontextHasher: crc32.NewIEEE(),\n\t\tfileRefs:      make(map[string]bool),\n\t}\n\n\tgoldsmith.Chain(new(loader))\n\treturn goldsmith\n}", "id": 18613, "concepts": ["chain of responsibility", "file reading", "CRC32 checksum", "map usage"], "_raw_llm_output": "chain of responsibility, file reading, CRC32 checksum, map usage"}
{"seed": "// ArrayValue returns a Value holding the given arg.\nfunc ArrayValue(a []Value) Value {\n\treturn Value{iface: a}\n}", "id": 18620, "concepts": ["struct definition", "interface definition", "slice definition", "basic function definition"], "_raw_llm_output": "struct definition, interface definition, slice definition, basic function definition"}
{"seed": "//extractIP returns client IP address parsed from HTTP request (headers, remoteAddr)\nfunc extractIP(c *gin.Context) string {\n\tip := c.Request.Header.Get(\"X-Real-IP\")\n\tif ip == \"\" {\n\t\tip = c.Request.Header.Get(\"X-Forwarded-For\")\n\t}\n\tif ip == \"\" {\n\t\tremoteAddr := c.Request.RemoteAddr\n\t\tif remoteAddr != \"\" {\n\t\t\taddrPort := strings.Split(remoteAddr, \":\")\n\t\t\tip = addrPort[0]\n\t\t}\n\t}\n\n\t//Case when Nginx concatenate remote_addr to client addr\n\tif strings.Contains(ip, \",\") {\n\t\taddresses := strings.Split(ip, \",\")\n\t\treturn strings.TrimSpace(addresses[0])\n\t}\n\n\treturn ip\n}", "id": 18631, "concepts": ["string manipulation", "string splitting", "string trimming", "string search", "string concatenation", "string comparison", "string formatting", "string length", "string index", "string slice", "string iteration", "string regex", "string regular expression", "string regular expression matching", "string regular expression search", "string regular expression replace", "string regular expression split", "string regular expression capture group", "string regular expression group", "string regular expression named group", "string regular expression named capture group", "string regular expression named capture group matching", "string regular expression named capture group search", "string regular expression named capture group replace", "string regular expression named capture group split", "string regular expression named capture group capture", "string regular expression named capture group iteration", "string regular expression named capture group iteration", "string regular expression named capture group iteration", "string regular expression named capture group iteration", "string regular expression named capture group iteration", "string regular expression named capture group iteration", "string regular expression named capture group iteration", "string regular expression named capture group iteration", "string regular expression named capture group iteration", "string regular expression named capture group iteration", "string regular expression named capture group iteration", "string regular expression named capture group iteration", "string regular expression named capture group iteration", "string regular expression named capture group iteration", "string regular expression named capture group iteration", "string regular expression named capture group iteration", ""], "_raw_llm_output": "string manipulation, string splitting, string trimming, string search, string concatenation, string comparison, string formatting, string length, string index, string slice, string iteration, string regex, string regular expression, string regular expression matching, string regular expression search, string regular expression replace, string regular expression split, string regular expression capture group, string regular expression group, string regular expression named group, string regular expression named capture group, string regular expression named capture group matching, string regular expression named capture group search, string regular expression named capture group replace, string regular expression named capture group split, string regular expression named capture group capture, string regular expression named capture group iteration, string regular expression named capture group iteration, string regular expression named capture group iteration, string regular expression named capture group iteration, string regular expression named capture group iteration, string regular expression named capture group iteration, string regular expression named capture group iteration, string regular expression named capture group iteration, string regular expression named capture group iteration, string regular expression named capture group iteration, string regular expression named capture group iteration, string regular expression named capture group iteration, string regular expression named capture group iteration, string regular expression named capture group iteration, string regular expression named capture group iteration, string regular expression named capture group iteration,"}
{"seed": "// NewNetworkLicenseFileWithDefaults instantiates a new NetworkLicenseFile object\n// This constructor will only assign default values to properties that have it defined,\n// but it doesn't guarantee that properties required by API are set\nfunc NewNetworkLicenseFileWithDefaults() *NetworkLicenseFile {\n\tthis := NetworkLicenseFile{}\n\tvar classId string = \"network.LicenseFile\"\n\tthis.ClassId = classId\n\tvar objectType string = \"network.LicenseFile\"\n\tthis.ObjectType = objectType\n\treturn &this\n}", "id": 18652, "concepts": ["struct definition", "struct initialization", "struct field assignment"], "_raw_llm_output": "struct definition, struct initialization, struct field assignment"}
{"seed": "// NewValidateCreateServiceRequestNamingParams creates a new ValidateCreateServiceRequestNamingParams object\n// with the default values initialized.\nfunc NewValidateCreateServiceRequestNamingParams() *ValidateCreateServiceRequestNamingParams {\n\tvar ()\n\treturn &ValidateCreateServiceRequestNamingParams{\n\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 18658, "concepts": ["struct initialization", "default values", "pointer dereferencing"], "_raw_llm_output": "struct initialization, default values, pointer dereferencing"}
{"seed": "// Investigate recursively walks into a directory analyzing all of its\n// children and generating Media structures for files whose format is\n// known to Shaerlock.\nfunc Investigate(root string) ([]Media, error) {\n\tvar medias []Media\n\terr := filepath.Walk(root, func(path string, info os.FileInfo, fileErr error) error {\n\t\tif fileErr != nil {\n\t\t\treturn nil\n\t\t}\n\t\tif info.IsDir() {\n\t\t\treturn nil\n\t\t}\n\t\tmedia, err := ExamineFile(path)\n\t\tif err == nil {\n\t\t\tmedias = append(medias, media)\n\t\t}\n\t\treturn nil\n\t})\n\treturn medias, err\n}", "id": 18671, "concepts": ["filepath.Walk", "filepath.WalkFunc", "error handling", "filepath.WalkFunc", "error handling", "filepath.WalkFunc", "error handling", "filepath.WalkFunc", "error handling"], "_raw_llm_output": "filepath.Walk, filepath.WalkFunc, error handling, filepath.WalkFunc, error handling, filepath.WalkFunc, error handling, filepath.WalkFunc, error handling"}
{"seed": "// WithSeniority allows to get only email addresses for people with the selected seniority level.\n// The possible values are junior, senior or executive.\n// Several seniority levels can be selected (delimited by a comma).\n// Please pass exported const for this method as an arguments.\nfunc WithSeniority(levels ...seniorityLevel) requestOptionalParam {\n\treturn func(params requestOptionalParams) {\n\t\tif len(levels) <= 0 {\n\t\t\treturn\n\t\t}\n\n\t\tvar lvls string\n\n\t\tfor i := range levels {\n\t\t\tif i == len(levels)-1 {\n\t\t\t\tlvls += string(levels[i])\n\t\t\t} else {\n\t\t\t\tlvls += string(levels[i] + \";\")\n\t\t\t}\n\t\t}\n\n\t\tparams.Add(paramSeniority, lvls)\n\t}\n}", "id": 18673, "concepts": ["function composition", "variadic function", "function as value", "function as argument"], "_raw_llm_output": "function composition, variadic function, function as value, function as argument"}
{"seed": "// NewGetCwfNetworkIDGatewaysGatewayIDParams creates a new GetCwfNetworkIDGatewaysGatewayIDParams object\n// with the default values initialized.\nfunc NewGetCwfNetworkIDGatewaysGatewayIDParams() *GetCwfNetworkIDGatewaysGatewayIDParams {\n\tvar ()\n\treturn &GetCwfNetworkIDGatewaysGatewayIDParams{\n\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 18691, "concepts": ["struct initialization", "pointer handling"], "_raw_llm_output": "struct initialization, pointer handling"}
{"seed": "// NicknameNotIn applies the NotIn predicate on the \"nickname\" field.\nfunc NicknameNotIn(vs ...string) predicate.User {\n\treturn predicate.User(sql.FieldNotIn(FieldNickname, vs...))\n}", "id": 18697, "concepts": ["sql.FieldNotIn", "sql.FieldIn", "sql.FieldEq", "sql.FieldLike", "sql.FieldGt", "sql.FieldLt", "sql.FieldGte", "sql.FieldLte", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldIsNull", "sql.FieldIsNotNull", "sql.FieldBetween", "sql.FieldNotBetween", "sql.FieldIs", "sql.FieldIsNot", "sql.FieldContains", "sql.FieldNotContains", "sql.FieldStartsWith", "sql.FieldNotStartsWith", "sql.FieldEndsWith", "sql.FieldNotEndsWith", "sql.FieldRegexp", "sql.FieldNotRegexp", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldIs", "sql.FieldIsNot", "sql.FieldContains", "sql.FieldNotContains", "sql.FieldStartsWith", "sql.FieldNotStartsWith", "sql.FieldEndsWith", "sql.FieldNotEndsWith", "sql.FieldRegexp", "sql.FieldNotRegexp", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldIs", "sql.FieldIsNot", "sql.FieldContains", "sql.FieldNotContains", "sql.FieldStartsWith", "sql.FieldNotStartsWith", "sql.FieldEndsWith", "sql.FieldNotEndsWith", "sql.FieldRegexp", "sql.FieldNotRegexp", ""], "_raw_llm_output": "sql.FieldNotIn, sql.FieldIn, sql.FieldEq, sql.FieldLike, sql.FieldGt, sql.FieldLt, sql.FieldGte, sql.FieldLte, sql.FieldIn, sql.FieldNotIn, sql.FieldIsNull, sql.FieldIsNotNull, sql.FieldBetween, sql.FieldNotBetween, sql.FieldIs, sql.FieldIsNot, sql.FieldContains, sql.FieldNotContains, sql.FieldStartsWith, sql.FieldNotStartsWith, sql.FieldEndsWith, sql.FieldNotEndsWith, sql.FieldRegexp, sql.FieldNotRegexp, sql.FieldIn, sql.FieldNotIn, sql.FieldIs, sql.FieldIsNot, sql.FieldContains, sql.FieldNotContains, sql.FieldStartsWith, sql.FieldNotStartsWith, sql.FieldEndsWith, sql.FieldNotEndsWith, sql.FieldRegexp, sql.FieldNotRegexp, sql.FieldIn, sql.FieldNotIn, sql.FieldIs, sql.FieldIsNot, sql.FieldContains, sql.FieldNotContains, sql.FieldStartsWith, sql.FieldNotStartsWith, sql.FieldEndsWith, sql.FieldNotEndsWith, sql.FieldRegexp, sql.FieldNotRegexp,"}
{"seed": "// converts \"IndexesFromClientTest\" => \"indexes_from_client\"\nfunc testNameToFileName(s string) string {\n\ts = strings.TrimSuffix(s, \"Test\")\n\tlower := strings.ToLower(s)\n\tvar res []byte\n\tn := len(s)\n\tfor i := 0; i < n; i++ {\n\t\tc := s[i]\n\t\tif i > 0 && isUpper(c) {\n\t\t\tres = append(res, '_')\n\t\t}\n\t\tres = append(res, lower[i])\n\t}\n\treturn string(res)\n}", "id": 18701, "concepts": ["string manipulation", "string conversion", "character comparison"], "_raw_llm_output": "string manipulation, string conversion, character comparison"}
{"seed": "// NewUpdateZoneProjectsUsingPUTParamsWithHTTPClient creates a new UpdateZoneProjectsUsingPUTParams object\n// with the ability to set a custom HTTPClient for a request.\nfunc NewUpdateZoneProjectsUsingPUTParamsWithHTTPClient(client *http.Client) *UpdateZoneProjectsUsingPUTParams {\n\treturn &UpdateZoneProjectsUsingPUTParams{\n\t\tHTTPClient: client,\n\t}\n}", "id": 18715, "concepts": ["http.Client usage"], "_raw_llm_output": "http.Client usage"}
{"seed": "// AllLevelSlice returns a LevelSlice containing all levels.\nfunc AllLevelSlice() LevelSlice {\n\treturn LevelSlice{\n\t\tERROR,\n\t\tWARNING,\n\t\tALERT,\n\t\tNOTICE,\n\t\tINFO,\n\t\tDEBUG,\n\t}\n}", "id": 18717, "concepts": ["slice definition", "basic function definition"], "_raw_llm_output": "slice definition, basic function definition"}
{"seed": "// DropOptionalContainsFold applies the ContainsFold predicate on the \"drop_optional\" field.\nfunc DropOptionalContainsFold(v string) predicate.User {\n\treturn predicate.User(sql.FieldContainsFold(FieldDropOptional, v))\n}", "id": 18738, "concepts": ["predicate composition", "predicate composition with predicate.User", "sql.FieldContainsFold"], "_raw_llm_output": "predicate composition, predicate composition with predicate.User, sql.FieldContainsFold"}
{"seed": "// StringEnsureSuffix returns a string, which is the original string\n// if it has the suffix, or the suffix will be appended.\nfunc StringEnsureSuffix(s string, cut string) string {\n\tif strings.HasSuffix(s, cut) {\n\t\treturn s\n\t}\n\treturn s + cut\n}", "id": 18739, "concepts": ["string manipulation", "string comparison", "string concatenation"], "_raw_llm_output": "string manipulation, string comparison, string concatenation"}
{"seed": "// FilteredFileServer is similar to the standard librarie's http.FileServer\n// but the handler it returns will refuse to serve any files which don't\n// match the specified regexp pattern after running through path.Clean().\n// The idea is to make it easy to serve only specific kinds of\n// static files from a directory.  If pattern does not match a 404 will be returned.\n// Be sure to include a trailing \"$\" if you are checking for file extensions, so it\n// only matches the end of the path, e.g. \"[.](css|js)$\"\nfunc FilteredFileServer(pattern *regexp.Regexp, fs http.FileSystem) http.Handler {\n\n\tif pattern == nil {\n\t\tpanic(fmt.Errorf(\"pattern is nil\"))\n\t}\n\n\tif fs == nil {\n\t\tpanic(fmt.Errorf(\"fs is nil\"))\n\t}\n\n\tfserver := http.FileServer(fs)\n\n\tret := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\n\t\tp := path.Clean(\"/\" + r.URL.Path)\n\n\t\tif !strings.HasPrefix(p, \"/\") { // should never happen after Clean above, but just being extra cautious\n\t\t\thttp.NotFound(w, r)\n\t\t\treturn\n\t\t}\n\n\t\tif !pattern.MatchString(p) {\n\t\t\thttp.NotFound(w, r)\n\t\t\treturn\n\t\t}\n\n\t\t// delegate to the regular file-serving behavior\n\t\tfserver.ServeHTTP(w, r)\n\n\t})\n\n\treturn ret\n}", "id": 18741, "concepts": ["http.FileServer", "http.HandlerFunc", "regexp", "path.Clean", "path.MatchString", "http.NotFound"], "_raw_llm_output": "http.FileServer, http.HandlerFunc, regexp, path.Clean, path.MatchString, http.NotFound"}
{"seed": "// NewGetServerStatusParams creates a new GetServerStatusParams object\n// with the default values initialized.\nfunc NewGetServerStatusParams() *GetServerStatusParams {\n\n\treturn &GetServerStatusParams{\n\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 18752, "concepts": ["struct definition", "struct initialization", "method definition", "method invocation"], "_raw_llm_output": "struct definition, struct initialization, method definition, method invocation"}
{"seed": "// ignoreWebSocketReaders ignores all incoming WS messages on conn.\n// This is required by the underlying library if we don't care about sent messages.\n//\n// This implementation was borrowed from gorilla's docs:\n// https://godoc.org/github.com/gorilla/websocket#hdr-Control_Messages\nfunc ignoreWebSocketReaders(conn *websocket.Conn) {\n\tfor {\n\t\tif _, _, err := conn.NextReader(); err != nil {\n\t\t\tconn.Close()\n\t\t\treturn\n\t\t}\n\t}\n}", "id": 18760, "concepts": ["websocket package usage", "gorilla/websocket library usage"], "_raw_llm_output": "websocket package usage, gorilla/websocket library usage"}
{"seed": "// MixedStringEQ applies the EQ predicate on the \"mixed_string\" field.\nfunc MixedStringEQ(v string) predicate.User {\n\treturn predicate.User(sql.FieldEQ(FieldMixedString, v))\n}", "id": 18765, "concepts": ["sql.FieldEQ", "predicate.User", "sql package usage"], "_raw_llm_output": "sql.FieldEQ, predicate.User, sql package usage"}
{"seed": "// ParseDuration parses an duration string in the format of hh:mm:ss\nfunc ParseDuration(dur string) time.Duration {\n\tparts := strings.Split(dur, \":\")\n\n\tif len(parts) != 3 {\n\t\treturn 0\n\t}\n\n\tvar d time.Duration\n\th, _ := strconv.ParseInt(parts[0], 10, 64)\n\td += time.Duration(h) * time.Hour\n\n\tm, _ := strconv.ParseFloat(parts[1], 64)\n\td += time.Duration(m) * time.Minute\n\n\ts, _ := strconv.ParseFloat(parts[2], 64)\n\td += time.Duration(s) * time.Second\n\n\treturn d\n}", "id": 18770, "concepts": ["string manipulation", "string to integer conversion", "string to float conversion", "string to duration conversion", "time.Duration usage"], "_raw_llm_output": "string manipulation, string to integer conversion, string to float conversion, string to duration conversion, time.Duration usage"}
{"seed": "// PhoneContains applies the Contains predicate on the \"phone\" field.\nfunc PhoneContains(v string) predicate.User {\n\treturn predicate.User(sql.FieldContains(FieldPhone, v))\n}", "id": 18785, "concepts": ["sql.FieldContains", "predicate.User", "sql.Field", "sql.FieldContains"], "_raw_llm_output": "sql.FieldContains, predicate.User, sql.Field, sql.FieldContains"}
{"seed": "// githubRepoDetect attempts to detect whether a given path is part of a git\n// repository that has a GitHub remote as the origin, and if so, returns the\n// owner and repo name.\n//\n// Errors returned are likely just be a simple \"not in git repo\" etc and should\n// be considered informational rather than fatal.\nfunc githubRepoDetect(path string) (owner, repo string, err error) {\n\tdefer timeTrack(time.Now(), \"githubRepoDetect()\")\n\tremoteURL, err := _detectRemoteURL_GoGit(path)\n\t// remoteURL, err := _detectRemoteURL_LocalGit(path)\n\tif err != nil {\n\t\treturn\n\t}\n\towner, repo, ok := parseGithubRemote(remoteURL)\n\tif !ok {\n\t\terr = errors.New(\"cannot pattern match remote url: \" + remoteURL)\n\t}\n\treturn\n}", "id": 18802, "concepts": ["error handling (defer)", "error handling (errors.New)", "error handling (errors.As)", "error handling (errors.Is)", "error handling (error wrapping)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error"], "_raw_llm_output": "error handling (defer), error handling (errors.New), error handling (errors.As), error handling (errors.Is), error handling (error wrapping), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error"}
{"seed": "// Fg256 256 colors for foreground\n//   0-7:      standard colors (Black, Red, Green, Yellow, Blue, Magenta, Cyan, White)\n//   8-15:     high intensity colors\n//   16-231:   16 + 36\u00d7r + 6\u00d7g + b (0 \u2264 r, g, b \u2264 5)\n//   232-255:  grayscale from black to white in 24 steps\n//   see: \"https://jonasjacek.github.io/colors\"\nfunc Fg256(num uint8) string {\n\treturn fmt.Sprintf(\"38;5;%d\", num)\n}", "id": 18805, "concepts": ["string formatting", "fmt package usage"], "_raw_llm_output": "string formatting, fmt package usage"}
{"seed": "// NewStringFromGoString create a new string and fills it with the go string.\nfunc NewStringFromGoString(value string) String {\n\tstr := NewString()\n\n\t// https://github.com/godotengine/godot/blob/ef5891091bceef2800b4fae4cd85af219e791467/core/ustring.h#L300\n\t// return true on error\n\tif str.ParseUtf8(value) {\n\t\tlog.Info(\"unable to parse utf-8\", StringField(\"value\", value))\n\t}\n\treturn str\n}", "id": 18808, "concepts": ["string manipulation", "string parsing", "string encoding", "string formatting", "string concatenation"], "_raw_llm_output": "string manipulation, string parsing, string encoding, string formatting, string concatenation"}
{"seed": "// HTTPToContext moves a JWT from request header to context. Particularly\n// useful for servers.\nfunc HTTPToContext() http.RequestFunc {\n\treturn func(ctx context.Context, r *stdhttp.Request) context.Context {\n\t\ttoken, ok := extractTokenFromAuthHeader(r.Header.Get(\"Authorization\"))\n\t\tif !ok {\n\t\t\treturn ctx\n\t\t}\n\n\t\treturn context.WithValue(ctx, JWTContextKey, token)\n\t}\n}", "id": 18818, "concepts": ["http.RequestFunc", "context.WithValue", "context.Context", "JWTContextKey", "http.Request.Header", "http.Request.Header.Get", "context.Context.WithValue", "context.Context.Value"], "_raw_llm_output": "http.RequestFunc, context.WithValue, context.Context, JWTContextKey, http.Request.Header, http.Request.Header.Get, context.Context.WithValue, context.Context.Value"}
{"seed": "// NewDefaultHTTPRetryConf constructs a HTTPRetryConfiguration object\n// with reasonable defaults.\nfunc NewDefaultHTTPRetryConf() HTTPRetryConfiguration {\n\treturn HTTPRetryConfiguration{\n\t\tMaxRetries:      50,\n\t\tTemporaryErrors: true,\n\t\tMaxDelay:        5 * time.Second,\n\t\tBaseDelay:       50 * time.Millisecond,\n\t\tMethods: []string{\n\t\t\thttp.MethodGet,\n\t\t\thttp.MethodPost,\n\t\t\thttp.MethodPut,\n\t\t\thttp.MethodDelete,\n\t\t\thttp.MethodPatch,\n\t\t},\n\t\tStatuses: []int{\n\t\t\thttp.StatusInternalServerError,\n\t\t\thttp.StatusBadGateway,\n\t\t\thttp.StatusServiceUnavailable,\n\t\t\thttp.StatusGatewayTimeout,\n\t\t\thttp.StatusInsufficientStorage,\n\t\t\thttp.StatusConflict,\n\t\t\thttp.StatusRequestTimeout,\n\t\t\thttp.StatusPreconditionFailed,\n\t\t\thttp.StatusExpectationFailed,\n\t\t},\n\t}\n}", "id": 18843, "concepts": ["struct definition", "function definition", "function return value", "function parameter", "function call", "type conversion", "basic control flow", "standard library usage"], "_raw_llm_output": "struct definition, function definition, function return value, function parameter, function call, type conversion, basic control flow, standard library usage"}
{"seed": "// GetLeaderboard get the leaderboard for a specific entity type and statistic.\n// https://api.playfab.com/Documentation/Leaderboards/method/GetLeaderboard\nfunc GetLeaderboard(settings *playfab.Settings, postData *GetEntityLeaderboardRequestModel, entityToken string) (*GetEntityLeaderboardResponseModel, error) {\n    if entityToken == \"\" {\n        return nil, playfab.NewCustomError(\"entityToken should not be an empty string\", playfab.ErrorGeneric)\n    }\n    b, errMarshal := json.Marshal(postData)\n    if errMarshal != nil {\n        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)\n    }\n\n    sourceMap, err := playfab.Request(settings, b, \"/Leaderboard/GetLeaderboard\", \"X-EntityToken\", entityToken)\n    if err != nil {\n        return nil, err\n    }\n    \n    result := &GetEntityLeaderboardResponseModel{}\n\n    config := mapstructure.DecoderConfig{\n        DecodeHook: playfab.StringToDateTimeHook,\n        Result:     result,\n    }\n    \n    decoder, errDecoding := mapstructure.NewDecoder(&config)\n    if errDecoding != nil {\n        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)\n    }\n   \n    errDecoding = decoder.Decode(sourceMap)\n    if errDecoding != nil {\n        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)\n    }\n\n    return result, nil\n}", "id": 18845, "concepts": ["PlayFab API usage", "error handling (idiomatic `if err != nil`", "`errors.Is`", "`errors.As`)", "types (structs", "interfaces", "slices", "maps)", "common Go idioms (like `defer`)", "pointers", "and control flow."], "_raw_llm_output": "PlayFab API usage, error handling (idiomatic `if err != nil`, `errors.Is`, `errors.As`), types (structs, interfaces, slices, maps), common Go idioms (like `defer`), pointers, and control flow."}
{"seed": "// NewCreateDNSZoneRequestWithBody generates requests for CreateDNSZone with any type of body\nfunc NewCreateDNSZoneRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {\n\tvar err error\n\n\tqueryUrl, err := url.Parse(server)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbasePath := fmt.Sprintf(\"/domain/v2alpha2/dns-zones\")\n\tif basePath[0] == '/' {\n\t\tbasePath = basePath[1:]\n\t}\n\n\tqueryUrl, err = queryUrl.Parse(basePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq, err := http.NewRequest(\"POST\", queryUrl.String(), body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Add(\"Content-Type\", contentType)\n\treturn req, nil\n}", "id": 18849, "concepts": ["url parsing", "http.NewRequest", "io.Reader", "io.Writer", "url.URL", "url.Parse", "url.ParseRequestURI", "url.Request", "url.Values", "url.PathEscape", "url.QueryEscape", "url.User", "url.UserPassword", "url.UserPassword", "url.UserPassword", "url.UserPassword", "url.UserPassword", "url.UserPassword", "url.UserPassword", "url.UserPassword", "url.UserPassword", "url.UserPassword", "url.UserPassword", "url.UserPassword", "url.UserPassword", "url.UserPassword", "url.UserPassword", "url.UserPassword", "url.UserPassword", "url.UserPassword", "url.UserPassword", "url.UserPassword", "url.UserPassword", "url.UserPassword", "url.UserPassword", "url.UserPassword", "url.UserPassword", "url.UserPassword", "url.UserPassword", "url.UserPassword", "url.UserPassword", "url.UserPassword", "url.UserPassword", "url.UserPassword", "url.UserPassword", "url.UserPassword", "url.UserPassword", "url.UserPassword", "url.UserPassword", "url.UserPassword", "url.UserPassword", "url.UserPassword", "url.UserPassword"], "_raw_llm_output": "url parsing, http.NewRequest, io.Reader, io.Writer, url.URL, url.Parse, url.ParseRequestURI, url.Request, url.Values, url.PathEscape, url.QueryEscape, url.User, url.UserPassword, url.UserPassword, url.UserPassword, url.UserPassword, url.UserPassword, url.UserPassword, url.UserPassword, url.UserPassword, url.UserPassword, url.UserPassword, url.UserPassword, url.UserPassword, url.UserPassword, url.UserPassword, url.UserPassword, url.UserPassword, url.UserPassword, url.UserPassword, url.UserPassword, url.UserPassword, url.UserPassword, url.UserPassword, url.UserPassword, url.UserPassword, url.UserPassword, url.UserPassword, url.UserPassword, url.UserPassword, url.UserPassword, url.UserPassword, url.UserPassword, url.UserPassword, url.UserPassword, url.UserPassword, url.UserPassword, url.UserPassword, url.UserPassword, url.UserPassword, url.UserPassword, url.UserPassword, url.UserPassword"}
{"seed": "// Start creates a new log wrapped StreamClient for recording output from the\n// client to an io.Writer. The caller is responsible for calling Close() on the\n// Wrapper to properly shutdown the wrapper.\nfunc Start(ctx context.Context, sc ondatra.StreamClient, o io.Writer) *IOWrappedClient {\n\tif err := sc.Stdin().Close(); err != nil {\n\t\tlog.Warningf(\"clientwrapper failed to close stdin: %v\", err)\n\t}\n\tc := &IOWrappedClient{\n\t\tsc:  sc,\n\t\tout: o,\n\t}\n\tc.start(ctx)\n\treturn c\n}", "id": 18855, "concepts": ["io.Writer", "context.Context", "io.Closer", "io.Reader", "io.ReadCloser", "io.ReadWriter", "io.ReadWriteCloser", "io.ReadWriteSeeker", "io.Seeker", "io.SeekerAt", "io.SeekerFrom", "io.WriterTo", "io.WriterAt", "io.WriterSeeker", "io.WriterToReader", "io.WriterToWriter", "io.WriterToWriterAt", "io.ReadFrom", "io.ReadFromReader", "io.ReadFromWriter", "io.ReadFromWriterAt", "io.ReaderFrom", "io.ReaderFromReader", "io.ReaderFromWriter", "io.ReaderFromWriterAt", "io.SeekerAt", "io.SeekerFrom", "io.Seeker", "io.SeekerAt", "io.SeekerFrom", "io.Writer", "io.WriterAt", "io.WriterSeeker", "io.WriterTo", "io.WriterToReader", "io.WriterToWriter", "io.WriterToWriterAt", "io.ReadWriter", "io.ReadWriterAt", "io.ReadWriterSeeker", "io.ReadWriterTo", "io.ReadWriterToReader", "io.ReadWriterToWriter", "io.ReadWriterToWriterAt", "io.ReadFrom"], "_raw_llm_output": "io.Writer, context.Context, io.Closer, io.Reader, io.ReadCloser, io.ReadWriter, io.ReadWriteCloser, io.ReadWriteSeeker, io.Seeker, io.SeekerAt, io.SeekerFrom, io.WriterTo, io.WriterAt, io.WriterSeeker, io.WriterToReader, io.WriterToWriter, io.WriterToWriterAt, io.ReadFrom, io.ReadFromReader, io.ReadFromWriter, io.ReadFromWriterAt, io.ReaderFrom, io.ReaderFromReader, io.ReaderFromWriter, io.ReaderFromWriterAt, io.SeekerAt, io.SeekerFrom, io.Seeker, io.SeekerAt, io.SeekerFrom, io.Writer, io.WriterAt, io.WriterSeeker, io.WriterTo, io.WriterToReader, io.WriterToWriter, io.WriterToWriterAt, io.ReadWriter, io.ReadWriterAt, io.ReadWriterSeeker, io.ReadWriterTo, io.ReadWriterToReader, io.ReadWriterToWriter, io.ReadWriterToWriterAt, io.ReadFrom"}
{"seed": "// InIPNet \u662f\u5426\u5305\u542b\u5728\u6307\u5b9a IPNet \u5217\u8868\u4e2d\nfunc InIPNet(ip net.IP, ipNets map[*net.IPNet]struct{}) bool {\n\tfor ipNet := range ipNets {\n\t\tif ipNet.Contains(ip) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}", "id": 18868, "concepts": ["map iteration", "map lookup", "struct definition", "pointer usage"], "_raw_llm_output": "map iteration, map lookup, struct definition, pointer usage"}
{"seed": "// Register creates an open file table entry for \"qi\" (or incrementes the\n// reference count if the entry already exists) and returns the entry.\nfunc Register(qi inomap.QIno) *Entry {\n\tt.Lock()\n\tdefer t.Unlock()\n\n\te := t.entries[qi]\n\tif e == nil {\n\t\te = &Entry{}\n\t\tt.entries[qi] = e\n\t}\n\te.refCount++\n\treturn e\n}", "id": 18880, "concepts": ["map iteration", "mutexes", "struct fields", "pointer dereference"], "_raw_llm_output": "map iteration, mutexes, struct fields, pointer dereference"}
{"seed": "//elvdoc:fn resolve\n//\n// ```elvish\n// resolve $command\n// ```\n//\n// Output what `$command` resolves to in symbolic form. Command resolution is\n// described in the [language reference](language.html#ordinary-command).\n//\n// Example:\n//\n// ```elvish-transcript\n// ~> resolve echo\n// \u25b6 <builtin echo>\n// ~> fn f { }\n// ~> resolve f\n// \u25b6 <closure 0xc4201c24d0>\n// ~> resolve cat\n// \u25b6 <external cat>\n// ```\n\nfunc resolve(fm *Frame, head string) string {\n\tspecial, fnRef := resolveCmdHeadInternally(fm, head, nil)\n\tswitch {\n\tcase special != nil:\n\t\treturn \"special\"\n\tcase fnRef != nil:\n\t\treturn \"$\" + head + FnSuffix\n\tdefault:\n\t\treturn \"(external \" + parse.Quote(head) + \")\"\n\t}\n}", "id": 18883, "concepts": ["external command resolution", "function resolution", "closure", "external command", "external function", "special command", "special function", "function definition", "string interpolation", "string formatting", "string manipulation", "string quoting", "external command resolution", "external function resolution", "external command definition", "external function definition", "external command definition", "external function definition", "external command definition", "external function definition", "external command definition", "external function definition", "external command definition", "external function definition", "external command definition", "external function definition", "external command definition", "external function definition", "external command definition", "external function definition", "external command definition", "external function definition", "external command definition", "external function definition", "external command definition", "external function definition", "external command definition", "external function definition", "external command definition", "external function definition", "external command definition", "external function definition", "external command definition", "external function definition", "external command definition", "external function definition", "external command definition", "external function definition", "external command definition", "external function definition", "external command definition", "external function definition", "external command definition", "external function definition", "external command definition", "external function definition", "external command definition", "external function definition", "external command definition", "external function definition", "external command definition", "external function definition", "external command definition", "external function definition", "external command definition", "external function definition", "external command"], "_raw_llm_output": "external command resolution, function resolution, closure, external command, external function, special command, special function, function definition, string interpolation, string formatting, string manipulation, string quoting, external command resolution, external function resolution, external command definition, external function definition, external command definition, external function definition, external command definition, external function definition, external command definition, external function definition, external command definition, external function definition, external command definition, external function definition, external command definition, external function definition, external command definition, external function definition, external command definition, external function definition, external command definition, external function definition, external command definition, external function definition, external command definition, external function definition, external command definition, external function definition, external command definition, external function definition, external command definition, external function definition, external command definition, external function definition, external command definition, external function definition, external command definition, external function definition, external command definition, external function definition, external command definition, external function definition, external command definition, external function definition, external command definition, external function definition, external command definition, external function definition, external command definition, external function definition, external command definition, external function definition, external command definition, external function definition, external command"}
{"seed": "// stateDot is the state after reading the integer and decimal point in a number,\n// such as after reading `G1.`.\nfunc stateDot(s *scanner, c byte) int {\n\tif '0' <= c && c <= '9' {\n\t\ts.step = stateDot0\n\t\treturn scanContinue\n\t}\n\treturn s.error(c, \"after decimal point in numeric literal\")\n}", "id": 18899, "concepts": ["state machine", "state transition", "state machine usage"], "_raw_llm_output": "state machine, state transition, state machine usage"}
{"seed": "// ImmutableBytesFromString is equivalent to []byte(s), except that it uses the\n// same memory backing s instead of making a heap-allocated copy. This is only\n// valid if the returned slice is never mutated.\nfunc ImmutableBytesFromString(s string) []byte {\n\tb := unsafe.StringData(s)\n\treturn unsafe.Slice(b, len(s))\n}", "id": 18908, "concepts": ["unsafe package usage", "string to byte slice conversion"], "_raw_llm_output": "unsafe package usage, string to byte slice conversion"}
{"seed": "// RiskDetailPUserPerformedSecuredPasswordReset returns a pointer to RiskDetailVUserPerformedSecuredPasswordReset\nfunc RiskDetailPUserPerformedSecuredPasswordReset() *RiskDetail {\n\tv := RiskDetailVUserPerformedSecuredPasswordReset\n\treturn &v\n}", "id": 18911, "concepts": ["pointer", "pointer dereference", "struct definition", "struct initialization"], "_raw_llm_output": "pointer, pointer dereference, struct definition, struct initialization"}
{"seed": "// SocialEmailGT applies the GT predicate on the \"social_email\" field.\nfunc SocialEmailGT(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.GT(s.C(FieldSocialEmail), v))\n\t})\n}", "id": 18913, "concepts": ["sql package usage", "predicate definition", "sql.Selector usage"], "_raw_llm_output": "sql package usage, predicate definition, sql.Selector usage"}
{"seed": "// ApplicationSecurityGroupSpec_PrivateEndpoint_SubResourceEmbeddedGenerator returns a generator of ApplicationSecurityGroupSpec_PrivateEndpoint_SubResourceEmbedded instances for property testing.\nfunc ApplicationSecurityGroupSpec_PrivateEndpoint_SubResourceEmbeddedGenerator() gopter.Gen {\n\tif applicationSecurityGroupSpec_PrivateEndpoint_SubResourceEmbeddedGenerator != nil {\n\t\treturn applicationSecurityGroupSpec_PrivateEndpoint_SubResourceEmbeddedGenerator\n\t}\n\n\tgenerators := make(map[string]gopter.Gen)\n\tapplicationSecurityGroupSpec_PrivateEndpoint_SubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(ApplicationSecurityGroupSpec_PrivateEndpoint_SubResourceEmbedded{}), generators)\n\n\treturn applicationSecurityGroupSpec_PrivateEndpoint_SubResourceEmbeddedGenerator\n}", "id": 18916, "concepts": ["struct definition", "anonymous struct definition", "map definition", "generator definition", "property testing"], "_raw_llm_output": "struct definition, anonymous struct definition, map definition, generator definition, property testing"}
{"seed": "// NewEntryServiceDeleteParamsWithContext creates a new EntryServiceDeleteParams object\n// with the default values initialized, and the ability to set a context for a request\nfunc NewEntryServiceDeleteParamsWithContext(ctx context.Context) *EntryServiceDeleteParams {\n\tvar ()\n\treturn &EntryServiceDeleteParams{\n\n\t\tContext: ctx,\n\t}\n}", "id": 18929, "concepts": ["context package usage", "function definition", "context.Context"], "_raw_llm_output": "context package usage, function definition, context.Context"}
{"seed": "// checkAndSetDBRouteDefaults checks the database route and sets defaults for certificate generation.\nfunc checkAndSetDBRouteDefaults(r *tlsca.RouteToDatabase) error {\n\t// When generating certificate for MongoDB access, database username must\n\t// be encoded into it. This is required to be able to tell which database\n\t// user to authenticate the connection as Elasticsearch needs database username too.\n\tif r.Username == \"\" {\n\t\tswitch r.Protocol {\n\t\tcase defaults.ProtocolMongoDB, defaults.ProtocolElasticsearch, defaults.ProtocolOracle, defaults.ProtocolOpenSearch:\n\t\t\treturn trace.BadParameter(\"please provide the database user name using the --db-user flag\")\n\t\tcase defaults.ProtocolRedis:\n\t\t\t// Default to \"default\" in the same way as Redis does. We need the username to check access on our side.\n\t\t\t// ref: https://redis.io/commands/auth\n\t\t\tr.Username = defaults.DefaultRedisUsername\n\t\t}\n\t}\n\tif r.Database != \"\" {\n\t\tswitch r.Protocol {\n\t\tcase defaults.ProtocolDynamoDB:\n\t\t\tlog.Warnf(\"Database %v protocol %v does not support --db-name flag, ignoring --db-name=%v\",\n\t\t\t\tr.ServiceName, defaults.ReadableDatabaseProtocol(r.Protocol), r.Database)\n\t\t\tr.Database = \"\"\n\t\t}\n\t} else {\n\t\tswitch r.Protocol {\n\t\t// Always require db-name for Oracle Protocol.\n\t\tcase defaults.ProtocolOracle:\n\t\t\treturn trace.BadParameter(\"please provide the database name using the --db-name flag\")\n\t\t}\n\t}\n\treturn nil\n}", "id": 18930, "concepts": ["error handling (errors.Is)", "string comparison", "switch statement", "basic function definition"], "_raw_llm_output": "error handling (errors.Is), string comparison, switch statement, basic function definition"}
{"seed": "// NewInvitationProjector creates a new InvitationProjector.\nfunc NewInvitationProjector() *InvitationProjector {\n\treturn &InvitationProjector{}\n}", "id": 18932, "concepts": ["struct definition", "basic function definition"], "_raw_llm_output": "struct definition, basic function definition"}
{"seed": "// RecentTasksActivityLRStatusASC function sorts data by LastRunStatus field in ascending order\n// sorting layers: LRStatus > LRTime(DESC)  > Name(ASC)\n// function chain according to sorting layers: RecentTasksActivityLRStatusASC > subsortingByLRTimeDESC > subsortingByNameASC\nfunc RecentTasksActivityLRStatusASC(p1, p2 interface{}) bool {\n\tp1Status := getSortableLastRunStatus(p1.(RecentTasksActivity).LastRunStatus)\n\tp2Status := getSortableLastRunStatus(p2.(RecentTasksActivity).LastRunStatus)\n\n\tif p1Status == p2Status {\n\t\treturn subsortingByLRTimeDESC(p1, p2)\n\t}\n\n\treturn p1Status < p2Status\n}", "id": 18934, "concepts": ["interface", "sorting", "function chaining", "sorting by multiple fields", "sorting by multiple fields with different sorting layers"], "_raw_llm_output": "interface, sorting, function chaining, sorting by multiple fields, sorting by multiple fields with different sorting layers"}
{"seed": "// ID filters vertices based on their ID field.\nfunc ID(id int) predicate.Bulk {\n\treturn predicate.Bulk(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldID), id))\n\t})\n}", "id": 18938, "concepts": ["sql package usage", "predicate.Bulk usage", "function definition", "struct field access"], "_raw_llm_output": "sql package usage, predicate.Bulk usage, function definition, struct field access"}
{"seed": "// NewSessionClient returns a client for the Session from the given config.\nfunc NewSessionClient(c config) *SessionClient {\n\treturn &SessionClient{config: c}\n}", "id": 18942, "concepts": ["struct definition", "struct field definition", "struct initialization"], "_raw_llm_output": "struct definition, struct field definition, struct initialization"}
{"seed": "// NewHyperflexSnapshotStatusWithDefaults instantiates a new HyperflexSnapshotStatus object\n// This constructor will only assign default values to properties that have it defined,\n// but it doesn't guarantee that properties required by API are set\nfunc NewHyperflexSnapshotStatusWithDefaults() *HyperflexSnapshotStatus {\n\tthis := HyperflexSnapshotStatus{}\n\tvar classId string = \"hyperflex.SnapshotStatus\"\n\tthis.ClassId = classId\n\tvar objectType string = \"hyperflex.SnapshotStatus\"\n\tthis.ObjectType = objectType\n\treturn &this\n}", "id": 18952, "concepts": ["constructor", "default value assignment", "object instantiation"], "_raw_llm_output": "constructor, default value assignment, object instantiation"}
{"seed": "// PossiblePrivateEndpointStatusValues returns an array of possible values for the PrivateEndpointStatus const type.\nfunc PossiblePrivateEndpointStatusValues() []PrivateEndpointStatus {\n\treturn []PrivateEndpointStatus{PrivateEndpointStatusApproved, PrivateEndpointStatusDisconnected, PrivateEndpointStatusPending, PrivateEndpointStatusRejected, PrivateEndpointStatusTimeout}\n}", "id": 18956, "concepts": ["const declaration", "array declaration", "array iteration"], "_raw_llm_output": "const declaration, array declaration, array iteration"}
{"seed": "// Marquee represents the HTML element 'marquee'.\n// For more information visit https://www.w3schools.com/tags/tag_marquee.asp.\nfunc Marquee(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"marquee\", Attributes: attrs, Children: children}\n}", "id": 18962, "concepts": ["HTML generation", "HTML element definition", "HTML attribute definition", "HTML element child definition"], "_raw_llm_output": "HTML generation, HTML element definition, HTML attribute definition, HTML element child definition"}
{"seed": "// indexFragment looks for the last sentence split-point (defined as one of\n// the punctuation characters .:;,!?\"' followed by a space) in the string s\n// and returns the index in the string after that split-point. If no split-\n// point is found it returns the index after the last space in s, or -1.\nfunc indexFragment(s string) int {\n\tmax := -1\n\tfor _, sep := range []string{\". \", \": \", \"; \", \", \", \"! \", \"? \", \"\\\" \", \"' \"} {\n\t\tif idx := strings.LastIndex(s, sep); idx > max {\n\t\t\tmax = idx\n\t\t}\n\t}\n\tif max > 0 {\n\t\treturn max + 2\n\t}\n\tif idx := strings.LastIndex(s, \" \"); idx > 0 {\n\t\treturn idx + 1\n\t}\n\treturn -1\n}", "id": 18965, "concepts": ["string manipulation", "string splitting", "string indexing", "string comparison"], "_raw_llm_output": "string manipulation, string splitting, string indexing, string comparison"}
{"seed": "// NewPushFilter returns a new PushFilter.\nfunc NewPushFilter() *PushFilter {\n\n\treturn &PushFilter{\n\t\tIdentities: map[string][]EventType{},\n\t}\n}", "id": 18973, "concepts": ["map initialization", "map iteration (range loop)", "map key lookup", "map value lookup"], "_raw_llm_output": "map initialization, map iteration (range loop), map key lookup, map value lookup"}
{"seed": "// ParseCreateSksClusterResponse parses an HTTP response from a CreateSksClusterWithResponse call\nfunc ParseCreateSksClusterResponse(rsp *http.Response) (*CreateSksClusterResponse, error) {\n\tbodyBytes, err := ioutil.ReadAll(rsp.Body)\n\tdefer rsp.Body.Close()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse := &CreateSksClusterResponse{\n\t\tBody:         bodyBytes,\n\t\tHTTPResponse: rsp,\n\t}\n\n\tswitch {\n\tcase strings.Contains(rsp.Header.Get(\"Content-Type\"), \"json\") && rsp.StatusCode == 200:\n\t\tvar dest Operation\n\t\tif err := json.Unmarshal(bodyBytes, &dest); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresponse.JSON200 = &dest\n\n\t}\n\n\treturn response, nil\n}", "id": 18978, "concepts": ["HTTP response parsing", "JSON parsing", "error handling"], "_raw_llm_output": "HTTP response parsing, JSON parsing, error handling"}
{"seed": "// SafeSend sends result to the metadataSyncResultChannel but ignores panic when the channel is already closed\n// Returns true if the channel is already closed.\nfunc SafeSend(ch chan MetadataSyncResult, result MetadataSyncResult) (closed bool) {\n\tif ch == nil {\n\t\treturn\n\t}\n\tdefer func() {\n\t\tif recover() != nil {\n\t\t\tclosed = true\n\t\t}\n\t}()\n\n\tch <- result\n\treturn false\n}", "id": 18991, "concepts": ["channel", "channel close", "channel send", "recover"], "_raw_llm_output": "channel, channel close, channel send, recover"}
{"seed": "// ParsePartitionedData reads a data file and, with p probability, chooses ((1-p)*100)% of the data\n// file to be used as evidence file. For instance, p=0.7 will create a map[int]learn.Variable,\n// which contains the data variables, and two []map[int]int. The first []map[int]int returned is\n// the training data, which composes 70% of the data file. The second map will return the evidence\n// table with the remaining 30% data file. This partitioning is defined by the pseudo-random seed\n// rseed. If rseed < 0, then use the default pseudo-random seed. It also returns the labels of each\n// test line.\n//\n// Note: since this function \"breaks\" the order of classification, it returns a separate label\n// containing the actual classification of each instantiation.\nfunc ParsePartitionedData(filename string, p float64, rseed int64) (map[int]learn.Variable,\n\t[]map[int]int, []map[int]int, []int) {\n\tvartable, fdata := ParseData(filename)\n\tvar rint func(n int) int\n\n\tif rseed < 0 {\n\t\trint = rand.Intn\n\t} else {\n\t\tif glrseed < 0 {\n\t\t\tglrand, glrseed = rand.New(rand.NewSource(rseed)), rseed\n\t\t}\n\t\trint = glrand.Intn\n\t}\n\n\tn := len(fdata)\n\tm := int((1 - p) * float64(n))\n\ttest := make([]map[int]int, m)\n\tdels := make([]int, m)\n\tlbls := make([]int, m)\n\n\t// Marks instantiations that should serve as training set.\n\tfor i := 0; i < m; i++ {\n\t\tl := rint(n)\n\t\tfor fdata[l] == nil {\n\t\t\tl = rint(n)\n\t\t}\n\t\ttest[i] = fdata[l]\n\t\tfdata[l] = nil\n\t\tdels[i] = l\n\t}\n\tsort.Ints(dels)\n\n\t// Discards marked lines from fdata.\n\tfor i := 0; i < m; i++ {\n\t\tj := dels[i] - i\n\t\tfdata = append(fdata[:j], fdata[j+1:]...)\n\t}\n\n\t// All test lines have their real labels deleted and stored in a separate lbls slice.\n\tk := len(vartable) - 1\n\tfor i := 0; i < m; i++ {\n\t\tlbls[i] = test[i][k]\n\t\tdelete(test[i], k)\n\t}\n\n\treturn vartable, fdata, test, lbls\n}", "id": 19018, "concepts": ["map iteration (range loop)", "slice iteration (range loop)", "slice deletion", "slice sorting", "pseudo-random number generation", "pseudo-random seed", "function definition", "function return"], "_raw_llm_output": "map iteration (range loop), slice iteration (range loop), slice deletion, slice sorting,\npseudo-random number generation, pseudo-random seed, function definition, function return"}
{"seed": "// NewPeerPicker creates an object from a Tracker that follows PeerPicker\n// interface rules. This is separate from tracker, as it can only be created\n// once the local node is known.\nfunc NewPeerPicker(tracker *Tracker, list *memberlist.Memberlist) PeerPicker {\n\treturn PeerPicker{\n\t\ttracker: tracker,\n\t\tourName: list.LocalNode().Name,\n\t}\n}", "id": 19023, "concepts": ["memberlist package usage", "interface implementation", "struct composition"], "_raw_llm_output": "memberlist package usage, interface implementation, struct composition"}
{"seed": "// GetExampleFeature returns a sample feature file that can be ran to ensure the new project is configured correctly\nfunc GetExampleFeature() string {\n\treturn `Feature: Test Textbox Manipulation and Validation\n    Verify that Kosher's steps for manipulating\n    and verifying textboxes work correctly.\n\n    Background:\n        Given I maximize the window\n\n    Scenario: Fill a Textbox\n        Verify steps for fill a textbox.\n\n        Given I go to the \"basicform\" page\n        When I fill \"user-message\" with \"Hello, World\"\n        And I press \"Show Message\"\n        Then I should see \"Hello, World\"\n\n    Scenario: Fill Multiple Textboxes\n        Verify steps for filling multiple textboxes.\n\n        Given I go to the \"basicform\" page\n        When I fill in the following:\n            | sum1 | 4 |\n            | sum2 | 3 |\n        And I press \"Get Total\"\n        Then I should see \"7\"`\n}", "id": 19027, "concepts": ["string manipulation", "basic function definition", "basic step definition"], "_raw_llm_output": "string manipulation, basic function definition, basic step definition"}
{"seed": "// CalculatePeriodicPayment returns the per-period payment for a given principal, subject to given interestRate over\n// given number of periods.\nfunc CalculatePeriodicPayment(principal currency.Amount, interestRate *big.Rat, periods uint32) currency.Amount {\n\tbigPeriods := big.NewRat(int64(periods), 1)\n\t// \"big\" operations all send their results to their receiever, in-place, so this works best if we accumulate the\n\t// calculation rather than a single expression\n\tnumerator := &big.Rat{}\n\tnumerator.Add(one, interestRate)\n\tbigPow(numerator, bigPeriods)\n\tnumerator.Mul(interestRate, numerator)\n\n\tdenominator := &big.Rat{}\n\tdenominator.Add(one, interestRate)\n\tbigPow(denominator, bigPeriods)\n\tdenominator.Sub(denominator, one)\n\n\tpayment := &big.Rat{}\n\tpayment.Quo(numerator, denominator)\n\tpayment.Mul(&principal.Rat, payment)\n\n\treturn currency.Amount{Rat: *payment}\n}", "id": 19037, "concepts": ["big.Rat", "big.Int", "big.Rat.Mul", "big.Rat.Quo", "big.Rat.Add", "big.Rat.Sub", "big.Rat.Div", "big.Rat.Mul", "big.Rat.Quo", "big.Rat.Add", "big.Rat.Sub", "big.Rat.Mul", "big.Rat.Quo", "big.Rat.Add", "big.Rat.Sub", "big.Rat.Mul", "big.Rat.Quo", "big.Rat.Add", "big.Rat.Sub", "big.Rat.Mul", "big.Rat.Quo", "big.Rat.Add", "big.Rat.Sub", "big.Rat.Mul", "big.Rat.Quo", "big.Rat.Add", "big.Rat.Sub", "big.Rat.Mul", "big.Rat.Quo", "big.Rat.Add", "big.Rat.Sub", "big.Rat.Mul", "big.Rat.Quo", "big.Rat.Add", "big.Rat.Sub", "big.Rat.Mul", "big.Rat.Quo", "big.Rat.Add", "big.Rat.Sub", "big.Rat.Mul", "big.Rat.Quo", "big.Rat"], "_raw_llm_output": "big.Rat, big.Int, big.Rat.Mul, big.Rat.Quo, big.Rat.Add, big.Rat.Sub, big.Rat.Div, big.Rat.Mul, big.Rat.Quo, big.Rat.Add, big.Rat.Sub, big.Rat.Mul, big.Rat.Quo, big.Rat.Add, big.Rat.Sub, big.Rat.Mul, big.Rat.Quo, big.Rat.Add, big.Rat.Sub, big.Rat.Mul, big.Rat.Quo, big.Rat.Add, big.Rat.Sub, big.Rat.Mul, big.Rat.Quo, big.Rat.Add, big.Rat.Sub, big.Rat.Mul, big.Rat.Quo, big.Rat.Add, big.Rat.Sub, big.Rat.Mul, big.Rat.Quo, big.Rat.Add, big.Rat.Sub, big.Rat.Mul, big.Rat.Quo, big.Rat.Add, big.Rat.Sub, big.Rat.Mul, big.Rat.Quo, big.Rat"}
{"seed": "// IDNotIn applies the NotIn predicate on the ID field.\nfunc IDNotIn(ids ...int) predicate.Bulk {\n\treturn predicate.Bulk(func(s *sql.Selector) {\n\t\t// if not arguments were provided, append the FALSE constants,\n\t\t// since we can't apply \"IN ()\". This will make this predicate falsy.\n\t\tif len(ids) == 0 {\n\t\t\ts.Where(sql.False())\n\t\t\treturn\n\t\t}\n\t\tv := make([]interface{}, len(ids))\n\t\tfor i := range v {\n\t\t\tv[i] = ids[i]\n\t\t}\n\t\ts.Where(sql.NotIn(s.C(FieldID), v...))\n\t})\n}", "id": 19049, "concepts": ["sql.Selector", "sql.NotIn", "sql.False", "sql.Bulk", "predicate.Bulk", "basic function definition"], "_raw_llm_output": "sql.Selector, sql.NotIn, sql.False, sql.Bulk, predicate.Bulk, basic function definition"}
{"seed": "// DeleteStatisticDefinition delete an entity statistic definition. Will delete all statistics on entity profiles and leaderboards.\n// https://api.playfab.com/Documentation/Leaderboards/method/DeleteStatisticDefinition\nfunc DeleteStatisticDefinition(settings *playfab.Settings, postData *DeleteStatisticDefinitionRequestModel, entityToken string) (*EmptyResponseModel, error) {\n    if entityToken == \"\" {\n        return nil, playfab.NewCustomError(\"entityToken should not be an empty string\", playfab.ErrorGeneric)\n    }\n    b, errMarshal := json.Marshal(postData)\n    if errMarshal != nil {\n        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)\n    }\n\n    sourceMap, err := playfab.Request(settings, b, \"/Statistic/DeleteStatisticDefinition\", \"X-EntityToken\", entityToken)\n    if err != nil {\n        return nil, err\n    }\n    \n    result := &EmptyResponseModel{}\n\n    config := mapstructure.DecoderConfig{\n        DecodeHook: playfab.StringToDateTimeHook,\n        Result:     result,\n    }\n    \n    decoder, errDecoding := mapstructure.NewDecoder(&config)\n    if errDecoding != nil {\n        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)\n    }\n   \n    errDecoding = decoder.Decode(sourceMap)\n    if errDecoding != nil {\n        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)\n    }\n\n    return result, nil\n}", "id": 19054, "concepts": ["JSON marshalling", "JSON unmarshalling", "HTTP request", "HTTP response", "function definition", "string manipulation", "string formatting", "standard library usage", "error handling (errors.New)", "concurrency patterns (goroutines", "channels", "mutexes)", "error handling (idiomatic `if err != nil`", "`errors.Is`", "`errors.As`)", "types (structs", "interfaces", "slices", "maps)", "common Go idioms (like `defer`)", "pointers", "and control flow."], "_raw_llm_output": "JSON marshalling, JSON unmarshalling, HTTP request, HTTP response, function definition, string manipulation, string formatting, standard library usage, error handling (errors.New), concurrency patterns (goroutines, channels, mutexes), error handling (idiomatic `if err != nil`, `errors.Is`, `errors.As`), types (structs, interfaces, slices, maps), common Go idioms (like `defer`), pointers, and control flow."}
{"seed": "// Provides information about a Lambda Function.\n//\n// > This content is derived from https://github.com/terraform-providers/terraform-provider-aws/blob/master/website/docs/d/lambda_function.html.markdown.\nfunc LookupFunction(ctx *pulumi.Context, args *GetFunctionArgs) (*GetFunctionResult, error) {\n\tinputs := make(map[string]interface{})\n\tif args != nil {\n\t\tinputs[\"functionName\"] = args.FunctionName\n\t\tinputs[\"qualifier\"] = args.Qualifier\n\t\tinputs[\"tags\"] = args.Tags\n\t}\n\toutputs, err := ctx.Invoke(\"aws:lambda/getFunction:getFunction\", inputs)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &GetFunctionResult{\n\t\tArn: outputs[\"arn\"],\n\t\tDeadLetterConfig: outputs[\"deadLetterConfig\"],\n\t\tDescription: outputs[\"description\"],\n\t\tEnvironment: outputs[\"environment\"],\n\t\tFunctionName: outputs[\"functionName\"],\n\t\tHandler: outputs[\"handler\"],\n\t\tInvokeArn: outputs[\"invokeArn\"],\n\t\tKmsKeyArn: outputs[\"kmsKeyArn\"],\n\t\tLastModified: outputs[\"lastModified\"],\n\t\tLayers: outputs[\"layers\"],\n\t\tMemorySize: outputs[\"memorySize\"],\n\t\tQualifiedArn: outputs[\"qualifiedArn\"],\n\t\tQualifier: outputs[\"qualifier\"],\n\t\tReservedConcurrentExecutions: outputs[\"reservedConcurrentExecutions\"],\n\t\tRole: outputs[\"role\"],\n\t\tRuntime: outputs[\"runtime\"],\n\t\tSourceCodeHash: outputs[\"sourceCodeHash\"],\n\t\tSourceCodeSize: outputs[\"sourceCodeSize\"],\n\t\tTags: outputs[\"tags\"],\n\t\tTimeout: outputs[\"timeout\"],\n\t\tTracingConfig: outputs[\"tracingConfig\"],\n\t\tVersion: outputs[\"version\"],\n\t\tVpcConfig: outputs[\"vpcConfig\"],\n\t\tId: outputs[\"id\"],\n\t}, nil\n}", "id": 19055, "concepts": ["map iteration (range loop)", "map lookup", "function definition", "standard library usage"], "_raw_llm_output": "map iteration (range loop), map lookup, function definition, standard library usage"}
{"seed": "// GetXMPPConnectionInfo builds an XMPPConnectionInfo structure\n// reading default values from the following environment variables:\n//\n//\tGRIP_XMPP_HOSTNAME\n//\tGRIP_XMPP_USERNAME\n//\tGRIP_XMPP_PASSWORD\nfunc GetXMPPConnectionInfo() XMPPConnectionInfo {\n\treturn XMPPConnectionInfo{\n\t\tHostname: os.Getenv(xmppHostEnvVar),\n\t\tUsername: os.Getenv(xmppUsernameEnvVar),\n\t\tPassword: os.Getenv(xmppPasswordEnvVar),\n\t}\n}", "id": 19065, "concepts": ["environment variable usage", "struct definition", "basic function definition"], "_raw_llm_output": "environment variable usage, struct definition, basic function definition"}
{"seed": "// NewGetConfigsClusterParamsWithTimeout creates a new GetConfigsClusterParams object\n// with the default values initialized, and the ability to set a timeout on a request\nfunc NewGetConfigsClusterParamsWithTimeout(timeout time.Duration) *GetConfigsClusterParams {\n\tvar ()\n\treturn &GetConfigsClusterParams{\n\n\t\ttimeout: timeout,\n\t}\n}", "id": 19072, "concepts": ["timeout handling", "function definition", "struct definition", "pointer handling"], "_raw_llm_output": "timeout handling, function definition, struct definition, pointer handling"}
{"seed": "// NewGetIPAMsubnetsParamsWithContext creates a new GetIPAMsubnetsParams object\n// with the default values initialized, and the ability to set a context for a request\nfunc NewGetIPAMsubnetsParamsWithContext(ctx context.Context) *GetIPAMsubnetsParams {\n\tvar ()\n\treturn &GetIPAMsubnetsParams{\n\n\t\tContext: ctx,\n\t}\n}", "id": 19076, "concepts": ["context package usage", "function definition", "function parameters"], "_raw_llm_output": "context package usage, function definition, function parameters"}
{"seed": "// Repository is the  accessor for ITaskRepo.\nfunc Repository() ITaskRepo {\n\treturn taskRepository\n}", "id": 19083, "concepts": ["interface implementation", "interface usage"], "_raw_llm_output": "interface implementation, interface usage"}
{"seed": "// runCmd runs the command line, returning its output. If the command cannot\n// be run or does return a bad exit code, it will return an error.\nfunc runCmd(command string, args ...string) ([]byte, error) {\n\tif *flagVerbose {\n\t\tlog.Printf(\"runCmd: %s %s\", command, strings.Join(args, \" \"))\n\t}\n\n\tout, err := execCommand(command, args...).CombinedOutput()\n\tif err != nil {\n\t\tlog.Printf(\"runCmd: %s\", out)\n\t\treturn nil, err\n\t}\n\n\treturn out, nil\n}", "id": 19091, "concepts": ["exec.Command", "exec.Command.CombinedOutput", "error handling (idiomatic if err != nil)", "basic function definition"], "_raw_llm_output": "exec.Command, exec.Command.CombinedOutput, error handling (idiomatic if err != nil), basic function definition"}
{"seed": "// Creates a new priority queue.\nfunc New() *Prque {\n\treturn &Prque{newSstack()}\n}", "id": 19093, "concepts": ["struct definition", "method definition", "pointer handling", "stack usage"], "_raw_llm_output": "struct definition, method definition, pointer handling, stack usage"}
{"seed": "// NewGCMWithNonceSize returns the given 128-bit, block cipher wrapped in Galois\n// Counter Mode, which accepts nonces of the given length. The length must not\n// be zero.\n//\n// Only use this function if you require compatibility with an existing\n// cryptosystem that uses non-standard nonce lengths. All other users should use\n// NewGCM, which is faster and more resistant to misuse.\nfunc newGCMWithNonceSize(cipher goCipher.Block, size int) (aeadIf, error) {\n\treturn newGCMWithNonceAndTagSize(cipher, size, gcmTagSize)\n}", "id": 19107, "concepts": ["cryptography", "Galois Counter Mode", "block cipher", "nonce", "standard library usage"], "_raw_llm_output": "cryptography, Galois Counter Mode, block cipher, nonce, standard library usage"}
{"seed": "// WithCharset sets the Charset setting.\n//\n// See `Configuration`.\nfunc WithCharset(charset string) Configurator {\n\treturn func(app *Application) {\n\t\tapp.config.Charset = charset\n\t}\n}", "id": 19115, "concepts": ["function composition", "function definition", "function composition", "function composition"], "_raw_llm_output": "function composition, function definition, function composition, function composition"}
{"seed": "// Newf formats according to a format specifier and calls New() to\n// return an Error.\nfunc Newf(code interface{}, format string, args ...interface{}) Error {\n\treturn New(code, fmt.Sprintf(format, args...))\n}", "id": 19119, "concepts": ["error handling (fmt.Sprintf)", "error handling (errors.New)", "error handling (errors.Is)", "error handling (errors.As)"], "_raw_llm_output": "error handling (fmt.Sprintf), error handling (errors.New), error handling (errors.Is), error handling (errors.As)"}
{"seed": "// offsetN calculates the offset after nIterations.\n// The iterative/recursive version of the function can be transformed into a\n// closed form (which involves a partial sum of a geometric series).\n//\n// E.g. deriving it by induction (factor[0]=1134, offset[0]=4518):\n//     offset[3] = 5815077138 * 1134 + 4518\n//               = 5815077138 * 1134 + 4518\n//               = ((1134 * 4518 + 4518) * 1134 + 4518) * 1134 + 4518\n//               = ((a * b + b) * a + b) * a + b\n//               = a * a * a * b + a * a * b + a * b + b\n//               = b (a * a * a + a * a + a + 1)\n//               = b (a^3 + a^2 + a^1 + a^0)\n//\n// Reference (for the closed form of a partial sum of a geometric series):\n// https://math.stackexchange.com/a/971770\nfunc offsetN(factor0 int64, offset0 int64, nIterations int64, nCards int64) int64 {\n\t// offset[n] = (offset[n-1] * factor[0] + offset[0]) % d.nCards\n\t// or\n\t// offset[n] = offset[0] * (factor[0]^n + factor[0]^(n - 1) + factor[0]^(n - 2) + ... + factor[0]^0)\n\t//           = offset[0] * ((factor[0]^(n + 1) - 1) / (factor[0] - 1))\n\tsum := sumOfPowersMod(factor0, nIterations, nCards)\n\tresult := big.NewInt(offset0)\n\tresult.Mul(result, big.NewInt(sum))\n\tresult.Mod(result, big.NewInt(nCards))\n\n\tif !result.IsInt64() {\n\t\tpanic(\"result should be int64!\")\n\t}\n\n\treturn result.Int64()\n}", "id": 19120, "concepts": ["integer arithmetic", "big.Int package usage", "modular arithmetic", "closed form of a partial sum of a geometric series"], "_raw_llm_output": "integer arithmetic, big.Int package usage, modular arithmetic, closed form of a partial sum of a geometric series"}
{"seed": "// createOverlayForPage returns a PDF object which contains:\n// - white opaque margin up to bleedMargin\n// - trim marks up to bleedMargin\n// - other printmarks such as tile/page number\n// This will update the contentIds of the page to include a ref\n// to the new overlay object.\nfunc createOverlayForPage(overlayID int, p *page) string {\n\tmb, bb, tb := p.mediaBox, p.bleedBox, p.trimBox\n\t// Draw opaque bleed margin\n\tstream := fmt.Sprintf(` q\n\t    1 1 1 rg %f %f m %f %f l %f %f l %f %f l h\n\t    %f %f m %f %f l %f %f l %f %f l h f\n\t  Q `,\n\t\t// +1s and -1s are to bleed the box outside of viewpoint\n\t\tmb.llx-1, mb.lly-1, mb.llx-1, mb.ury+1, mb.urx+1, mb.ury+1, mb.urx+1, mb.lly-1,\n\t\tbb.llx, bb.lly, bb.urx, bb.lly, bb.urx, bb.ury, bb.llx, bb.ury,\n\t)\n\t// Draw trim marks\n\n\tif !*longTrimMarks {\n\t\tstream += fmt.Sprintf(` q\n\t\t    0 0 0 rg %f w\n\t      %f %f m %f %f l S\n\t      %f %f m %f %f l S\n\t      %f %f m %f %f l S\n\t      %f %f m %f %f l S\n\t      %f %f m %f %f l S\n\t      %f %f m %f %f l S\n\t      %f %f m %f %f l S\n\t      %f %f m %f %f l S\n\t    Q `,\n\t\t\ttrimMarkLineWidth,\n\t\t\tmb.llx-1, tb.lly, bb.llx, tb.lly,\n\t\t\tmb.llx-1, tb.ury, bb.llx, tb.ury,\n\t\t\ttb.llx, mb.ury+1, tb.llx, bb.ury,\n\t\t\ttb.urx, mb.ury+1, tb.urx, bb.ury,\n\t\t\tbb.urx, tb.ury, mb.urx+1, tb.ury,\n\t\t\tbb.urx, tb.lly, mb.urx+1, tb.lly,\n\t\t\ttb.llx, bb.lly, tb.llx, mb.lly-1,\n\t\t\ttb.urx, bb.lly, tb.urx, mb.lly-1,\n\t\t)\n\t} else {\n\t\tstream += fmt.Sprintf(` q\n\t\t    0 0 0 rg %f w\n\t      %f %f m %f %f l S\n\t      %f %f m %f %f l S\n\t      %f %f m %f %f l S\n\t      %f %f m %f %f l S\n\t    Q `,\n\t\t\ttrimMarkLineWidth,\n\t\t\tmb.llx-1, tb.lly, mb.urx+1, tb.lly, // bottom trim line\n\t\t\tmb.llx-1, tb.ury, mb.urx+1, tb.ury, // top trim line\n\t\t\ttb.llx, mb.lly-1, tb.llx, mb.ury+1, // left trim line\n\t\t\ttb.urx, mb.lly-1, tb.urx, mb.ury+1, // right trim line\n\t\t)\n\t}\n\t// Draw tile ref\n\tvch := float32(vecCharHeight)\n\tstream += fmt.Sprintf(`\n    q 0 0 0 rg\n      q 1 0 0 1 %f %f cm %s Q\n      q 1 0 0 1 %f %f cm %s Q\n    Q\n    q\n      0 0 0 rg %f w 2 J\n      %f %f m %f %f l S\n      %f %f m %f %f l S\n      %f %f m %f %f l %f %f l h f\n      %f %f m %f %f l %f %f l h f\n    Q\n  `,\n\t\tbb.urx, bb.ury+vch/2, strToVecChars(numToAlpha(p.tileY), -1, 1),\n\t\tbb.urx+vch/2, bb.ury, strToVecChars(strconv.Itoa(p.tileX+1), 1, -1),\n\t\ttrimMarkLineWidth,\n\t\tbb.urx+vch/2, bb.ury+vch/2, bb.urx+vch/2, bb.ury+vch*1.5,\n\t\tbb.urx+vch/2, bb.ury+vch/2, bb.urx+vch*1.5, bb.ury+vch/2,\n\t\tbb.urx+vch/4, bb.ury+vch*1.5, bb.urx+vch*3/4, bb.ury+vch*1.5, bb.urx+vch/2, bb.ury+vch*2,\n\t\tbb.urx+vch*1.5, bb.ury+vch/4, bb.urx+vch*1.5, bb.ury+vch*3/4, bb.urx+vch*2, bb.ury+vch/2,\n\t)\n\t// Draw page ref\n\tstream += fmt.Sprintf(` q 0 0 0 rg\n    q 1 0 0 1 %f %f cm %s Q\n    q 1 0 0 1 %f %f cm %s Q\n  Q `,\n\t\ttb.llx-vch/2, bb.ury+vch/2, strToVecChars(strconv.Itoa(p.number), -1, 1),\n\t\tbb.llx-vch/2, bb.ury, strToVecChars(\"PAGE\", -1, -1),\n\t)\n\t// Draw page title\n\tstream += fmt.Sprintf(` q 0 0 0 rg q 1 0 0 1 %f %f cm %s Q Q `,\n\t\ttb.llx+vch/2, bb.lly-vch/2, strToVecChars(*tileTitle, 1, -1),\n\t)\n\tp.contentIds = append(p.contentIds, overlayID)\n\treturn fmt.Sprintf(\"%d 0 obj\\n<< /Length %d >> stream\\n%sendstream\\nendobj\\n\",\n\t\toverlayID, len(stream), stream)\n}", "id": 19122, "concepts": ["string formatting", "fmt package usage", "error handling (errors.New)", "string manipulation", "rune handling", "character comparison", "integer division", "slice iteration (range loop)", "integer summation", "basic function definition", "string to rune conversion", "rune to string conversion", "string to integer conversion", "integer to string conversion", "string to slice conversion", "slice to string conversion", "string to slice conversion", "slice to integer conversion", "integer to slice conversion", "string to slice conversion", "slice to string conversion", "string to slice conversion", "slice to integer conversion", "integer to slice conversion", "string to slice conversion", "slice to string conversion", "string to slice conversion", "slice to integer conversion", "integer to slice conversion", "string to slice conversion", "slice to string conversion", "string to slice conversion", "slice to integer conversion", "integer to slice conversion", "string to slice conversion", "slice to string conversion", "string to slice conversion", "slice to integer conversion", "integer to slice conversion", "string to slice conversion", "slice to string conversion", "string to slice conversion", "slice to integer conversion", "integer to slice conversion", "string to slice conversion", "slice to string conversion", "string to slice conversion", "slice to integer conversion", "integer to slice conversion", "string to slice conversion", "slice to string conversion", "string to slice conversion", "slice"], "_raw_llm_output": "string formatting, fmt package usage, error handling (errors.New), string manipulation, rune handling, character comparison, integer division, slice iteration (range loop), integer summation, basic function definition, string to rune conversion, rune to string conversion, string to integer conversion, integer to string conversion, string to slice conversion, slice to string conversion, string to slice conversion, slice to integer conversion, integer to slice conversion, string to slice conversion, slice to string conversion, string to slice conversion, slice to integer conversion, integer to slice conversion, string to slice conversion, slice to string conversion, string to slice conversion, slice to integer conversion, integer to slice conversion, string to slice conversion, slice to string conversion, string to slice conversion, slice to integer conversion, integer to slice conversion, string to slice conversion, slice to string conversion, string to slice conversion, slice to integer conversion, integer to slice conversion, string to slice conversion, slice to string conversion, string to slice conversion, slice to integer conversion, integer to slice conversion, string to slice conversion, slice to string conversion, string to slice conversion, slice to integer conversion, integer to slice conversion, string to slice conversion, slice to string conversion, string to slice conversion, slice"}
{"seed": "// ToGObject() type converts an unsafe.Pointer as a native C GObject.\n// This function is exported for visibility in other gotk3 packages and\n// is not meant to be used by applications.\nfunc ToGObject(p unsafe.Pointer) *C.GObject {\n\treturn (*C.GObject)(p)\n}", "id": 19123, "concepts": ["unsafe package usage", "pointer dereferencing", "C interop"], "_raw_llm_output": "unsafe package usage, pointer dereferencing, C interop"}
{"seed": "// ErrorWordStart returns the maximum byte offset into the input\n// among all word-node errors.\nfunc errorWordStart(n *peg.Fail) int {\n\tmax := -1\n\tif isWordNode(n) {\n\t\tmax = n.Pos\n\t}\n\tfor _, k := range n.Kids {\n\t\tif m := errorWordStart(k); m > max {\n\t\t\tmax = m\n\t\t}\n\t}\n\treturn max\n}", "id": 19132, "concepts": ["recursive function definition", "error handling", "peg package usage"], "_raw_llm_output": "recursive function definition, error handling, peg package usage"}
{"seed": "// NewNamedSelector creates a new Selector instance with a given human readable name.\n// Name appears in stack traces that are blocked on this Selector.\nfunc NewNamedSelector(ctx Context, name string) Selector {\n\treturn &selectorImpl{name: name}\n}", "id": 19136, "concepts": ["selector", "context", "stack trace", "interface definition"], "_raw_llm_output": "selector, context, stack trace, interface definition"}
{"seed": "// LatestHeroScoreEQ applies the EQ predicate on the \"latest_hero_score\" field.\nfunc LatestHeroScoreEQ(v int) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldLatestHeroScore), v))\n\t})\n}", "id": 19137, "concepts": ["sql package usage", "sql.Selector", "sql.C", "sql.EQ"], "_raw_llm_output": "sql package usage, sql.Selector, sql.C, sql.EQ"}
{"seed": "// PossibleDataLakeAnalyticsAccountStateValues returns an array of possible values for the DataLakeAnalyticsAccountState const type.\nfunc PossibleDataLakeAnalyticsAccountStateValues() []DataLakeAnalyticsAccountState {\n\treturn []DataLakeAnalyticsAccountState{Active, Suspended}\n}", "id": 19142, "concepts": ["const type", "array", "possible values"], "_raw_llm_output": "const type, array, possible values"}
{"seed": "// ResolvePackages resolves package paths, i.e. paths starting with '//',\n// against the workspace root folder closest to the current working directory.\n// It updates paths in place.\n// It returns an error if it cannot find a workspace root or working directory.\nfunc ResolvePackages(paths []string) error {\n\tfor i, p := range paths {\n\t\tif strings.HasPrefix(p, \"//\") {\n\t\t\twd, err := os.Getwd()\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to get working directory: %v\", err)\n\t\t\t}\n\t\t\tg3root, err := workspace.Root(wd)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to find workspace root under %q: %v\", wd, err)\n\t\t\t}\n\t\t\tpaths[i] = filepath.Join(g3root, p)\n\t\t}\n\t}\n\treturn nil\n}", "id": 19161, "concepts": ["string manipulation", "filepath package usage", "workspace package usage"], "_raw_llm_output": "string manipulation, filepath package usage, workspace package usage"}
{"seed": "// NewCreateSecurityGroupRequestWithBody generates requests for CreateSecurityGroup with any type of body\nfunc NewCreateSecurityGroupRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {\n\tvar err error\n\n\tqueryUrl, err := url.Parse(server)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbasePath := fmt.Sprintf(\"/security-group\")\n\tif basePath[0] == '/' {\n\t\tbasePath = basePath[1:]\n\t}\n\n\tqueryUrl, err = queryUrl.Parse(basePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq, err := http.NewRequest(\"POST\", queryUrl.String(), body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Add(\"Content-Type\", contentType)\n\treturn req, nil\n}", "id": 19170, "concepts": ["http.NewRequest", "url.Parse", "url.ParseRequestURI", "io.Reader", "io.Writer", "io.ReadWriter", "io.Closer", "url.URL", "url.Values", "url.Query", "url.RawQuery", "url.RawPath", "url.Path", "url.EscapedPath", "url.User", "url.Userinfo", "url.Host", "url.Scheme", "url.Opaque", "url.RawPath", "url.Path", "url.RawQuery", "url.Fragment", "url.RequestURI", "url.String", "url.User", "url.Hostname", "url.Port", "url.Path", "url.RawPath", "url.RawQuery", "url.Fragment", "url.RequestURI", "url.String", "url.String", "url.String", "url.String", "url.String", "url.String", "url.String", "url.String", "url.String", "url.String", "url.String", "url.String", "url.String", "url.String", "url.String", "url.String", "url.String", "url.String", "url.String", "url.String", "url.String", "url.String", "url.String", "url.String", "url.String", "url.String", "url.String", "url"], "_raw_llm_output": "http.NewRequest, url.Parse, url.ParseRequestURI, io.Reader, io.Writer, io.ReadWriter, io.Closer, url.URL, url.Values, url.Query, url.RawQuery, url.RawPath, url.Path, url.EscapedPath, url.User, url.Userinfo, url.Host, url.Scheme, url.Opaque, url.RawPath, url.Path, url.RawQuery, url.Fragment, url.RequestURI, url.String, url.User, url.Hostname, url.Port, url.Path, url.RawPath, url.RawQuery, url.Fragment, url.RequestURI, url.String, url.String, url.String, url.String, url.String, url.String, url.String, url.String, url.String, url.String, url.String, url.String, url.String, url.String, url.String, url.String, url.String, url.String, url.String, url.String, url.String, url.String, url.String, url.String, url.String, url.String, url.String, url"}
{"seed": "// Writer sets the writer to use. The default writer is os.Stdout.\nfunc Writer(w io.Writer) Option {\n\treturn optionFunc(func(l *lineWriter) {\n\t\tl.out = w\n\t})\n}", "id": 19178, "concepts": ["io.Writer", "io.Writer interface", "io.Writer type", "io.Writer method", "io.Writer method signature", "io.Writer method implementation", "io.Writer method receiver", "io.Writer method receiver type", "io.Writer method receiver value", "io.Writer method receiver value type", "io.Writer method receiver value assignment", "io.Writer method receiver value assignment type", "io.Writer method receiver value assignment value", "io.Writer method receiver value assignment value type", "io.Writer method receiver value assignment value assignment", "io.Writer method receiver value assignment value assignment type", "io.Writer method receiver value assignment value assignment value", "io.Writer method receiver value assignment value assignment value type", "io.Writer method receiver value assignment value assignment value assignment", "io.Writer method receiver value assignment value assignment value assignment type", "io.Writer method receiver value assignment value assignment value assignment value", "io.Writer method receiver value assignment value assignment value assignment value type", "io.Writer method receiver value assignment value assignment value assignment value assignment", "io.Writer method receiver value assignment value assignment value assignment value assignment type", "io.Writer method receiver value assignment value assignment value assignment value assignment value", "io.Writer method receiver value assignment value assignment value assignment value assignment value type", "io.Writer method"], "_raw_llm_output": "io.Writer, io.Writer interface, io.Writer type, io.Writer method, io.Writer method signature, io.Writer method implementation, io.Writer method receiver, io.Writer method receiver type, io.Writer method receiver value, io.Writer method receiver value type, io.Writer method receiver value assignment, io.Writer method receiver value assignment type, io.Writer method receiver value assignment value, io.Writer method receiver value assignment value type, io.Writer method receiver value assignment value assignment, io.Writer method receiver value assignment value assignment type, io.Writer method receiver value assignment value assignment value, io.Writer method receiver value assignment value assignment value type, io.Writer method receiver value assignment value assignment value assignment, io.Writer method receiver value assignment value assignment value assignment type, io.Writer method receiver value assignment value assignment value assignment value, io.Writer method receiver value assignment value assignment value assignment value type, io.Writer method receiver value assignment value assignment value assignment value assignment, io.Writer method receiver value assignment value assignment value assignment value assignment type, io.Writer method receiver value assignment value assignment value assignment value assignment value, io.Writer method receiver value assignment value assignment value assignment value assignment value type, io.Writer method"}
{"seed": "// hash returns the git hash for the current repo or \"\" if none.\nfunc hash() string {\n\thash, _ := sh.Output(\"git\", \"rev-parse\", \"--short\", \"HEAD\")\n\treturn hash\n}", "id": 19197, "concepts": ["shelling out to git", "git rev-parse", "string handling"], "_raw_llm_output": "shelling out to git, git rev-parse, string handling"}
{"seed": "// Insert uses the globally established session S to insert the `data` into the\n// specified `table`. The `soft` parameter is used to run a Soft durability.\n// This function returns the id of the new entry as the first returned element,\n// or the error (second) in case of failure.\nfunc Insert(table string, data interface{}, soft bool) (string, error) {\n\topts := r.InsertOpts{}\n\tif soft {\n\t\topts.Durability = \"soft\"\n\t} else {\n\t\topts.Durability = \"hard\"\n\t}\n\n\tres, err := r.Table(table).Insert(data, opts).Run(S)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer res.Close()\n\n\tvar result RDict\n\tif err = res.One(&result); err != nil {\n\t\treturn \"\", err\n\t}\n\n\tid := result[\"generated_keys\"].([]interface{})[0].(string)\n\treturn id, nil\n}", "id": 19201, "concepts": ["r.Table", "r.InsertOpts", "r.Insert", "r.Run", "r.One", "defer", "error handling (idiomatic)", "standard library usage"], "_raw_llm_output": "r.Table, r.InsertOpts, r.Insert, r.Run, r.One, defer, error handling (idiomatic), standard library usage"}
{"seed": "// SocialAvatarURLIn applies the In predicate on the \"social_avatar_url\" field.\nfunc SocialAvatarURLIn(vs ...string) predicate.User {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.User(func(s *sql.Selector) {\n\t\t// if not arguments were provided, append the FALSE constants,\n\t\t// since we can't apply \"IN ()\". This will make this predicate falsy.\n\t\tif len(vs) == 0 {\n\t\t\ts.Where(sql.False())\n\t\t\treturn\n\t\t}\n\t\ts.Where(sql.In(s.C(FieldSocialAvatarURL), v...))\n\t})\n}", "id": 19208, "concepts": ["predicate", "sql.Selector", "sql.In", "sql.False", "sql.C", "sql.Where", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql"], "_raw_llm_output": "predicate, sql.Selector, sql.In, sql.False, sql.C, sql.Where, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql"}
{"seed": "// SafeClose closes the metadataSyncResultChannel but ignores panic when the channel is already closed.\n// Returns true if the channel is already closed.\nfunc SafeClose(ch chan MetadataSyncResult) (closed bool) {\n\tif ch == nil {\n\t\treturn\n\t}\n\tdefer func() {\n\t\tif recover() != nil {\n\t\t\tclosed = true\n\t\t}\n\t}()\n\n\tclose(ch)\n\treturn false\n}", "id": 19219, "concepts": ["panic handling", "channel closing", "channel nil check"], "_raw_llm_output": "panic handling, channel closing, channel nil check"}
{"seed": "// MoMoRefAsRecoveryBackupConfigPolicyRelationship is a convenience function that returns MoMoRef wrapped in RecoveryBackupConfigPolicyRelationship\nfunc MoMoRefAsRecoveryBackupConfigPolicyRelationship(v *MoMoRef) RecoveryBackupConfigPolicyRelationship {\n\treturn RecoveryBackupConfigPolicyRelationship{\n\t\tMoMoRef: v,\n\t}\n}", "id": 19224, "concepts": ["MoMoRef", "function definition", "pointer handling"], "_raw_llm_output": "MoMoRef, function definition, pointer handling"}
{"seed": "// ValidateNoProxyFormat validates the no-proxy format which should be a comma-separated list\n// of destination domain names, domains, IP addresses or other network CIDRs. A domain can be\n// prefaced with '.' to include all subdomains of that domain.\nfunc ValidateNoProxyFormat(noProxy string) error {\n\tdomains := strings.Split(noProxy, \",\")\n\tfor _, s := range domains {\n\t\ts = strings.TrimPrefix(s, \".\")\n\t\tif govalidator.IsIP(s) {\n\t\t\tcontinue\n\t\t}\n\n\t\tif govalidator.IsCIDR(s) {\n\t\t\tcontinue\n\t\t}\n\n\t\tif govalidator.IsDNSName(s) {\n\t\t\tcontinue\n\t\t}\n\t\treturn errors.Errorf(\"NO Proxy format is not valid: '%s'. \"+\n\t\t\t\"NO Proxy is a comma-separated list of destination domain names, domains, IP addresses or other network CIDRs. \"+\n\t\t\t\"A domain can be prefaced with '.' to include all subdomains of that domain.\", noProxy)\n\t}\n\treturn nil\n}", "id": 19258, "concepts": ["string manipulation", "string validation", "govalidator package usage"], "_raw_llm_output": "string manipulation, string validation, govalidator package usage"}
{"seed": "// RandomTrytesInsecure returns random Trytes with the given length.\n// the result is not cryptographically secure.\n// DO NOT USE this function to generate a seed.\nfunc RandomTrytesInsecure(length int) trinary.Trytes {\n\t// Rand needs to be locked: https://github.com/golang/go/issues/3611\n\trandLock.Lock()\n\tdefer randLock.Unlock()\n\n\ttrytes := make([]byte, length)\n\tfor i := range trytes {\n\t\ttrytes[i] = charsetTrytes[seededRand.Intn(len(charsetTrytes))]\n\t}\n\treturn trinary.Trytes(trytes)\n}", "id": 19264, "concepts": ["cryptographically insecure random number generation", "charsetTrytes", "seededRand", "randLock", "concurrency", "standard library usage"], "_raw_llm_output": "cryptographically insecure random number generation, charsetTrytes, seededRand, randLock, concurrency, standard library usage"}
{"seed": "// parseTime parses a string as time.Time. It supports the RFC3339 format, unix seconds, and json marshalled time.Time\n// structs.\nfunc parseTime(s string) (time.Time, error) {\n\t// attempt to parse time as RFC3339 string\n\tt, err := time.Parse(time.RFC3339Nano, s)\n\tif err == nil {\n\t\treturn t, nil\n\t}\n\n\t// attempt to parse time as float number of unix seconds\n\tif f, err := strconv.ParseFloat(s, 64); err == nil {\n\t\tsec, dec := math.Modf(f)\n\t\treturn time.Unix(int64(sec), int64(dec*(1e9))), nil\n\t}\n\n\t// attempt to parse time as json marshaled value\n\tif err := json.Unmarshal([]byte(s), &t); err == nil {\n\t\treturn t, nil\n\t}\n\n\treturn time.Time{}, err\n}", "id": 19268, "concepts": ["time package usage", "string parsing", "float parsing", "json marshaling", "json unmarshaling", "time.Time struct"], "_raw_llm_output": "time package usage, string parsing, float parsing, json marshaling, json unmarshaling, time.Time struct"}
{"seed": "// CreateMicrosoftManagedDesktopFromDiscriminatorValue creates a new instance of the appropriate class based on discriminator value\nfunc CreateMicrosoftManagedDesktopFromDiscriminatorValue(parseNode i878a80d2330e89d26896388a3f487eef27b0a0e6c010c493bf80be1452208f91.ParseNode)(i878a80d2330e89d26896388a3f487eef27b0a0e6c010c493bf80be1452208f91.Parsable, error) {\n    return NewMicrosoftManagedDesktop(), nil\n}", "id": 19270, "concepts": ["interface", "standard library usage"], "_raw_llm_output": "interface, standard library usage"}
{"seed": "// NewNameContains applies the Contains predicate on the \"new_name\" field.\nfunc NewNameContains(v string) predicate.User {\n\treturn predicate.User(sql.FieldContains(FieldNewName, v))\n}", "id": 19274, "concepts": ["interface", "sql.FieldContains", "sql.Field"], "_raw_llm_output": "interface, sql.FieldContains, sql.Field"}
{"seed": "// CredentialAssertionResponseFromProto converts a CredentialAssertionResponse\n// proto to its lib counterpart.\nfunc CredentialAssertionResponseFromProto(car *wantypes.CredentialAssertionResponse) *CredentialAssertionResponse {\n\tif car == nil {\n\t\treturn nil\n\t}\n\treturn &CredentialAssertionResponse{\n\t\tPublicKeyCredential: PublicKeyCredential{\n\t\t\tCredential: Credential{\n\t\t\t\tID:   base64.RawURLEncoding.EncodeToString(car.RawId),\n\t\t\t\tType: car.Type,\n\t\t\t},\n\t\t\tRawID:      car.RawId,\n\t\t\tExtensions: outputExtensionsFromProto(car.Extensions),\n\t\t},\n\t\tAssertionResponse: authenticatorAssertionResponseFromProto(car.Response),\n\t}\n}", "id": 19277, "concepts": ["conversion", "base64 encoding", "struct definition", "interface definition", "function definition", "pointer handling", "slice iteration", "anonymous function", "map iteration", "function composition", "function composition with anonymous function", "function composition with anonymous function and pointer handling", "function composition with anonymous function and pointer handling", "function composition with anonymous function and pointer handling", "function composition with anonymous function and pointer handling", "function composition with anonymous function and pointer handling", "function composition with anonymous function and pointer handling", "function composition with anonymous function and pointer handling", "function composition with anonymous function and pointer handling", "function composition with anonymous function and pointer handling", "function composition with anonymous function and pointer handling", "function composition with anonymous function and pointer handling", "function composition with anonymous function and pointer handling", "function composition with anonymous function and pointer handling", "function composition with anonymous function and pointer handling", "function composition with anonymous function and pointer handling", "function composition with anonymous function and pointer handling", "function composition with anonymous function and pointer handling", "function composition with anonymous function and pointer handling", "function composition with anonymous function and pointer handling", "function composition with anonymous function and pointer handling", "function composition with anonymous function and pointer handling", "function composition with anonymous function and pointer handling", "function composition with anonymous function and pointer handling", "function composition with anonymous function and pointer handling", "function composition"], "_raw_llm_output": "conversion, base64 encoding, struct definition, interface definition, function definition, pointer handling, slice iteration, anonymous function, map iteration, function composition, function composition with anonymous function, function composition with anonymous function and pointer handling, function composition with anonymous function and pointer handling, function composition with anonymous function and pointer handling, function composition with anonymous function and pointer handling, function composition with anonymous function and pointer handling, function composition with anonymous function and pointer handling, function composition with anonymous function and pointer handling, function composition with anonymous function and pointer handling, function composition with anonymous function and pointer handling, function composition with anonymous function and pointer handling, function composition with anonymous function and pointer handling, function composition with anonymous function and pointer handling, function composition with anonymous function and pointer handling, function composition with anonymous function and pointer handling, function composition with anonymous function and pointer handling, function composition with anonymous function and pointer handling, function composition with anonymous function and pointer handling, function composition with anonymous function and pointer handling, function composition with anonymous function and pointer handling, function composition with anonymous function and pointer handling, function composition with anonymous function and pointer handling, function composition with anonymous function and pointer handling, function composition with anonymous function and pointer handling, function composition with anonymous function and pointer handling, function composition"}
{"seed": "// PossibleResourceProviderTypeValues returns the possible values for the ResourceProviderType const type.\nfunc PossibleResourceProviderTypeValues() []ResourceProviderType {\n\treturn []ResourceProviderType{\n\t\tResourceProviderTypeAuthorizationFree,\n\t\tResourceProviderTypeExternal,\n\t\tResourceProviderTypeHidden,\n\t\tResourceProviderTypeInternal,\n\t\tResourceProviderTypeLegacyRegistrationRequired,\n\t\tResourceProviderTypeNotSpecified,\n\t\tResourceProviderTypeRegistrationFree,\n\t\tResourceProviderTypeTenantOnly,\n\t}\n}", "id": 19280, "concepts": ["constant definition", "type definition", "array definition", "array iteration"], "_raw_llm_output": "constant definition, type definition, array definition, array iteration"}
{"seed": "// LoggingMiddleware logs the incoming HTTP request & its duration.\nfunc LoggingMiddleware(next http.Handler) http.HandlerFunc {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tstart := time.Now()\n\t\twrapped := wrapResponseWriter(w)\n\t\tnext.ServeHTTP(wrapped, r)\n\t\tLog.Info().Int(\"status\", wrapped.status).Str(\"method\", r.Method).Str(\"path\", r.URL.EscapedPath()).Str(\"duration\", time.Since(start).String()).Msg(\"Request processed\")\n\t})\n}", "id": 19296, "concepts": ["http.HandlerFunc", "middleware", "logging", "time.Since"], "_raw_llm_output": "http.HandlerFunc, middleware, logging, time.Since"}
{"seed": "// authWriteLine writes the given line in the authentication protocol format\n// (elements of data separated by a \" \" and terminated by \"\\r\\n\").\nfunc authWriteLine(out io.Writer, data ...[]byte) error {\n\tbuf := make([]byte, 0)\n\tfor i, v := range data {\n\t\tbuf = append(buf, v...)\n\t\tif i != len(data)-1 {\n\t\t\tbuf = append(buf, ' ')\n\t\t}\n\t}\n\tbuf = append(buf, '\\r')\n\tbuf = append(buf, '\\n')\n\tn, err := out.Write(buf)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif n != len(buf) {\n\t\treturn io.ErrUnexpectedEOF\n\t}\n\treturn nil\n}", "id": 19301, "concepts": ["io.Writer", "io.Write", "io.WriteCloser", "io.Reader", "io.ReadCloser", "io.ReaderFrom", "io.ReaderAt", "io.Seeker", "io.Seek", "io.ByteReader", "io.ByteScanner", "io.RuneReader", "io.RuneScanner", "io.RuneScanner", "io.RuneReader", "io.RuneScanner", "io.ByteReader", "io.ByteScanner", "io.ByteReader", "io.ByteScanner", "io.ByteReader", "io.ByteScanner", "io.ByteReader", "io.ByteScanner", "io.ByteReader", "io.ByteScanner", "io.ByteReader", "io.ByteScanner", "io.ByteReader", "io.ByteScanner", "io.ByteReader", "io.ByteScanner", "io.ByteReader", "io.ByteScanner", "io.ByteReader", "io.ByteScanner", "io.ByteReader", "io.ByteScanner", "io.ByteReader", "io.ByteScanner", "io.ByteReader", "io.ByteScanner", "io.ByteReader", "io.ByteScanner", "io.ByteReader", "io.ByteScanner", "io.ByteReader", "io.ByteScanner", "io.ByteReader", "io.ByteScanner", "io.ByteReader", "io.ByteScanner"], "_raw_llm_output": "io.Writer, io.Write, io.WriteCloser, io.Reader, io.ReadCloser, io.ReaderFrom, io.ReaderAt, io.Seeker, io.Seek, io.ByteReader, io.ByteScanner, io.RuneReader, io.RuneScanner, io.RuneScanner, io.RuneReader, io.RuneScanner, io.ByteReader, io.ByteScanner, io.ByteReader, io.ByteScanner, io.ByteReader, io.ByteScanner, io.ByteReader, io.ByteScanner, io.ByteReader, io.ByteScanner, io.ByteReader, io.ByteScanner, io.ByteReader, io.ByteScanner, io.ByteReader, io.ByteScanner, io.ByteReader, io.ByteScanner, io.ByteReader, io.ByteScanner, io.ByteReader, io.ByteScanner, io.ByteReader, io.ByteScanner, io.ByteReader, io.ByteScanner, io.ByteReader, io.ByteScanner, io.ByteReader, io.ByteScanner, io.ByteReader, io.ByteScanner, io.ByteReader, io.ByteScanner, io.ByteReader, io.ByteScanner"}
{"seed": "// SetSecureStore sets cookies as HTTPOnly and with the Secure bit\n// on in any environment other than development and test. Most of it\n// is ripped straight from the buffalo source code;\n// https://github.com/gobuffalo/buffalo/blob/9f469851d4d4b00652bf49701840ad41037e6a93/options.go#L153-L162\nfunc SetSecureStore(opts buffalo.Options) buffalo.Options {\n\tstore := sessions.NewCookieStore([]byte(getSecret(opts.Env)))\n\tif opts.Env != \"development\" && opts.Env != \"test\" {\n\t\tstore.Options.Secure = true\n\t\tstore.Options.HttpOnly = true\n\t}\n\topts.SessionStore = store\n\treturn opts\n}", "id": 19321, "concepts": ["buffalo", "sessions", "cookie handling", "environment variable handling", "standard library usage"], "_raw_llm_output": "buffalo, sessions, cookie handling, environment variable handling, standard library usage"}
{"seed": "// function with explicit return type\n// if return references are assigned a value. same is returned.\nfunc addSub(x, y int) (sum, sub int){\n\tsum = x+y\n\tsub = x-y // if not initialized, int is assigned as 0 and 0 is returned\n\treturn // return all references\n}", "id": 19324, "concepts": ["function definition", "return type", "explicit return type", "return references"], "_raw_llm_output": "function definition, return type, explicit return type, return references"}
{"seed": "// IntToStringWithFormat creates a binding that connects a Int data item to a String and is\n// presented using the specified format. Changes to the Int will be pushed to the String and setting\n// the string will parse and set the Int if the string matches the format and its parse was successful.\n//\n// Since: 2.0\nfunc IntToStringWithFormat(v Int, format string) String {\n\tif format == \"%d\" { // Same as not using custom formatting.\n\t\treturn IntToString(v)\n\t}\n\n\tstr := &stringFromInt{from: v, format: format}\n\tv.AddListener(str)\n\treturn str\n}", "id": 19328, "concepts": ["struct", "interface", "string formatting", "fmt package usage", "string manipulation", "integer conversion"], "_raw_llm_output": "struct, interface, string formatting, fmt package usage, string manipulation, integer conversion"}
{"seed": "// NewIamServiceProviderAllOf instantiates a new IamServiceProviderAllOf object\n// This constructor will assign default values to properties that have it defined,\n// and makes sure properties required by API are set, but the set of arguments\n// will change when the set of required properties is changed\nfunc NewIamServiceProviderAllOf(classId string, objectType string) *IamServiceProviderAllOf {\n\tthis := IamServiceProviderAllOf{}\n\tthis.ClassId = classId\n\tthis.ObjectType = objectType\n\treturn &this\n}", "id": 19330, "concepts": ["constructor", "basic function definition"], "_raw_llm_output": "constructor, basic function definition"}
{"seed": "// DescriptionNotNil applies the NotNil predicate on the \"description\" field.\nfunc DescriptionNotNil() predicate.User {\n\treturn predicate.User(sql.FieldNotNull(FieldDescription))\n}", "id": 19331, "concepts": ["predicate.User", "sql.FieldNotNull"], "_raw_llm_output": "predicate.User, sql.FieldNotNull"}
{"seed": "// Track_ is a convenience wrapper for Track without the attrs argument.\nfunc Track_() HTML {\n  return Track(nil)\n}", "id": 19333, "concepts": ["function definition", "function call", "function return"], "_raw_llm_output": "function definition, function call, function return"}
{"seed": "// IsValueStruct reports whether v is a struct type.\nfunc IsValueStruct(v reflect.Value) bool {\n\treturn v.Kind() == reflect.Struct\n}", "id": 19335, "concepts": ["reflect package usage", "reflect.Value", "type checking"], "_raw_llm_output": "reflect package usage, reflect.Value, type checking"}
{"seed": "// CombinedOutput builds the given command, starts and waits for the command to successfully complete\n// It returns the combined contents of stderr and stdout as a []byte\n// The command returns an error if there is a non-zero exit code, unless ignoreExitError is enabled\nfunc CombinedOutput(cmd string) ([]byte, error) {\n\tb := New(cmd)\n\tout, err := b.Cmd().CombinedOutput()\n\tif err != nil {\n\t\tif handledErr := b.handleExitError(err); handledErr != nil {\n\t\t\treturn nil, stacktrace.Propagate(err, \"error running command: %v\\nerror: %v\", b.String(), string(out))\n\t\t}\n\t}\n\treturn out, nil\n}", "id": 19338, "concepts": ["error handling", "error propagation", "standard library usage", "command execution"], "_raw_llm_output": "error handling, error propagation, standard library usage, command execution"}
{"seed": "// increaseMarkersIndexCallbackStrategy implements the default strategy for increasing marker Indexes in the Tangle.\nfunc increaseMarkersIndexCallbackStrategy(markers.SequenceID, markers.Index) bool {\n\treturn true\n}", "id": 19343, "concepts": ["callback function", "function definition", "function call"], "_raw_llm_output": "callback function, function definition, function call"}
{"seed": "// ValidateEnabledAPIFields checks that the enable-api-fields feature gate is set\n// to a version at most as stable as wantVersion, if not, returns an error stating which feature\n// is dependent on the version and what the current version actually is.\nfunc ValidateEnabledAPIFields(ctx context.Context, featureName string, wantVersion string) *apis.FieldError {\n\tcurrentVersion := config.FromContextOrDefaults(ctx).FeatureFlags.EnableAPIFields\n\tvar errs *apis.FieldError\n\tmessage := `%s requires \"enable-api-fields\" feature gate to be %s but it is %q`\n\tswitch wantVersion {\n\tcase config.StableAPIFields:\n\t\t// If the feature is stable, it doesn't matter what the current version is\n\tcase config.BetaAPIFields:\n\t\t// If the feature requires \"beta\" fields to be enabled, the current version may be \"beta\" or \"alpha\"\n\t\tif currentVersion != config.BetaAPIFields && currentVersion != config.AlphaAPIFields {\n\t\t\tmessage = fmt.Sprintf(message, featureName, fmt.Sprintf(\"%q or %q\", config.AlphaAPIFields, config.BetaAPIFields), currentVersion)\n\t\t\terrs = apis.ErrGeneric(message)\n\t\t}\n\tcase config.AlphaAPIFields:\n\t\t// If the feature requires \"alpha\" fields to be enabled, the current version must be \"alpha\"\n\t\tif currentVersion != wantVersion {\n\t\t\tmessage = fmt.Sprintf(message, featureName, fmt.Sprintf(\"%q\", config.AlphaAPIFields), currentVersion)\n\t\t\terrs = apis.ErrGeneric(message)\n\t\t}\n\tdefault:\n\t\terrs = apis.ErrGeneric(\"invalid wantVersion %s, must be one of (%s, %s, %s)\", wantVersion, config.AlphaAPIFields, config.BetaAPIFields, config.StableAPIFields)\n\t}\n\treturn errs\n}", "id": 19346, "concepts": ["context", "error handling (apis.FieldError)", "feature flags", "feature gate", "feature gate usage", "string formatting"], "_raw_llm_output": "context, error handling (apis.FieldError), feature flags, feature gate, feature gate usage, string formatting"}
{"seed": "// TriggerEvent triggers a udev event for the device with syspath.\n// The event is generated by writing the event action into\n// syspath/devicename/uevent file. This write will cause UDEV to trigger\n// the corresponding event. It is same as using `udevadm trigger`\nfunc TriggerEvent(event, syspath, devicePath string) error {\n\tsplitName := strings.Split(devicePath, \"/\")\n\tdeviceName := splitName[len(splitName)-1]\n\tfileName := syspath + \"/\" + deviceName + \"/uevent\"\n\tcommand1 := \"echo \" + event\n\tcommand2 := \"sudo tee \" + fileName\n\t_, err := execCommandWithPipe(command1, command2)\n\treturn err\n}", "id": 19350, "concepts": ["string manipulation", "file system", "udev", "exec.Command", "exec.Command.Output", "exec.Command.Run", "exec.Command.CombinedOutput", "exec.Command.Stderr", "exec.Command.Stdin", "exec.Command.Start", "exec.Command.Wait", "exec.Command.Output", "exec.Command.Run", "exec.Command.CombinedOutput", "exec.Command.Stderr", "exec.Command.Stdin", "exec.Command.Start", "exec.Command.Wait", "exec.Command.Output", "exec.Command.Run", "exec.Command.CombinedOutput", "exec.Command.Stderr", "exec.Command.Stdin", "exec.Command.Start", "exec.Command.Wait", "exec.Command.Output", "exec.Command.Run", "exec.Command.CombinedOutput", "exec.Command.Stderr", "exec.Command.Stdin", "exec.Command.Start", "exec.Command.Wait", "exec.Command.Output", "exec.Command.Run", "exec.Command.CombinedOutput", "exec.Command.Stderr", "exec.Command.Stdin", "exec.Command.Start", "exec.Command.Wait", "exec.Command.Output", "exec.Command.Run", "exec.Command.CombinedOutput", "exec."], "_raw_llm_output": "string manipulation, file system, udev, exec.Command, exec.Command.Output, exec.Command.Run, exec.Command.CombinedOutput, exec.Command.Stderr, exec.Command.Stdin, exec.Command.Start, exec.Command.Wait, exec.Command.Output, exec.Command.Run, exec.Command.CombinedOutput, exec.Command.Stderr, exec.Command.Stdin, exec.Command.Start, exec.Command.Wait, exec.Command.Output, exec.Command.Run, exec.Command.CombinedOutput, exec.Command.Stderr, exec.Command.Stdin, exec.Command.Start, exec.Command.Wait, exec.Command.Output, exec.Command.Run, exec.Command.CombinedOutput, exec.Command.Stderr, exec.Command.Stdin, exec.Command.Start, exec.Command.Wait, exec.Command.Output, exec.Command.Run, exec.Command.CombinedOutput, exec.Command.Stderr, exec.Command.Stdin, exec.Command.Start, exec.Command.Wait, exec.Command.Output, exec.Command.Run, exec.Command.CombinedOutput, exec."}
{"seed": "// SetRestAPIConfig assigns the values in \"configFile\" to the 'RestAPIConfig' struct.\n// You should pass \"restAPI_config.yml\" to this function\nfunc SetRestAPIConfig(configFile string) error {\n\n\tyamlData, err := ioutil.ReadFile(configFile)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = yaml.Unmarshal(yamlData, &RestAPIConfig)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn err\n}", "id": 19357, "concepts": ["yaml package usage", "struct assignment", "file I/O"], "_raw_llm_output": "yaml package usage, struct assignment, file I/O"}
{"seed": "// Dfn represents the HTML element 'dfn'.\n// For more information visit https://www.w3schools.com/tags/tag_dfn.asp.\nfunc Dfn(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"dfn\", Attributes: attrs, Children: children}\n}", "id": 19359, "concepts": ["HTML generation", "HTML tree generation", "HTML element definition"], "_raw_llm_output": "HTML generation, HTML tree generation, HTML element definition"}
{"seed": "// \ub9e4\uac1c\ubcc0\uc218\ub85c \ubc1b\uc740 \uc815\uc218\uc758 \uae38\uc774\ub9cc\ud07c\uc758 \ubc14\uc774\ud2b8 \ubc30\uc5f4\uc758 \uac12\uc744 \ub79c\ub364\uc73c\ub85c \ub300\uc785\ud574\uc11c \ubb38\uc790\uc5f4\ub85c \ubcc0\ud658\ud558\uc5ec \ubc18\ud658\ud558\ub294 \ud568\uc218\uc774\ub2e4.\nfunc generateRandomSalt(byteLen int) string {\n\t// \ub9e4\uac1c\ubcc0\uc218\ub85c \ubc1b\uc740 byteLen \uae38\uc774 \ub9cc\ud07c\uc758 \ubc14\uc774\ud2b8 \ubc30\uc5f4\uc744 \uc0dd\uc131\ud55c\ub2e4.\n\tsalt := make([]byte, byteLen)\n\n\t// io.ReadFull \ud568\uc218\uc758 \uccab \ubc88\uc9f8 \ub9e4\uac1c\ubcc0\uc218\uc5d0 rand.Reader\uc744 \uc804\ub2ec\ud558\uba74 \ubc14\uc774\ud2b8 \ubc30\uc5f4\uc758 \uc778\ub371\uc2a4\ub4e4\uc744 \ub79c\ub364\uc758 \uac12\uc73c\ub85c \ucc44\uc6b8 \uc218 \uc788\ub2e4.\n\t_, err := io.ReadFull(rand.Reader, salt)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// \uac01\uac01\uc758 \ubc14\uc774\ud2b8\ub97c 4\ube44\ud2b8\uc529 \ub098\ub204\uc5b4 \uac01\uac01\uc744 16\uc9c4\uc218\ub85c \ubcc0\ud658\ud558\uc5ec \ubb36\uc740 \ub2e4\uc74c \uadf8\uac83\uc744 \uadf8\ub300\ub85c \ubb38\uc790\uc5f4\ub85c \ubcc0\ud658\uc2dc\ucf1c \ubc18\ud658\ud55c\ub2e4.\n\treturn hex.EncodeToString(salt)\n}", "id": 19365, "concepts": ["random number generation", "io.ReadFull", "hex.EncodeToString", "panic"], "_raw_llm_output": "random number generation, io.ReadFull, hex.EncodeToString, panic"}
{"seed": "// NewInternalServerError creates new HTTP InternalServerError(500) error.\nfunc NewInternalServerError(err error, opts ...xerrors.XErrOpt) *xerrors.XErr {\n\treturn NewError(err, \"Internal Server Error\", http.StatusInternalServerError, opts...)\n}", "id": 19374, "concepts": ["error handling (xerrors.XErr)", "error wrapping"], "_raw_llm_output": "error handling (xerrors.XErr), error wrapping"}
{"seed": "// NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded_ARMGenerator returns a generator of NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded_ARM instances for property testing.\nfunc NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded_ARMGenerator() gopter.Gen {\n\tif networkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded_ARMGenerator != nil {\n\t\treturn networkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded_ARMGenerator\n\t}\n\n\tgenerators := make(map[string]gopter.Gen)\n\tAddIndependentPropertyGeneratorsForNetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded_ARM(generators)\n\tnetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded_ARMGenerator = gen.Struct(reflect.TypeOf(NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded_ARM{}), generators)\n\n\treturn networkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded_ARMGenerator\n}", "id": 19381, "concepts": ["struct definition", "property testing", "reflection"], "_raw_llm_output": "struct definition, property testing, reflection"}
{"seed": "// AssertASHandleErrorRequest asserts the given error request.\nfunc AssertASHandleErrorRequest(req as.HandleErrorRequest) Assertion {\n\treturn func(assert *require.Assertions, ts *IntegrationTestSuite) {\n\t\tr := <-ts.ASClient.HandleErrorChan\n\t\tif !proto.Equal(&r, &req) {\n\t\t\tassert.Equal(req, r)\n\t\t}\n\t}\n}", "id": 19406, "concepts": ["interface assertion", "proto.Equal", "channel assertion"], "_raw_llm_output": "interface assertion, proto.Equal, channel assertion"}
{"seed": "// Int64InSlice returns true if the provided int64 is in the provided slice\nfunc Int64InSlice(key int64, list []int64) bool {\n\tfor _, entry := range list {\n\t\tif entry == key {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}", "id": 19420, "concepts": ["slice iteration (range loop)", "integer comparison"], "_raw_llm_output": "slice iteration (range loop), integer comparison"}
{"seed": "// PrepareTerraformRootDir creates a directory named path including all\n// required parents.\n// An error is returned if the directory already exists.\nfunc PrepareTerraformRootDir(path string) error {\n\tpathExists, err := util.PathExists(path)\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"failed to stat path %q: %v\", path, err)\n\t}\n\tif pathExists {\n\t\treturn nil\n\t}\n\tif err := os.MkdirAll(path, 0755); err != nil {\n\t\treturn errors.Wrapf(err, \"failed to create terraform assets directory at: %s\", path)\n\t}\n\treturn nil\n}", "id": 19422, "concepts": ["os.MkdirAll", "os.Stat", "error handling (errors.Wrapf)", "path existence check"], "_raw_llm_output": "os.MkdirAll, os.Stat, error handling (errors.Wrapf), path existence check"}
{"seed": "// TopicConfigFromTopicInfo generates a TopicConfig from a ClusterConfig and admin.TopicInfo\n// struct generated from the cluster state.\nfunc TopicConfigFromTopicInfo(\n\tclusterConfig ClusterConfig,\n\ttopicInfo admin.TopicInfo,\n) TopicConfig {\n\ttopicConfig := TopicConfig{\n\t\tMeta: TopicMeta{\n\t\t\tName:        topicInfo.Name,\n\t\t\tCluster:     clusterConfig.Meta.Name,\n\t\t\tRegion:      clusterConfig.Meta.Region,\n\t\t\tEnvironment: clusterConfig.Meta.Environment,\n\t\t\tDescription: \"Bootstrapped via topicctl bootstrap\",\n\t\t},\n\t\tSpec: TopicSpec{\n\t\t\tPartitions:        len(topicInfo.Partitions),\n\t\t\tReplicationFactor: len(topicInfo.Partitions[0].Replicas),\n\t\t\tPlacementConfig: TopicPlacementConfig{\n\t\t\t\tStrategy: PlacementStrategyAny,\n\t\t\t},\n\t\t},\n\t}\n\n\ttopicConfig.Spec.Settings = FromConfigMap(topicInfo.Config)\n\n\tretentionMinutes := topicInfo.Retention().Minutes()\n\tif retentionMinutes >= 1.0 && float64(int(retentionMinutes)) == retentionMinutes {\n\t\ttopicConfig.Spec.RetentionMinutes = int(retentionMinutes)\n\t\tdelete(topicConfig.Spec.Settings, admin.RetentionKey)\n\t}\n\n\treturn topicConfig\n}", "id": 19426, "concepts": ["struct definition", "map iteration", "map lookup", "map deletion", "map iteration", "map lookup", "map deletion", "map iteration", "map lookup", "map deletion", "map iteration", "map lookup", "map deletion", "map iteration", "map lookup", "map deletion", "map iteration", "map lookup", "map deletion", "map iteration", "map lookup", "map deletion", "map iteration", "map lookup", "map deletion", "map iteration", "map lookup", "map deletion", "map iteration", "map lookup", "map deletion", "map iteration", "map lookup", "map deletion", "map iteration", "map lookup", "map deletion", "map iteration", "map lookup", "map deletion", "map iteration", "map lookup", "map deletion", "map iteration", "map lookup", "map deletion", "map iteration", "map lookup", "map deletion", "map iteration", "map lookup", "map deletion", "map iteration", "map lookup", "map deletion", "map iteration", "map lookup", "map deletion", "map iteration", "map lookup", "map deletion", "map iteration", "map lookup", "map deletion", "map iteration", "map lookup", "map deletion", "map iteration", "map lookup", "map deletion", "map iteration", "map lookup", "map deletion", "map iteration", "map lookup", "map deletion", "map iteration", "map lookup", "map deletion", "map iteration", "map lookup", "map deletion", "map iteration", "map lookup", "map deletion", ""], "_raw_llm_output": "struct definition, map iteration, map lookup, map deletion, map iteration, map lookup, map deletion, map iteration, map lookup, map deletion, map iteration, map lookup, map deletion, map iteration, map lookup, map deletion, map iteration, map lookup, map deletion, map iteration, map lookup, map deletion, map iteration, map lookup, map deletion, map iteration, map lookup, map deletion, map iteration, map lookup, map deletion, map iteration, map lookup, map deletion, map iteration, map lookup, map deletion, map iteration, map lookup, map deletion, map iteration, map lookup, map deletion, map iteration, map lookup, map deletion, map iteration, map lookup, map deletion, map iteration, map lookup, map deletion, map iteration, map lookup, map deletion, map iteration, map lookup, map deletion, map iteration, map lookup, map deletion, map iteration, map lookup, map deletion, map iteration, map lookup, map deletion, map iteration, map lookup, map deletion, map iteration, map lookup, map deletion, map iteration, map lookup, map deletion, map iteration, map lookup, map deletion, map iteration, map lookup, map deletion, map iteration, map lookup, map deletion,"}
{"seed": "// StartTestServiceInternal instantiates a test DB-backed service, returning\n// the derived reindexer and job queue for internal usage.\n// Supported drivers include: postgres.\nfunc StartTestServiceInternal(t *testing.T, dbName, dbDriver string) (reindex.Reindexer, reindex.JobQueue) {\n\tdb := sqorc.OpenCleanForTest(t, dbName, dbDriver)\n\treturn startService(t, db)\n}", "id": 19437, "concepts": ["testing", "sqorc package usage", "testing.T", "testing.B", "testing.T.Parallel", "testing.T.Run", "testing.T.Skip", "testing.T.SkipNow", "testing.T.Fail", "testing.T.FailNow", "testing.T.Fatal", "testing.T.Fatalf", "testing.T.Helper", "testing.T.Log", "testing.T.Logf", "testing.T.Error", "testing.T.Errorf", "testing.T.Helper", "testing.T.Skipf", "testing.T.SkipNowf", "testing.T.Failf", "testing.T.Fatalf", "testing.T.Helperf", "testing.T.Parallel", "testing.T.Run", "testing.T.Skip", "testing.T.SkipNow", "testing.T.Fail", "testing.T.FailNow", "testing.T.Fatal", "testing.T.Fatalf", "testing.T.Helper", "testing.T.Log", "testing.T.Logf", "testing.T.Error", "testing.T.Errorf", "testing.T.Helper", "testing.T.Skipf", "testing.T.SkipNowf", "testing.T.Failf", "testing.T.Fatalf", "testing.T.Helper"], "_raw_llm_output": "testing, sqorc package usage, testing.T, testing.B, testing.T.Parallel, testing.T.Run, testing.T.Skip, testing.T.SkipNow, testing.T.Fail, testing.T.FailNow, testing.T.Fatal, testing.T.Fatalf, testing.T.Helper, testing.T.Log, testing.T.Logf, testing.T.Error, testing.T.Errorf, testing.T.Helper, testing.T.Skipf, testing.T.SkipNowf, testing.T.Failf, testing.T.Fatalf, testing.T.Helperf, testing.T.Parallel, testing.T.Run, testing.T.Skip, testing.T.SkipNow, testing.T.Fail, testing.T.FailNow, testing.T.Fatal, testing.T.Fatalf, testing.T.Helper, testing.T.Log, testing.T.Logf, testing.T.Error, testing.T.Errorf, testing.T.Helper, testing.T.Skipf, testing.T.SkipNowf, testing.T.Failf, testing.T.Fatalf, testing.T.Helper"}
{"seed": "// FindPredictByUserMatch searches for a Predict entity given a userId and a matchId.\n// The pair (user id , match id) should be unique. So if the query returns more than one entity we return 'nil' and write in the error log.\n//\nfunc FindPredictByUserMatch(c appengine.Context, userID, matchID int64) *Predict {\n\tdesc := \"Predict.FindPredictByUserMatch:\"\n\tq := datastore.NewQuery(\"Predict\").\n\t\tFilter(\"UserId\"+\" =\", userID).\n\t\tFilter(\"MatchId\"+\" =\", matchID)\n\n\tvar predicts []*Predict\n\n\tif _, err := q.GetAll(c, &predicts); err == nil {\n\t\tif len(predicts) == 1 {\n\t\t\treturn predicts[0]\n\t\t} else if len(predicts) == 0 {\n\t\t\treturn nil\n\t\t} else {\n\t\t\tlog.Errorf(c, \"%s too many predicts found. pair matchId, UserId should be unique.\", desc)\n\t\t\treturn nil\n\t\t}\n\t} else {\n\t\tlog.Errorf(c, \"%s an error occurred during GetAll: %v\", err)\n\t\treturn nil\n\t}\n}", "id": 19441, "concepts": ["datastore", "datastore query", "datastore entity", "datastore query filter", "datastore query order", "datastore query limit", "datastore query offset", "datastore query ancestor", "datastore query keys only", "datastore query distinct", "datastore query count", "datastore query group", "datastore query group by", "datastore query having", "datastore query distinct on", "datastore query distinct on group by", "datastore query distinct on group by having", "datastore query distinct on group by having count", "datastore query distinct on group by having count order by", "datastore query distinct on group by having count order by limit", "datastore query distinct on group by having count order by limit offset", "datastore query distinct on group by having count order by limit offset", "datastore query distinct on group by having count order by limit offset keys only", "datastore query distinct on group by having count order by limit offset keys only"], "_raw_llm_output": "datastore, datastore query, datastore entity, datastore query filter, datastore query order, datastore query limit, datastore query offset, datastore query ancestor, datastore query keys only, datastore query distinct, datastore query count, datastore query group, datastore query group by, datastore query having, datastore query distinct on, datastore query distinct on group by, datastore query distinct on group by having, datastore query distinct on group by having count, datastore query distinct on group by having count order by, datastore query distinct on group by having count order by limit, datastore query distinct on group by having count order by limit offset, datastore query distinct on group by having count order by limit offset, datastore query distinct on group by having count order by limit offset keys only, datastore query distinct on group by having count order by limit offset keys only"}
{"seed": "// DnsZones_CAA_STATUSGenerator returns a generator of DnsZones_CAA_STATUS instances for property testing.\n// We first initialize dnsZones_CAA_STATUSGenerator with a simplified generator based on the\n// fields with primitive types then replacing it with a more complex one that also handles complex fields\n// to ensure any cycles in the object graph properly terminate.\nfunc DnsZones_CAA_STATUSGenerator() gopter.Gen {\n\tif dnsZones_CAA_STATUSGenerator != nil {\n\t\treturn dnsZones_CAA_STATUSGenerator\n\t}\n\n\tgenerators := make(map[string]gopter.Gen)\n\tAddIndependentPropertyGeneratorsForDnsZones_CAA_STATUS(generators)\n\tdnsZones_CAA_STATUSGenerator = gen.Struct(reflect.TypeOf(DnsZones_CAA_STATUS{}), generators)\n\n\t// The above call to gen.Struct() captures the map, so create a new one\n\tgenerators = make(map[string]gopter.Gen)\n\tAddIndependentPropertyGeneratorsForDnsZones_CAA_STATUS(generators)\n\tAddRelatedPropertyGeneratorsForDnsZones_CAA_STATUS(generators)\n\tdnsZones_CAA_STATUSGenerator = gen.Struct(reflect.TypeOf(DnsZones_CAA_STATUS{}), generators)\n\n\treturn dnsZones_CAA_STATUSGenerator\n}", "id": 19443, "concepts": ["gopter", "property-based testing", "generator", "reflection"], "_raw_llm_output": "gopter, property-based testing, generator, reflection"}
{"seed": "// MapUintInt64Ptr takes two inputs -\n// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list\nfunc MapUintInt64Ptr(f func(*uint) *int64, list []*uint) []*int64 {\n\tif f == nil {\n\t\treturn []*int64{}\n\t}\n\tnewList := make([]*int64, len(list))\n\tfor i, v := range list {\n\t\tnewList[i] = f(v)\n\t}\n\treturn newList\n}", "id": 19444, "concepts": ["function definition", "function pointer", "function composition", "map", "anonymous function", "concurrency", "standard library usage"], "_raw_llm_output": "function definition, function pointer, function composition, map, anonymous function, concurrency, standard library usage"}
{"seed": "// ValueInit() is a wrapper around g_value_init() and allocates and\n// initializes a new Value with the Type t.  A runtime finalizer is set\n// to call g_value_unset() on the underlying GValue after leaving scope.\n// ValueInit() returns a non-nil error if the allocation failed.\nfunc ValueInit(t Type) (*Value, error) {\n\tc := C._g_value_init(C.GType(t))\n\tif c == nil {\n\t\treturn nil, nilPtrErr\n\t}\n\tv := &Value{*c}\n\truntime.SetFinalizer(v, (*Value).unset)\n\treturn v, nil\n}", "id": 19457, "concepts": ["GObject", "GValue", "GType", "GValueInit", "GValueUnset", "runtime.SetFinalizer", "nil pointer handling"], "_raw_llm_output": "GObject, GValue, GType, GValueInit, GValueUnset, runtime.SetFinalizer, nil pointer handling"}
{"seed": "// SocialName applies equality check predicate on the \"social_name\" field. It's identical to SocialNameEQ.\nfunc SocialName(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldSocialName), v))\n\t})\n}", "id": 19463, "concepts": ["sql.Selector", "sql.EQ", "predicate.User"], "_raw_llm_output": "sql.Selector, sql.EQ, predicate.User"}
{"seed": "// New creates a new LekvaV1Client for the given RESTClient.\nfunc New(c rest.Interface) *LekvaV1Client {\n\treturn &LekvaV1Client{c}\n}", "id": 19476, "concepts": ["struct definition", "method definition", "REST client usage"], "_raw_llm_output": "struct definition, method definition, REST client usage"}
{"seed": "// ExtractID is a utility function to check a user/channel string against\n// the pattern '<internalID>' and if it matches return the internalID,true;\n// otherwise return the unmodified string,false.\nfunc ExtractID(u string) (string, bool) {\n\tmatches := idRegex.FindStringSubmatch(u)\n\tif len(matches) > 0 {\n\t\treturn matches[1], true\n\t}\n\treturn u, false\n}", "id": 19477, "concepts": ["regular expression matching", "string manipulation", "string comparison"], "_raw_llm_output": "regular expression matching, string manipulation, string comparison"}
{"seed": "// NewContent instantiates a new Content object\n// This constructor will assign default values to properties that have it defined,\n// and makes sure properties required by API are set, but the set of arguments\n// will change when the set of required properties is changed\nfunc NewContent(name string) *Content {\n\tthis := Content{}\n\tvar accessType string = \"acl\"\n\tthis.AccessType = &accessType\n\tvar runAsCurrentUser bool = false\n\tthis.RunAsCurrentUser = &runAsCurrentUser\n\tthis.Name = name\n\treturn &this\n}", "id": 19479, "concepts": ["constructor", "pointer", "struct", "basic function definition"], "_raw_llm_output": "constructor, pointer, struct, basic function definition"}
{"seed": "// AssetDir returns the file names below a certain\n// directory embedded in the file by go-bindata.\n// For example if you run go-bindata on data/... and data contains the\n// following hierarchy:\n//     data/\n//       foo.txt\n//       img/\n//         a.png\n//         b.png\n// then AssetDir(\"data\") would return []string{\"foo.txt\", \"img\"}\n// AssetDir(\"data/img\") would return []string{\"a.png\", \"b.png\"}\n// AssetDir(\"foo.txt\") and AssetDir(\"notexist\") would return an error\n// AssetDir(\"\") will return []string{\"data\"}.\nfunc AssetDir(name string) ([]string, error) {\n\tnode := _bintree\n\tif len(name) != 0 {\n\t\tcannonicalName := strings.Replace(name, \"\\\\\", \"/\", -1)\n\t\tpathList := strings.Split(cannonicalName, \"/\")\n\t\tfor _, p := range pathList {\n\t\t\tnode = node.Children[p]\n\t\t\tif node == nil {\n\t\t\t\treturn nil, fmt.Errorf(\"Asset %s not found\", name)\n\t\t\t}\n\t\t}\n\t}\n\tif node.Func != nil {\n\t\treturn nil, fmt.Errorf(\"Asset %s not found\", name)\n\t}\n\trv := make([]string, 0, len(node.Children))\n\tfor childName := range node.Children {\n\t\trv = append(rv, childName)\n\t}\n\treturn rv, nil\n}", "id": 19499, "concepts": ["go-bindata", "string manipulation", "map iteration", "error handling"], "_raw_llm_output": "go-bindata, string manipulation, map iteration, error handling"}
{"seed": "// PossiblePolicyModeValues returns an array of possible values for the PolicyMode const type.\nfunc PossiblePolicyModeValues() []PolicyMode {\n\treturn []PolicyMode{PolicyModeDetection, PolicyModePrevention}\n}", "id": 19503, "concepts": ["type definition", "const definition", "array definition"], "_raw_llm_output": "type definition, const definition, array definition"}
{"seed": "// NewRetryWatcher creates a new RetryWatcher.\n// It will make sure that watches gets restarted in case of recoverable errors.\n// The initialResourceVersion will be given to watch method when first called.\nfunc NewRetryWatcher(initialResourceVersion string, watcherClient cache.Watcher) (*RetryWatcher, error) {\n\treturn newRetryWatcher(initialResourceVersion, watcherClient, 1*time.Second)\n}", "id": 19526, "concepts": ["retry logic", "exponential backoff", "time.Sleep", "time.Duration", "time.Ticker", "time.After", "time.AfterFunc", "time.Now", "time.Tick", "time.NewTicker", "time.NewTimer", "time.NewTimer", "time.NewTimer", "time.NewTimer", "time.NewTimer", "time.NewTimer", "time.NewTimer", "time.NewTimer", "time.NewTimer", "time.NewTimer", "time.NewTimer", "time.NewTimer", "time.NewTimer", "time.NewTimer", "time.NewTimer", "time.NewTimer", "time.NewTimer", "time.NewTimer", "time.NewTimer", "time.NewTimer", "time.NewTimer", "time.NewTimer", "time.NewTimer", "time.NewTimer", "time.NewTimer", "time.NewTimer", "time.NewTimer", "time.NewTimer", "time.NewTimer", "time.NewTimer", "time.NewTimer", "time.NewTimer", "time.NewTimer", "time.NewTimer", "time.NewTimer", "time.NewTimer", "time.NewTimer", "time.NewTimer", "time.NewTimer", "time.NewTimer", "time.NewTimer", "time.NewTimer", "time.NewTimer", ""], "_raw_llm_output": "retry logic, exponential backoff, time.Sleep, time.Duration, time.Ticker, time.After, time.AfterFunc, time.Now, time.Tick, time.NewTicker, time.NewTimer, time.NewTimer, time.NewTimer, time.NewTimer, time.NewTimer, time.NewTimer, time.NewTimer, time.NewTimer, time.NewTimer, time.NewTimer, time.NewTimer, time.NewTimer, time.NewTimer, time.NewTimer, time.NewTimer, time.NewTimer, time.NewTimer, time.NewTimer, time.NewTimer, time.NewTimer, time.NewTimer, time.NewTimer, time.NewTimer, time.NewTimer, time.NewTimer, time.NewTimer, time.NewTimer, time.NewTimer, time.NewTimer, time.NewTimer, time.NewTimer, time.NewTimer, time.NewTimer, time.NewTimer, time.NewTimer, time.NewTimer, time.NewTimer, time.NewTimer, time.NewTimer, time.NewTimer, time.NewTimer, time.NewTimer, time.NewTimer,"}
{"seed": "// IsReplicaRebuildingFailed returns true if the rebuilding replica failed not caused by network issues.\nfunc IsReplicaRebuildingFailed(reusableFailedReplica *longhorn.Replica) bool {\n\treplicaRebuildFailedCondition := types.GetCondition(reusableFailedReplica.Status.Conditions, longhorn.ReplicaConditionTypeRebuildFailed)\n\n\tif replicaRebuildFailedCondition.Status != longhorn.ConditionStatusTrue {\n\t\treturn true\n\t}\n\n\tswitch replicaRebuildFailedCondition.Reason {\n\tcase longhorn.ReplicaConditionReasonRebuildFailedDisconnection, longhorn.NodeConditionReasonManagerPodDown, longhorn.NodeConditionReasonKubernetesNodeGone, longhorn.NodeConditionReasonKubernetesNodeNotReady:\n\t\treturn false\n\tdefault:\n\t\treturn true\n\t}\n}", "id": 19535, "concepts": ["struct", "interface", "condition handling", "switch statement", "boolean logic"], "_raw_llm_output": "struct, interface, condition handling, switch statement, boolean logic"}
{"seed": "// NewGetServerStatusParamsWithTimeout creates a new GetServerStatusParams object\n// with the default values initialized, and the ability to set a timeout on a request\nfunc NewGetServerStatusParamsWithTimeout(timeout time.Duration) *GetServerStatusParams {\n\n\treturn &GetServerStatusParams{\n\n\t\ttimeout: timeout,\n\t}\n}", "id": 19541, "concepts": ["struct definition", "anonymous function", "timeout handling"], "_raw_llm_output": "struct definition, anonymous function, timeout handling"}
{"seed": "// StepGraphJSONURL takes a base url like https://storage.googleapis.com/origin-ci-test/pr-logs/pull/openshift_ci-tools/999/pull-ci-openshift-ci-tools-master-validate-vendor/1283812971092381696\n// and returns the full url for the step graph json document.\nfunc StepGraphJSONURL(baseJobURL string) string {\n\treturn strings.Join([]string{baseJobURL, \"artifacts\", CIOperatorStepGraphJSONFilename}, \"/\")\n}", "id": 19548, "concepts": ["string manipulation", "string concatenation", "string joining", "string splitting"], "_raw_llm_output": "string manipulation, string concatenation, string joining, string splitting"}
{"seed": "// Canvas represents the HTML element 'canvas'.\n// For more information visit https://www.w3schools.com/tags/tag_canvas.asp.\nfunc Canvas(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"canvas\", Attributes: attrs, Children: children}\n}", "id": 19552, "concepts": ["HTML generation", "HTML element definition", "HTML attribute definition"], "_raw_llm_output": "HTML generation, HTML element definition, HTML attribute definition"}
{"seed": "// NetworkInterfaceDnsSettings_ARMGenerator returns a generator of NetworkInterfaceDnsSettings_ARM instances for property testing.\nfunc NetworkInterfaceDnsSettings_ARMGenerator() gopter.Gen {\n\tif networkInterfaceDnsSettings_ARMGenerator != nil {\n\t\treturn networkInterfaceDnsSettings_ARMGenerator\n\t}\n\n\tgenerators := make(map[string]gopter.Gen)\n\tAddIndependentPropertyGeneratorsForNetworkInterfaceDnsSettings_ARM(generators)\n\tnetworkInterfaceDnsSettings_ARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceDnsSettings_ARM{}), generators)\n\n\treturn networkInterfaceDnsSettings_ARMGenerator\n}", "id": 19567, "concepts": ["struct definition", "property generators", "reflect package usage"], "_raw_llm_output": "struct definition, property generators, reflect package usage"}
{"seed": "// StringToFloatWithFormat creates a binding that connects a String data item to a Float and is\n// presented using the specified format. Changes to the Float will be parsed and if the format matches and\n// the parse is successful it will be pushed to the String. Setting the Float will push a formatted value\n// into the String.\n//\n// Since: 2.0\nfunc StringToFloatWithFormat(str String, format string) Float {\n\tif format == \"%f\" { // Same as not using custom format.\n\t\treturn StringToFloat(str)\n\t}\n\n\tv := &stringToFloat{from: str, format: format}\n\tstr.AddListener(v)\n\treturn v\n}", "id": 19570, "concepts": ["string formatting", "fmt package usage", "string manipulation", "rune handling", "character comparison"], "_raw_llm_output": "string formatting, fmt package usage, string manipulation, rune handling, character comparison"}
{"seed": "// HandleTransactionUpdate returns a convenience http.HandlerFunc for getting\n// notifications from Vipps about transaction updates.\n//\n// The provided authToken, if not empty, will be matched with the\n// `Authorization` header of the incoming requests. If they don't match, the\n// request will fail.\n//\n// `cb` will be called with the TransactionUpdate. Please be aware that for\n// payments of PaymentTypeRegular, the fields `ShippingDetails` and\n// `UserDetails` will be nil.\nfunc HandleTransactionUpdate(authToken string, cb func(t TransactionUpdate)) http.HandlerFunc {\n\tfn := func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodPost {\n\t\t\tw.Header().Set(\"ALLOW\", \"POST\")\n\t\t\thttp.Error(w, \"Unsupported method\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\t\tif authToken != \"\" && r.Header.Get(\"Authorization\") != authToken {\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tvar t TransactionUpdate\n\t\tbodyDec := json.NewDecoder(r.Body)\n\t\tdefer r.Body.Close()\n\n\t\terr := bodyDec.Decode(&t)\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\tcb(t)\n\t}\n\treturn fn\n}", "id": 19573, "concepts": ["http.HandlerFunc", "http.ResponseWriter", "http.Request", "json.Decoder", "json.Decode", "http.Error", "http.StatusMethodNotAllowed", "http.StatusUnauthorized", "http.MethodPost", "http.Header", "http.Request.Header", "http.Request.Body", "http.Request.Close", "json.NewDecoder", "json.Decode", "errors.New"], "_raw_llm_output": "http.HandlerFunc, http.ResponseWriter, http.Request, json.Decoder, json.Decode, http.Error, http.StatusMethodNotAllowed, http.StatusUnauthorized, http.MethodPost, http.Header, http.Request.Header, http.Request.Body, http.Request.Close, json.NewDecoder, json.Decode, errors.New"}
{"seed": "// Source_ is a convenience wrapper for Source without the attrs argument.\nfunc Source_() HTML {\n  return Source(nil)\n}", "id": 19594, "concepts": ["struct composition", "anonymous struct", "function composition"], "_raw_llm_output": "struct composition, anonymous struct, function composition"}
{"seed": "// beerInfoTestClient builds upon testClient, and adds additional sanity checks\n// for tests which target the beer info API.\nfunc beerInfoTestClient(t *testing.T, fn func(t *testing.T, w http.ResponseWriter, r *http.Request)) (*Client, func()) {\n\treturn testClient(t, func(t *testing.T, w http.ResponseWriter, r *http.Request) {\n\t\t// Always GET request\n\t\tmethod := \"GET\"\n\t\tif m := r.Method; m != method {\n\t\t\tt.Fatalf(\"unexpected HTTP method: %q != %q\", m, method)\n\t\t}\n\n\t\t// Always uses specific path prefix\n\t\tprefix := \"/v4/beer/info/\"\n\t\tif p := r.URL.Path; !strings.HasPrefix(p, prefix) {\n\t\t\tt.Fatalf(\"unexpected HTTP path prefix: %q != %q\", p, prefix)\n\t\t}\n\n\t\t// Guard against panics\n\t\tif fn != nil {\n\t\t\tfn(t, w, r)\n\t\t}\n\t})\n}", "id": 19599, "concepts": ["string comparison", "string manipulation", "HTTP request handling"], "_raw_llm_output": "string comparison, string manipulation, HTTP request handling"}
{"seed": "// NewRegisterExternalDomainRequestWithBody generates requests for RegisterExternalDomain with any type of body\nfunc NewRegisterExternalDomainRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {\n\tvar err error\n\n\tqueryUrl, err := url.Parse(server)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbasePath := fmt.Sprintf(\"/domain/v2alpha2/domains/external-domain\")\n\tif basePath[0] == '/' {\n\t\tbasePath = basePath[1:]\n\t}\n\n\tqueryUrl, err = queryUrl.Parse(basePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq, err := http.NewRequest(\"POST\", queryUrl.String(), body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Add(\"Content-Type\", contentType)\n\treturn req, nil\n}", "id": 19604, "concepts": ["URL parsing", "HTTP request generation", "URL encoding", "standard library usage"], "_raw_llm_output": "URL parsing, HTTP request generation, URL encoding, standard library usage"}
{"seed": "// WithReconcilePeriod is an Option that configures the reconcile period of the\n// controller. This will cause the controller to reconcile CRs at least once\n// every period. By default, the reconcile period is set to 0, which means no\n// time-based reconciliations will occur.\nfunc WithReconcilePeriod(rp time.Duration) Option {\n\treturn func(r *Reconciler) error {\n\t\tif rp < 0 {\n\t\t\treturn errors.New(\"reconcile period must not be negative\")\n\t\t}\n\t\tr.reconcilePeriod = rp\n\t\treturn nil\n\t}\n}", "id": 19633, "concepts": ["struct definition", "struct field definition", "struct field initialization", "struct field access", "struct field assignment", "struct field type assertion", "struct field type assertion", "struct field type assertion", "struct field type assertion", "struct field type assertion", "struct field type assertion", "struct field type assertion", "struct field type assertion", "struct field type assertion", "struct field type assertion", "struct field type assertion", "struct field type assertion", "struct field type assertion", "struct field type assertion", "struct field type assertion", "struct field type assertion", "struct field type assertion", "struct field type assertion", "struct field type assertion", "struct field type assertion", "struct field type assertion", "struct field type assertion", "struct field type assertion", "struct field type assertion", "struct field type assertion", "struct field type assertion", "struct field type assertion", "struct field type assertion", "struct field type assertion", "struct field type assertion", "struct field type assertion", "struct field type assertion", "struct field type assertion", "struct field type assertion", "struct field type assertion", "struct field type assertion", "struct field type assertion", "struct field type assertion", "struct field type assertion", "struct field type assertion", "struct field type assertion", "struct field type assertion", "struct field type assertion", "struct field type assertion", "struct field type assertion", "struct field type assertion", "struct field type assertion", "struct"], "_raw_llm_output": "struct definition, struct field definition, struct field initialization, struct field access, struct field assignment, struct field type assertion, struct field type assertion, struct field type assertion, struct field type assertion, struct field type assertion, struct field type assertion, struct field type assertion, struct field type assertion, struct field type assertion, struct field type assertion, struct field type assertion, struct field type assertion, struct field type assertion, struct field type assertion, struct field type assertion, struct field type assertion, struct field type assertion, struct field type assertion, struct field type assertion, struct field type assertion, struct field type assertion, struct field type assertion, struct field type assertion, struct field type assertion, struct field type assertion, struct field type assertion, struct field type assertion, struct field type assertion, struct field type assertion, struct field type assertion, struct field type assertion, struct field type assertion, struct field type assertion, struct field type assertion, struct field type assertion, struct field type assertion, struct field type assertion, struct field type assertion, struct field type assertion, struct field type assertion, struct field type assertion, struct field type assertion, struct field type assertion, struct field type assertion, struct field type assertion, struct field type assertion, struct field type assertion, struct"}
{"seed": "// NewRect creates a rect with the given coordinates\n// and dimensions.\nfunc NewRect(x, y, width, height int) Rect {\n\treturn Rect{x, y, width, height}\n}", "id": 19645, "concepts": ["struct definition", "struct field access"], "_raw_llm_output": "struct definition, struct field access"}
{"seed": "// New returns an error with the supplied message.\n// New also records the stack trace at the point it was called.\nfunc New(class int, code Code, v ...interface{}) *Error {\n\tvar format, message string\n\tif len(v) == 0 {\n\t\tformat = \"\"\n\t} else {\n\t\tvar ok bool\n\t\tformat, ok = v[0].(string)\n\t\tif !ok {\n\t\t\tformat = strings.Repeat(\"%v\", len(v))\n\t\t} else {\n\t\t\tv = v[1:]\n\t\t}\n\t}\n\tmessage = fmt.Sprintf(format, v...)\n\n\te := &Error{}\n\te.Description = message\n\te.Class = int32(class)\n\te.Stack = getStack(1)\n\te.Created = time.Now().UnixNano()\n\te.Code = code.String()\n\treturn e\n}", "id": 19649, "concepts": ["error handling (error struct)", "stack trace", "error message formatting"], "_raw_llm_output": "error handling (error struct), stack trace, error message formatting"}
{"seed": "// NewDcimRacksListParamsWithHTTPClient creates a new DcimRacksListParams object\n// with the ability to set a custom HTTPClient for a request.\nfunc NewDcimRacksListParamsWithHTTPClient(client *http.Client) *DcimRacksListParams {\n\treturn &DcimRacksListParams{\n\t\tHTTPClient: client,\n\t}\n}", "id": 19656, "concepts": ["function definition", "function parameter", "function return value", "function pointer", "struct definition", "struct field", "struct field access", "struct field initialization", "HTTPClient field", "HTTPClient field access", "HTTPClient field initialization", "HTTPClient field usage"], "_raw_llm_output": "function definition, function parameter, function return value, function pointer, struct definition, struct field, struct field access, struct field initialization, HTTPClient field, HTTPClient field access, HTTPClient field initialization, HTTPClient field usage"}
{"seed": "// DescriptionIn applies the In predicate on the \"description\" field.\nfunc DescriptionIn(vs ...string) predicate.User {\n\treturn predicate.User(sql.FieldIn(FieldDescription, vs...))\n}", "id": 19659, "concepts": ["sql.FieldIn", "sql.FieldNotIn", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldBetween", "sql.FieldNotBetween", "sql.FieldIsNull", "sql.FieldIsNotNull", "sql.FieldEq", "sql.FieldNotEq", "sql.FieldGt", "sql.FieldGte", "sql.FieldLt", "sql.FieldLte", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldBetween", "sql.FieldNotBetween", "sql.FieldIsNull", "sql.FieldIsNotNull", "sql.FieldEq", "sql.FieldNotEq", "sql.FieldGt", "sql.FieldGte", "sql.FieldLt", "sql.FieldLte", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldBetween", "sql.FieldNotBetween", "sql.FieldIsNull", "sql.FieldIsNotNull", "sql.FieldEq", "sql.FieldNotEq", "sql.FieldGt", "sql.FieldGte", "sql.FieldLt", "sql.FieldLte", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldBetween", "sql.FieldNot"], "_raw_llm_output": "sql.FieldIn, sql.FieldNotIn, sql.FieldLike, sql.FieldNotLike, sql.FieldBetween, sql.FieldNotBetween, sql.FieldIsNull, sql.FieldIsNotNull, sql.FieldEq, sql.FieldNotEq, sql.FieldGt, sql.FieldGte, sql.FieldLt, sql.FieldLte, sql.FieldIn, sql.FieldNotIn, sql.FieldLike, sql.FieldNotLike, sql.FieldBetween, sql.FieldNotBetween, sql.FieldIsNull, sql.FieldIsNotNull, sql.FieldEq, sql.FieldNotEq, sql.FieldGt, sql.FieldGte, sql.FieldLt, sql.FieldLte, sql.FieldIn, sql.FieldNotIn, sql.FieldLike, sql.FieldNotLike, sql.FieldBetween, sql.FieldNotBetween, sql.FieldIsNull, sql.FieldIsNotNull, sql.FieldEq, sql.FieldNotEq, sql.FieldGt, sql.FieldGte, sql.FieldLt, sql.FieldLte, sql.FieldIn, sql.FieldNotIn, sql.FieldLike, sql.FieldNotLike, sql.FieldBetween, sql.FieldNot"}
{"seed": "// AssetDigest returns the digest of the file with the given name. It returns an\n// error if the asset could not be found or the digest could not be loaded.\nfunc AssetDigest(name string) ([sha256.Size]byte, error) {\n\tcanonicalName := strings.Replace(name, \"\\\\\", \"/\", -1)\n\tif f, ok := _bindata[canonicalName]; ok {\n\t\ta, err := f()\n\t\tif err != nil {\n\t\t\treturn [sha256.Size]byte{}, fmt.Errorf(\"AssetDigest %s can't read by error: %v\", name, err)\n\t\t}\n\t\treturn a.digest, nil\n\t}\n\treturn [sha256.Size]byte{}, fmt.Errorf(\"AssetDigest %s not found\", name)\n}", "id": 19673, "concepts": ["bindata", "sha256", "error handling", "standard library usage"], "_raw_llm_output": "bindata, sha256, error handling, standard library usage"}
{"seed": "// NewComponent returns an Item of type Component without content.\nfunc NewComponent() Component {\n\tnow := time.Now().UTC().Format(timeLayout)\n\n\tvar c Component\n\n\tc.ContentType = \"SN|Component\"\n\tc.CreatedAtTimestamp = time.Now().UTC().UnixMicro()\n\tc.CreatedAt = now\n\tc.UUID = GenUUID()\n\n\treturn c\n}", "id": 19675, "concepts": ["time package usage", "time formatting", "UUID generation"], "_raw_llm_output": "time package usage, time formatting, UUID generation"}
{"seed": "// TimeToCFDate will convert the given time.Time to a CFDateRef, which\n// must be released with Release(ref).\nfunc TimeToCFDate(t time.Time) C.CFDateRef {\n\ts := t.Unix()\n\tns := int64(t.Nanosecond())\n\tabs := unixToAbsoluteTime(s, ns)\n\treturn C.CFDateCreate(C.kCFAllocatorDefault, abs)\n}", "id": 19681, "concepts": ["time package usage", "CFDateRef", "CFAllocatorRef", "C.CFDateCreate", "C.CFRelease"], "_raw_llm_output": "time package usage, CFDateRef, CFAllocatorRef, C.CFDateCreate, C.CFRelease"}
{"seed": "// NewMultipleMetricsParamsWithContext creates a new MultipleMetricsParams object\n// with the default values initialized, and the ability to set a context for a request\nfunc NewMultipleMetricsParamsWithContext(ctx context.Context) *MultipleMetricsParams {\n\tvar ()\n\treturn &MultipleMetricsParams{\n\n\t\tContext: ctx,\n\t}\n}", "id": 19685, "concepts": ["context", "function definition", "function parameter", "function return value"], "_raw_llm_output": "context, function definition, function parameter, function return value"}
{"seed": "// NewBuilder returns a new Builder instance, ready to emit a gzip\n// compressed CPTV file to the provided Writer.\nfunc NewBuilder(w io.Writer) *Builder {\n\treturn &Builder{\n\t\tw: gzip.NewWriter(w),\n\t}\n}", "id": 19706, "concepts": ["io.Writer", "gzip.NewWriter", "io.Closer", "io.WriterCloser", "io.ReadWriter"], "_raw_llm_output": "io.Writer, gzip.NewWriter, io.Closer, io.WriterCloser, io.ReadWriter"}
{"seed": "// processConfig marks the config as existing and corrects its .spec.parent field if it's wrong. It\n// ignores the object if it's not a HierarchyConfiguration.\nfunc processConfig(item *yaml.RNode, meta yaml.ResourceMeta) error {\n\tif meta.APIVersion != \"hnc.x-k8s.io/v1alpha2\" || meta.Kind != \"HierarchyConfiguration\" {\n\t\treturn nil\n\t}\n\tns := forest[meta.Namespace]\n\tns.hasConfig = true\n\n\tspec, err := item.Pipe(yaml.Get(\"spec\"))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"couldn't get spec: %w\", err)\n\t}\n\tparent, err := spec.Pipe(yaml.Get(\"parent\"))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"couldn't get spec.parent: %w\", err)\n\t}\n\n\toldParent := strings.TrimSpace(parent.MustString())\n\tif oldParent != ns.parent {\n\t\tfmt.Fprintf(os.Stderr, \"HC config for %q has the wrong parent %q; updating to %q\\n\", meta.Namespace, oldParent, ns.parent)\n\t\tif err := spec.PipeE(yaml.SetField(\"parent\", yaml.MustParse(ns.parent))); err != nil {\n\t\t\treturn fmt.Errorf(\"couldn't update HC config: %s\\n\", err)\n\t\t}\n\t}\n\treturn nil\n}", "id": 19708, "concepts": ["yaml package usage", "string manipulation", "string trimming", "string formatting", "string comparison", "string concatenation", "string conversion", "error handling (errors.Is)", "function definition", "function return values", "function parameters", "function arguments", "function calls", "function scope", "function closures", "function recursion", "function pointers", "function interfaces", "function type", "function type assertion", "function type switch", "function type switch case", "function type switch default", "function type switch fallthrough", "function type switch break", "function type switch continue", "function type switch return", "function type switch return value", "function type switch return value type", "function type switch return value type assertion", "function type switch return value type assertion", "function type switch return value type assertion value", "function type switch return value type assertion value type", "function type switch return value type assertion value type assertion", "function type switch return value type assertion value type assertion value", "function type switch return value type assertion value type assertion value type", "function type switch return value type assertion value type assertion value type assertion", "function type switch return value type assertion value type assertion value type assertion value", "function type switch return value type assertion value type assertion value type assertion value type", "function type switch return value type assertion value type assertion value type assertion value type assertion", "function type switch"], "_raw_llm_output": "yaml package usage, string manipulation, string trimming, string formatting, string comparison, string concatenation, string conversion, error handling (errors.Is), function definition, function return values, function parameters, function arguments, function calls, function scope, function closures, function recursion, function pointers, function interfaces, function type, function type assertion, function type switch, function type switch case, function type switch default, function type switch fallthrough, function type switch break, function type switch continue, function type switch return, function type switch return value, function type switch return value type, function type switch return value type assertion, function type switch return value type assertion, function type switch return value type assertion value, function type switch return value type assertion value type, function type switch return value type assertion value type assertion, function type switch return value type assertion value type assertion value, function type switch return value type assertion value type assertion value type, function type switch return value type assertion value type assertion value type assertion, function type switch return value type assertion value type assertion value type assertion value, function type switch return value type assertion value type assertion value type assertion value type, function type switch return value type assertion value type assertion value type assertion value type assertion, function type switch"}
{"seed": "// DefaultOracleParams returns the default instance of OracleParams\nfunc DefaultOracleParams() OracleParams {\n\treturn NewOracleParams(\n\t\t32,\n\t\t10,\n\t\t6,\n\t\t50_000,\n\t\t200_000,\n\t\t\"desmos-ibc-profiles\",\n\t\tsdk.NewCoin(\"band\", sdk.NewInt(10)),\n\t)\n}", "id": 19712, "concepts": ["struct definition", "struct initialization", "SDK usage"], "_raw_llm_output": "struct definition, struct initialization, SDK usage"}
{"seed": "// NewEntityClient creates a new EntityClient given a store, an event store and\n// an authorizer.\nfunc NewEntityClient(store store.ResourceStore, eventStore store.EventStore, auth authorization.Authorizer) *EntityClient {\n\treturn &EntityClient{\n\t\tclient: &GenericClient{\n\t\t\tAuth:       auth,\n\t\t\tStore:      store,\n\t\t\tKind:       &corev2.Entity{},\n\t\t\tAPIGroup:   \"core\",\n\t\t\tAPIVersion: \"v2\",\n\t\t},\n\t\teventStore: eventStore,\n\t\tauth:       auth,\n\t}\n}", "id": 19722, "concepts": ["struct definition", "pointer usage", "method definition", "anonymous struct definition", "method receiver", "method receiver type", "method receiver name", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type", "method receiver type"], "_raw_llm_output": "struct definition, pointer usage, method definition, anonymous struct definition, method receiver, method receiver type, method receiver name, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type, method receiver type"}
{"seed": "// WithMaxRetries defines the number of maximum retries for a failed task.\nfunc WithMaxRetries(maxRetries int) Option {\n\treturn func(opts *Options) {\n\t\topts.MaxRetries = maxRetries\n\t}\n}", "id": 19723, "concepts": ["function composition", "function options", "function options composition"], "_raw_llm_output": "function composition, function options, function options composition"}
{"seed": "// SetLanguage sets the program's current locale. If the language is not\n// supported, then the default locale is used.\nfunc SetLanguage(language string) {\n\tif _, ok := supportedTranslations[language]; ok {\n\t\tgotext.SetLanguage(language)\n\t\treturn\n\t}\n\tgotext.SetLanguage(defaultLanguage)\n}", "id": 19725, "concepts": ["map lookup", "map iteration", "map key lookup", "string comparison", "standard library usage"], "_raw_llm_output": "map lookup, map iteration, map key lookup, string comparison, standard library usage"}
{"seed": "// convertLogs converts an array of geth logs ([]type.Log) to an array of logpoller logs ([]Log)\n//\n//\tBlock timestamps are extracted from blocks param.  If len(blocks) == 1, the same timestamp from this block\n//\twill be used for all logs.  If len(blocks) == len(logs) then the block number of each block is used for the\n//\tcorresponding log.  Any other length for blocks is invalid.\nfunc convertLogs(logs []types.Log, blocks []LogPollerBlock, lggr logger.Logger, chainID *big.Int) []Log {\n\tvar lgs []Log\n\tblockTimestamp := time.Now()\n\tif len(logs) == 0 {\n\t\treturn lgs\n\t}\n\tif len(blocks) != 1 && len(blocks) != len(logs) {\n\t\tlggr.Errorf(\"AssumptionViolation:  invalid params passed to convertLogs, length of blocks must either be 1 or match length of logs\")\n\t\treturn lgs\n\t}\n\n\tfor i, l := range logs {\n\t\tif i == 0 || len(blocks) == len(logs) {\n\t\t\tblockTimestamp = blocks[i].BlockTimestamp\n\t\t}\n\t\tlgs = append(lgs, Log{\n\t\t\tEvmChainId: utils.NewBig(chainID),\n\t\t\tLogIndex:   int64(l.Index),\n\t\t\tBlockHash:  l.BlockHash,\n\t\t\t// We assume block numbers fit in int64\n\t\t\t// in many places.\n\t\t\tBlockNumber:    int64(l.BlockNumber),\n\t\t\tBlockTimestamp: blockTimestamp,\n\t\t\tEventSig:       l.Topics[0], // First topic is always event signature.\n\t\t\tTopics:         convertTopics(l.Topics),\n\t\t\tAddress:        l.Address,\n\t\t\tTxHash:         l.TxHash,\n\t\t\tData:           l.Data,\n\t\t})\n\t}\n\treturn lgs\n}", "id": 19734, "concepts": ["type conversion", "basic function definition", "basic function call"], "_raw_llm_output": "type conversion, basic function definition, basic function call"}
{"seed": "// NewBuilder returns a validationBuilder object that implements the ValidationBuilder interface.\nfunc NewBuilder() ValidationBuilder {\n\treturn &validationBuilder{}\n}", "id": 19742, "concepts": ["interface", "basic function definition", "method definition"], "_raw_llm_output": "interface, basic function definition, method definition"}
{"seed": "// PrivateLinkServiceConnectionStateGenerator returns a generator of PrivateLinkServiceConnectionState instances for property testing.\nfunc PrivateLinkServiceConnectionStateGenerator() gopter.Gen {\n\tif privateLinkServiceConnectionStateGenerator != nil {\n\t\treturn privateLinkServiceConnectionStateGenerator\n\t}\n\n\tgenerators := make(map[string]gopter.Gen)\n\tAddIndependentPropertyGeneratorsForPrivateLinkServiceConnectionState(generators)\n\tprivateLinkServiceConnectionStateGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServiceConnectionState{}), generators)\n\n\treturn privateLinkServiceConnectionStateGenerator\n}", "id": 19744, "concepts": ["reflection", "struct definition", "map definition", "generator definition"], "_raw_llm_output": "reflection, struct definition, map definition, generator definition"}
{"seed": "// SocialNameNEQ applies the NEQ predicate on the \"social_name\" field.\nfunc SocialNameNEQ(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldSocialName), v))\n\t})\n}", "id": 19748, "concepts": ["sql package usage", "sql.Selector", "sql.C", "sql.NEQ", "sql.Where", "sql.FieldSocialName", "predicate.User", "function definition"], "_raw_llm_output": "sql package usage, sql.Selector, sql.C, sql.NEQ, sql.Where, sql.FieldSocialName, predicate.User, function definition"}
{"seed": "// Step 2 is the removal of the \"\u0456\" suffix.\n//\nfunc step2(word *snowballword.SnowballWord) bool {\n\tsuffix, _ := word.RemoveFirstSuffixIn(word.RVstart, \"\u0456\")\n\tif suffix != \"\" {\n\t\treturn true\n\t}\n\treturn false\n}", "id": 19749, "concepts": ["string manipulation", "string iteration", "string removal", "string concatenation"], "_raw_llm_output": "string manipulation, string iteration, string removal, string concatenation"}
{"seed": "// New returns a release for the current year and month with a zero\n// iteration counter.\nfunc New() Release {\n\tnow := time.Now()\n\n\treturn Release{\n\t\tYear:  now.Year(),\n\t\tMonth: int(now.Month()),\n\t}\n}", "id": 19751, "concepts": ["time package usage", "time.Now", "time.Month", "time.Year", "struct definition"], "_raw_llm_output": "time package usage, time.Now, time.Month, time.Year, struct definition"}
{"seed": "// NewAPIComposer returns a new Composer that composes infrastructure resources\n// in a Kubernetes API server.\nfunc NewAPIComposer(c client.Client) *APIComposer {\n\treturn &APIComposer{\n\t\tclient: resource.ClientApplicator{\n\t\t\tClient:     c,\n\t\t\tApplicator: resource.NewAPIPatchingApplicator(c),\n\t\t},\n\t}\n}", "id": 19752, "concepts": ["client-go", "resource.ClientApplicator", "resource.NewAPIPatchingApplicator", "client.Client", "client.Applicator", "client.Patcher", "client.Patch", "resource.ApplyOptions", "resource.Apply", "resource.ApplyResult", "resource.ApplyError", "resource.ApplyErrorList", "resource.ApplyErrorList.Error", "resource.ApplyErrorList.Error.Error", "resource.ApplyErrorList.Error.Error.Error", "resource.ApplyErrorList.Error.Error.Error.Error", "resource.ApplyErrorList.Error.Error.Error.Error.Error", "resource.ApplyErrorList.Error.Error.Error.Error.Error.Error", "resource.ApplyErrorList.Error.Error.Error.Error.Error.Error.Error", "resource.ApplyErrorList.Error.Error.Error.Error.Error.Error.Error.Error", "resource.ApplyErrorList.Error.Error.Error.Error.Error.Error.Error.Error.Error", "resource.ApplyErrorList.Error.Error.Error.Error.Error.Error.Error.Error.Error.Error", "resource.ApplyErrorList.Error.Error.Error.Error.Error.Error.Error.Error.Error"], "_raw_llm_output": "client-go, resource.ClientApplicator, resource.NewAPIPatchingApplicator, client.Client, client.Applicator, client.Patcher, client.Patch, resource.ApplyOptions, resource.Apply, resource.ApplyResult, resource.ApplyError, resource.ApplyErrorList, resource.ApplyErrorList.Error, resource.ApplyErrorList.Error.Error, resource.ApplyErrorList.Error.Error.Error, resource.ApplyErrorList.Error.Error.Error.Error, resource.ApplyErrorList.Error.Error.Error.Error.Error, resource.ApplyErrorList.Error.Error.Error.Error.Error.Error, resource.ApplyErrorList.Error.Error.Error.Error.Error.Error.Error, resource.ApplyErrorList.Error.Error.Error.Error.Error.Error.Error.Error, resource.ApplyErrorList.Error.Error.Error.Error.Error.Error.Error.Error.Error, resource.ApplyErrorList.Error.Error.Error.Error.Error.Error.Error.Error.Error.Error, resource.ApplyErrorList.Error.Error.Error.Error.Error.Error.Error.Error.Error"}
{"seed": "// InsertIntoMap inserts value with key into parent which must be a map, map ptr, or interface to map.\nfunc InsertIntoMap(parentMap interface{}, key interface{}, value interface{}) error {\n\tscope.Debugf(\"InsertIntoMap key=%v, value=%s, map=\\n%s\", key, pretty.Sprint(value), pretty.Sprint(parentMap))\n\tv := reflect.ValueOf(parentMap)\n\tkv := reflect.ValueOf(key)\n\tvv := reflect.ValueOf(value)\n\n\tif v.Type().Kind() == reflect.Ptr {\n\t\tv = v.Elem()\n\t}\n\tif v.Type().Kind() == reflect.Interface {\n\t\tv = v.Elem()\n\t}\n\n\tif v.Type().Kind() != reflect.Map {\n\t\tscope.Debugf(\"error %v\", v.Type().Kind())\n\t\treturn fmt.Errorf(\"insertIntoMap parent type is %T, must be map\", parentMap)\n\t}\n\n\tv.SetMapIndex(kv, vv)\n\n\treturn nil\n}", "id": 19771, "concepts": ["reflect package usage", "map insertion", "interface to map"], "_raw_llm_output": "reflect package usage, map insertion, interface to map"}
{"seed": "// Must acts as New, but panics if an error is reported. This function exists\n// to support static initialization.\nfunc Must(lhs, rhs string, binds pattern.Binds) *T {\n\tt, err := New(lhs, rhs, binds)\n\tif err != nil {\n\t\tpanic(\"transform: \" + err.Error())\n\t}\n\treturn t\n}", "id": 19774, "concepts": ["error handling (panic)", "pattern matching", "static initialization"], "_raw_llm_output": "error handling (panic), pattern matching, static initialization"}
{"seed": "// HasPrefix tests whether the string s begins with prefix.\nfunc HasPrefix(s, prefix string) bool {\n\tif len(s) < len(prefix) {\n\t\treturn false\n\t}\n\tfor i := 0; i < len(prefix); i++ {\n\t\tif s[i] != prefix[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}", "id": 19779, "concepts": ["string manipulation", "character comparison"], "_raw_llm_output": "string manipulation, character comparison"}
{"seed": "// hasMeta determines if a path has special chars used to build a Regexp.\nfunc hasMeta(path string) bool {\n\treturn strings.IndexAny(path, \"*?[{\") >= 0\n}", "id": 19796, "concepts": ["string manipulation", "string search"], "_raw_llm_output": "string manipulation, string search"}
{"seed": "// NewCancelWorkflowExecutionParams creates a new CancelWorkflowExecutionParams object\n// with the default values initialized.\nfunc NewCancelWorkflowExecutionParams() *CancelWorkflowExecutionParams {\n\tvar ()\n\treturn &CancelWorkflowExecutionParams{\n\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 19807, "concepts": ["struct initialization", "struct field initialization", "struct field declaration"], "_raw_llm_output": "struct initialization, struct field initialization, struct field declaration"}
{"seed": "// makeCommR generates a \"fake\" but valid CommR for a sector. It is unique for the given sector/miner.\nfunc MockCommR(minerAddr address.Address, sno abi.SectorNumber) cid.Cid {\n\treturn tutils.MakeCID(fmt.Sprintf(\"%s:%d\", minerAddr, sno), &miner5.SealedCIDPrefix)\n}", "id": 19813, "concepts": ["CID generation", "address.Address", "abi.SectorNumber", "fmt.Sprintf", "anonymous function", "type conversion"], "_raw_llm_output": "CID generation, address.Address, abi.SectorNumber, fmt.Sprintf, anonymous function, type conversion"}
{"seed": "// NewPutParamsWithTimeout creates a new PutParams object\n// with the default values initialized, and the ability to set a timeout on a request\nfunc NewPutParamsWithTimeout(timeout time.Duration) *PutParams {\n\tvar ()\n\treturn &PutParams{\n\n\t\ttimeout: timeout,\n\t}\n}", "id": 19819, "concepts": ["struct initialization", "struct field initialization", "struct field assignment"], "_raw_llm_output": "struct initialization, struct field initialization, struct field assignment"}
{"seed": "// SetIdentity stores the identity in storageDir.\n// If identity is already set, it asserts that stored\n// identity matches with given identity. It is recommended\n// to call SetIdentity before using storageDir.\n//\n// If the storageDir is already in use, returns ErrLockExists.\n// If the stored identity does not match given identity, returns ErrIdentityAlreadySet.\nfunc SetIdentity(storageDir string, cid, nid uint64) (err error) {\n\tif cid == 0 {\n\t\treturn errors.New(\"raft: cid is zero\")\n\t}\n\tif nid == 0 {\n\t\treturn errors.New(\"raft: nid is zero\")\n\t}\n\td, err := os.Stat(storageDir)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !d.IsDir() {\n\t\treturn fmt.Errorf(\"raft: %q is not a diretory\", storageDir)\n\t}\n\tif err := lockDir(storageDir); err != nil {\n\t\treturn err\n\t}\n\tdefer func() {\n\t\terr = unlockDir(storageDir)\n\t}()\n\tval, err := openValue(storageDir, \".id\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tif cid == val.v1 && nid == val.v2 {\n\t\treturn nil\n\t}\n\tif val.v1 != 0 && val.v2 != 0 {\n\t\treturn ErrIdentityAlreadySet\n\t}\n\treturn val.set(cid, nid)\n}", "id": 19826, "concepts": ["os.Stat", "os.IsDir", "os.OpenFile", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os.Stat", "os"], "_raw_llm_output": "os.Stat, os.IsDir, os.OpenFile, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os.Stat, os"}
{"seed": "// NewLoggerHandler returns a new LoggerHandler instance\nfunc NewLoggerHandler() *LoggerHandler {\n\treturn &LoggerHandler{}\n}", "id": 19833, "concepts": ["struct definition", "pointer usage"], "_raw_llm_output": "struct definition, pointer usage"}
{"seed": "// PossibleThrottlingMetricTypeValues returns the possible values for the ThrottlingMetricType const type.\nfunc PossibleThrottlingMetricTypeValues() []ThrottlingMetricType {\n\treturn []ThrottlingMetricType{\n\t\tThrottlingMetricTypeNotSpecified,\n\t\tThrottlingMetricTypeNumberOfRequests,\n\t\tThrottlingMetricTypeNumberOfResources,\n\t}\n}", "id": 19835, "concepts": ["enumerations", "const type", "type conversion"], "_raw_llm_output": "enumerations, const type, type conversion"}
{"seed": "// Meter_ is a convenience wrapper for Meter without the attrs argument.\nfunc Meter_(children ...HTML) HTML {\n  return Meter(nil, children...)\n}", "id": 19841, "concepts": ["HTML struct", "HTML struct field", "HTML struct method", "HTML struct field method", "HTML struct field method with argument", "HTML struct field method with argument and return value", "HTML struct field method with argument and return value and anonymous function", "HTML struct field method with argument and return value and anonymous function with argument", "HTML struct field method with argument and return value and anonymous function with argument and return value and anonymous function with argument and return value", "HTML struct field method with argument and return value and anonymous function with argument and return value and anonymous function with argument and return value and anonymous function with argument and return value and anonymous function with argument and return value and anonymous function with argument and return value and anonymous function with argument and return value and anonymous function with argument and return value and anonymous function with argument and return value and anonymous function with argument and return value and anonymous function with argument and return value and anonymous function with argument and return value and anonymous function with argument and return value and anonymous function with argument and return value and anonymous function with argument and return value and anonymous function with argument and return value and anonymous function with argument and return value and anonymous function with argument and return value and anonymous function with argument and return value and anonymous function with argument and return value and anonymous function with argument and return"], "_raw_llm_output": "HTML struct, HTML struct field, HTML struct method, HTML struct field method, HTML struct field method with argument, HTML struct field method with argument and return value, HTML struct field method with argument and return value and anonymous function, HTML struct field method with argument and return value and anonymous function with argument, HTML struct field method with argument and return value and anonymous function with argument and return value and anonymous function with argument and return value, HTML struct field method with argument and return value and anonymous function with argument and return value and anonymous function with argument and return value and anonymous function with argument and return value and anonymous function with argument and return value and anonymous function with argument and return value and anonymous function with argument and return value and anonymous function with argument and return value and anonymous function with argument and return value and anonymous function with argument and return value and anonymous function with argument and return value and anonymous function with argument and return value and anonymous function with argument and return value and anonymous function with argument and return value and anonymous function with argument and return value and anonymous function with argument and return value and anonymous function with argument and return value and anonymous function with argument and return value and anonymous function with argument and return value and anonymous function with argument and return value and anonymous function with argument and return"}
{"seed": "// CheckResponse checks the API response for errors, and returns them if present. A response is considered an\n// error if it has a non-zero response code. API error responses are expected to have a JSON response body\n// that maps to ErrorResponse. Any other response body will be silently ignored.\nfunc CheckResponse(r *http.Response) error {\n\tif c := r.StatusCode; c >= 200 && c <= 299 {\n\t\treturn nil\n\t}\n\n\terrorResponse := &ErrorResponse{Response: r}\n\tdata, err := ioutil.ReadAll(r.Body)\n\tif err == nil && len(data) > 0 {\n\t\terr := json.Unmarshal(data, errorResponse)\n\t\tif err != nil {\n\t\t\terrorResponse.Message = string(data)\n\t\t\terrorResponse.ResponseCode = -1\n\t\t}\n\t}\n\n\tswitch errorResponse.ResponseCode {\n\tcase 0:\n\t\t// no error\n\t\treturn nil\n\tcase 1:\n\t\terrorResponse.Message = \"Server's request to controller timed out\"\n\tcase 2:\n\t\terrorResponse.Message = \"Invalid URI\"\n\tcase 3:\n\t\terrorResponse.Message = \"Unsupported operation\"\n\tdefault:\n\t\terrorResponse.Message = \"Other error\"\n\t}\n\n\treturn errorResponse\n}", "id": 19849, "concepts": ["http.Response", "http.Client", "http.Request", "http.RoundTripper", "http.Transport", "http.Client.Do", "http.Client.Transport", "http.Client.Transport.RoundTrip", "http.Client.Transport.RoundTrip.Response", "http.Client.Transport.RoundTrip.Response.Body", "http.Client.Transport.RoundTrip.Response.Body.Read", "http.Client.Transport.RoundTrip.Response.Body.Read.Error", "http.Client.Transport.RoundTrip.Response.Body.Read.Error.Error", "http.Client.Transport.RoundTrip.Response.Body.Read.Error.Error.Error", "http.Client.Transport.RoundTrip.Response.Body.Read.Error.Error.Error.Error", "http.Client.Transport.RoundTrip.Response.Body.Read.Error.Error.Error.Error.Error", "http.Client.Transport.RoundTrip.Response.Body.Read.Error.Error.Error.Error.Error.Error", "http.Client.Transport.RoundTrip.Response.Body.Read.Error.Error.Error.Error.Error.Error.Error", "http.Client.Transport.RoundTrip.Response.Body"], "_raw_llm_output": "http.Response, http.Client, http.Request, http.RoundTripper, http.Transport, http.Client.Do, http.Client.Transport, http.Client.Transport.RoundTrip, http.Client.Transport.RoundTrip.Response, http.Client.Transport.RoundTrip.Response.Body, http.Client.Transport.RoundTrip.Response.Body.Read, http.Client.Transport.RoundTrip.Response.Body.Read.Error, http.Client.Transport.RoundTrip.Response.Body.Read.Error.Error, http.Client.Transport.RoundTrip.Response.Body.Read.Error.Error.Error, http.Client.Transport.RoundTrip.Response.Body.Read.Error.Error.Error.Error, http.Client.Transport.RoundTrip.Response.Body.Read.Error.Error.Error.Error.Error, http.Client.Transport.RoundTrip.Response.Body.Read.Error.Error.Error.Error.Error.Error, http.Client.Transport.RoundTrip.Response.Body.Read.Error.Error.Error.Error.Error.Error.Error, http.Client.Transport.RoundTrip.Response.Body"}
{"seed": "// filterInformerActions filters list and watch actions for testing resources.\n// Since list and watch don't change resource state we can filter it to lower\n// nose level in our tests.\nfunc filterInformerActions(actions []k8stesting.Action) []k8stesting.Action {\n\tret := []k8stesting.Action{}\n\tfor _, action := range actions {\n\t\tif action.Matches(\"get\", \"workflows\") ||\n\t\t\taction.Matches(\"list\", \"workflows\") ||\n\t\t\taction.Matches(\"watch\", \"workflows\") {\n\t\t\tcontinue\n\t\t}\n\t\tret = append(ret, action)\n\t}\n\n\treturn ret\n}", "id": 19852, "concepts": ["k8s testing package usage", "list and watch actions filtering"], "_raw_llm_output": "k8s testing package usage, list and watch actions filtering"}
{"seed": "// ParseDeletePrivateNetworkResponse parses an HTTP response from a DeletePrivateNetworkWithResponse call\nfunc ParseDeletePrivateNetworkResponse(rsp *http.Response) (*DeletePrivateNetworkResponse, error) {\n\tbodyBytes, err := ioutil.ReadAll(rsp.Body)\n\tdefer rsp.Body.Close()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse := &DeletePrivateNetworkResponse{\n\t\tBody:         bodyBytes,\n\t\tHTTPResponse: rsp,\n\t}\n\n\tswitch {\n\tcase strings.Contains(rsp.Header.Get(\"Content-Type\"), \"json\") && rsp.StatusCode == 200:\n\t\tvar dest Operation\n\t\tif err := json.Unmarshal(bodyBytes, &dest); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresponse.JSON200 = &dest\n\n\t}\n\n\treturn response, nil\n}", "id": 19869, "concepts": ["HTTP response parsing", "JSON parsing", "error handling (json.Unmarshal)", "HTTP response status code handling"], "_raw_llm_output": "HTTP response parsing, JSON parsing, error handling (json.Unmarshal), HTTP response status code handling"}
{"seed": "// isCloudEvent returns true if the event is a CloudEvent.\n// An event is a CloudEvent if it `id`, `source`, `specversion` and `type` fields.\n// See https://github.com/cloudevents/spec/blob/main/cloudevents/spec.md for more details.\nfunc isCloudEvent(event []byte) bool {\n\tvar ce struct {\n\t\tID          string `json:\"id\"`\n\t\tSource      string `json:\"source\"`\n\t\tSpecVersion string `json:\"specversion\"`\n\t\tType        string `json:\"type\"`\n\t}\n\tif err := json.Unmarshal(event, &ce); err != nil {\n\t\treturn false\n\t}\n\treturn ce.ID != \"\" && ce.Source != \"\" && ce.SpecVersion != \"\" && ce.Type != \"\"\n}", "id": 19870, "concepts": ["JSON parsing", "struct usage", "string comparison"], "_raw_llm_output": "JSON parsing, struct usage, string comparison"}
{"seed": "// PossibleResourceProviderCapabilitiesEffectValues returns the possible values for the ResourceProviderCapabilitiesEffect const type.\nfunc PossibleResourceProviderCapabilitiesEffectValues() []ResourceProviderCapabilitiesEffect {\n\treturn []ResourceProviderCapabilitiesEffect{\n\t\tResourceProviderCapabilitiesEffectAllow,\n\t\tResourceProviderCapabilitiesEffectDisallow,\n\t\tResourceProviderCapabilitiesEffectNotSpecified,\n\t}\n}", "id": 19871, "concepts": ["enum definition", "enum type", "enum value definition", "enum value usage"], "_raw_llm_output": "enum definition, enum type, enum value definition, enum value usage"}
{"seed": "// NewIscsiTargetsClient creates a new instance of IscsiTargetsClient with the specified values.\n//   - subscriptionID - The ID of the target subscription.\n//   - credential - used to authorize requests. Usually a credential from azidentity.\n//   - options - pass nil to accept the default values.\nfunc NewIscsiTargetsClient(subscriptionID string, credential azcore.TokenCredential, options *arm.ClientOptions) (*IscsiTargetsClient, error) {\n\tcl, err := arm.NewClient(moduleName+\".IscsiTargetsClient\", moduleVersion, credential, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tclient := &IscsiTargetsClient{\n\t\tsubscriptionID: subscriptionID,\n\t\tinternal:       cl,\n\t}\n\treturn client, nil\n}", "id": 19874, "concepts": ["module initialization", "client initialization", "module version", "module name", "anonymous function", "function definition", "function call", "function return", "function argument", "function return value", "function scope", "function call", "function return", "function argument", "function return value", "function scope", "function call", "function return", "function argument", "function return value", "function scope", "function call", "function return", "function argument", "function return value", "function scope", "function call", "function return", "function argument", "function return value", "function scope", "function call", "function return", "function argument", "function return value", "function scope", "function call", "function return", "function argument", "function return value", "function scope", "function call", "function return", "function argument", "function return value", "function scope", "function call", "function return", "function argument", "function return value", "function scope", "function call", "function return", "function argument", "function return value", "function scope", "function call", "function return", "function argument", "function return value", "function scope", "function call", "function return", "function argument", "function return value", "function scope", "function call", "function return", "function argument", "function return value", "function scope", "function call", "function return", "function argument", "function return value", "function scope", "function call", "function return", "function argument", "function return value", ""], "_raw_llm_output": "module initialization, client initialization, module version, module name, anonymous function, function definition, function call, function return, function argument, function return value, function scope, function call, function return, function argument, function return value, function scope, function call, function return, function argument, function return value, function scope, function call, function return, function argument, function return value, function scope, function call, function return, function argument, function return value, function scope, function call, function return, function argument, function return value, function scope, function call, function return, function argument, function return value, function scope, function call, function return, function argument, function return value, function scope, function call, function return, function argument, function return value, function scope, function call, function return, function argument, function return value, function scope, function call, function return, function argument, function return value, function scope, function call, function return, function argument, function return value, function scope, function call, function return, function argument, function return value, function scope, function call, function return, function argument, function return value, function scope, function call, function return, function argument, function return value,"}
{"seed": "// Map represents the HTML element 'map'.\n// For more information visit https://www.w3schools.com/tags/tag_map.asp.\nfunc Map(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"map\", Attributes: attrs, Children: children}\n}", "id": 19887, "concepts": ["HTML tree representation", "HTML element definition", "HTML attribute definition"], "_raw_llm_output": "HTML tree representation, HTML element definition, HTML attribute definition"}
{"seed": "// MakeJobInterchange changes a Job interface into a JobInterchange\n// structure, for easier serialization.\nfunc MakeJobInterchange(j amboy.Job, f amboy.Format) (*JobInterchange, error) {\n\ttypeInfo := j.Type()\n\n\tif typeInfo.Version < 0 {\n\t\treturn nil, errors.New(\"cannot use jobs with versions less than 0 with job interchange\")\n\t}\n\n\tdep, err := makeDependencyInterchange(f, j.Dependency())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdata, err := convertTo(f, j)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\toutput := &JobInterchange{\n\t\tName:             j.ID(),\n\t\tType:             typeInfo.Name,\n\t\tVersion:          typeInfo.Version,\n\t\tPriority:         j.Priority(),\n\t\tStatus:           j.Status(),\n\t\tTimeInfo:         j.TimeInfo(),\n\t\tEnqueueScopes:    j.EnqueueScopes(),\n\t\tEnqueueAllScopes: j.EnqueueAllScopes(),\n\t\tRetryInfo:        j.RetryInfo(),\n\t\tJob:              data,\n\t\tDependency:       dep,\n\t}\n\n\treturn output, nil\n}", "id": 19893, "concepts": ["interface", "struct", "type conversion", "standard library usage"], "_raw_llm_output": "interface, struct, type conversion, standard library usage"}
{"seed": "// isVideoPadding returns true iff c corresponds to the expected color of the padding that a\n// video gets when in full screen so that it appears centered. This color is black within a\n// certain tolerance.\nfunc isVideoPadding(c color.Color) bool {\n\tblack := color.RGBA{0, 0, 0, 255}\n\t// The tolerance was picked empirically. For example, on kukui, the first padding row below\n\t// the video has a color of (20, 1, 22, 255).\n\ttolerance := 25\n\treturn ColorDistance(c, black) < tolerance\n}", "id": 19894, "concepts": ["color handling", "color distance calculation", "color comparison"], "_raw_llm_output": "color handling, color distance calculation, color comparison"}
{"seed": "// PathIsDir returns true if the specified path is a directory.\nfunc PathIsDir(directory string) bool {\n\tif info, err := os.Stat(directory); err != nil || !info.IsDir() {\n\t\treturn false\n\t}\n\treturn true\n}", "id": 19898, "concepts": ["os.Stat", "os.IsDir", "error handling"], "_raw_llm_output": "os.Stat, os.IsDir, error handling"}
{"seed": "// NewWebhooksClient creates a new instance of WebhooksClient with the specified values.\n//   - subscriptionID - The Microsoft Azure subscription ID.\n//   - credential - used to authorize requests. Usually a credential from azidentity.\n//   - options - pass nil to accept the default values.\nfunc NewWebhooksClient(subscriptionID string, credential azcore.TokenCredential, options *arm.ClientOptions) (*WebhooksClient, error) {\n\tcl, err := arm.NewClient(internal.ModuleName+\"/armcontainerregistry.WebhooksClient\", internal.ModuleVersion, credential, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tclient := &WebhooksClient{\n\t\tsubscriptionID: subscriptionID,\n\t\tinternal:       cl,\n\t}\n\treturn client, nil\n}", "id": 19905, "concepts": ["struct definition", "function definition", "pointer usage", "method definition", "anonymous function", "standard library usage"], "_raw_llm_output": "struct definition, function definition, pointer usage, method definition, anonymous function, standard library usage"}
{"seed": "// Mode_Values returns all elements of the Mode enum\nfunc Mode_Values() []string {\n\treturn []string{\n\t\tModeOff,\n\t\tModeBehindLiveEdge,\n\t\tModeAfterLiveEdge,\n\t}\n}", "id": 19916, "concepts": ["enum", "string iteration", "basic function definition"], "_raw_llm_output": "enum, string iteration, basic function definition"}
{"seed": "// searchForFile checks the working directory and every parent directory to\n// find a configuration file with the default name.\n// This should be called when an explicit file is not passed in to determine\n// the full path to the relevant config file.\nfunc searchForFile() (string, error) {\n\tprevPath := \"\"\n\tdirPath, err := os.Getwd()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor dirPath != prevPath {\n\t\tfullPath, found, err := findFileInDir(dirPath)\n\t\tif err != nil || found {\n\t\t\treturn fullPath, err\n\t\t}\n\t\tprevPath, dirPath = dirPath, filepath.Dir(dirPath)\n\t}\n\n\treturn \"\", nil\n}", "id": 19921, "concepts": ["os package usage", "filepath package usage", "error handling (os.Getwd)", "error handling (filepath.Dir)", "error handling (filepath.Walk)", "error handling (os.Stat)", "error handling (os.IsNotExist)", "error handling (os.IsPermission)"], "_raw_llm_output": "os package usage, filepath package usage, error handling (os.Getwd), error handling (filepath.Dir), error handling (filepath.Walk), error handling (os.Stat), error handling (os.IsNotExist), error handling (os.IsPermission)"}
{"seed": "// Center_ is a convenience wrapper for Center without the attrs argument.\nfunc Center_(children ...HTML) HTML {\n  return Center(nil, children...)\n}", "id": 19929, "concepts": ["function definition", "variadic function", "function argument", "function return value", "function call"], "_raw_llm_output": "function definition, variadic function, function argument, function return value, function call"}
{"seed": "// isInterfaceRequestType returns true if the reflected type is a FIDL interface\n// request type.\nfunc isInterfaceRequestType(t reflect.Type) bool {\n\t// FIDL interfaces are represented as aliases over InterfaceRequest.\n\treturn t.ConvertibleTo(interfaceRequestType)\n}", "id": 19947, "concepts": ["reflection", "type conversion", "interface aliasing"], "_raw_llm_output": "reflection, type conversion, interface aliasing"}
{"seed": "// NewParser creates a new parser for a PDF file via ReadSeeker. Loads the cross reference stream and trailer.\n// An error is returned on failure.\nfunc NewParser(rs io.ReadSeeker) (*PdfParser, error) {\n\tparser := &PdfParser{\n\t\trs:                                    rs,\n\t\tObjCache:                              make(objectCache),\n\t\tstreamLengthReferenceLookupInProgress: map[int64]bool{},\n\t}\n\n\t// Parse PDF version.\n\tmajorVersion, minorVersion, err := parser.parsePdfVersion()\n\tif err != nil {\n\t\tcommon.Log.Error(\"Unable to parse version: %v\", err)\n\t\treturn nil, err\n\t}\n\tparser.version.Major = majorVersion\n\tparser.version.Minor = minorVersion\n\n\t// Start by reading the xrefs (from bottom).\n\tif parser.trailer, err = parser.loadXrefs(); err != nil {\n\t\tcommon.Log.Debug(\"ERROR: Failed to load xref table! %s\", err)\n\t\treturn nil, err\n\t}\n\tcommon.Log.Trace(\"Trailer: %s\", parser.trailer)\n\n\tif len(parser.xrefs.ObjectMap) == 0 {\n\t\treturn nil, fmt.Errorf(\"empty XREF table - Invalid\")\n\t}\n\n\treturn parser, nil\n}", "id": 19951, "concepts": ["io.ReadSeeker", "io.Reader", "io.ReaderAt", "io.Seeker", "io.Writer", "io.Closer", "io.ReadWriter", "io.ReadWriteSeeker", "io.ReadWriteCloser", "io.ReadWriteSeeker", "io.ReadAtSeeker", "io.ReadSeeker", "io.ReadCloser", "io.ReadSeeker", "io.ReaderAt", "io.Seeker", "io.Writer", "io.Closer", "io.ReadWriter", "io.ReadWriteSeeker", "io.ReadWriteCloser", "io.ReadWriteSeeker", "io.ReadAtSeeker", "io.ReadSeeker", "io.ReadCloser", "io.ReadSeeker", "io.ReaderAt", "io.Seeker", "io.Writer", "io.Closer", "io.ReadWriter", "io.ReadWriteSeeker", "io.ReadWriteCloser", "io.ReadWriteSeeker", "io.ReadAtSeeker", "io.ReadSeeker", "io.ReadCloser", "io.ReadSeeker", "io.ReaderAt", "io.Seeker", "io.Writer", "io.Closer", "io.ReadWriter", "io.ReadWriteSeeker", "io.ReadWriteCloser", "io.ReadWriteSeeker", "io.ReadAtSeeker", "io.ReadSeeker", ""], "_raw_llm_output": "io.ReadSeeker, io.Reader, io.ReaderAt, io.Seeker, io.Writer, io.Closer, io.ReadWriter, io.ReadWriteSeeker, io.ReadWriteCloser, io.ReadWriteSeeker, io.ReadAtSeeker, io.ReadSeeker, io.ReadCloser, io.ReadSeeker, io.ReaderAt, io.Seeker, io.Writer, io.Closer, io.ReadWriter, io.ReadWriteSeeker, io.ReadWriteCloser, io.ReadWriteSeeker, io.ReadAtSeeker, io.ReadSeeker, io.ReadCloser, io.ReadSeeker, io.ReaderAt, io.Seeker, io.Writer, io.Closer, io.ReadWriter, io.ReadWriteSeeker, io.ReadWriteCloser, io.ReadWriteSeeker, io.ReadAtSeeker, io.ReadSeeker, io.ReadCloser, io.ReadSeeker, io.ReaderAt, io.Seeker, io.Writer, io.Closer, io.ReadWriter, io.ReadWriteSeeker, io.ReadWriteCloser, io.ReadWriteSeeker, io.ReadAtSeeker, io.ReadSeeker,"}
{"seed": "// Input represents the HTML void element 'input'.\n// For more information visit https://www.w3schools.com/tags/tag_input.asp.\nfunc Input(attrs []htmlgo.Attribute) HTML {\n\treturn &htmlgo.Tree{Tag: \"input\", Attributes: attrs, SelfClosing: true}\n}", "id": 19963, "concepts": ["HTML generation", "HTML tree traversal", "HTML attribute handling"], "_raw_llm_output": "HTML generation, HTML tree traversal, HTML attribute handling"}
{"seed": "// ExtractPhysical returns a ts's physical part.\nfunc ExtractPhysical(ts uint64) int64 {\n\treturn int64(ts >> physicalShiftBits)\n}", "id": 19973, "concepts": ["bit shifting", "bitwise operations", "bitwise AND", "bitwise OR", "bitwise XOR", "bitwise NOT"], "_raw_llm_output": "bit shifting, bitwise operations, bitwise AND, bitwise OR, bitwise XOR, bitwise NOT"}
{"seed": "// isV1 reports if the major version is 'v1' (e.g., 'v1.2.3')\r\nfunc isV1(version string) bool {\r\n\tif !semver.IsValid(version) || isBeforeV1(version) {\r\n\t\treturn false\r\n\t}\r\n\treturn semver.Major(version) == \"v1\"\r\n}", "id": 19976, "concepts": ["semver package usage", "semver.IsValid", "semver.Major"], "_raw_llm_output": "semver package usage, semver.IsValid, semver.Major"}
{"seed": "// NewNetworkPruneParamsWithContext creates a new NetworkPruneParams object\n// with the default values initialized, and the ability to set a context for a request\nfunc NewNetworkPruneParamsWithContext(ctx context.Context) *NetworkPruneParams {\n\tvar ()\n\treturn &NetworkPruneParams{\n\n\t\tContext: ctx,\n\t}\n}", "id": 19983, "concepts": ["context", "struct initialization", "function definition", "method definition"], "_raw_llm_output": "context, struct initialization, function definition, method definition"}
{"seed": "// levelToStr returns string format of debug level.\nfunc levelToStr(wl debugLevel) string {\n\tswitch wl {\n\tcase LevelTrace:\n\t\treturn \"TRACE\"\n\tcase LevelInfo:\n\t\treturn \"INFO\"\n\tcase LevelCritical:\n\t\treturn \"CRITICAL\"\n\tdefault:\n\t\treturn \"UNKNOWN\"\n\t}\n}", "id": 19995, "concepts": ["switch statement", "basic function definition"], "_raw_llm_output": "switch statement, basic function definition"}
{"seed": "// RegisterConversions adds conversion functions to the given scheme.\n// Public to allow building arbitrary schemes.\nfunc RegisterConversions(s *runtime.Scheme) error {\n\tif err := s.AddGeneratedConversionFunc((*v1.Group)(nil), (*user.Group)(nil), func(a, b interface{}, scope conversion.Scope) error {\n\t\treturn Convert_v1_Group_To_user_Group(a.(*v1.Group), b.(*user.Group), scope)\n\t}); err != nil {\n\t\treturn err\n\t}\n\tif err := s.AddGeneratedConversionFunc((*user.Group)(nil), (*v1.Group)(nil), func(a, b interface{}, scope conversion.Scope) error {\n\t\treturn Convert_user_Group_To_v1_Group(a.(*user.Group), b.(*v1.Group), scope)\n\t}); err != nil {\n\t\treturn err\n\t}\n\tif err := s.AddGeneratedConversionFunc((*v1.GroupList)(nil), (*user.GroupList)(nil), func(a, b interface{}, scope conversion.Scope) error {\n\t\treturn Convert_v1_GroupList_To_user_GroupList(a.(*v1.GroupList), b.(*user.GroupList), scope)\n\t}); err != nil {\n\t\treturn err\n\t}\n\tif err := s.AddGeneratedConversionFunc((*user.GroupList)(nil), (*v1.GroupList)(nil), func(a, b interface{}, scope conversion.Scope) error {\n\t\treturn Convert_user_GroupList_To_v1_GroupList(a.(*user.GroupList), b.(*v1.GroupList), scope)\n\t}); err != nil {\n\t\treturn err\n\t}\n\tif err := s.AddGeneratedConversionFunc((*v1.Identity)(nil), (*user.Identity)(nil), func(a, b interface{}, scope conversion.Scope) error {\n\t\treturn Convert_v1_Identity_To_user_Identity(a.(*v1.Identity), b.(*user.Identity), scope)\n\t}); err != nil {\n\t\treturn err\n\t}\n\tif err := s.AddGeneratedConversionFunc((*user.Identity)(nil), (*v1.Identity)(nil), func(a, b interface{}, scope conversion.Scope) error {\n\t\treturn Convert_user_Identity_To_v1_Identity(a.(*user.Identity), b.(*v1.Identity), scope)\n\t}); err != nil {\n\t\treturn err\n\t}\n\tif err := s.AddGeneratedConversionFunc((*v1.IdentityList)(nil), (*user.IdentityList)(nil), func(a, b interface{}, scope conversion.Scope) error {\n\t\treturn Convert_v1_IdentityList_To_user_IdentityList(a.(*v1.IdentityList), b.(*user.IdentityList), scope)\n\t}); err != nil {\n\t\treturn err\n\t}\n\tif err := s.AddGeneratedConversionFunc((*user.IdentityList)(nil), (*v1.IdentityList)(nil), func(a, b interface{}, scope conversion.Scope) error {\n\t\treturn Convert_user_IdentityList_To_v1_IdentityList(a.(*user.IdentityList), b.(*v1.IdentityList), scope)\n\t}); err != nil {\n\t\treturn err\n\t}\n\tif err := s.AddGeneratedConversionFunc((*v1.User)(nil), (*user.User)(nil), func(a, b interface{}, scope conversion.Scope) error {\n\t\treturn Convert_v1_User_To_user_User(a.(*v1.User), b.(*user.User), scope)\n\t}); err != nil {\n\t\treturn err\n\t}\n\tif err := s.AddGeneratedConversionFunc((*user.User)(nil), (*v1.User)(nil), func(a, b interface{}, scope conversion.Scope) error {\n\t\treturn Convert_user_User_To_v1_User(a.(*user.User), b.(*v1.User), scope)\n\t}); err != nil {\n\t\treturn err\n\t}\n\tif err := s.AddGeneratedConversionFunc((*v1.UserIdentityMapping)(nil), (*user.UserIdentityMapping)(nil), func(a, b interface{}, scope conversion.Scope) error {\n\t\treturn Convert_v1_UserIdentityMapping_To_user_UserIdentityMapping(a.(*v1.UserIdentityMapping), b.(*user.UserIdentityMapping), scope)\n\t}); err != nil {\n\t\treturn err\n\t}\n\tif err := s.AddGeneratedConversionFunc((*user.UserIdentityMapping)(nil), (*v1.UserIdentityMapping)(nil), func(a, b interface{}, scope conversion.Scope) error {\n\t\treturn Convert_user_UserIdentityMapping_To_v1_UserIdentityMapping(a.(*user.UserIdentityMapping), b.(*v1.UserIdentityMapping), scope)\n\t}); err != nil {\n\t\treturn err\n\t}\n\tif err := s.AddGeneratedConversionFunc((*v1.UserList)(nil), (*user.UserList)(nil), func(a, b interface{}, scope conversion.Scope) error {\n\t\treturn Convert_v1_UserList_To_user_UserList(a.(*v1.UserList), b.(*user.UserList), scope)\n\t}); err != nil {\n\t\treturn err\n\t}\n\tif err := s.AddGeneratedConversionFunc((*user.UserList)(nil), (*v1.UserList)(nil), func(a, b interface{}, scope conversion.Scope) error {\n\t\treturn Convert_user_UserList_To_v1_UserList(a.(*user.UserList), b.(*v1.UserList), scope)\n\t}); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "id": 19996, "concepts": ["conversion functions", "runtime.Scheme", "conversion.Scope", "conversion.Scope.Convert", "conversion.Scope.UnsafeConvert", "conversion.Scope.UnsafeConvertWithConversionFunc", "conversion.Scope.UnsafeConvertWithConversionFunc", "conversion.Scope.UnsafeConvertWithConversionFunc", "conversion.Scope.UnsafeConvertWithConversionFunc", "conversion.Scope.UnsafeConvertWithConversionFunc", "conversion.Scope.UnsafeConvertWithConversionFunc", "conversion.Scope.UnsafeConvertWithConversionFunc", "conversion.Scope.UnsafeConvertWithConversionFunc", "conversion.Scope.UnsafeConvertWithConversionFunc", "conversion.Scope.UnsafeConvertWithConversionFunc", "conversion.Scope.UnsafeConvertWithConversionFunc", "conversion.Scope.UnsafeConvertWithConversionFunc", "conversion.Scope.UnsafeConvertWithConversionFunc", "conversion.Scope.UnsafeConvertWithConversionFunc", "conversion.Scope.UnsafeConvertWithConversionFunc", "conversion.Scope.UnsafeConvertWithConversionFunc", "conversion.Scope.UnsafeConvertWithConversionFunc", "conversion.Scope.UnsafeConvertWithConversionFunc", "conversion.Scope.UnsafeConvertWithConversionFunc", "conversion.Scope.UnsafeConvertWithConversionFunc", "conversion.Scope.UnsafeConvertWithConversionFunc", "conversion.Scope.UnsafeConvertWithConversionFunc", "conversion.Scope.UnsafeConvertWithConversionFunc", "conversion"], "_raw_llm_output": "conversion functions, runtime.Scheme, conversion.Scope, conversion.Scope.Convert, conversion.Scope.UnsafeConvert, conversion.Scope.UnsafeConvertWithConversionFunc, conversion.Scope.UnsafeConvertWithConversionFunc, conversion.Scope.UnsafeConvertWithConversionFunc, conversion.Scope.UnsafeConvertWithConversionFunc, conversion.Scope.UnsafeConvertWithConversionFunc, conversion.Scope.UnsafeConvertWithConversionFunc, conversion.Scope.UnsafeConvertWithConversionFunc, conversion.Scope.UnsafeConvertWithConversionFunc, conversion.Scope.UnsafeConvertWithConversionFunc, conversion.Scope.UnsafeConvertWithConversionFunc, conversion.Scope.UnsafeConvertWithConversionFunc, conversion.Scope.UnsafeConvertWithConversionFunc, conversion.Scope.UnsafeConvertWithConversionFunc, conversion.Scope.UnsafeConvertWithConversionFunc, conversion.Scope.UnsafeConvertWithConversionFunc, conversion.Scope.UnsafeConvertWithConversionFunc, conversion.Scope.UnsafeConvertWithConversionFunc, conversion.Scope.UnsafeConvertWithConversionFunc, conversion.Scope.UnsafeConvertWithConversionFunc, conversion.Scope.UnsafeConvertWithConversionFunc, conversion.Scope.UnsafeConvertWithConversionFunc, conversion.Scope.UnsafeConvertWithConversionFunc, conversion.Scope.UnsafeConvertWithConversionFunc, conversion"}
{"seed": "// Keep takes a list of times that snapshots were taken at and\n// returns which ones should be kept.\n//\n// The retention policy is based on the last snapshot time,\n// not use the current time.\n// Times will be returned in sorted order.\nfunc Keep(c Config, snapshots []time.Time) []time.Time {\n\tshots := make(timeseries, 0, len(snapshots)+1)\n\tshots.Push(snapshots...)\n\tnewest := shots.PeekNewest()\n\tbuks := newBuckets(c, newest)\n\tbuks.Assign(shots)\n\n\t// Redistribute the snapshots between buckets with the\n\t// goal of having 1 snapshot per bucket.\n\tredistributeBackups(buks)\n\n\t// Do an initial pass marking snapshots to keep.\n\tkeep := make(timeseries, 0, len(buks))\n\tfor i, b := range buks {\n\t\t// Don't keep any snapshots in fall\n\t\t// before our defined buckets.\n\t\tif b.IsCatchall() {\n\t\t\tcontinue\n\t\t}\n\t\t// Keep all snapshots in hour buckets.\n\t\tif b.Width == Hour {\n\t\t\tkeep.Push(b.Snapshots...)\n\t\t\tcontinue\n\t\t}\n\t\t// Keep the oldest snapshot in each bucket.\n\t\tkeep.Push(b.Snapshots.PeekOldest())\n\t\t// Keep the very newest snapshot of all.\n\t\tif i == len(buks)-1 {\n\t\t\tkeep.Push(b.Snapshots.PeekNewest())\n\t\t}\n\t}\n\n\t// Per Acronis:\n\t//\n\t//   Go through each interval spanning 2 snapshots marked to keep\n\t//   (with at least 1.5 bucket length between them)\n\t//   and find one snapshot marked for deletion in that interval\n\t//   which is the closest to the middle of the interval\n\t//   (but no closer than 0.5 of the bucket length from either\n\t//   beginning or ending of the interval).\n\t//   If such a snapshot is found then it is marked for retention\n\t//   and won't be deleted.\n\tkeep2 := make(timeseries, 0, len(keep)/2)\n\tfor i, n := 0, len(keep)-1; i < n; i++ {\n\t\tsnapLeft, snapRight := keep[i], keep[i+1]\n\t\tbucketLeft, bucketRight := buks.Has(snapLeft), buks.Has(snapRight)\n\t\tif bucketLeft == bucketRight {\n\t\t\t// The same bucket can't be 1.5 bucket length apart.\n\t\t\tcontinue\n\t\t}\n\n\t\t// The Acronis algorithm doesn't really define what \"1.5 bucket length\"\n\t\t// is when the buckets are different sizes.\n\t\t// I think the geometric mean is the correct way to go.\n\t\tbucketLength := math.Sqrt(float64(bucketLeft.Width) * float64(bucketRight.Width))\n\t\tdistance := snapRight.Sub(snapLeft)\n\t\tif float64(distance) < 1.5*bucketLength {\n\t\t\tcontinue\n\t\t}\n\n\t\tcenter := snapLeft.Add(distance / 2)\n\t\tend := shots.Find(snapRight)\n\t\tclosestDistance := distance\n\t\tvar closestSnap time.Time\n\t\tfor i := shots.Find(snapLeft) + 1; i < end; i++ {\n\t\t\tsnapMiddle := shots[i]\n\t\t\tdistanceLeft := float64(snapMiddle.Sub(snapLeft))\n\t\t\tif distanceLeft < 0.5*bucketLength {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tdistanceRight := float64(snapRight.Sub(snapMiddle))\n\t\t\tif distanceRight < 0.5*bucketLength {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\td := center.Sub(snapMiddle)\n\t\t\tif d < 0 {\n\t\t\t\td = -d\n\t\t\t}\n\t\t\tif d < closestDistance {\n\t\t\t\tclosestDistance = d\n\t\t\t\tclosestSnap = snapMiddle\n\t\t\t}\n\t\t}\n\t\tif !closestSnap.IsZero() {\n\t\t\tkeep2.Push(closestSnap)\n\t\t}\n\t}\n\n\tkeep.Push(keep2...)\n\treturn keep\n}", "id": 20003, "concepts": ["time package usage", "time.Time", "time.Duration", "time.Add", "time.Sub", "time.IsZero", "time.After", "time.Sleep", "time.Now", "time.Parse", "time.Unix", "time.Date", "time.Month", "time.Hour", "time.Minute", "time.Second", "time.Nanosecond", "time.UTC", "time.LoadLocation", "time.LoadLocationFromTZData", "time.LoadLocationFromTZDataFile", "time.LoadLocationFromTZDataFiles", "time.LoadLocationFromTZDataFile", "time.LoadLocationFromTZDataFiles", "time.LoadLocationFromTZDataFiles", "time.LoadLocationFromTZDataFiles", "time.LoadLocationFromTZDataFiles", "time.LoadLocationFromTZDataFiles", "time.LoadLocationFromTZDataFiles", "time.LoadLocationFromTZDataFiles", "time.LoadLocationFromTZDataFiles", "time.LoadLocationFromTZDataFiles", "time.LoadLocationFromTZDataFiles", "time.LoadLocationFromTZDataFiles", "time.LoadLocationFromTZDataFiles", "time.LoadLocationFromTZDataFiles", "time.LoadLocationFromTZDataFiles", "time.LoadLocationFromTZDataFiles", "time.LoadLocationFrom"], "_raw_llm_output": "time package usage, time.Time, time.Duration, time.Add, time.Sub, time.IsZero, time.After, time.Sleep, time.Now, time.Parse, time.Unix, time.Date, time.Month, time.Hour, time.Minute, time.Second, time.Nanosecond, time.UTC, time.LoadLocation, time.LoadLocationFromTZData, time.LoadLocationFromTZDataFile, time.LoadLocationFromTZDataFiles, time.LoadLocationFromTZDataFile, time.LoadLocationFromTZDataFiles, time.LoadLocationFromTZDataFiles, time.LoadLocationFromTZDataFiles, time.LoadLocationFromTZDataFiles, time.LoadLocationFromTZDataFiles, time.LoadLocationFromTZDataFiles, time.LoadLocationFromTZDataFiles, time.LoadLocationFromTZDataFiles, time.LoadLocationFromTZDataFiles, time.LoadLocationFromTZDataFiles, time.LoadLocationFromTZDataFiles, time.LoadLocationFromTZDataFiles, time.LoadLocationFromTZDataFiles, time.LoadLocationFromTZDataFiles, time.LoadLocationFromTZDataFiles, time.LoadLocationFrom"}
{"seed": "// RunJSONSerializationTestForPrivateEndpointIPConfiguration runs a test to see if a specific instance of PrivateEndpointIPConfiguration round trips to JSON and back losslessly\nfunc RunJSONSerializationTestForPrivateEndpointIPConfiguration(subject PrivateEndpointIPConfiguration) string {\n\t// Serialize to JSON\n\tbin, err := json.Marshal(subject)\n\tif err != nil {\n\t\treturn err.Error()\n\t}\n\n\t// Deserialize back into memory\n\tvar actual PrivateEndpointIPConfiguration\n\terr = json.Unmarshal(bin, &actual)\n\tif err != nil {\n\t\treturn err.Error()\n\t}\n\n\t// Check for outcome\n\tmatch := cmp.Equal(subject, actual, cmpopts.EquateEmpty())\n\tif !match {\n\t\tactualFmt := pretty.Sprint(actual)\n\t\tsubjectFmt := pretty.Sprint(subject)\n\t\tresult := diff.Diff(subjectFmt, actualFmt)\n\t\treturn result\n\t}\n\n\treturn \"\"\n}", "id": 20018, "concepts": ["JSON serialization", "JSON deserialization", "cmp package usage"], "_raw_llm_output": "JSON serialization, JSON deserialization, cmp package usage"}
{"seed": "// Directory specifies the working directory of mkcert, and is the path relative\n// to which CertFile and KeyFile are relative to, if specified. When blank,\n// defaults to the current directory.\nfunc Directory(path string) Opt {\n\treturn func(p *params) { p.dir = path }\n}", "id": 20025, "concepts": ["function composition", "function composition", "function composition", "function composition", "function composition"], "_raw_llm_output": "function composition, function composition, function composition, function composition, function composition"}
{"seed": "// Meta represents the HTML void element 'meta'.\n// For more information visit https://www.w3schools.com/tags/tag_meta.asp.\nfunc Meta(attrs []htmlgo.Attribute) HTML {\n\treturn &htmlgo.Tree{Tag: \"meta\", Attributes: attrs, SelfClosing: true}\n}", "id": 20030, "concepts": ["HTML generation", "HTML tree traversal", "HTML attribute handling"], "_raw_llm_output": "HTML generation, HTML tree traversal, HTML attribute handling"}
{"seed": "// Spacer represents the HTML element 'spacer'.\n// For more information visit https://www.w3schools.com/tags/tag_spacer.asp.\nfunc Spacer(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"spacer\", Attributes: attrs, Children: children}\n}", "id": 20033, "concepts": ["HTML generation", "HTML tree manipulation", "HTML element definition"], "_raw_llm_output": "HTML generation, HTML tree manipulation, HTML element definition"}
{"seed": "// CrossProduct is a binary operation on two vectors in three-dimensional space.\n// Given two linearly independent vectors, the cross product is a vector that is\n// perpendicular to both and and thus normal to the plane containing them.\nfunc CrossProduct(lhs Vector, rhs Vector) Vector {\n\treturn Vector{\n\t\tI: lhs.J*rhs.K - lhs.K*rhs.J,\n\t\tJ: lhs.K*rhs.I - lhs.I*rhs.K,\n\t\tK: lhs.I*rhs.J - lhs.J*rhs.I,\n\t}\n}", "id": 20034, "concepts": ["struct definition", "struct field access", "struct field access with pointer", "struct field access with pointer", "struct field access with pointer", "struct field access with pointer", "struct field access with pointer", "struct field access with pointer", "struct field access with pointer", "struct field access with pointer", "struct field access with pointer", "struct field access with pointer", "struct field access with pointer", "struct field access with pointer", "struct field access with pointer", "struct field access with pointer", "struct field access with pointer", "struct field access with pointer", "struct field access with pointer", "struct field access with pointer", "struct field access with pointer", "struct field access with pointer", "struct field access with pointer", "struct field access with pointer", "struct field access with pointer", "struct field access with pointer", "struct field access with pointer", "struct field access with pointer", "struct field access with pointer", "struct field access with pointer", "struct field access with pointer", "struct field access with pointer", "struct field access with pointer", "struct field access with pointer", "struct field access with pointer", "struct field access with pointer", "struct field access with pointer", "struct field access with pointer", "struct field access with pointer", "struct field access with pointer", "struct field access with pointer", "struct field access with pointer", "struct field access with pointer", "struct field"], "_raw_llm_output": "struct definition, struct field access, struct field access with pointer, struct field access with pointer, struct field access with pointer, struct field access with pointer, struct field access with pointer, struct field access with pointer, struct field access with pointer, struct field access with pointer, struct field access with pointer, struct field access with pointer, struct field access with pointer, struct field access with pointer, struct field access with pointer, struct field access with pointer, struct field access with pointer, struct field access with pointer, struct field access with pointer, struct field access with pointer, struct field access with pointer, struct field access with pointer, struct field access with pointer, struct field access with pointer, struct field access with pointer, struct field access with pointer, struct field access with pointer, struct field access with pointer, struct field access with pointer, struct field access with pointer, struct field access with pointer, struct field access with pointer, struct field access with pointer, struct field access with pointer, struct field access with pointer, struct field access with pointer, struct field access with pointer, struct field access with pointer, struct field access with pointer, struct field access with pointer, struct field access with pointer, struct field access with pointer, struct field access with pointer, struct field"}
{"seed": "// NewS3Store creates an instance of a chunk store with S3 backing. The URL\n// should be provided like this: s3+http://host:port/bucket\n// Credentials are passed in via the environment variables S3_ACCESS_KEY\n// and S3S3_SECRET_KEY.\nfunc NewS3Store(location string) (S3Store, error) {\n\ts := S3Store{Location: location}\n\tu, err := url.Parse(location)\n\tif err != nil {\n\t\treturn s, err\n\t}\n\tif !strings.HasPrefix(u.Scheme, \"s3+http\") {\n\t\treturn s, fmt.Errorf(\"invalid scheme '%s', expected 's3+http' or 's3+https'\", u.Scheme)\n\t}\n\tvar useSSL bool\n\tif strings.HasSuffix(u.Scheme, \"s\") {\n\t\tuseSSL = true\n\t}\n\n\t// Pull the bucket as well as the prefix from a path-style URL\n\tpath := strings.Trim(u.Path, \"/\")\n\tif path == \"\" {\n\t\treturn s, fmt.Errorf(\"expected bucket name in path of '%s'\", u.Scheme)\n\t}\n\tf := strings.Split(path, \"/\")\n\ts.bucket = f[0]\n\ts.prefix = filepath.Join(f[1:]...)\n\n\t// Read creds from the environment and setup a client\n\taccessKey := os.Getenv(\"S3_ACCESS_KEY\")\n\tsecretKey := os.Getenv(\"S3_SECRET_KEY\")\n\n\ts.client, err = minio.New(u.Host, accessKey, secretKey, useSSL)\n\tif err != nil {\n\t\treturn s, errors.Wrap(err, location)\n\t}\n\n\t// Might as well confirm the bucket exists\n\tbucketExists, err := s.client.BucketExists(s.bucket)\n\tif err != nil {\n\t\treturn s, errors.Wrap(err, location)\n\t}\n\tif !bucketExists {\n\t\treturn s, fmt.Errorf(\"bucket '%s' does not exist in %s\", s.bucket, location)\n\t}\n\treturn s, nil\n}", "id": 20036, "concepts": ["URL parsing", "string manipulation", "string splitting", "environment variable usage", "minio package usage", "error handling", "error wrapping", "string formatting", "error handling", "error wrapping", "error handling", "error wrapping", "error handling", "error wrapping", "error handling", "error wrapping", "error handling", "error wrapping", "error handling", "error wrapping", "error handling", "error wrapping", "error handling", "error wrapping", "error handling", "error wrapping", "error handling", "error wrapping", "error handling", "error wrapping", "error handling", "error wrapping", "error handling", "error wrapping", "error handling", "error wrapping", "error handling", "error wrapping", "error handling", "error wrapping", "error handling", "error wrapping", "error handling", "error wrapping", "error handling", "error wrapping", "error handling", "error wrapping", "error handling", "error wrapping", "error handling", "error wrapping", "error handling", "error wrapping", "error handling", "error wrapping", "error handling", "error wrapping", "error handling", "error wrapping", "error handling", "error wrapping", "error handling", "error wrapping", "error handling", "error wrapping", "error handling", "error wrapping", "error handling", "error wrapping", "error handling", "error wrapping", "error handling", "error wrapping", "error handling", "error wrapping", "error handling", "error wrapping", "error handling", "error wrapping", "error handling", "error wrapping", "error handling", "error wrapping", ""], "_raw_llm_output": "URL parsing, string manipulation, string splitting, environment variable usage, minio package usage, error handling, error wrapping, string formatting, error handling, error wrapping, error handling, error wrapping, error handling, error wrapping, error handling, error wrapping, error handling, error wrapping, error handling, error wrapping, error handling, error wrapping, error handling, error wrapping, error handling, error wrapping, error handling, error wrapping, error handling, error wrapping, error handling, error wrapping, error handling, error wrapping, error handling, error wrapping, error handling, error wrapping, error handling, error wrapping, error handling, error wrapping, error handling, error wrapping, error handling, error wrapping, error handling, error wrapping, error handling, error wrapping, error handling, error wrapping, error handling, error wrapping, error handling, error wrapping, error handling, error wrapping, error handling, error wrapping, error handling, error wrapping, error handling, error wrapping, error handling, error wrapping, error handling, error wrapping, error handling, error wrapping, error handling, error wrapping, error handling, error wrapping, error handling, error wrapping, error handling, error wrapping, error handling, error wrapping, error handling, error wrapping, error handling, error wrapping,"}
{"seed": "// ResolverRuleStatus_Values returns all elements of the ResolverRuleStatus enum\nfunc ResolverRuleStatus_Values() []string {\n\treturn []string{\n\t\tResolverRuleStatusComplete,\n\t\tResolverRuleStatusDeleting,\n\t\tResolverRuleStatusUpdating,\n\t\tResolverRuleStatusFailed,\n\t}\n}", "id": 20038, "concepts": ["enum", "string comparison", "string manipulation"], "_raw_llm_output": "enum, string comparison, string manipulation"}
{"seed": "// PathsWithModules returns all paths under and including the\n// root containing files with a \".yang\" extension, as well as\n// any error encountered\nfunc PathsWithModules(root string) (paths []string, err error) {\n\tpm := map[string]bool{}\n\tfilepath.Walk(root, func(p string, info os.FileInfo, e error) error {\n\t\terr = e\n\t\tif err == nil {\n\t\t\tif info == nil {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif !info.IsDir() && strings.HasSuffix(p, \".yang\") {\n\t\t\t\tdir := filepath.Dir(p)\n\t\t\t\tif !pm[dir] {\n\t\t\t\t\tpm[dir] = true\n\t\t\t\t\tpaths = append(paths, dir)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t})\n\treturn\n}", "id": 20071, "concepts": ["filepath.Walk", "map iteration", "error handling", "filepath.Dir", "filepath.IsDir", "filepath.Ext", "string comparison", "string manipulation"], "_raw_llm_output": "filepath.Walk, map iteration, error handling, filepath.Dir, filepath.IsDir, filepath.Ext, string comparison, string manipulation"}
{"seed": "// AddService adds a microservice.\n// It will enable internal common services (PING, STATS and INFO).\n// Request handlers have to be registered separately using Service.AddEndpoint.\n// A service name, version and Endpoint configuration are required to add a service.\n// AddService returns a [Service] interface, allowing service management.\n// Each service is assigned a unique ID.\nfunc AddService(nc *nats.Conn, config Config) (Service, error) {\n\tif err := config.valid(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif config.Metadata == nil {\n\t\tconfig.Metadata = map[string]string{}\n\t}\n\n\tid := nuid.Next()\n\tsvc := &service{\n\t\tConfig: config,\n\t\tnc:     nc,\n\t\tid:     id,\n\t\tasyncDispatcher: asyncCallbacksHandler{\n\t\t\tcbQueue: make(chan func(), 100),\n\t\t},\n\t\tverbSubs:  make(map[string]*nats.Subscription),\n\t\tendpoints: make([]*Endpoint, 0),\n\t}\n\n\t// Add connection event (closed, error) wrapper handlers. If the service has\n\t// custom callbacks, the events are queued and invoked by the same\n\t// goroutine, starting now.\n\tgo svc.asyncDispatcher.run()\n\tsvc.wrapConnectionEventCallbacks()\n\n\tif config.Endpoint != nil {\n\t\topts := []EndpointOpt{WithEndpointSubject(config.Endpoint.Subject)}\n\t\tif config.Endpoint.Metadata != nil {\n\t\t\topts = append(opts, WithEndpointMetadata(config.Endpoint.Metadata))\n\t\t}\n\t\tif err := svc.AddEndpoint(\"default\", config.Endpoint.Handler, opts...); err != nil {\n\t\t\tsvc.asyncDispatcher.close()\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Setup internal subscriptions.\n\tpingResponse := Ping{\n\t\tServiceIdentity: svc.serviceIdentity(),\n\t\tType:            PingResponseType,\n\t}\n\n\thandleVerb := func(verb Verb, valuef func() any) func(req Request) {\n\t\treturn func(req Request) {\n\t\t\tresponse, _ := json.Marshal(valuef())\n\t\t\tif err := req.Respond(response); err != nil {\n\t\t\t\tif err := req.Error(\"500\", fmt.Sprintf(\"Error handling %s request: %s\", verb, err), nil); err != nil && config.ErrorHandler != nil {\n\t\t\t\t\tsvc.asyncDispatcher.push(func() { config.ErrorHandler(svc, &NATSError{req.Subject(), err.Error()}) })\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor verb, source := range map[Verb]func() any{\n\t\tInfoVerb:  func() any { return svc.Info() },\n\t\tPingVerb:  func() any { return pingResponse },\n\t\tStatsVerb: func() any { return svc.Stats() },\n\t} {\n\t\thandler := handleVerb(verb, source)\n\t\tif err := svc.addVerbHandlers(nc, verb, handler); err != nil {\n\t\t\tsvc.asyncDispatcher.close()\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tsvc.started = time.Now().UTC()\n\treturn svc, nil\n}", "id": 20075, "concepts": ["map iteration", "map key iteration", "map value iteration", "map key/value iteration", "map key/value iteration", "map key/value iteration", "map key/value iteration", "map key/value iteration", "map key/value iteration", "map key/value iteration", "map key/value iteration", "map key/value iteration", "map key/value iteration", "map key/value iteration", "map key/value iteration", "map key/value iteration", "map key/value iteration", "map key/value iteration", "map key/value iteration", "map key/value iteration", "map key/value iteration", "map key/value iteration", "map key/value iteration", "map key/value iteration", "map key/value iteration", "map key/value iteration", "map key/value iteration", "map key/value iteration", "map key/value iteration", "map key/value iteration", "map key/value iteration", "map key/value iteration", "map key/value iteration", "map key/value iteration", "map key/value iteration", "map key/value iteration", "map key/value iteration", "map key/value iteration", "map key/value iteration", "map key/value iteration", "map key/value iteration", "map key/value iteration", "map key/value iteration", "map key/value"], "_raw_llm_output": "map iteration, map key iteration, map value iteration, map key/value iteration, map key/value iteration, map key/value iteration, map key/value iteration, map key/value iteration, map key/value iteration, map key/value iteration, map key/value iteration, map key/value iteration, map key/value iteration, map key/value iteration, map key/value iteration, map key/value iteration, map key/value iteration, map key/value iteration, map key/value iteration, map key/value iteration, map key/value iteration, map key/value iteration, map key/value iteration, map key/value iteration, map key/value iteration, map key/value iteration, map key/value iteration, map key/value iteration, map key/value iteration, map key/value iteration, map key/value iteration, map key/value iteration, map key/value iteration, map key/value iteration, map key/value iteration, map key/value iteration, map key/value iteration, map key/value iteration, map key/value iteration, map key/value iteration, map key/value iteration, map key/value iteration, map key/value iteration, map key/value"}
{"seed": "// DefaultGlobalConfig returns a new GlobalConfig instance with default values.\nfunc DefaultGlobalConfig() *GlobalConfig {\n\treturn &GlobalConfig{\n\t\tV1: &V1{\n\t\t\tBackups: &Backups{\n\t\t\t\tLocation: w.String(\"filesystem\"),\n\t\t\t\tFilesystem: &Backups_Filesystem{\n\t\t\t\t\tPath: w.String(\"/var/opt/chef-automate/backups\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tMlsa: &Mlsa{\n\t\t\t\tAccept: w.Bool(true),\n\t\t\t},\n\t\t\tDisclosure: &Disclosure{\n\t\t\t\tShow:            w.Bool(false),\n\t\t\t\tMessageFilePath: w.String(\"\"),\n\t\t\t},\n\t\t\tBanner: &Banner{\n\t\t\t\tShow:            w.Bool(false),\n\t\t\t\tMessage:         w.String(\"\"),\n\t\t\t\tBackgroundColor: w.String(\"#3864f2\"), // Chef Success blue\n\t\t\t\tTextColor:       w.String(\"#FFFFFF\"), // White\n\t\t\t},\n\t\t\tSessionSettings: &SessionSettings{\n\t\t\t\tEnableIdleTimeout:  w.Bool(false),\n\t\t\t\tIdleTimeoutMinutes: w.Int32(30),\n\t\t\t},\n\t\t\tLargeReporting: &LargeReporting{\n\t\t\t\tEnableLargeReporting: w.Bool(false),\n\t\t\t},\n\t\t},\n\t}\n}", "id": 20078, "concepts": ["struct", "pointer", "method definition", "method invocation", "boolean", "integer", "string", "anonymous struct", "anonymous struct field definition", "anonymous struct field initialization", "anonymous struct field access", "boolean comparison", "integer comparison", "string comparison", "boolean conversion", "integer conversion", "string conversion", "boolean assignment", "integer assignment", "string assignment", "boolean comparison", "integer comparison", "string comparison", "boolean conversion", "integer conversion", "string conversion", "boolean assignment", "integer assignment", "string assignment", "boolean comparison", "integer comparison", "string comparison", "boolean conversion", "integer conversion", "string conversion", "boolean assignment", "integer assignment", "string assignment", "boolean comparison", "integer comparison", "string comparison", "boolean conversion", "integer conversion", "string conversion", "boolean assignment", "integer assignment", "string assignment", "boolean comparison", "integer comparison", "string comparison", "boolean conversion", "integer conversion", "string conversion", "boolean assignment", "integer assignment", "string assignment", "boolean comparison", "integer comparison", "string comparison", "boolean conversion", "integer conversion", "string conversion", "boolean assignment", "integer assignment", "string assignment", "boolean comparison", "integer comparison", "string comparison", "boolean conversion", "integer conversion", "string conversion", "boolean assignment", "integer assignment", "string assignment", "boolean comparison", "integer comparison", "string comparison", "boolean conversion", "integer conversion", "string conversion", "boolean assignment", "integer assignment", "string assignment", "boolean comparison", "integer comparison"], "_raw_llm_output": "struct, pointer, method definition, method invocation, boolean, integer, string, anonymous struct, anonymous struct field definition, anonymous struct field initialization, anonymous struct field access, boolean comparison, integer comparison, string comparison, boolean conversion, integer conversion, string conversion, boolean assignment, integer assignment, string assignment, boolean comparison, integer comparison, string comparison, boolean conversion, integer conversion, string conversion, boolean assignment, integer assignment, string assignment, boolean comparison, integer comparison, string comparison, boolean conversion, integer conversion, string conversion, boolean assignment, integer assignment, string assignment, boolean comparison, integer comparison, string comparison, boolean conversion, integer conversion, string conversion, boolean assignment, integer assignment, string assignment, boolean comparison, integer comparison, string comparison, boolean conversion, integer conversion, string conversion, boolean assignment, integer assignment, string assignment, boolean comparison, integer comparison, string comparison, boolean conversion, integer conversion, string conversion, boolean assignment, integer assignment, string assignment, boolean comparison, integer comparison, string comparison, boolean conversion, integer conversion, string conversion, boolean assignment, integer assignment, string assignment, boolean comparison, integer comparison, string comparison, boolean conversion, integer conversion, string conversion, boolean assignment, integer assignment, string assignment, boolean comparison, integer comparison"}
{"seed": "// OkArcVisitor specifies a visitor function to perform some test at each arc\n// and return a boolean result.\n//\n// As long as v return a result of true, the search progresses to traverse all\n// arcs.\n//\n// If v returns false, the search terminates immediately.\n//\n// See also ArcVisitor.\nfunc OkArcVisitor(v func(n graph.NI, x int) bool) func(*config) {\n\treturn func(c *config) {\n\t\tc.okArcVisitor = v\n\t}\n}", "id": 20083, "concepts": ["function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", ""], "_raw_llm_output": "function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition,"}
{"seed": "// UnaryClientInterceptor returns a new unary client interceptor that performs rate limiting on the request on the\n// client side.\n// This can be helpful for clients that want to limit the number of requests they send in a given time, potentially\n// saving cost.\nfunc UnaryClientInterceptor(limiter Limiter) grpc.UnaryClientInterceptor {\n\treturn func(ctx context.Context, method string, req, reply interface{}, cc *grpc.ClientConn,\n\t\tinvoker grpc.UnaryInvoker, opts ...grpc.CallOption) error {\n\t\tif err := limiter.Limit(ctx); err != nil {\n\t\t\treturn status.Errorf(codes.ResourceExhausted, \"%s is rejected by grpc_ratelimit middleware, please retry later. %s\", method, err)\n\t\t}\n\t\treturn invoker(ctx, method, req, reply, cc, opts...)\n\t}\n}", "id": 20084, "concepts": ["grpc.UnaryClientInterceptor", "grpc.UnaryInvoker", "grpc.CallOption", "grpc.ClientConn", "context.Context", "grpc.status.Errorf", "grpc.codes.ResourceExhausted", "grpc_ratelimit.Limiter", "grpc_ratelimit.Limit"], "_raw_llm_output": "grpc.UnaryClientInterceptor, grpc.UnaryInvoker, grpc.CallOption, grpc.ClientConn, context.Context, grpc.status.Errorf, grpc.codes.ResourceExhausted, grpc_ratelimit.Limiter, grpc_ratelimit.Limit"}
{"seed": "// New constructs the minimal chain {1}.\nfunc New() Chain {\n\treturn Chain{big.NewInt(1)}\n}", "id": 20089, "concepts": ["integer type", "big.Int package usage"], "_raw_llm_output": "integer type, big.Int package usage"}
{"seed": "// NewCreateElasticIpRequestWithBody generates requests for CreateElasticIp with any type of body\nfunc NewCreateElasticIpRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {\n\tvar err error\n\n\tqueryUrl, err := url.Parse(server)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbasePath := fmt.Sprintf(\"/elastic-ip\")\n\tif basePath[0] == '/' {\n\t\tbasePath = basePath[1:]\n\t}\n\n\tqueryUrl, err = queryUrl.Parse(basePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq, err := http.NewRequest(\"POST\", queryUrl.String(), body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Add(\"Content-Type\", contentType)\n\treturn req, nil\n}", "id": 20091, "concepts": ["http.NewRequest", "url.Parse", "url.ParseRequestURI", "io.Reader", "fmt.Sprintf", "string formatting"], "_raw_llm_output": "http.NewRequest, url.Parse, url.ParseRequestURI, io.Reader, fmt.Sprintf, string formatting"}
{"seed": "// NewProcessLimiter returns a new ProcessLimiter\nfunc NewProcessLimiter() ProcessLimiter {\n\treturn &processLimiter{}\n}", "id": 20092, "concepts": ["interface implementation", "struct definition", "basic function definition"], "_raw_llm_output": "interface implementation, struct definition, basic function definition"}
{"seed": "// NewPutOrdersOrderFidProductsOrderProductFidSetInitialTermParamsWithContext creates a new PutOrdersOrderFidProductsOrderProductFidSetInitialTermParams object\n// with the ability to set a context for a request.\nfunc NewPutOrdersOrderFidProductsOrderProductFidSetInitialTermParamsWithContext(ctx context.Context) *PutOrdersOrderFidProductsOrderProductFidSetInitialTermParams {\n\treturn &PutOrdersOrderFidProductsOrderProductFidSetInitialTermParams{\n\t\tContext: ctx,\n\t}\n}", "id": 20113, "concepts": ["context package usage", "function definition", "function composition"], "_raw_llm_output": "context package usage, function definition, function composition"}
{"seed": "// Execute the given query with the Google Drive API, returning an array of\n// files that match the query's conditions. Handles transient HTTP errors and\n// the like.\nfunc runDriveQuery(query string) []*drive.File {\n\tpageToken := \"\"\n\tvar result []*drive.File\n\tfor {\n\t\tq := drivesvc.Files.List().Q(query)\n\t\tif pageToken != \"\" {\n\t\t\tq = q.PageToken(pageToken)\n\t\t}\n\n\t\tfor ntries := 0; ; ntries++ {\n\t\t\tr, err := q.Do()\n\t\t\tif err == nil {\n\t\t\t\tresult = append(result, r.Items...)\n\t\t\t\tpageToken = r.NextPageToken\n\t\t\t\tbreak\n\t\t\t} else if err = tryToHandleDriveAPIError(err, ntries); err != nil {\n\t\t\t\tlog.Fatalf(\"couldn't run Google Drive query: %v\\n\",\n\t\t\t\t\terr)\n\t\t\t}\n\t\t}\n\n\t\tif pageToken == \"\" {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn result\n}", "id": 20132, "concepts": ["HTTP client", "API error handling", "retry logic", "retry count", "Google Drive API usage"], "_raw_llm_output": "HTTP client, API error handling, retry logic, retry count, Google Drive API usage"}
{"seed": "// GetNatsClusterIfNil returns a new NatsCluster instance if the given one is nil.\nfunc GetNatsClusterIfNil(natsCluster *v1alpha2.NatsCluster) *v1alpha2.NatsCluster {\n\tif natsCluster != nil {\n\t\treturn natsCluster\n\t}\n\treturn &v1alpha2.NatsCluster{}\n}", "id": 20164, "concepts": ["nil handling", "basic function definition"], "_raw_llm_output": "nil handling, basic function definition"}
{"seed": "// NewNodeList returns a new NodeList head. The list is empty.\nfunc NewNodeList() *NodeList {\n\treturn new(NodeList)\n}", "id": 20174, "concepts": ["struct definition", "basic function definition", "pointer usage"], "_raw_llm_output": "struct definition, basic function definition, pointer usage"}
{"seed": "// NewIamUserAuthorizationWithDefaults instantiates a new IamUserAuthorization object\n// This constructor will only assign default values to properties that have it defined,\n// but it doesn't guarantee that properties required by API are set\nfunc NewIamUserAuthorizationWithDefaults() *IamUserAuthorization {\n\tthis := IamUserAuthorization{}\n\treturn &this\n}", "id": 20186, "concepts": ["struct instantiation", "default value assignment", "basic function definition"], "_raw_llm_output": "struct instantiation, default value assignment, basic function definition"}
{"seed": "// PossibleDatabasePrincipalRoleValues returns an array of possible values for the DatabasePrincipalRole const type.\nfunc PossibleDatabasePrincipalRoleValues() []DatabasePrincipalRole {\n\treturn []DatabasePrincipalRole{Admin, Ingestor, Monitor, UnrestrictedViewers, User, Viewer}\n}", "id": 20192, "concepts": ["enumerations", "array definition", "const declaration"], "_raw_llm_output": "enumerations, array definition, const declaration"}
{"seed": "// NewDigitalOceanMachineConfig is a constructor to set up rke-machine-config.cattle.io.digitaloceanconfig. It returns an *unstructured.Unstructured\n// that CreateMachineConfig uses to created the rke-machine-config\nfunc NewDigitalOceanMachineConfig(generatedPoolName, namespace string) *unstructured.Unstructured {\n\tvar doMachineConfig DOMachineConfig\n\tconfig.LoadConfig(DOMachineConfigConfigurationFileKey, &doMachineConfig)\n\n\tmachineConfig := &unstructured.Unstructured{}\n\tmachineConfig.SetAPIVersion(\"rke-machine-config.cattle.io/v1\")\n\tmachineConfig.SetKind(DOKind)\n\tmachineConfig.SetGenerateName(generatedPoolName)\n\tmachineConfig.SetNamespace(namespace)\n\tmachineConfig.Object[\"accessToken\"] = \"\"\n\tmachineConfig.Object[\"image\"] = doMachineConfig.Image\n\tmachineConfig.Object[\"backups\"] = doMachineConfig.Backups\n\tmachineConfig.Object[\"ipv6\"] = doMachineConfig.IPV6\n\tmachineConfig.Object[\"monitoring\"] = doMachineConfig.Monitoring\n\tmachineConfig.Object[\"privateNetworking\"] = doMachineConfig.PrivateNetworking\n\tmachineConfig.Object[\"region\"] = doMachineConfig.Region\n\tmachineConfig.Object[\"size\"] = doMachineConfig.Size\n\tmachineConfig.Object[\"sshKeyContents\"] = doMachineConfig.SSHKeyContents\n\tmachineConfig.Object[\"sshKeyFingerprint\"] = doMachineConfig.SSHKeyFingerprint\n\tmachineConfig.Object[\"sshPort\"] = doMachineConfig.SSHPort\n\tmachineConfig.Object[\"sshUser\"] = doMachineConfig.SSHUser\n\tmachineConfig.Object[\"tags\"] = doMachineConfig.Tags\n\tmachineConfig.Object[\"type\"] = DOPoolType\n\tmachineConfig.Object[\"userdata\"] = doMachineConfig.Userdata\n\treturn machineConfig\n}", "id": 20197, "concepts": ["unstructured.Unstructured", "struct", "map", "string formatting", "string manipulation", "struct field access", "struct field assignment", "struct field initialization", "struct field type", "struct field value", "struct initialization", "struct member access", "struct member assignment", "struct member initialization", "struct member type", "struct member value", "struct pointer", "struct pointer access", "struct pointer assignment", "struct pointer initialization", "struct pointer type", "struct pointer value", "struct type", "struct value", "string", "string access", "string assignment", "string initialization", "string type", "string value", "unstructured.Unstructured", "unstructured.Unstructured access", "unstructured.Unstructured assignment", "unstructured.Unstructured initialization", "unstructured.Unstructured type", "unstructured.Unstructured value", "unstructured.Unstructured pointer", "unstructured.Unstructured pointer access", "unstructured.Unstructured pointer assignment", "unstructured.Unstructured pointer initialization", "unstructured.Unstructured pointer type", "unstructured.Unstructured pointer value", "unstructured.Unstructured pointer type", "unstructured.Unstructured pointer value", "unstructured.Unstructured type", "unstructured.Unstructured value", "unstructured.Unstructured pointer", "unstructured.Unstructured pointer access", "unstructured.Unstructured pointer assignment", "unstructured.Unstructured pointer initialization", "un"], "_raw_llm_output": "unstructured.Unstructured, struct, map, string formatting, string manipulation, struct field access, struct field assignment, struct field initialization, struct field type, struct field value, struct initialization, struct member access, struct member assignment, struct member initialization, struct member type, struct member value, struct pointer, struct pointer access, struct pointer assignment, struct pointer initialization, struct pointer type, struct pointer value, struct type, struct value, string, string access, string assignment, string initialization, string type, string value, unstructured.Unstructured, unstructured.Unstructured access, unstructured.Unstructured assignment, unstructured.Unstructured initialization, unstructured.Unstructured type, unstructured.Unstructured value, unstructured.Unstructured pointer, unstructured.Unstructured pointer access, unstructured.Unstructured pointer assignment, unstructured.Unstructured pointer initialization, unstructured.Unstructured pointer type, unstructured.Unstructured pointer value, unstructured.Unstructured pointer type, unstructured.Unstructured pointer value, unstructured.Unstructured type, unstructured.Unstructured value, unstructured.Unstructured pointer, unstructured.Unstructured pointer access, unstructured.Unstructured pointer assignment, unstructured.Unstructured pointer initialization, un"}
{"seed": "// AzureADLicenseTypePPremiumP1 returns a pointer to AzureADLicenseTypeVPremiumP1\nfunc AzureADLicenseTypePPremiumP1() *AzureADLicenseType {\n\tv := AzureADLicenseTypeVPremiumP1\n\treturn &v\n}", "id": 20221, "concepts": ["pointer", "struct", "basic function definition"], "_raw_llm_output": "pointer, struct, basic function definition"}
{"seed": "// DefaultLevelInformation returns an instance of LevelInformation with default values.\nfunc DefaultLevelInformation() *LevelInformation {\n\tinfo := &LevelInformation{\n\t\tUnknown0000: defaultMapDimension,\n\t\tUnknown0004: defaultMapDimension,\n\t\tUnknown0008: defaultMapDimensionShift,\n\t\tUnknown000C: defaultMapDimensionShift,\n\t\tHeightShift: defaultHeightShift,\n\t\tTimerValue1: defaultTimerValue1,\n\t\tTimerValue2: defaultTimerValue2}\n\n\treturn info\n}", "id": 20231, "concepts": ["struct definition", "struct field initialization", "pointer usage"], "_raw_llm_output": "struct definition, struct field initialization, pointer usage"}
{"seed": "// setupEnvironmentVariables converts a string array of environment variables\n// into a map as required by the HCS. Source array is in format [v1=k1] [v2=k2] etc.\nfunc setupEnvironmentVariables(a []string) map[string]string {\n\tr := make(map[string]string)\n\tfor _, s := range a {\n\t\tarr := strings.SplitN(s, \"=\", 2)\n\t\tif len(arr) == 2 {\n\t\t\tr[arr[0]] = arr[1]\n\t\t}\n\t}\n\treturn r\n}", "id": 20233, "concepts": ["string manipulation", "map creation", "map iteration"], "_raw_llm_output": "string manipulation, map creation, map iteration"}
{"seed": "// PossiblePrincipalsModificationKindValues returns an array of possible values for the PrincipalsModificationKind const type.\nfunc PossiblePrincipalsModificationKindValues() []PrincipalsModificationKind {\n\treturn []PrincipalsModificationKind{PrincipalsModificationKindNone, PrincipalsModificationKindReplace, PrincipalsModificationKindUnion}\n}", "id": 20249, "concepts": ["constants", "type definition", "array declaration", "array iteration"], "_raw_llm_output": "constants, type definition, array declaration, array iteration"}
{"seed": "// SocialUserIDHasPrefix applies the HasPrefix predicate on the \"social_user_id\" field.\nfunc SocialUserIDHasPrefix(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.HasPrefix(s.C(FieldSocialUserID), v))\n\t})\n}", "id": 20252, "concepts": ["sql.Selector", "sql.C", "sql.HasPrefix", "predicate.User"], "_raw_llm_output": "sql.Selector, sql.C, sql.HasPrefix, predicate.User"}
{"seed": "// NewInlineResponse200115CompanyWithDefaults instantiates a new InlineResponse200115Company object\n// This constructor will only assign default values to properties that have it defined,\n// but it doesn't guarantee that properties required by API are set\nfunc NewInlineResponse200115CompanyWithDefaults() *InlineResponse200115Company {\n\tthis := InlineResponse200115Company{}\n\treturn &this\n}", "id": 20253, "concepts": ["struct", "struct initialization", "struct field initialization", "struct field assignment"], "_raw_llm_output": "struct, struct initialization, struct field initialization, struct field assignment"}
{"seed": "// GetTableNameInsensitive implements a case-insensitive search of a slice of table names. It looks for exact matches\n// first.  If no exact matches are found then any table matching the name case insensitively should be returned.  If\n// there is more than one table that matches a case-insensitive comparison the resolution strategy is not defined.\nfunc GetTableNameInsensitive(tblName string, tableNames []string) (string, bool) {\n\tfor _, name := range tableNames {\n\t\tif tblName == name {\n\t\t\treturn name, true\n\t\t}\n\t}\n\n\tlwrName := strings.ToLower(tblName)\n\n\tfor _, name := range tableNames {\n\t\tif lwrName == strings.ToLower(name) {\n\t\t\treturn name, true\n\t\t}\n\t}\n\n\treturn \"\", false\n}", "id": 20260, "concepts": ["string comparison", "string manipulation", "slice iteration (range loop)", "string formatting", "string to lowercase conversion"], "_raw_llm_output": "string comparison, string manipulation, slice iteration (range loop), string formatting, string to lowercase conversion"}
{"seed": "// IsDirectMention returns true is message is a Direct Mention that mentions a specific user.\n// A direct mention is a mention at the very beginning of the message\nfunc IsDirectMention(rtm *slack.RTM, evt *slack.MessageEvent, userID string) bool {\n\tr, err := regexp.Compile(`^\\s*<@` + userID + `>`)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\treturn r.MatchString(evt.Text)\n}", "id": 20266, "concepts": ["regular expressions", "string matching"], "_raw_llm_output": "regular expressions, string matching"}
{"seed": "// ConnectionPool returns a new database connection pool\n// that is already configured with the correct credentials and\n// instrumented with tracing and logging\nfunc ConnectionPool() *pg.DB {\n\treturn CustomConnectionPool(&pg.Options{\n\t\tAddr:     fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tUser:     cfg.User,\n\t\tPassword: cfg.Password,\n\t\tDatabase: cfg.Database,\n\t})\n}", "id": 20272, "concepts": ["database connection pool", "database connection pool initialization", "database connection pool configuration", "database connection pool usage"], "_raw_llm_output": "database connection pool, database connection pool initialization, database connection pool configuration, database connection pool usage"}
{"seed": "// PacketTypeFromHeader determines the packet type from a *wire.Header.\nfunc PacketTypeFromHeader(hdr *wire.Header) PacketType {\n\tif !hdr.IsLongHeader {\n\t\treturn PacketType1RTT\n\t}\n\tif hdr.Version == 0 {\n\t\treturn PacketTypeVersionNegotiation\n\t}\n\tswitch hdr.Type {\n\tcase protocol.PacketTypeInitial:\n\t\treturn PacketTypeInitial\n\tcase protocol.PacketTypeHandshake:\n\t\treturn PacketTypeHandshake\n\tcase protocol.PacketType0RTT:\n\t\treturn PacketType0RTT\n\tcase protocol.PacketTypeRetry:\n\t\treturn PacketTypeRetry\n\tdefault:\n\t\treturn PacketTypeNotDetermined\n\t}\n}", "id": 20274, "concepts": ["switch statement", "type assertion"], "_raw_llm_output": "switch statement, type assertion"}
{"seed": "// validateSecretName checks if a secret name is valid.\n// It performs the same validation as ValidateSecretName from k8s.io/kubernetes/pkg/apis/core/validation/validation.go.\nfunc validateSecretName(name string, fieldPath *field.Path) field.ErrorList {\n\tif name == \"\" {\n\t\treturn nil\n\t}\n\n\tallErrs := field.ErrorList{}\n\tfor _, msg := range validation.IsDNS1123Subdomain(name) {\n\t\tallErrs = append(allErrs, field.Invalid(fieldPath, name, msg))\n\t}\n\treturn allErrs\n}", "id": 20281, "concepts": ["field.ErrorList", "field.Path", "field.Invalid", "field.Required", "field.Forbidden", "field.Contains", "field.MaxLength", "field.MinLength", "field.MaxLength", "field.MinLength", "field.MaxLength", "field.MinLength", "field.MaxLength", "field.MinLength", "field.MaxLength", "field.MinLength", "field.MaxLength", "field.MinLength", "field.MaxLength", "field.MinLength", "field.MaxLength", "field.MinLength", "field.MaxLength", "field.MinLength", "field.MaxLength", "field.MinLength", "field.MaxLength", "field.MinLength", "field.MaxLength", "field.MinLength", "field.MaxLength", "field.MinLength", "field.MaxLength", "field.MinLength", "field.MaxLength", "field.MinLength", "field.MaxLength", "field.MinLength", "field.MaxLength", "field.MinLength", "field.MaxLength", "field.MinLength", "field.MaxLength", "field.MinLength", "field.MaxLength", "field.MinLength", "field.MaxLength", "field.MinLength", "field.MaxLength", "field.MinLength", "field.MaxLength", "field.MinLength", "field.MaxLength", "field.MinLength", "field.MaxLength", "field.MinLength", "field.MaxLength", "field"], "_raw_llm_output": "field.ErrorList, field.Path, field.Invalid, field.Required, field.Forbidden, field.Contains, field.MaxLength, field.MinLength, field.MaxLength, field.MinLength, field.MaxLength, field.MinLength, field.MaxLength, field.MinLength, field.MaxLength, field.MinLength, field.MaxLength, field.MinLength, field.MaxLength, field.MinLength, field.MaxLength, field.MinLength, field.MaxLength, field.MinLength, field.MaxLength, field.MinLength, field.MaxLength, field.MinLength, field.MaxLength, field.MinLength, field.MaxLength, field.MinLength, field.MaxLength, field.MinLength, field.MaxLength, field.MinLength, field.MaxLength, field.MinLength, field.MaxLength, field.MinLength, field.MaxLength, field.MinLength, field.MaxLength, field.MinLength, field.MaxLength, field.MinLength, field.MaxLength, field.MinLength, field.MaxLength, field.MinLength, field.MaxLength, field.MinLength, field.MaxLength, field.MinLength, field.MaxLength, field.MinLength, field.MaxLength, field"}
{"seed": "// withFullDatabaseAccessUserRole creates a Teleport role with full access to\n// databases.\nfunc withFullDatabaseAccessUserRole(t *testing.T) testOptionsFunc {\n\tt.Helper()\n\t// Create a new role with full access to all databases.\n\treturn withUserRole(t, \"db-access\", types.RoleSpecV6{\n\t\tAllow: types.RoleConditions{\n\t\t\tDatabaseLabels: types.Labels{types.Wildcard: []string{types.Wildcard}},\n\t\t\tDatabaseUsers:  []string{types.Wildcard},\n\t\t\tDatabaseNames:  []string{types.Wildcard},\n\t\t},\n\t})\n}", "id": 20290, "concepts": ["testing", "testing.T", "testOptionsFunc", "testing.T.Helper", "testing.T.Parallel", "testing.T.Run", "testing.T.Skip", "testing.T.SkipNow", "testing.T.Skipf", "testing.T.Fatalf", "testing.T.Error", "testing.T.Errorf", "testing.T.Helper", "testing.T.Parallel", "testing.T.Run", "testing.T.Skip", "testing.T.SkipNow", "testing.T.Skipf", "testing.T.Fatalf", "testing.T.Error", "testing.T.Errorf", "testing.T.Helper", "testing.T.Parallel", "testing.T.Run", "testing.T.Skip", "testing.T.SkipNow", "testing.T.Skipf", "testing.T.Fatalf", "testing.T.Error", "testing.T.Errorf", "testing.T.Helper", "testing.T.Parallel", "testing.T.Run", "testing.T.Skip", "testing.T.SkipNow", "testing.T.Skipf", "testing.T.Fatalf", "testing.T.Error", "testing.T.Errorf", "testing.T.Helper", "testing.T.Parallel", "testing.T.Run", "testing.T"], "_raw_llm_output": "testing, testing.T, testOptionsFunc, testing.T.Helper, testing.T.Parallel, testing.T.Run, testing.T.Skip, testing.T.SkipNow, testing.T.Skipf, testing.T.Fatalf, testing.T.Error, testing.T.Errorf, testing.T.Helper, testing.T.Parallel, testing.T.Run, testing.T.Skip, testing.T.SkipNow, testing.T.Skipf, testing.T.Fatalf, testing.T.Error, testing.T.Errorf, testing.T.Helper, testing.T.Parallel, testing.T.Run, testing.T.Skip, testing.T.SkipNow, testing.T.Skipf, testing.T.Fatalf, testing.T.Error, testing.T.Errorf, testing.T.Helper, testing.T.Parallel, testing.T.Run, testing.T.Skip, testing.T.SkipNow, testing.T.Skipf, testing.T.Fatalf, testing.T.Error, testing.T.Errorf, testing.T.Helper, testing.T.Parallel, testing.T.Run, testing.T"}
{"seed": "// NewCreateMigrationInvoiceParamsWithContext creates a new CreateMigrationInvoiceParams object\n// with the ability to set a context for a request.\nfunc NewCreateMigrationInvoiceParamsWithContext(ctx context.Context) *CreateMigrationInvoiceParams {\n\treturn &CreateMigrationInvoiceParams{\n\t\tContext: ctx,\n\t}\n}", "id": 20292, "concepts": ["context package usage", "context.Context", "basic function definition"], "_raw_llm_output": "context package usage, context.Context, basic function definition"}
{"seed": "// YellowString is a convenient helper function to return a string with yellow\n// foreground.\nfunc YellowString(format string, a ...interface{}) (s string) {\n\ts = colorString(FgYellow, format, a...)\n\treturn\n}", "id": 20299, "concepts": ["string formatting", "fmt package usage", "color formatting"], "_raw_llm_output": "string formatting, fmt package usage, color formatting"}
{"seed": "// Managed returns a managed Davis weather client. It accepts a context for\n// cancelling the Client. It automatically discovers the WeatherLink Live (WLL)\n// unit on the local network. If multicast DNS is disabled on the network, use\n// the unmanaged client. It returns a new client for consuming weather data.\n// Verbose enables Client logging.\nfunc Managed(ctx context.Context, verbose bool) *Client {\n\t// initialize report and notification channel\n\treport, notify := NewReport(verbose)\n\t// generate client\n\tc := &Client{\n\t\tNotify:  notify,\n\t\treport:  report,\n\t\tverbose: verbose,\n\t\twg:      &sync.WaitGroup{},\n\t}\n\tc.println(\"[davisweather] managed client initialized\")\n\n\t// mDNS context to notify engine when to start\n\tmDNSCtx, mDNSDone := context.WithCancel(ctx)\n\n\t// start mDNS discovery and event engine\n\tc.wg.Add(2)\n\tgo c.discovery(ctx, mDNSDone)\n\tgo c.engine(ctx, mDNSCtx)\n\treturn c\n}", "id": 20309, "concepts": ["context", "sync.WaitGroup", "sync.Mutex", "sync.Once", "sync.Cond", "channels", "goroutines", "concurrency", "mDNS", "multicast DNS", "multicast DNS service discovery", "multicast DNS service discovery", "multicast DNS service discovery", "multicast DNS\nservice discovery", "multicast DNS service discovery", "multicast DNS service\ndiscovery", "multicast DNS service discovery", "multicast DNS service discovery", "multicast DNS service discovery", "multicast DNS service discovery", "multicast DNS\nservice discovery", "multicast DNS service discovery", "multicast DNS service\ndiscovery", "multicast DNS service discovery", "multicast DNS service discovery", "multicast DNS service discovery", "multicast DNS service discovery", "multicast DNS\nservice discovery", "multicast DNS service discovery", "multicast DNS service\ndiscovery", "multicast DNS service discovery", "multicast DNS service discovery", "multicast DNS service discovery", "multicast DNS service discovery", "multicast DNS\nservice discovery", "multicast DNS service discovery", "multicast DNS service\ndiscovery", "multicast DNS service discovery", "multicast DNS service discovery", "multicast DNS service discovery", "multicast DNS service discovery", "multicast DNS\nservice discovery", "multicast DNS service discovery", "multicast DNS service\ndiscovery", "multicast DNS service discovery", "multicast DNS service discovery", "multicast DNS service discovery", "multicast DNS service discovery", "multicast DNS\nservice discovery", "multicast DNS service discovery"], "_raw_llm_output": "context, sync.WaitGroup, sync.Mutex, sync.Once, sync.Cond, channels, goroutines,\nconcurrency, mDNS, multicast DNS, multicast DNS service discovery,\nmulticast DNS service discovery, multicast DNS service discovery, multicast DNS\nservice discovery, multicast DNS service discovery, multicast DNS service\ndiscovery, multicast DNS service discovery, multicast DNS service discovery,\nmulticast DNS service discovery, multicast DNS service discovery, multicast DNS\nservice discovery, multicast DNS service discovery, multicast DNS service\ndiscovery, multicast DNS service discovery, multicast DNS service discovery,\nmulticast DNS service discovery, multicast DNS service discovery, multicast DNS\nservice discovery, multicast DNS service discovery, multicast DNS service\ndiscovery, multicast DNS service discovery, multicast DNS service discovery,\nmulticast DNS service discovery, multicast DNS service discovery, multicast DNS\nservice discovery, multicast DNS service discovery, multicast DNS service\ndiscovery, multicast DNS service discovery, multicast DNS service discovery,\nmulticast DNS service discovery, multicast DNS service discovery, multicast DNS\nservice discovery, multicast DNS service discovery, multicast DNS service\ndiscovery, multicast DNS service discovery, multicast DNS service discovery,\nmulticast DNS service discovery, multicast DNS service discovery, multicast DNS\nservice discovery, multicast DNS service discovery"}
{"seed": "// Listen creates a Noise Listener accepting connections on the\n// given network address using net.Listen.\n// The configuration config must be non-nil.\nfunc Listen(network, laddr string, config *Config) (net.Listener, error) {\n\tif config == nil {\n\t\treturn &Listener{}, errors.New(\"Noise: no Config set\")\n\t}\n\n\tl, err := net.Listen(network, laddr)\n\tif err != nil {\n\t\treturn &Listener{}, err\n\t}\n\n\tnoiseListener := &Listener{}\n\tnoiseListener.Listener = l\n\tnoiseListener.config = config\n\treturn noiseListener, nil\n}", "id": 20312, "concepts": ["net.Listener", "net.Listen", "basic function definition", "error handling"], "_raw_llm_output": "net.Listener, net.Listen, basic function definition, error handling"}
{"seed": "// CauchyQtlFor returns the inverse of the CDF (quantile) of the Cauchy distribution, for given probability.\nfunc CauchyQtlFor(\u03b4, \u03b3, p float64) float64 {\n\tqtl := CauchyQtl(\u03b4, \u03b3)\n\treturn qtl(p)\n}", "id": 20320, "concepts": ["probability", "Cauchy distribution", "quantile function"], "_raw_llm_output": "probability, Cauchy distribution, quantile function"}
{"seed": "// NewNameGT applies the GT predicate on the \"new_name\" field.\nfunc NewNameGT(v string) predicate.User {\n\treturn predicate.User(sql.FieldGT(FieldNewName, v))\n}", "id": 20326, "concepts": ["sql package usage", "predicate package usage"], "_raw_llm_output": "sql package usage, predicate package usage"}
{"seed": "// NewGetCwfNetworkIDGatewaysGatewayIDParamsWithHTTPClient creates a new GetCwfNetworkIDGatewaysGatewayIDParams object\n// with the default values initialized, and the ability to set a custom HTTPClient for a request\nfunc NewGetCwfNetworkIDGatewaysGatewayIDParamsWithHTTPClient(client *http.Client) *GetCwfNetworkIDGatewaysGatewayIDParams {\n\tvar ()\n\treturn &GetCwfNetworkIDGatewaysGatewayIDParams{\n\t\tHTTPClient: client,\n\t}\n}", "id": 20329, "concepts": ["http.Client", "http.NewRequest", "http.NewRequestWithContext", "http.NewRequestWithContext", "http.NewRequestWithContext", "http.NewRequestWithContext", "http.NewRequestWithContext", "http.NewRequestWithContext", "http.NewRequestWithContext", "http.NewRequestWithContext", "http.NewRequestWithContext", "http.NewRequestWithContext", "http.NewRequestWithContext", "http.NewRequestWithContext", "http.NewRequestWithContext", "http.NewRequestWithContext", "http.NewRequestWithContext", "http.NewRequestWithContext", "http.NewRequestWithContext", "http.NewRequestWithContext", "http.NewRequestWithContext", "http.NewRequestWithContext", "http.NewRequestWithContext", "http.NewRequestWithContext", "http.NewRequestWithContext", "http.NewRequestWithContext", "http.NewRequestWithContext", "http.NewRequestWithContext", "http.NewRequestWithContext", "http.NewRequestWithContext", "http.NewRequestWithContext", "http.NewRequestWithContext", "http.NewRequestWithContext", "http.NewRequestWithContext", "http.NewRequestWithContext", "http.NewRequestWithContext", "http.NewRequestWithContext", "http.NewRequestWithContext", "http.NewRequestWithContext", "http.NewRequestWithContext", "http.NewRequestWithContext", "http.NewRequestWithContext", "http.NewRequestWithContext", "http.NewRequestWithContext", "http.NewRequestWithContext", "http.NewRequestWithContext", "http.NewRequestWithContext", "http.NewRequestWithContext", "http.NewRequestWithContext", "http.NewRequestWithContext", "http.NewRequestWithContext", "http."], "_raw_llm_output": "http.Client, http.NewRequest, http.NewRequestWithContext, http.NewRequestWithContext, http.NewRequestWithContext, http.NewRequestWithContext, http.NewRequestWithContext, http.NewRequestWithContext, http.NewRequestWithContext, http.NewRequestWithContext, http.NewRequestWithContext, http.NewRequestWithContext, http.NewRequestWithContext, http.NewRequestWithContext, http.NewRequestWithContext, http.NewRequestWithContext, http.NewRequestWithContext, http.NewRequestWithContext, http.NewRequestWithContext, http.NewRequestWithContext, http.NewRequestWithContext, http.NewRequestWithContext, http.NewRequestWithContext, http.NewRequestWithContext, http.NewRequestWithContext, http.NewRequestWithContext, http.NewRequestWithContext, http.NewRequestWithContext, http.NewRequestWithContext, http.NewRequestWithContext, http.NewRequestWithContext, http.NewRequestWithContext, http.NewRequestWithContext, http.NewRequestWithContext, http.NewRequestWithContext, http.NewRequestWithContext, http.NewRequestWithContext, http.NewRequestWithContext, http.NewRequestWithContext, http.NewRequestWithContext, http.NewRequestWithContext, http.NewRequestWithContext, http.NewRequestWithContext, http.NewRequestWithContext, http.NewRequestWithContext, http.NewRequestWithContext, http.NewRequestWithContext, http.NewRequestWithContext, http.NewRequestWithContext, http.NewRequestWithContext, http.NewRequestWithContext, http."}
{"seed": "// NewListCommentContext parses the incoming request URL and body, performs validations and creates the\n// context used by the comment controller list action.\nfunc NewListCommentContext(ctx context.Context, r *http.Request, service *goa.Service) (*ListCommentContext, error) {\n\tvar err error\n\tresp := goa.ContextResponse(ctx)\n\tresp.Service = service\n\treq := goa.ContextRequest(ctx)\n\treq.Request = r\n\trctx := ListCommentContext{Context: ctx, ResponseData: resp, RequestData: req}\n\treturn &rctx, err\n}", "id": 20344, "concepts": ["context package usage", "http.Request", "http.Response", "context.Context"], "_raw_llm_output": "context package usage, http.Request, http.Response, context.Context"}
{"seed": "// SocialUserIDContains applies the Contains predicate on the \"social_user_id\" field.\nfunc SocialUserIDContains(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.Contains(s.C(FieldSocialUserID), v))\n\t})\n}", "id": 20349, "concepts": ["predicate package usage", "sql package usage", "sql.Selector usage", "sql.C usage"], "_raw_llm_output": "predicate package usage, sql package usage, sql.Selector usage, sql.C usage"}
{"seed": "// PossibleNetworkExperimentResourceStateValues returns an array of possible values for the NetworkExperimentResourceState const type.\nfunc PossibleNetworkExperimentResourceStateValues() []NetworkExperimentResourceState {\n\treturn []NetworkExperimentResourceState{NetworkExperimentResourceStateCreating, NetworkExperimentResourceStateDeleting, NetworkExperimentResourceStateDisabled, NetworkExperimentResourceStateDisabling, NetworkExperimentResourceStateEnabled, NetworkExperimentResourceStateEnabling}\n}", "id": 20370, "concepts": ["array definition", "const type", "array iteration"], "_raw_llm_output": "array definition, const type, array iteration"}
{"seed": "// WithGroupVersionKind is an Option that configures a Reconciler's\n// GroupVersionKind.\n//\n// This option is required.\nfunc WithGroupVersionKind(gvk schema.GroupVersionKind) Option {\n\treturn func(r *Reconciler) error {\n\t\tr.gvk = &gvk\n\t\treturn nil\n\t}\n}", "id": 20373, "concepts": ["Option pattern", "struct definition", "struct field definition", "struct field initialization", "struct field assignment"], "_raw_llm_output": "Option pattern, struct definition, struct field definition, struct field initialization, struct field assignment"}
{"seed": "// NewEquipmentFanModule instantiates a new EquipmentFanModule object\n// This constructor will assign default values to properties that have it defined,\n// and makes sure properties required by API are set, but the set of arguments\n// will change when the set of required properties is changed\nfunc NewEquipmentFanModule(classId string, objectType string) *EquipmentFanModule {\n\tthis := EquipmentFanModule{}\n\tthis.ClassId = classId\n\tthis.ObjectType = objectType\n\treturn &this\n}", "id": 20390, "concepts": ["constructor", "default values", "object instantiation", "object property assignment"], "_raw_llm_output": "constructor, default values, object instantiation, object property assignment"}
{"seed": "// NewNameIsNil applies the IsNil predicate on the \"new_name\" field.\nfunc NewNameIsNil() predicate.User {\n\treturn predicate.User(sql.FieldIsNull(FieldNewName))\n}", "id": 20394, "concepts": ["interface", "predicate", "sql.FieldIsNull"], "_raw_llm_output": "interface, predicate, sql.FieldIsNull"}
{"seed": "// ByteCountSIInt converts input int like 982814103 (size in bytes)\n// to a more human-readable string like \"969.9 MB\"\nfunc ByteCountSIInt(input int) string {\n\n\tconst unit = 1000\n\tif input < unit {\n\t\treturn fmt.Sprintf(\"%d B\", input)\n\t}\n\tdiv, exp := int64(unit), 0\n\tfor n := input / unit; n >= unit; n /= unit {\n\t\tdiv *= unit\n\t\texp++\n\t}\n\treturn fmt.Sprintf(\"%.1f %cB\",\n\t\tfloat64(input)/float64(div), \"kMGTPE\"[exp])\n}", "id": 20400, "concepts": ["integer division", "string formatting", "math operations", "rune handling"], "_raw_llm_output": "integer division, string formatting, math operations, rune handling"}
{"seed": "// crdbInternalSendNotice sends a notice.\n// Note this is extracted to a different file to prevent churn on the pgwire\n// test, which records line numbers.\nfunc crdbInternalSendNotice(\n\tctx *tree.EvalContext, severity string, msg string,\n) (tree.Datum, error) {\n\tif ctx.ClientNoticeSender == nil {\n\t\treturn nil, errors.AssertionFailedf(\"notice sender not set\")\n\t}\n\tctx.ClientNoticeSender.BufferClientNotice(\n\t\tctx.Context,\n\t\tpgnotice.NewWithSeverityf(strings.ToUpper(severity), \"%s\", msg),\n\t)\n\treturn tree.NewDInt(0), nil\n}", "id": 20401, "concepts": ["error handling (errors.AssertionFailedf)", "string formatting", "string manipulation", "string concatenation", "string comparison", "string length", "string indexing", "string slicing", "string substring", "string concatenation", "string comparison", "string length", "string indexing", "string slicing", "string substring", "string concatenation", "string comparison", "string length", "string indexing", "string slicing", "string substring", "string concatenation", "string comparison", "string length", "string indexing", "string slicing", "string substring", "string concatenation", "string comparison", "string length", "string indexing", "string slicing", "string substring", "string concatenation", "string comparison", "string length", "string indexing", "string slicing", "string substring", "string concatenation", "string comparison", "string length", "string indexing", "string slicing", "string substring", "string concatenation", "string comparison", "string length", "string indexing", "string slicing", "string substring", "string concatenation", "string comparison", "string length", "string indexing", "string slicing", "string substring", "string concatenation", "string comparison", "string length", "string indexing", "string slicing", "string substring", "string concatenation", "string comparison", "string length", "string indexing", "string slicing", "string substring", "string concatenation", "string comparison", "string length", "string indexing", "string slicing", "string substring"], "_raw_llm_output": "error handling (errors.AssertionFailedf), string formatting, string manipulation, string concatenation, string comparison, string length, string indexing, string slicing, string substring, string concatenation, string comparison, string length, string indexing, string slicing, string substring, string concatenation, string comparison, string length, string indexing, string slicing, string substring, string concatenation, string comparison, string length, string indexing, string slicing, string substring, string concatenation, string comparison, string length, string indexing, string slicing, string substring, string concatenation, string comparison, string length, string indexing, string slicing, string substring, string concatenation, string comparison, string length, string indexing, string slicing, string substring, string concatenation, string comparison, string length, string indexing, string slicing, string substring, string concatenation, string comparison, string length, string indexing, string slicing, string substring, string concatenation, string comparison, string length, string indexing, string slicing, string substring, string concatenation, string comparison, string length, string indexing, string slicing, string substring, string concatenation, string comparison, string length, string indexing, string slicing, string substring"}
{"seed": "// MakeForbidden builds a goa.ServiceError from an error.\nfunc MakeForbidden(err error) *goa.ServiceError {\n\treturn &goa.ServiceError{\n\t\tName:    \"forbidden\",\n\t\tID:      goa.NewErrorID(),\n\t\tMessage: err.Error(),\n\t}\n}", "id": 20407, "concepts": ["goa.ServiceError", "error handling", "error ID generation"], "_raw_llm_output": "goa.ServiceError, error handling, error ID generation"}
{"seed": "// hexdig parses the hexadecimal digit in r.  If parsing was\n// successful, hexdig returns the value of hexadecimal digit r\n// and true.  Otherwise it returns 0 and false.\nfunc hexdig(r rune) (byte, bool) {\n\tswitch {\n\tcase r >= '0' && r <= '9':\n\t\treturn byte(r) - '0', true\n\tcase r >= 'A' && r <= 'F':\n\t\treturn byte(r) - ('A' - 0xa), true\n\tcase r >= 'a' && r <= 'f':\n\t\treturn byte(r) - ('a' - 0xa), true\n\t}\n\treturn 0, false\n}", "id": 20415, "concepts": ["rune handling", "ASCII character comparison", "switch statement"], "_raw_llm_output": "rune handling, ASCII character comparison, switch statement"}
{"seed": "// PossibleManagedRuleExclusionSelectorMatchOperatorValues returns an array of possible values for the ManagedRuleExclusionSelectorMatchOperator const type.\nfunc PossibleManagedRuleExclusionSelectorMatchOperatorValues() []ManagedRuleExclusionSelectorMatchOperator {\n\treturn []ManagedRuleExclusionSelectorMatchOperator{ManagedRuleExclusionSelectorMatchOperatorContains, ManagedRuleExclusionSelectorMatchOperatorEndsWith, ManagedRuleExclusionSelectorMatchOperatorEquals, ManagedRuleExclusionSelectorMatchOperatorEqualsAny, ManagedRuleExclusionSelectorMatchOperatorStartsWith}\n}", "id": 20421, "concepts": ["const type", "array definition"], "_raw_llm_output": "const type, array definition"}
{"seed": "// Of returns the SHA-256 hash of the data, as a Hash.\n// The odd name works well in the client: sha256key.Of.\nfunc Of(data []byte) (hash Hash) {\n\treturn sha256.Sum256(data)\n}", "id": 20431, "concepts": ["hashing", "crypto/sha256 package usage"], "_raw_llm_output": "hashing, crypto/sha256 package usage"}
{"seed": "// BetterHeroScoreAtIsNil applies the IsNil predicate on the \"better_hero_score_at\" field.\nfunc BetterHeroScoreAtIsNil() predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.IsNull(s.C(FieldBetterHeroScoreAt)))\n\t})\n}", "id": 20450, "concepts": ["sql.Selector", "sql.IsNull", "predicate.User", "predicate definition"], "_raw_llm_output": "sql.Selector, sql.IsNull, predicate.User, predicate definition"}
{"seed": "// Returns the canonical begin-tag for a given description.  This does not\n// include the trailing newline.\nfunc beginMungeTag(desc string) string {\n\treturn fmt.Sprintf(\"<!-- BEGIN MUNGE: %s -->\", desc)\n}", "id": 20465, "concepts": ["string formatting", "fmt package usage"], "_raw_llm_output": "string formatting, fmt package usage"}
{"seed": "// RoleAsApplicationKeyResponseIncludedItem is a convenience function that returns Role wrapped in ApplicationKeyResponseIncludedItem.\nfunc RoleAsApplicationKeyResponseIncludedItem(v *Role) ApplicationKeyResponseIncludedItem {\n\treturn ApplicationKeyResponseIncludedItem{Role: v}\n}", "id": 20466, "concepts": ["struct embedding", "basic function definition"], "_raw_llm_output": "struct embedding, basic function definition"}
{"seed": "// StringSliceEqual \u5224\u65ad\u4e24\u4e2a\u5b57\u7b26\u4e32\u5207\u7247\u662f\u5426\u76f8\u7b49\nfunc StringSliceEqual(a, b []string) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tif (a == nil) != (b == nil) {\n\t\treturn false\n\t}\n\tfor i, v := range a {\n\t\tif v != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}", "id": 20489, "concepts": ["slice comparison", "basic function definition"], "_raw_llm_output": "slice comparison, basic function definition"}
{"seed": "// OutpostResolverStatus_Values returns all elements of the OutpostResolverStatus enum\nfunc OutpostResolverStatus_Values() []string {\n\treturn []string{\n\t\tOutpostResolverStatusCreating,\n\t\tOutpostResolverStatusOperational,\n\t\tOutpostResolverStatusUpdating,\n\t\tOutpostResolverStatusDeleting,\n\t\tOutpostResolverStatusActionNeeded,\n\t\tOutpostResolverStatusFailedCreation,\n\t\tOutpostResolverStatusFailedDeletion,\n\t}\n}", "id": 20498, "concepts": ["enum", "string comparison", "array iteration"], "_raw_llm_output": "enum, string comparison, array iteration"}
{"seed": "// IPIpaddrPath returns the URL path to the ipaddr service ip HTTP endpoint.\nfunc IPIpaddrPath() string {\n\treturn \"/ip\"\n}", "id": 20500, "concepts": ["string formatting", "function definition", "basic function definition"], "_raw_llm_output": "string formatting, function definition, basic function definition"}
{"seed": "// UpdatedAtLT applies the LT predicate on the \"updated_at\" field.\nfunc UpdatedAtLT(v time.Time) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.LT(s.C(FieldUpdatedAt), v))\n\t})\n}", "id": 20505, "concepts": ["predicate.User", "sql.Selector", "sql.LT", "sql.Where", "sql.C", "sql.Selector.Where", "sql.Selector.C", "sql.Selector.AddQuery"], "_raw_llm_output": "predicate.User, sql.Selector, sql.LT, sql.Where, sql.C, sql.Selector.Where, sql.Selector.C, sql.Selector.AddQuery"}
{"seed": "// WorkplaceEQ applies the EQ predicate on the \"workplace\" field.\nfunc WorkplaceEQ(v string) predicate.User {\n\treturn predicate.User(sql.FieldEQ(FieldWorkplace, v))\n}", "id": 20515, "concepts": ["predicate.User", "sql.FieldEQ", "sql.Field", "sql.Predicate"], "_raw_llm_output": "predicate.User, sql.FieldEQ, sql.Field, sql.Predicate"}
{"seed": "// Colgroup_ is a convenience wrapper for Colgroup without the attrs argument.\nfunc Colgroup_(children ...HTML) HTML {\n  return Colgroup(nil, children...)\n}", "id": 20522, "concepts": ["HTML", "function definition", "function overloading", "variadic function", "function composition"], "_raw_llm_output": "HTML, function definition, function overloading, variadic function, function composition"}
{"seed": "// PossibleIdentityManagementTypesValues returns the possible values for the IdentityManagementTypes const type.\nfunc PossibleIdentityManagementTypesValues() []IdentityManagementTypes {\n\treturn []IdentityManagementTypes{\n\t\tIdentityManagementTypesActor,\n\t\tIdentityManagementTypesDelegatedResourceIdentity,\n\t\tIdentityManagementTypesNotSpecified,\n\t\tIdentityManagementTypesSystemAssigned,\n\t\tIdentityManagementTypesUserAssigned,\n\t}\n}", "id": 20525, "concepts": ["const type", "possible values", "enum"], "_raw_llm_output": "const type, possible values, enum"}
{"seed": "// newMonitor returns a new monitor. The returned monitor will\n// write output information to the provided ui. The length parameter determines\n// the number of characters for identifiers in the ui.\nfunc newMonitor(ui cli.Ui, client *api.Client, length int) *monitor {\n\tmon := &monitor{\n\t\tui: &cli.PrefixedUi{\n\t\t\tInfoPrefix:   \"==> \",\n\t\t\tOutputPrefix: \"    \",\n\t\t\tErrorPrefix:  \"==> \",\n\t\t\tUi:           ui,\n\t\t},\n\t\tclient: client,\n\t\tstate:  newEvalState(),\n\t\tlength: length,\n\t}\n\treturn mon\n}", "id": 20530, "concepts": ["struct definition", "method definition", "pointer usage", "struct field access", "function definition", "function return value", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function parameter", "function"], "_raw_llm_output": "struct definition, method definition, pointer usage, struct field access, function definition, function return value, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function parameter, function"}
{"seed": "// NewGetFileSystemParametersInternalParamsWithHTTPClient creates a new GetFileSystemParametersInternalParams object\n// with the default values initialized, and the ability to set a custom HTTPClient for a request\nfunc NewGetFileSystemParametersInternalParamsWithHTTPClient(client *http.Client) *GetFileSystemParametersInternalParams {\n\tvar (\n\t\tattachedClusterDefault = bool(false)\n\t\tsecureDefault          = bool(false)\n\t)\n\treturn &GetFileSystemParametersInternalParams{\n\t\tAttachedCluster: &attachedClusterDefault,\n\t\tSecure:          &secureDefault,\n\t\tHTTPClient:      client,\n\t}\n}", "id": 20541, "concepts": ["struct initialization", "pointer dereference", "pointer assignment", "pointer comparison", "boolean assignment", "boolean comparison", "HTTPClient usage"], "_raw_llm_output": "struct initialization, pointer dereference, pointer assignment, pointer comparison, boolean assignment, boolean comparison, HTTPClient usage"}
{"seed": "// New returns a new Chain from the slice of Middleware it receives.\nfunc New(middlewares ...Middleware) Chain {\n\treturn Chain(middlewares)\n}", "id": 20548, "concepts": ["function definition", "function composition", "function chaining", "function composition"], "_raw_llm_output": "function definition, function composition, function chaining, function composition"}
{"seed": "// stateL is the state after reading `L` or during a number.\nfunc stateL(s *scanner, c byte) int {\n\tswitch c {\n\tcase '-':\n\t\ts.step = stateLNeg\n\t\treturn scanContinue\n\tcase '0':\n\t\ts.step = stateEndValue\n\t\treturn scanContinue\n\t}\n\tif '1' <= c && c <= '9' {\n\t\ts.step = stateL1\n\t\treturn scanContinue\n\t}\n\treturn s.error(c, \"in numeric literal\")\n}", "id": 20560, "concepts": ["state machine", "state transition", "state machine usage"], "_raw_llm_output": "state machine, state transition, state machine usage"}
{"seed": "// generatePtrs takes in a list of fields, the field map giving the type info\n// per field and the target struct value and generates a list of interface\n// pointers\n//\n// If a field is nil, it means it couldn't be matched and we insert an\n// IgnoreFieldType pointer instead. This means you will always get back\n// len(fields) pointers initialized\nfunc generatePtrs(fields []string, fieldMap map[string]r.Field, structVal reflect.Value) []interface{} {\n\tptrs := make([]interface{}, len(fields))\n\tfor i, fieldName := range fields {\n\t\tfield, ok := fieldMap[strings.ToLower(fieldName)]\n\t\tif !ok {\n\t\t\tptrs[i] = &IgnoreFieldType{}\n\t\t\tcontinue\n\t\t}\n\n\t\t// Handle the case where the embedded struct hasn't been allocated yet\n\t\t// if it's a pointer. Because these are anonymous, if they are nil we\n\t\t// can't access them! We could be smarter here by allocating embedded\n\t\t// pointers (if they aren't allocated already) and traversing the\n\t\t// struct allocating all the way down as necessary\n\t\tif len(field.Index()) > 1 {\n\t\t\telem := structVal.FieldByIndex([]int{field.Index()[0]})\n\t\t\tif elem.Kind() == reflect.Ptr && elem.IsNil() {\n\t\t\t\tptrs[i] = &IgnoreFieldType{}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\telem := structVal.FieldByIndex(field.Index())\n\t\tif !elem.CanSet() {\n\t\t\tptrs[i] = &IgnoreFieldType{}\n\t\t\tcontinue\n\t\t}\n\n\t\tswitch elem.Kind() {\n\t\tcase reflect.Map:\n\t\t\tif elem.IsNil() {\n\t\t\t\telem.Set(reflect.MakeMap(elem.Type()))\n\t\t\t}\n\t\tcase reflect.Slice:\n\t\t\tif elem.IsNil() {\n\t\t\t\telem.Set(reflect.MakeSlice(elem.Type(), 0, 0))\n\t\t\t}\n\t\t}\n\n\t\tptrs[i] = elem.Addr().Interface()\n\t}\n\treturn ptrs\n}", "id": 20567, "concepts": ["reflection", "map", "slice", "interface", "pointer", "reflect.Value", "reflect.Kind", "reflect.Type", "reflect.Field", "reflect.Value.FieldByIndex", "reflect.Value.Addr", "reflect.Value.Interface", "reflect.Value.CanSet", "reflect.Value.Set", "reflect.Value.Type", "reflect.Value.Kind", "reflect.Value.MakeMap", "reflect.Value.MakeSlice", "reflect.Value.IsNil", "reflect.Value.Set", "reflect.Value.Field", "reflect.Value.Index", "reflect.Value.Type", "reflect.Type.Kind", "reflect.Type.Name", "reflect.Type.Field", "reflect.Type.FieldByIndex", "reflect.Type.NumField", "reflect.Type.NumMethod", "reflect.Type.Method", "reflect.Type.MethodByName", "reflect.Type.Implements", "reflect.Type.AssignableTo", "reflect.Type.Implements", "reflect.Type.Implements", "reflect.Type.Implements", "reflect.Type.Implements", "reflect.Type.Implements", "reflect.Type.Implements", "reflect.Type.Implements", "reflect.Type.Implements", "reflect.Type.Implements", "reflect.Type.Implements", "reflect.Type.Implements", "reflect.Type.Implements", "reflect.Type."], "_raw_llm_output": "reflection, map, slice, interface, pointer, reflect.Value, reflect.Kind, reflect.Type, reflect.Field, reflect.Value.FieldByIndex, reflect.Value.Addr, reflect.Value.Interface, reflect.Value.CanSet, reflect.Value.Set, reflect.Value.Type, reflect.Value.Kind, reflect.Value.MakeMap, reflect.Value.MakeSlice, reflect.Value.IsNil, reflect.Value.Set, reflect.Value.Field, reflect.Value.Index, reflect.Value.Type, reflect.Type.Kind, reflect.Type.Name, reflect.Type.Field, reflect.Type.FieldByIndex, reflect.Type.NumField, reflect.Type.NumMethod, reflect.Type.Method, reflect.Type.MethodByName, reflect.Type.Implements, reflect.Type.AssignableTo, reflect.Type.Implements, reflect.Type.Implements, reflect.Type.Implements, reflect.Type.Implements, reflect.Type.Implements, reflect.Type.Implements, reflect.Type.Implements, reflect.Type.Implements, reflect.Type.Implements, reflect.Type.Implements, reflect.Type.Implements, reflect.Type.Implements, reflect.Type."}
{"seed": "// Figcaption_ is a convenience wrapper for Figcaption without the attrs argument.\nfunc Figcaption_(children ...HTML) HTML {\n  return Figcaption(nil, children...)\n}", "id": 20573, "concepts": ["HTML struct", "HTML struct composition", "HTML struct embedding"], "_raw_llm_output": "HTML struct, HTML struct composition, HTML struct embedding"}
{"seed": "// IDNotIn applies the NotIn predicate on the ID field.\nfunc IDNotIn(ids ...string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\t// if not arguments were provided, append the FALSE constants,\n\t\t// since we can't apply \"IN ()\". This will make this predicate falsy.\n\t\tif len(ids) == 0 {\n\t\t\ts.Where(sql.False())\n\t\t\treturn\n\t\t}\n\t\tv := make([]interface{}, len(ids))\n\t\tfor i := range v {\n\t\t\tv[i] = ids[i]\n\t\t}\n\t\ts.Where(sql.NotIn(s.C(FieldID), v...))\n\t})\n}", "id": 20575, "concepts": ["sql package usage", "predicate definition", "predicate usage", "predicate composition"], "_raw_llm_output": "sql package usage, predicate definition, predicate usage, predicate composition"}
{"seed": "// NewListIdpGroupMappingsDefault creates a ListIdpGroupMappingsDefault with default headers values\nfunc NewListIdpGroupMappingsDefault(code int) *ListIdpGroupMappingsDefault {\n\treturn &ListIdpGroupMappingsDefault{\n\t\t_statusCode: code,\n\t}\n}", "id": 20586, "concepts": ["function definition", "return value", "basic function definition", "function return value"], "_raw_llm_output": "function definition, return value, basic function definition, function return value"}
{"seed": "// WithProxy configures the client to proxy outgoing requests to the specified url.\nfunc WithProxy(proxyURL string) (Option, error) {\n\tu, err := url.Parse(proxyURL)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to parse proxy url %q: %s\", proxyURL, err)\n\t}\n\n\treturn func(c *Client) {\n\t\ttransport := http.DefaultTransport.(*http.Transport).Clone()\n\t\tif c.client.Transport != nil {\n\t\t\ttransport = c.client.Transport.(*http.Transport).Clone()\n\t\t}\n\n\t\ttransport.Proxy = http.ProxyURL(u)\n\n\t\tc.client.Transport = transport\n\t}, nil\n}", "id": 20588, "concepts": ["client configuration", "http.Transport usage", "http.ProxyURL usage"], "_raw_llm_output": "client configuration, http.Transport usage, http.ProxyURL usage"}
{"seed": "// NewSiteMapReadDetailedWithDefaults instantiates a new SiteMapReadDetailed object\n// This constructor will only assign default values to properties that have it defined,\n// but it doesn't guarantee that properties required by API are set\nfunc NewSiteMapReadDetailedWithDefaults() *SiteMapReadDetailed {\n\tthis := SiteMapReadDetailed{}\n\treturn &this\n}", "id": 20594, "concepts": ["constructor", "default value assignment"], "_raw_llm_output": "constructor, default value assignment"}
{"seed": "// NewNamedChannel create new Channel instance with a given human readable name.\n// Name appears in stack traces that are blocked on this channel.\nfunc NewNamedChannel(ctx Context, name string) Channel {\n\treturn &channelImpl{name: name}\n}", "id": 20600, "concepts": ["channel", "channel name", "anonymous function", "standard library usage"], "_raw_llm_output": "channel, channel name, anonymous function, standard library usage"}
{"seed": "// V23RunnerFunc is like cmdutil.RunnerFunc, but allows for a context.T\n// parameter that is given the context as obtained from ctxfn.\nfunc V23RunnerFunc(ctxfn func() *context.T, run func(*context.T, *cmdline.Env, []string) error) cmdline.Runner {\n\treturn RunnerFunc(runner{false, ctxfn, run}.Run)\n}", "id": 20628, "concepts": ["context package usage", "function composition", "anonymous function"], "_raw_llm_output": "context package usage, function composition, anonymous function"}
{"seed": "// SocketUnitName returns a systemd socket unit name for the given app name.\nfunc SocketUnitName(appName types.ACName) string {\n\treturn appName.String() + \".socket\"\n}", "id": 20646, "concepts": ["string formatting", "type conversion", "string manipulation"], "_raw_llm_output": "string formatting, type conversion, string manipulation"}
{"seed": "// IsErrMySQLNotFound returns true when the err type is ErrMySQLNotFoundIdentity.\nfunc IsErrMySQLNotFound(err error) bool {\n\ttarget := new(ErrMySQLNotFoundIdentity)\n\treturn As(err, &target)\n}", "id": 20660, "concepts": ["error handling (errors.As)", "error type comparison"], "_raw_llm_output": "error handling (errors.As), error type comparison"}
{"seed": "// NewReplaceSubscriptionParamsWithContext creates a new ReplaceSubscriptionParams object\n// with the default values initialized, and the ability to set a context for a request\nfunc NewReplaceSubscriptionParamsWithContext(ctx context.Context) *ReplaceSubscriptionParams {\n\tvar ()\n\treturn &ReplaceSubscriptionParams{\n\n\t\tContext: ctx,\n\t}\n}", "id": 20691, "concepts": ["context package usage", "function definition", "struct initialization"], "_raw_llm_output": "context package usage, function definition, struct initialization"}
{"seed": "// MustSimple creates a new lexer definition based on a single state described by `rules`.\n// panics if the rules trigger an error\nfunc MustSimple(rules []Rule, options ...Option) *Definition {\n\tdef, err := NewSimple(rules, options...)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn def\n}", "id": 20703, "concepts": ["panic", "error handling", "function definition", "option handling"], "_raw_llm_output": "panic, error handling, function definition, option handling"}
{"seed": "// initIdentityClient initializes openstack api using\n// gophercloud which handles auth tokens keeping api calls\n// simpler. Currently it uses environment variables for\n// authenticating with openstack identity.\nfunc initIdentityClient() (*gophercloud.ServiceClient, error) {\n\topts, err := openstack.AuthOptionsFromEnv()\n\tif err != nil {\n\t\tlog.Println(\"Error fetching openstack env vars: \", err)\n\t\treturn nil, err\n\t}\n\tprovider, err := openstack.AuthenticatedClient(opts)\n\tif err != nil {\n\t\tlog.Println(\"Error authenticating with openstack: \", err)\n\t\treturn nil, err\n\t}\n\treturn openstack.NewIdentityV2(provider), nil\n}", "id": 20709, "concepts": ["environment variables", "openstack auth", "gophercloud package usage"], "_raw_llm_output": "environment variables, openstack auth, gophercloud package usage"}
{"seed": "// BetterHeroScoreAtGT applies the GT predicate on the \"better_hero_score_at\" field.\nfunc BetterHeroScoreAtGT(v time.Time) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.GT(s.C(FieldBetterHeroScoreAt), v))\n\t})\n}", "id": 20728, "concepts": ["sql.Selector", "sql.Where", "sql.GT", "sql.C", "sql.Predicate", "sql.Field", "sql.Selector.Where", "sql.Selector.C", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where"], "_raw_llm_output": "sql.Selector, sql.Where, sql.GT, sql.C, sql.Predicate, sql.Field, sql.Selector.Where, sql.Selector.C, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where"}
{"seed": "// F logs message under tag with priority PriorityFatal to w.\nfunc F(w Writer, tag Tag, message string) error {\n\treturn w.Write(PriorityFatal, tag, message)\n}", "id": 20729, "concepts": ["error handling (error interface)", "error logging"], "_raw_llm_output": "error handling (error interface), error logging"}
{"seed": "// Cook up a unique-ish UNIX-domain socket name\n// in /var/tmp, for the master.\n// Can't use the current directory since\n// Athena AFS doesn't support UNIX-domain sockets.\nfunc masterSock() string {\n\ts := \"/var/tmp/824-mr-\"\n\ts += strconv.Itoa(os.Getuid())\n\treturn s\n}", "id": 20735, "concepts": ["string concatenation", "string formatting", "integer conversion", "file system access"], "_raw_llm_output": "string concatenation, string formatting, integer conversion, file system access"}
{"seed": "// NewGetConfigsClusterParamsWithContext creates a new GetConfigsClusterParams object\n// with the default values initialized, and the ability to set a context for a request\nfunc NewGetConfigsClusterParamsWithContext(ctx context.Context) *GetConfigsClusterParams {\n\tvar ()\n\treturn &GetConfigsClusterParams{\n\n\t\tContext: ctx,\n\t}\n}", "id": 20754, "concepts": ["context", "basic function definition"], "_raw_llm_output": "context, basic function definition"}
{"seed": "// BulkCreditSamedayFeeGT applies the GT predicate on the \"bulkCreditSamedayFee\" field.\nfunc BulkCreditSamedayFeeGT(v float64) predicate.Bulk {\n\treturn predicate.Bulk(func(s *sql.Selector) {\n\t\ts.Where(sql.GT(s.C(FieldBulkCreditSamedayFee), v))\n\t})\n}", "id": 20759, "concepts": ["sql.Selector", "sql.Where", "sql.GT", "sql.C", "sql.Field", "sql.Predicate", "sql.PredicateFunc", "sql.PredicateFunc", "sql.PredicateFunc", "sql.PredicateFunc", "sql.PredicateFunc", "sql.PredicateFunc", "sql.PredicateFunc", "sql.PredicateFunc", "sql.PredicateFunc", "sql.PredicateFunc", "sql.PredicateFunc", "sql.PredicateFunc", "sql.PredicateFunc", "sql.PredicateFunc", "sql.PredicateFunc", "sql.PredicateFunc", "sql.PredicateFunc", "sql.PredicateFunc", "sql.PredicateFunc", "sql.PredicateFunc", "sql.PredicateFunc", "sql.PredicateFunc", "sql.PredicateFunc", "sql.PredicateFunc", "sql.PredicateFunc", "sql.PredicateFunc", "sql.PredicateFunc", "sql.PredicateFunc", "sql.PredicateFunc", "sql.PredicateFunc", "sql.PredicateFunc", "sql.PredicateFunc", "sql.PredicateFunc", "sql.PredicateFunc", "sql.PredicateFunc", "sql.PredicateFunc", "sql.PredicateFunc", "sql.PredicateFunc", "sql.PredicateFunc", "sql.PredicateFunc", "sql.PredicateFunc", "sql.PredicateFunc", "sql.PredicateFunc", "sql.PredicateFunc", "sql.PredicateFunc", "sql.PredicateFunc", "sql"], "_raw_llm_output": "sql.Selector, sql.Where, sql.GT, sql.C, sql.Field, sql.Predicate, sql.PredicateFunc, sql.PredicateFunc, sql.PredicateFunc, sql.PredicateFunc, sql.PredicateFunc, sql.PredicateFunc, sql.PredicateFunc, sql.PredicateFunc, sql.PredicateFunc, sql.PredicateFunc, sql.PredicateFunc, sql.PredicateFunc, sql.PredicateFunc, sql.PredicateFunc, sql.PredicateFunc, sql.PredicateFunc, sql.PredicateFunc, sql.PredicateFunc, sql.PredicateFunc, sql.PredicateFunc, sql.PredicateFunc, sql.PredicateFunc, sql.PredicateFunc, sql.PredicateFunc, sql.PredicateFunc, sql.PredicateFunc, sql.PredicateFunc, sql.PredicateFunc, sql.PredicateFunc, sql.PredicateFunc, sql.PredicateFunc, sql.PredicateFunc, sql.PredicateFunc, sql.PredicateFunc, sql.PredicateFunc, sql.PredicateFunc, sql.PredicateFunc, sql.PredicateFunc, sql.PredicateFunc, sql.PredicateFunc, sql.PredicateFunc, sql.PredicateFunc, sql.PredicateFunc, sql.PredicateFunc, sql.PredicateFunc, sql.PredicateFunc, sql"}
{"seed": "// SumIntsOrFloats sums the values of map m. It supports both floats and integers\n// as map values.\nfunc SumIntsOrFloats[K comparable, V int64 | float64](m map[K]V) V {\n\tvar s V\n\tfor _, v := range m {\n\t\ts += v\n\t}\n\treturn s\n}", "id": 20764, "concepts": ["generic function definition", "map iteration", "type inference", "type constraint"], "_raw_llm_output": "generic function definition, map iteration, type inference, type constraint"}
{"seed": "// NewGetDevicesApsProfilesParams creates a new GetDevicesApsProfilesParams object,\n// with the default timeout for this client.\n//\n// Default values are not hydrated, since defaults are normally applied by the API server side.\n//\n// To enforce default values in parameter, use SetDefaults or WithDefaults.\nfunc NewGetDevicesApsProfilesParams() *GetDevicesApsProfilesParams {\n\treturn &GetDevicesApsProfilesParams{\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 20773, "concepts": ["default values", "timeout", "client timeout", "client timeout setting"], "_raw_llm_output": "default values, timeout, client timeout, client timeout setting"}
{"seed": "// SetupContractsT is the test friendly version of SetupContracts.\n// It uses the passed testing.T to handle the errors and registers the cleanup functions on it.\nfunc SetupContractsT(t *testing.T, chainURL string, onChainTxTimeout time.Duration) (\n\tadjudicator, asset pwallet.Address) {\n\tvar err error\n\tadjudicator, asset, err = SetupContracts(chainURL, onChainTxTimeout)\n\trequire.NoError(t, err)\n\treturn adjudicator, asset\n}", "id": 20776, "concepts": ["testing package usage", "testing.T", "require package usage"], "_raw_llm_output": "testing package usage, testing.T, require package usage"}
{"seed": "// New is the constructor of gee.Engine\nfunc New() *Engine {\n\treturn &Engine{router: newRouter()}\n}", "id": 20785, "concepts": ["constructor", "struct definition", "pointer usage"], "_raw_llm_output": "constructor, struct definition, pointer usage"}
{"seed": "// RemoveNonExactMappingReadsStrict is a filter that removes all reads\n// that are not exact matches with the reference, based on the\n// optional fields X0=1 (unique mapping), X1=0 (no suboptimal hit),\n// XM=0 (no mismatch), XO=0 (no gap opening), XG=0 (no gap extension).\nfunc RemoveNonExactMappingReadsStrict(header *sam.Header) sam.AlignmentFilter {\n\treturn func(aln *sam.Alignment) bool {\n\t\tif x0, ok := aln.TAGS.Get(X0); !ok || x0.(int32) != 1 {\n\t\t\treturn false\n\t\t}\n\t\tif x1, ok := aln.TAGS.Get(X1); !ok || x1.(int32) != 0 {\n\t\t\treturn false\n\t\t}\n\t\tif xm, ok := aln.TAGS.Get(XM); !ok || xm.(int32) != 0 {\n\t\t\treturn false\n\t\t}\n\t\tif xo, ok := aln.TAGS.Get(XO); !ok || xo.(int32) != 0 {\n\t\t\treturn false\n\t\t}\n\t\tif xg, ok := aln.TAGS.Get(XG); !ok || xg.(int32) != 0 {\n\t\t\treturn false\n\t\t}\n\t\treturn true\n\t}\n}", "id": 20800, "concepts": ["sam package usage", "error handling (errors.Is)", "map iteration", "struct iteration", "struct field access", "interface assertion", "interface type assertion", "interface type switch", "function definition", "function return", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return"], "_raw_llm_output": "sam package usage, error handling (errors.Is), map iteration, struct iteration, struct field access, interface assertion, interface type assertion, interface type switch, function definition, function return, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return"}
{"seed": "// CacheSymlinks enables the kernel to cache symlink contents.\nfunc CacheSymlinks() MountOption {\n\treturn func(conf *mountConfig) error {\n\t\tconf.initFlags |= InitCacheSymlinks\n\t\treturn nil\n\t}\n}", "id": 20802, "concepts": ["mount option", "mountConfig struct", "function composition"], "_raw_llm_output": "mount option, mountConfig struct, function composition"}
{"seed": "// StateNotNil applies the NotNil predicate on the \"state\" field.\nfunc StateNotNil() predicate.User {\n\treturn predicate.User(sql.FieldNotNull(FieldState))\n}", "id": 20816, "concepts": ["predicate.User", "sql.FieldNotNull", "sql.Field"], "_raw_llm_output": "predicate.User, sql.FieldNotNull, sql.Field"}
{"seed": "// TransfertobankaccountNotIn applies the NotIn predicate on the \"transfertobankaccount\" field.\nfunc TransfertobankaccountNotIn(vs ...float64) predicate.Bulk {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.Bulk(func(s *sql.Selector) {\n\t\t// if not arguments were provided, append the FALSE constants,\n\t\t// since we can't apply \"IN ()\". This will make this predicate falsy.\n\t\tif len(v) == 0 {\n\t\t\ts.Where(sql.False())\n\t\t\treturn\n\t\t}\n\t\ts.Where(sql.NotIn(s.C(FieldTransfertobankaccount), v...))\n\t})\n}", "id": 20827, "concepts": ["sql.Selector", "sql.NotIn", "sql.False", "sql.Bulk", "sql.C", "predicate.Bulk", "basic function definition"], "_raw_llm_output": "sql.Selector, sql.NotIn, sql.False, sql.Bulk, sql.C, predicate.Bulk, basic function definition"}
{"seed": "// DefaultExprsIn applies the In predicate on the \"default_exprs\" field.\nfunc DefaultExprsIn(vs ...string) predicate.User {\n\treturn predicate.User(sql.FieldIn(FieldDefaultExprs, vs...))\n}", "id": 20828, "concepts": ["sql.FieldIn", "predicate.User", "sql.Field", "sql.Field"], "_raw_llm_output": "sql.FieldIn, predicate.User, sql.Field, sql.Field"}
{"seed": "/*\n\tGets data from source (ex - database request) and prepare for aerospake storing.\n\tFunction type is \"type LoadFunc func([]interface{}) (map[string]interface{}, error)\"\n\tWe can pass db connection and other date with \"params []interface{}\".\n*/\nfunc _myFuncGetDataForCache(params []interface{}) (map[string]interface{}, error) {\n\tif len(params) != 2 {\n\t\t// params[0] => \"my-add-param\"\n\t\t// params[1] => \"my-add-param-too\"\n\t\treturn nil, fmt.Errorf(\"_myFuncGetDataForCache: Bad input len(params) != 2.\\n\")\n\t}\n\t// Our complex data...\n\treturn map[string]interface{}{\n\t\t\"1\": \"Winnie - 1!\",\n\t\t\"2\": \"Pooh - 2!\",\n\t\t\"3\": \"Honey - 3!\",\n\t}, nil\n}", "id": 20831, "concepts": ["function type", "function parameters", "function return values", "function call"], "_raw_llm_output": "function type, function parameters, function return values, function call"}
{"seed": "// GetKeyProtectionModeEnumValues Enumerates the set of values for KeyProtectionModeEnum\nfunc GetKeyProtectionModeEnumValues() []KeyProtectionModeEnum {\n\tvalues := make([]KeyProtectionModeEnum, 0)\n\tfor _, v := range mappingKeyProtectionModeEnum {\n\t\tvalues = append(values, v)\n\t}\n\treturn values\n}", "id": 20836, "concepts": ["enumerations", "mapping", "basic function definition"], "_raw_llm_output": "enumerations, mapping, basic function definition"}
{"seed": "// PossibleAggregationIntervalValues returns an array of possible values for the AggregationInterval const type.\nfunc PossibleAggregationIntervalValues() []AggregationInterval {\n\treturn []AggregationInterval{AggregationIntervalDaily, AggregationIntervalHourly}\n}", "id": 20842, "concepts": ["constant definition", "array definition", "type definition", "array iteration"], "_raw_llm_output": "constant definition, array definition, type definition, array iteration"}
{"seed": "// IndexOfSingleToken gets the index of the single-byte token with the given string value.\n// If there's no token with the given value, the second return value will be false.\nfunc IndexOfSingleToken(token string) (val byte, ok bool) {\n\tval, ok = mdSingleByteTokenIndex[token]\n\treturn\n}", "id": 20843, "concepts": ["map", "map iteration", "map lookup", "map key lookup", "map value lookup", "map key/value lookup"], "_raw_llm_output": "map, map iteration, map lookup, map key lookup, map value lookup, map key/value lookup"}
{"seed": "// GetOwnerReferencesForBackingImage returns OwnerReference for the given\n// backing image name and UID\nfunc GetOwnerReferencesForBackingImage(backingImage *longhorn.BackingImage) []metav1.OwnerReference {\n\tcontroller := true\n\tblockOwnerDeletion := true\n\treturn []metav1.OwnerReference{\n\t\t{\n\t\t\tAPIVersion:         longhorn.SchemeGroupVersion.String(),\n\t\t\tKind:               types.LonghornKindBackingImage,\n\t\t\tName:               backingImage.Name,\n\t\t\tUID:                backingImage.UID,\n\t\t\tController:         &controller,\n\t\t\tBlockOwnerDeletion: &blockOwnerDeletion,\n\t\t},\n\t}\n}", "id": 20847, "concepts": ["OwnerReference", "metav1.OwnerReference", "longhorn.BackingImage", "longhorn.SchemeGroupVersion", "longhorn.SchemeGroupVersion.String()", "longhorn.KindBackingImage", "types.LonghornKindBackingImage"], "_raw_llm_output": "OwnerReference, metav1.OwnerReference, longhorn.BackingImage, longhorn.SchemeGroupVersion, longhorn.SchemeGroupVersion.String(), longhorn.KindBackingImage, types.LonghornKindBackingImage"}
{"seed": "// This takes either \"us-east-1\" or \"US_EAST_1\"\n// and returns \"us-east-1\" -- i.e. a valid AWS region\nfunc EnsureAWSRegion(region string) string {\n\tr := strings.ToLower(strings.Replace(string(region), \"_\", \"-\", -1))\n    log.Printf(\"EnsureAWSRegion--- region:%s r:%s\", region,r)\n\treturn r\n}", "id": 20848, "concepts": ["string manipulation", "string comparison", "string concatenation", "string formatting", "string conversion", "string replacement"], "_raw_llm_output": "string manipulation, string comparison, string concatenation, string formatting, string conversion, string replacement"}
{"seed": "// WithLinkName creates a new Option that sets the\n// symbolic link name that gets linked to the current\n// file name being used.\nfunc WithLinkName(s string) Option {\n\treturn OptionFn(func(rl *RotateLogs) error {\n\t\trl.linkName = s\n\t\treturn nil\n\t})\n}", "id": 20855, "concepts": ["Option pattern", "function composition", "function composition", "function composition", "function composition"], "_raw_llm_output": "Option pattern, function composition, function composition, function composition, function composition"}
{"seed": "// extractCredentialsFromData extracts and trims a value from the given data map. The first key that exists is being\n// returned, otherwise, the next key is tried, etc. If no key exists then an empty string is returned.\nfunc extractCredentialsFromData(data map[string][]byte, keys ...string) string {\n\tfor _, key := range keys {\n\t\tif val, ok := data[key]; ok {\n\t\t\treturn strings.TrimSpace(string(val))\n\t\t}\n\t}\n\treturn \"\"\n}", "id": 20868, "concepts": ["map iteration (range loop)", "map key existence check", "string trimming"], "_raw_llm_output": "map iteration (range loop), map key existence check, string trimming"}
{"seed": "// NewMyReader creates a new instance of MyReader. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.\n// The first argument is typically a *testing.T value.\nfunc NewMyReader(t interface {\n\tmock.TestingT\n\tCleanup(func())\n}) *MyReader {\n\tmock := &MyReader{}\n\tmock.Mock.Test(t)\n\n\tt.Cleanup(func() { mock.AssertExpectations(t) })\n\n\treturn mock\n}", "id": 20869, "concepts": ["mocking", "testing interface", "testing cleanup", "testing assertions"], "_raw_llm_output": "mocking, testing interface, testing cleanup, testing assertions"}
{"seed": "// Acronym represents the HTML element 'acronym'.\n// For more information visit https://www.w3schools.com/tags/tag_acronym.asp.\nfunc Acronym(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"acronym\", Attributes: attrs, Children: children}\n}", "id": 20875, "concepts": ["HTML generation", "HTML tree creation", "HTML element definition", "HTML attribute definition", "HTML child definition"], "_raw_llm_output": "HTML generation, HTML tree creation, HTML element definition, HTML attribute definition, HTML child definition"}
{"seed": "// NameLT applies the LT predicate on the \"name\" field.\nfunc NameLT(v string) predicate.User {\n\treturn predicate.User(sql.FieldLT(FieldName, v))\n}", "id": 20887, "concepts": ["sql.FieldLT", "sql.FieldGT", "sql.FieldEQ", "sql.FieldNE", "sql.FieldIN", "sql.FieldNotIn", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldIs", "sql.FieldIsNot", "sql.FieldIsNull", "sql.FieldIsNotNull", "sql.FieldBetween", "sql.FieldNotBetween", "sql.FieldExists", "sql.FieldNotExists", "sql.FieldRegexp", "sql.FieldNotRegexp", "sql.FieldAnd", "sql.FieldOr", "sql.FieldNot", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldIs", "sql.FieldIsNot", "sql.FieldIsNull", "sql.FieldIsNotNull", "sql.FieldBetween", "sql.FieldNotBetween", "sql.FieldExists", "sql.FieldNotExists", "sql.FieldRegexp", "sql.FieldNotRegexp", "sql.FieldAnd", "sql.FieldOr", "sql.FieldNot", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldIs", "sql.FieldIsNot", "sql.FieldIsNull", "sql.FieldIsNotNull", "sql.FieldBetween", "sql.FieldNotBetween", "sql.FieldExists", ""], "_raw_llm_output": "sql.FieldLT, sql.FieldGT, sql.FieldEQ, sql.FieldNE, sql.FieldIN, sql.FieldNotIn, sql.FieldLike, sql.FieldNotLike, sql.FieldIs, sql.FieldIsNot, sql.FieldIsNull, sql.FieldIsNotNull, sql.FieldBetween, sql.FieldNotBetween, sql.FieldExists, sql.FieldNotExists, sql.FieldRegexp, sql.FieldNotRegexp, sql.FieldAnd, sql.FieldOr, sql.FieldNot, sql.FieldIn, sql.FieldNotIn, sql.FieldLike, sql.FieldNotLike, sql.FieldIs, sql.FieldIsNot, sql.FieldIsNull, sql.FieldIsNotNull, sql.FieldBetween, sql.FieldNotBetween, sql.FieldExists, sql.FieldNotExists, sql.FieldRegexp, sql.FieldNotRegexp, sql.FieldAnd, sql.FieldOr, sql.FieldNot, sql.FieldIn, sql.FieldNotIn, sql.FieldLike, sql.FieldNotLike, sql.FieldIs, sql.FieldIsNot, sql.FieldIsNull, sql.FieldIsNotNull, sql.FieldBetween, sql.FieldNotBetween, sql.FieldExists,"}
{"seed": "// New creates a new JE struct.\n// Domain is optional but can be at most 1 string.\nfunc New(code int, error string, message string, domain ...string) JE {\n\tj := JE{Code: code, error: error, message: message, time: time.Now().UTC()}\n\tif len(domain) != 0 {\n\t\tj.Domain = domain[0]\n\t}\n\treturn j\n}", "id": 20906, "concepts": ["struct definition", "struct field initialization", "basic function definition"], "_raw_llm_output": "struct definition, struct field initialization, basic function definition"}
{"seed": "// PossibleSkuTierValues returns an array of possible values for the SkuTier const type.\nfunc PossibleSkuTierValues() []SkuTier {\n\treturn []SkuTier{SkuTierBasic, SkuTierPremium, SkuTierStandard}\n}", "id": 20907, "concepts": ["const type", "array declaration"], "_raw_llm_output": "const type, array declaration"}
{"seed": "// WithRetryDefault is a specialization of WithRetry, where retry parameters\n// are set to default values.\nfunc WithRetryDefault(ctx context.Context) context.Context {\n\treturn context.WithValue(ctx, retryCtxKey, &RetryOpt{\n\t\tPeriod:     DefaultRetryPeriod,\n\t\tMaxCount:   DefaultRetryMaxCount,\n\t\tExpBackoff: DefaultRetryBackoff,\n\t})\n}", "id": 20911, "concepts": ["context.Context", "context.WithValue", "context.Context interface", "retry parameters"], "_raw_llm_output": "context.Context, context.WithValue, context.Context interface, retry parameters"}
{"seed": "// Focus returns an event that responds to the javascript \"focus\" event. This event is triggered when a control\n// receives the focus.\nfunc Focus() *Event {\n\treturn NewEvent(\"focus\")\n}", "id": 20917, "concepts": ["event handling", "event listener", "event registration"], "_raw_llm_output": "event handling, event listener, event registration"}
{"seed": "// PossibleEngineTypeValues returns an array of possible values for the EngineType const type.\nfunc PossibleEngineTypeValues() []EngineType {\n\treturn []EngineType{V2, V3}\n}", "id": 20920, "concepts": ["type definition", "type alias", "type conversion", "type assertion"], "_raw_llm_output": "type definition, type alias, type conversion, type assertion"}
{"seed": "// Selector is an ASCII string generated from all labels and their values for a TimeSeries\n// This is the definition of a unique series in Prometheus.\nfunc makeSelector(ts *prompb.TimeSeries) string {\n\ts := []string{}\n\tfor _, label := range ts.Labels[1:] {\n\t\ts = append(s, fmt.Sprintf(\"%s=%s\", label.Name, label.Value))\n\t}\n\treturn strings.Join(s, \":\")\n}", "id": 20922, "concepts": ["string manipulation", "string formatting", "fmt package usage", "string joining"], "_raw_llm_output": "string manipulation, string formatting, fmt package usage, string joining"}
{"seed": "// newMatcher builds an index for the given supported tags and returns it as\n// a matcher. It also expands the index by considering various equivalence classes\n// for a given tag.\nfunc newMatcher(supported []Tag, options []MatchOption) *matcher {\n\tm := &matcher{\n\t\tindex:            make(map[language.Language]*matchHeader),\n\t\tpreferSameScript: true,\n\t}\n\tfor _, o := range options {\n\t\to(m)\n\t}\n\tif len(supported) == 0 {\n\t\tm.default_ = &haveTag{}\n\t\treturn m\n\t}\n\t// Add supported languages to the index. Add exact matches first to give\n\t// them precedence.\n\tfor i, tag := range supported {\n\t\ttt := tag.tag()\n\t\tpair, _ := makeHaveTag(tt, i)\n\t\tm.header(tt.LangID).addIfNew(pair, true)\n\t\tm.supported = append(m.supported, &pair)\n\t}\n\tm.default_ = m.header(supported[0].lang()).haveTags[0]\n\t// Keep these in two different loops to support the case that two equivalent\n\t// languages are distinguished, such as iw and he.\n\tfor i, tag := range supported {\n\t\ttt := tag.tag()\n\t\tpair, max := makeHaveTag(tt, i)\n\t\tif max != tt.LangID {\n\t\t\tm.header(max).addIfNew(pair, true)\n\t\t}\n\t}\n\n\t// update is used to add indexes in the map for equivalent languages.\n\t// update will only add entries to original indexes, thus not computing any\n\t// transitive relations.\n\tupdate := func(want, have uint16, conf Confidence) {\n\t\tif hh := m.index[language.Language(have)]; hh != nil {\n\t\t\tif !hh.original {\n\t\t\t\treturn\n\t\t\t}\n\t\t\thw := m.header(language.Language(want))\n\t\t\tfor _, ht := range hh.haveTags {\n\t\t\t\tv := *ht\n\t\t\t\tif conf < v.conf {\n\t\t\t\t\tv.conf = conf\n\t\t\t\t}\n\t\t\t\tv.nextMax = 0 // this value needs to be recomputed\n\t\t\t\tif v.altScript != 0 {\n\t\t\t\t\tv.altScript = altScript(language.Language(want), v.maxScript)\n\t\t\t\t}\n\t\t\t\thw.addIfNew(v, conf == Exact && hh.original)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Add entries for languages with mutual intelligibility as defined by CLDR's\n\t// languageMatch data.\n\tfor _, ml := range matchLang {\n\t\tupdate(ml.want, ml.have, toConf(ml.distance))\n\t\tif !ml.oneway {\n\t\t\tupdate(ml.have, ml.want, toConf(ml.distance))\n\t\t}\n\t}\n\n\t// Add entries for possible canonicalizations. This is an optimization to\n\t// ensure that only one map lookup needs to be done at runtime per desired tag.\n\t// First we match deprecated equivalents. If they are perfect equivalents\n\t// (their canonicalization simply substitutes a different language code, but\n\t// nothing else), the match confidence is Exact, otherwise it is High.\n\tfor i, lm := range language.AliasMap {\n\t\t// If deprecated codes match and there is no fiddling with the script or\n\t\t// or region, we consider it an exact match.\n\t\tconf := Exact\n\t\tif language.AliasTypes[i] != language.Macro {\n\t\t\tif !isExactEquivalent(language.Language(lm.From)) {\n\t\t\t\tconf = High\n\t\t\t}\n\t\t\tupdate(lm.To, lm.From, conf)\n\t\t}\n\t\tupdate(lm.From, lm.To, conf)\n\t}\n\treturn m\n}", "id": 20951, "concepts": ["map", "map iteration", "map lookup", "standard library usage"], "_raw_llm_output": "map, map iteration, map lookup, standard library usage"}
{"seed": "// RenameChromosomes is a filter for prepending \"chr\" to the reference\n// sequence names in a Header, and in RNAME and RNEXT in each\n// Alignment.\nfunc RenameChromosomes(header *sam.Header) sam.AlignmentFilter {\n\tfor _, entry := range header.SQ {\n\t\tif sn, found := entry[\"SN\"]; found {\n\t\t\tentry[\"SN\"] = \"chr\" + sn\n\t\t}\n\t}\n\treturn func(aln *sam.Alignment) bool {\n\t\tif (aln.RNAME != \"=\") && (aln.RNAME != \"*\") {\n\t\t\taln.RNAME = \"chr\" + aln.RNAME\n\t\t}\n\t\tif (aln.RNEXT != \"=\") && (aln.RNEXT != \"*\") {\n\t\t\taln.RNEXT = \"chr\" + aln.RNEXT\n\t\t}\n\t\treturn true\n\t}\n}", "id": 20953, "concepts": ["struct", "interface", "function definition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition"], "_raw_llm_output": "struct, interface, function definition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition"}
{"seed": "// align increases size such that size is aligned to bytes, and returns the new size.\n//\n// bytes must be a power of 2.\nfunc align(size, bytes int) int {\n\toffset := size & (bytes - 1)\n\t// If we're not currently aligned to |bytes| bytes, add padding.\n\tif offset != 0 {\n\t\tsize += (bytes - offset)\n\t}\n\treturn size\n}", "id": 20955, "concepts": ["bitwise operations", "integer division", "integer alignment"], "_raw_llm_output": "bitwise operations, integer division, integer alignment"}
{"seed": "// AnyError returns an `ErrorMatcher` that returns true for an error\n// that matches any of the `ems`.\nfunc AnyError(ems ...ErrorMatcher) ErrorMatcher {\n\treturn func(err error) bool {\n\t\tif err == nil {\n\t\t\treturn false\n\t\t}\n\t\tfor _, em := range ems {\n\t\t\tif em(err) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n}", "id": 20965, "concepts": ["error handling (errors.Is)", "error matcher function definition"], "_raw_llm_output": "error handling (errors.Is), error matcher function definition"}
{"seed": "// GetObjects retrieves the objects in an Amazon Simple Storage Service (Amazon S3) bucket\n// Inputs:\n//     c is the context of the method call, which includes the AWS Region\n//     api is the interface that defines the method call\n//     input defines the input arguments to the service call.\n// Output:\n//     If success, a ListObjectsV2Output object containing the result of the service call and nil\n//     Otherwise, nil and an error from the call to ListObjectsV2\nfunc GetObjects(c context.Context, api S3ListObjectsAPI, input *s3.ListObjectsV2Input) (*s3.ListObjectsV2Output, error) {\n\treturn api.ListObjectsV2(c, input)\n}", "id": 20975, "concepts": ["context", "interface", "function definition", "method call", "standard library usage"], "_raw_llm_output": "context, interface, function definition, method call, standard library usage"}
{"seed": "// Calculate the Sun Eq Ctr based on the formula: sin(deg2rad(geomMeanAnomSun))*(1.914602-julianCentury*(0.004817+0.000014*julianCentury))+sin(deg2rad(2*geomMeanAnomSun))*(0.019993-0.000101*julianCentury)+sin(deg2rad(3*geomMeanAnomSun))*0.000289;\n// julianCentury - Julian century calculated by the calcJulianCentury function\n// geomMeanAnomSun - Geom Mean Anom Sun calculated by the calcGeomMeanAnomSun function\n// Return The Sun Eq Ctr slice\nfunc calcSunEqCtr(julianCentury []float64, geomMeanAnomSun []float64) (sunEqCtr []float64) {\n\tif len(julianCentury) != len(geomMeanAnomSun) {\n\t\treturn\n\t}\n\n\tfor index := 0; index < len(julianCentury); index++ {\n\t\ttemp := math.Sin(deg2rad(geomMeanAnomSun[index]))*(1.914602-julianCentury[index]*(0.004817+0.000014*julianCentury[index])) + math.Sin(deg2rad(2*geomMeanAnomSun[index]))*(0.019993-0.000101*julianCentury[index]) + math.Sin(deg2rad(3*geomMeanAnomSun[index]))*0.000289\n\t\tsunEqCtr = append(sunEqCtr, temp)\n\t}\n\treturn\n}", "id": 21001, "concepts": ["slice iteration (range loop)", "slice append", "slice length check", "slice length", "slice index", "slice element access", "slice assignment", "slice creation", "slice deletion", "slice deletion by index", "slice deletion by value", "slice deletion by range", "slice deletion by range with index", "slice deletion by range with value", "slice deletion by range with index and value", "slice deletion by range with index and value", "slice deletion by range with index and value", "slice deletion by range with index and value", "slice deletion by range with index and value", "slice deletion by range with index and value", "slice deletion by range with index and value", "slice deletion by range with index and value", "slice deletion by range with index and value", "slice deletion by range with index and value", "slice deletion by range with index and value", "slice deletion by range with index and value", "slice deletion by range with index and value", "slice deletion by range with index and value", "slice deletion by range with index and value", "slice deletion by range with index and value", "slice deletion by range with index and value", "slice deletion by range with index and value", "slice deletion by range with index and value", "slice deletion by range with index and value", "slice deletion by range with index and value", "slice deletion by range with"], "_raw_llm_output": "slice iteration (range loop), slice append, slice length check, slice length, slice index, slice element access, slice assignment, slice creation, slice deletion, slice deletion by index, slice deletion by value, slice deletion by range, slice deletion by range with index, slice deletion by range with value, slice deletion by range with index and value, slice deletion by range with index and value, slice deletion by range with index and value, slice deletion by range with index and value, slice deletion by range with index and value, slice deletion by range with index and value, slice deletion by range with index and value, slice deletion by range with index and value, slice deletion by range with index and value, slice deletion by range with index and value, slice deletion by range with index and value, slice deletion by range with index and value, slice deletion by range with index and value, slice deletion by range with index and value, slice deletion by range with index and value, slice deletion by range with index and value, slice deletion by range with index and value, slice deletion by range with index and value, slice deletion by range with index and value, slice deletion by range with index and value, slice deletion by range with index and value, slice deletion by range with"}
{"seed": "// NewGenBow generates a new random Bow with `numRows` rows and eventual GenSeriesOptions.\nfunc NewGenBow(numRows int, options ...GenSeriesOptions) (Bow, error) {\n\tseries := make([]Series, len(options))\n\tnameMap := make(map[string]struct{})\n\tfor i, o := range options {\n\t\to.NumRows = numRows\n\t\to.validate()\n\t\tif _, ok := nameMap[o.Name]; ok {\n\t\t\to.Name = fmt.Sprintf(\"%s_%d\", o.Name, i)\n\t\t}\n\t\tnameMap[o.Name] = struct{}{}\n\t\tseries[i] = o.genSeries()\n\t}\n\n\treturn NewBow(series...)\n}", "id": 21004, "concepts": ["map", "slice", "function definition", "function call", "function return", "function parameter", "function return value", "function return value type", "function return value type conversion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return value type assertion", "function return"], "_raw_llm_output": "map, slice, function definition, function call, function return, function parameter, function return value, function return value type, function return value type conversion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return value type assertion, function return"}
{"seed": "// contains reports whether the string contains the byte c.\nfunc contains(s string, c byte) bool {\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == c {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}", "id": 21007, "concepts": ["string iteration (range loop)", "byte comparison"], "_raw_llm_output": "string iteration (range loop), byte comparison"}
{"seed": "// Destructure will take a multipolygon, break up the polygon into a set of segments that have the following characteristics:\n// 1. no segment will intersect with another segment, other then at the end points; or colinear and partial-coliner lines.\n// 2. normalize direction of line segments to left to right\n// 3. line segments are generally unique.\n// 4. line segments outside of the clipbox will be clipped\nfunc Destructure(ctx context.Context, cmp pkgcmp.Compare, clipbox *geom.Extent, multipolygon *geom.MultiPolygon) ([]geom.Line, error) {\n\n\tsegments, err := asSegments(*multipolygon)\n\tif err != nil {\n\t\tif debug {\n\t\t\tlog.Printf(\"asSegments returned error: %v\", err)\n\t\t}\n\t\treturn nil, err\n\t}\n\tgext, err := geom.NewExtentFromGeometry(multipolygon)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Let's see if our clip box is bigger then our polygon.\n\t// if it is we don't need the clip box.\n\thasClipbox := clipbox != nil && !clipbox.Contains(gext)\n\t// Let's get the edges of our clipbox; as segments and add it to the begining.\n\tif hasClipbox {\n\t\tedges := clipbox.Edges(nil)\n\t\tsegments = append([]geom.Line{\n\t\t\tgeom.Line(edges[0]), geom.Line(edges[1]),\n\t\t\tgeom.Line(edges[2]), geom.Line(edges[3]),\n\t\t}, segments...)\n\t}\n\tipts := make(map[int][][2]float64)\n\n\t// Lets find all the places we need to split the lines on.\n\teq := intersect.NewEventQueue(segments)\n\teq.FindIntersects(ctx, true, func(src, dest int, pt [2]float64) error {\n\t\tipts[src] = append(ipts[src], pt)\n\t\tipts[dest] = append(ipts[dest], pt)\n\t\treturn nil\n\t})\n\n\t// Time to start splitting lines. if we have a clip box we can ignore the first 4 (0,1,2,3) lines.\n\n\tnsegs := make([]geom.Line, 0, len(segments))\n\n\tfor i := 0; i < len(segments); i++ {\n\t\tpts := append([][2]float64{segments[i][0], segments[i][1]}, ipts[i]...)\n\n\t\t// Normalize the direction of the points.\n\t\tsort.Sort(ByXYPoint(pts))\n\n\t\tfor j := 1; j < len(pts); j++ {\n\t\t\tif cmp.PointEqual(pts[j-1], pts[j]) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tnl := geom.Line{pts[j-1], pts[j]}\n\t\t\tif hasClipbox && !clipbox.ContainsLine(nl) {\n\t\t\t\t// Not in clipbox discard segment.\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tnsegs = append(nsegs, nl)\n\t\t}\n\t\tif ctx.Err() != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tunique(nsegs)\n\treturn nsegs, nil\n}", "id": 21009, "concepts": ["slice iteration (range loop)", "slice append", "slice sorting", "slice unique", "map iteration", "map value append", "map key existence check", "concurrency", "context cancellation", "context error check", "context error handling", "context error propagation", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling", "context error handling"], "_raw_llm_output": "slice iteration (range loop), slice append, slice sorting, slice unique, map iteration, map value append, map key existence check, concurrency, context cancellation, context error check, context error handling, context error propagation, context error handling, context error handling, context error handling, context error handling, context error handling, context error handling, context error handling, context error handling, context error handling, context error handling, context error handling, context error handling, context error handling, context error handling, context error handling, context error handling, context error handling, context error handling, context error handling, context error handling, context error handling, context error handling, context error handling, context error handling, context error handling, context error handling, context error handling, context error handling, context error handling, context error handling, context error handling, context error handling, context error handling, context error handling, context error handling, context error handling, context error handling, context error handling, context error handling, context error handling, context error handling, context error handling, context error handling, context error handling, context error handling, context error handling, context error handling, context error handling, context error handling, context error handling, context error handling, context error handling, context error handling"}
{"seed": "// ParseCreateAntiAffinityGroupResponse parses an HTTP response from a CreateAntiAffinityGroupWithResponse call\nfunc ParseCreateAntiAffinityGroupResponse(rsp *http.Response) (*CreateAntiAffinityGroupResponse, error) {\n\tbodyBytes, err := ioutil.ReadAll(rsp.Body)\n\tdefer rsp.Body.Close()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse := &CreateAntiAffinityGroupResponse{\n\t\tBody:         bodyBytes,\n\t\tHTTPResponse: rsp,\n\t}\n\n\tswitch {\n\tcase strings.Contains(rsp.Header.Get(\"Content-Type\"), \"json\") && rsp.StatusCode == 200:\n\t\tvar dest Operation\n\t\tif err := json.Unmarshal(bodyBytes, &dest); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresponse.JSON200 = &dest\n\n\t}\n\n\treturn response, nil\n}", "id": 21012, "concepts": ["HTTP response parsing", "JSON parsing", "HTTP status code handling", "error handling", "JSON unmarshaling"], "_raw_llm_output": "HTTP response parsing, JSON parsing, HTTP status code handling, error handling, JSON unmarshaling"}
{"seed": "// MustACName generates a new ACName from a string, If the given string is\n// not a valid ACName, it panics.\nfunc MustACName(s string) *ACName {\n\tn, err := NewACName(s)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn n\n}", "id": 21032, "concepts": ["panic", "error handling", "error wrapping", "error handling (errors.Is)", "error handling (errors.As)"], "_raw_llm_output": "panic, error handling, error wrapping, error handling (errors.Is), error handling (errors.As)"}
{"seed": "// NewSingleSignatureFulfillment creates an unsigned SingleSignatureFulfillment,\n// using the given Public Key, which is to be matched with the private key given\n// as part of the later sign call to the returned instance.\nfunc NewSingleSignatureFulfillment(pk PublicKey) *SingleSignatureFulfillment {\n\treturn &SingleSignatureFulfillment{PublicKey: pk}\n}", "id": 21037, "concepts": ["struct definition", "pointer usage", "method definition"], "_raw_llm_output": "struct definition, pointer usage, method definition"}
{"seed": "// SocialEmailHasSuffix applies the HasSuffix predicate on the \"social_email\" field.\nfunc SocialEmailHasSuffix(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.HasSuffix(s.C(FieldSocialEmail), v))\n\t})\n}", "id": 21039, "concepts": ["sql package usage", "sql.Selector", "sql.C", "sql.HasSuffix", "predicate.User", "function definition"], "_raw_llm_output": "sql package usage, sql.Selector, sql.C, sql.HasSuffix, predicate.User, function definition"}
{"seed": "// GetOwnerReferencesForSupportBundle returns a list contains single OwnerReference for the\n// given SupportBundle object\nfunc GetOwnerReferencesForSupportBundle(supportBundle *longhorn.SupportBundle) []metav1.OwnerReference {\n\treturn []metav1.OwnerReference{\n\t\t{\n\t\t\tAPIVersion: longhorn.SchemeGroupVersion.String(),\n\t\t\tKind:       types.LonghornKindSupportBundle,\n\t\t\tName:       supportBundle.Name,\n\t\t\tUID:        supportBundle.UID,\n\t\t},\n\t}\n}", "id": 21046, "concepts": ["metav1.OwnerReference", "longhorn.SchemeGroupVersion", "longhorn.SupportBundle", "types.LonghornKindSupportBundle"], "_raw_llm_output": "metav1.OwnerReference, longhorn.SchemeGroupVersion, longhorn.SupportBundle, types.LonghornKindSupportBundle"}
{"seed": "// WithHTTPClient allows overriding the default Doer, which is\n// automatically created using http.Client. This is useful for tests.\nfunc WithHTTPClient(doer HttpRequestDoer) ClientOption {\n\treturn func(c *Client) error {\n\t\tc.Client = doer\n\t\treturn nil\n\t}\n}", "id": 21058, "concepts": ["http.Client", "http.Request", "http.Response", "http.Client.Do", "http.Client.Transport", "http.RoundTripper", "http.RoundTripper.RoundTrip", "http.Transport.RoundTrip", "http.Transport.RoundTrip", "http.Do", "http.RoundTrip", "http.RoundTripper.RoundTrip", "http.Request.Header", "http.Request.Method", "http.Request.URL", "http.Response.Body", "http.Response.StatusCode", "http.Response.Header", "http.Response.Close", "http.Client.Do", "http.Client.Transport", "http.Client.Transport.RoundTrip", "http.Client.Transport.RoundTrip", "http.Client.Transport.RoundTrip", "http.Client.Transport.RoundTrip", "http.Client.Transport.RoundTrip", "http.Client.Transport.RoundTrip", "http.Client.Transport.RoundTrip", "http.Client.Transport.RoundTrip", "http.Client.Transport.RoundTrip", "http.Client.Transport.RoundTrip", "http.Client.Transport.RoundTrip", "http.Client.Transport.RoundTrip", "http.Client.Transport.RoundTrip", "http.Client.Transport.RoundTrip", "http.Client."], "_raw_llm_output": "http.Client, http.Request, http.Response, http.Client.Do, http.Client.Transport, http.RoundTripper, http.RoundTripper.RoundTrip, http.Transport.RoundTrip, http.Transport.RoundTrip, http.Do, http.RoundTrip, http.RoundTripper.RoundTrip, http.Request.Header, http.Request.Method, http.Request.URL, http.Response.Body, http.Response.StatusCode, http.Response.Header, http.Response.Close, http.Client.Do, http.Client.Transport, http.Client.Transport.RoundTrip, http.Client.Transport.RoundTrip, http.Client.Transport.RoundTrip, http.Client.Transport.RoundTrip, http.Client.Transport.RoundTrip, http.Client.Transport.RoundTrip, http.Client.Transport.RoundTrip, http.Client.Transport.RoundTrip, http.Client.Transport.RoundTrip, http.Client.Transport.RoundTrip, http.Client.Transport.RoundTrip, http.Client.Transport.RoundTrip, http.Client.Transport.RoundTrip, http.Client.Transport.RoundTrip, http.Client."}
{"seed": "// Mix does a linear interpolation from x to y, a = [0,1]\nfunc Mix(x, y, a float64) float64 {\n\treturn x + (a * (y - x))\n}", "id": 21068, "concepts": ["linear interpolation", "basic function definition"], "_raw_llm_output": "linear interpolation, basic function definition"}
{"seed": "// PossibleAzureScaleTypeValues returns an array of possible values for the AzureScaleType const type.\nfunc PossibleAzureScaleTypeValues() []AzureScaleType {\n\treturn []AzureScaleType{Automatic, Manual, None}\n}", "id": 21073, "concepts": ["const type", "array definition", "array iteration"], "_raw_llm_output": "const type, array definition, array iteration"}
{"seed": "// NewFromTile creates Metatile from Tile.\nfunc NewFromTile(t tile.Tile) Metatile {\n\th := xyToHashes(t.X, t.Y)\n\tx, y := h.XY()\n\treturn Metatile{\n\t\tMap:    t.Map,\n\t\tZoom:   t.Zoom,\n\t\tHashes: h,\n\t\tX:      x,\n\t\tY:      y,\n\t}\n}", "id": 21077, "concepts": ["struct definition", "struct field access", "struct field initialization", "struct field type inference", "struct field type conversion", "struct field assignment", "struct field pointer access", "struct field pointer assignment", "struct field pointer type inference", "struct field pointer type conversion", "struct field pointer assignment", "struct field pointer type conversion", "struct field pointer assignment", "struct field pointer type conversion", "struct field pointer assignment", "struct field pointer type conversion", "struct field pointer assignment", "struct field pointer type conversion", "struct field pointer assignment", "struct field pointer type conversion", "struct field pointer assignment", "struct field pointer type conversion", "struct field pointer assignment", "struct field pointer type conversion", "struct field pointer assignment", "struct field pointer type conversion", "struct field pointer assignment", "struct field pointer type conversion", "struct field pointer assignment", "struct field pointer type conversion", "struct field pointer assignment", "struct field pointer type conversion", "struct field pointer assignment", "struct field pointer type conversion", "struct field pointer assignment", "struct field pointer type conversion", "struct field pointer assignment", "struct field pointer type conversion", "struct field pointer assignment", "struct field pointer type conversion", "struct field pointer assignment", "struct field pointer type conversion", "struct field pointer assignment", "struct field pointer type conversion", "struct field pointer assignment", "struct field pointer type conversion", "struct field pointer assignment", "struct field pointer type conversion"], "_raw_llm_output": "struct definition, struct field access, struct field initialization, struct field type inference, struct field type conversion, struct field assignment, struct field pointer access, struct field pointer assignment, struct field pointer type inference, struct field pointer type conversion, struct field pointer assignment, struct field pointer type conversion, struct field pointer assignment, struct field pointer type conversion, struct field pointer assignment, struct field pointer type conversion, struct field pointer assignment, struct field pointer type conversion, struct field pointer assignment, struct field pointer type conversion, struct field pointer assignment, struct field pointer type conversion, struct field pointer assignment, struct field pointer type conversion, struct field pointer assignment, struct field pointer type conversion, struct field pointer assignment, struct field pointer type conversion, struct field pointer assignment, struct field pointer type conversion, struct field pointer assignment, struct field pointer type conversion, struct field pointer assignment, struct field pointer type conversion, struct field pointer assignment, struct field pointer type conversion, struct field pointer assignment, struct field pointer type conversion, struct field pointer assignment, struct field pointer type conversion, struct field pointer assignment, struct field pointer type conversion, struct field pointer assignment, struct field pointer type conversion, struct field pointer assignment, struct field pointer type conversion, struct field pointer assignment, struct field pointer type conversion"}
{"seed": "// CreateQueryLaunchTimeDistributionRequest creates a request to invoke QueryLaunchTimeDistribution API\nfunc CreateQueryLaunchTimeDistributionRequest() (request *QueryLaunchTimeDistributionRequest) {\n\trequest = &QueryLaunchTimeDistributionRequest{\n\t\tRpcRequest: &requests.RpcRequest{},\n\t}\n\trequest.InitWithApiInfo(\"emas-appmonitor\", \"2019-06-11\", \"QueryLaunchTimeDistribution\", \"\", \"\")\n\trequest.Method = requests.POST\n\treturn\n}", "id": 21086, "concepts": ["struct definition", "struct initialization", "method definition", "method invocation"], "_raw_llm_output": "struct definition, struct initialization, method definition, method invocation"}
{"seed": "// AccessScopePInOrganization returns a pointer to AccessScopeVInOrganization\nfunc AccessScopePInOrganization() *AccessScope {\n\tv := AccessScopeVInOrganization\n\treturn &v\n}", "id": 21092, "concepts": ["pointer", "struct", "pointer dereference"], "_raw_llm_output": "pointer, struct, pointer dereference"}
{"seed": "// Phone applies equality check predicate on the \"phone\" field. It's identical to PhoneEQ.\nfunc Phone(v string) predicate.User {\n\treturn predicate.User(sql.FieldEQ(FieldPhone, v))\n}", "id": 21111, "concepts": ["sql.FieldEQ", "sql.FieldNE", "sql.FieldLT", "sql.FieldGT", "sql.FieldLTE", "sql.FieldGTE", "sql.FieldIN", "sql.FieldNotIn", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldIs", "sql.FieldIsNot", "sql.FieldIsNull", "sql.FieldIsNotNull", "sql.FieldBetween", "sql.FieldNotBetween", "sql.FieldExists", "sql.FieldNotExists", "sql.FieldRaw", "sql.FieldAnd", "sql.FieldOr", "sql.FieldNot", "sql.FieldConcat", "sql.FieldConcatWS", "sql.FieldConcatWSWithSep", "sql.FieldConcatWSWithSepAnd", "sql.FieldConcatWSWithSepAndWithSep", "sql.FieldConcatWSWithSepAndWithSepAndWithSep", "sql.FieldConcatWSWithSepAndWithSepAndWithSepAndWithSep", "sql.FieldConcatWSWithSepAndWithSepAndWithSepAndWithSepAndWithSep", "sql.FieldConcatWSWithSepAndWithSepAndWithSepAndWithSepAndWithSepAndWithSep", "sql.FieldConcatWSWithSepAndWithSepAndWithSepAndWithSepAndWithSepAndWithSepAndWithSep", "sql."], "_raw_llm_output": "sql.FieldEQ, sql.FieldNE, sql.FieldLT, sql.FieldGT, sql.FieldLTE, sql.FieldGTE, sql.FieldIN, sql.FieldNotIn, sql.FieldLike, sql.FieldNotLike, sql.FieldIs, sql.FieldIsNot, sql.FieldIsNull, sql.FieldIsNotNull, sql.FieldBetween, sql.FieldNotBetween, sql.FieldExists, sql.FieldNotExists, sql.FieldRaw, sql.FieldAnd, sql.FieldOr, sql.FieldNot, sql.FieldConcat, sql.FieldConcatWS, sql.FieldConcatWSWithSep, sql.FieldConcatWSWithSepAnd, sql.FieldConcatWSWithSepAndWithSep, sql.FieldConcatWSWithSepAndWithSepAndWithSep, sql.FieldConcatWSWithSepAndWithSepAndWithSepAndWithSep, sql.FieldConcatWSWithSepAndWithSepAndWithSepAndWithSepAndWithSep, sql.FieldConcatWSWithSepAndWithSepAndWithSepAndWithSepAndWithSepAndWithSep, sql.FieldConcatWSWithSepAndWithSepAndWithSepAndWithSepAndWithSepAndWithSepAndWithSep, sql."}
{"seed": "// newBodyDownloadPolicy creates a policy object that downloads the response's body to a []byte.\nfunc newBodyDownloadPolicy() Policy {\n\treturn PolicyFunc(func(ctx context.Context, req *Request) (*Response, error) {\n\t\tresp, err := req.Next(ctx)\n\t\tif err != nil {\n\t\t\treturn resp, err\n\t\t}\n\t\tvar opValues bodyDownloadPolicyOpValues\n\t\tif req.OperationValue(&opValues); !opValues.skip && resp.Body != nil {\n\t\t\t// Either bodyDownloadPolicyOpValues was not specified (so skip is false)\n\t\t\t// or it was specified and skip is false: don't skip downloading the body\n\t\t\tresp.Payload, err = ioutil.ReadAll(resp.Body)\n\t\t\tresp.Body.Close()\n\t\t\tif err != nil {\n\t\t\t\terr = fmt.Errorf(\"body download policy: %w\", err)\n\t\t\t}\n\t\t}\n\t\treturn resp, err\n\t})\n}", "id": 21117, "concepts": ["context", "interface", "function composition", "function composition (PolicyFunc)", "function composition (Request.OperationValue)", "function composition (Request.Next)", "function composition (Response.Body)", "function composition (Response.Payload)", "function composition (Response.Body.Close)", "function composition (ioutil.ReadAll)", "function composition (fmt.Errorf)"], "_raw_llm_output": "context, interface, function composition, function composition (PolicyFunc), function composition (Request.OperationValue), function composition (Request.Next), function composition (Response.Body), function composition (Response.Payload), function composition (Response.Body.Close), function composition (ioutil.ReadAll), function composition (fmt.Errorf)"}
{"seed": "// ThreadCreateHandler will pass the call from /debug/pprof/threadcreate to pprof.\nfunc threadCreate(c echo.Context) error {\n\tpprof.Handler(\"threadcreate\").ServeHTTP(c.Response().Writer, c.Request())\n\treturn nil\n}", "id": 21120, "concepts": ["echo framework usage", "pprof package usage", "http server"], "_raw_llm_output": "echo framework usage, pprof package usage, http server"}
{"seed": "// MotorTorque computes empirical motor torque in Nm from motor rpm and motor phase C current\nfunc MotorTorque(rpm, iPhaseC, tMax float64) float64 {\n\ttorque := iPhaseC * (-0.0003*rpm + 1.4292)\n\tif torque > tMax {\n\t\treturn tMax\n\t}\n\treturn torque\n}", "id": 21123, "concepts": ["float64 handling", "basic function definition"], "_raw_llm_output": "float64 handling, basic function definition"}
{"seed": "// PossibleAvailabilityValues returns an array of possible values for the Availability const type.\nfunc PossibleAvailabilityValues() []Availability {\n\treturn []Availability{AvailabilityAvailable, AvailabilityUnavailable}\n}", "id": 21131, "concepts": ["constant definition", "array definition", "array iteration"], "_raw_llm_output": "constant definition, array definition, array iteration"}
{"seed": "// NewDigWithDefaults instantiates a new Dig object\n// This constructor will only assign default values to properties that have it defined,\n// but it doesn't guarantee that properties required by API are set\nfunc NewDigWithDefaults() *Dig {\n\tthis := Dig{}\n\treturn &this\n}", "id": 21139, "concepts": ["struct definition", "struct instantiation", "default values"], "_raw_llm_output": "struct definition, struct instantiation, default values"}
{"seed": "// TemporaryRedirect is a convenience function for building HTTP 307 Temporary\n// Redirect responses. It takes no data argument because there isn't much point\n// in custom status text for a redirect response. Instead, it takes a URL that\n// will be used as the Location header, which should be used by clients as the\n// redirect location. When deciding between HTTP 302, 303, and 307, consult\n// https://developer.mozilla.org/en-US/docs/Web/HTTP/Redirections#temporary_redirections.\nfunc TemporaryRedirect(location string, logging ...interface{}) Response {\n\treturn Response{\n\t\tStatus:  http.StatusTemporaryRedirect,\n\t\tData:    String(\"307 Temporary Redirect\"),\n\t\tLogging: logging,\n\t\tHeaders: http.Header{\"Location\": []string{location}},\n\t}\n}", "id": 21149, "concepts": ["http.StatusTemporaryRedirect", "http.Header", "http.ResponseWriter", "ResponseWriter", "Response", "http.ResponseWriter.Header()", "http.ResponseWriter.Write()", "http.ResponseWriter.WriteHeader()", "http.ResponseWriter.WriteHeader()", "http.ResponseWriter.Header()", "http.ResponseWriter.Header()", "http.ResponseWriter.Header()", "http.ResponseWriter.Header()", "http.ResponseWriter.Header()", "http.ResponseWriter.Header()", "http.ResponseWriter.Header()", "http.ResponseWriter.Header()", "http.ResponseWriter.Header()", "http.ResponseWriter.Header()", "http.ResponseWriter.Header()", "http.ResponseWriter.Header()", "http.ResponseWriter.Header()", "http.ResponseWriter.Header()", "http.ResponseWriter.Header()", "http.ResponseWriter.Header()", "http.ResponseWriter.Header()", "http.ResponseWriter.Header()", "http.ResponseWriter.Header()", "http.ResponseWriter.Header()", "http.ResponseWriter.Header()", "http.ResponseWriter.Header()", "http.ResponseWriter.Header()", "http.ResponseWriter.Header()", "http.ResponseWriter.Header()", "http.ResponseWriter.Header()", "http.ResponseWriter.Header()", "http.ResponseWriter.Header()", "http.ResponseWriter.Header()", "http.ResponseWriter.Header()", "http.ResponseWriter.Header()", "http.ResponseWriter.Header()", "http.ResponseWriter.Header()", "http.ResponseWriter.Header()", "http.ResponseWriter.Header()", "http"], "_raw_llm_output": "http.StatusTemporaryRedirect, http.Header, http.ResponseWriter, ResponseWriter, Response, http.ResponseWriter.Header(), http.ResponseWriter.Write(), http.ResponseWriter.WriteHeader(), http.ResponseWriter.WriteHeader(), http.ResponseWriter.Header(), http.ResponseWriter.Header(), http.ResponseWriter.Header(), http.ResponseWriter.Header(), http.ResponseWriter.Header(), http.ResponseWriter.Header(), http.ResponseWriter.Header(), http.ResponseWriter.Header(), http.ResponseWriter.Header(), http.ResponseWriter.Header(), http.ResponseWriter.Header(), http.ResponseWriter.Header(), http.ResponseWriter.Header(), http.ResponseWriter.Header(), http.ResponseWriter.Header(), http.ResponseWriter.Header(), http.ResponseWriter.Header(), http.ResponseWriter.Header(), http.ResponseWriter.Header(), http.ResponseWriter.Header(), http.ResponseWriter.Header(), http.ResponseWriter.Header(), http.ResponseWriter.Header(), http.ResponseWriter.Header(), http.ResponseWriter.Header(), http.ResponseWriter.Header(), http.ResponseWriter.Header(), http.ResponseWriter.Header(), http.ResponseWriter.Header(), http.ResponseWriter.Header(), http.ResponseWriter.Header(), http.ResponseWriter.Header(), http.ResponseWriter.Header(), http.ResponseWriter.Header(), http.ResponseWriter.Header(), http"}
{"seed": "//TokenBasicStub creates TokenBasic stub and initialize it with Methods\nfunc NewTokenBasicStub(logger log.Logger) *TokenBasicStub {\n\n\tvar stub TokenBasicStub\n\tstub.logger = logger\n\tstub.TbMethods = make([]Method, TB_METHODID_TOTALCOUNT)\n\tstub.TbMethods[TB_METHODID_TRANSFER].Prototype = prototype.TbTransfer\n\tstub.TbMethods[TB_METHODID_SETGASPRICE].Prototype = prototype.TbSetGasPrice\n\tstub.TbMethods[TB_METHODID_SETGASBASEPRICE].Prototype = prototype.TbSetGasBasePrice\n\tfor i, method := range stub.TbMethods {\n\t\tstub.TbMethods[i].MethodID = stubapi.ConvertPrototype2ID(method.Prototype)\n\t\tlogger.Info(\"  method\",\n\t\t\t\"id\", strconv.FormatUint(uint64(stub.TbMethods[i].MethodID), 16),\n\t\t\t\"prototype\", stub.TbMethods[i].Prototype)\n\t}\n\n\tstubapi.SetLogger(logger)\n\n\treturn &stub\n}", "id": 21161, "concepts": ["method definition", "method ID", "method prototype", "method ID conversion"], "_raw_llm_output": "method definition, method ID, method prototype, method ID conversion"}
{"seed": "// NewComponentReferenceDTO instantiates a new ComponentReferenceDTO object\n// This constructor will assign default values to properties that have it defined,\n// and makes sure properties required by API are set, but the set of arguments\n// will change when the set of required properties is changed\nfunc NewComponentReferenceDTO() *ComponentReferenceDTO {\n\tthis := ComponentReferenceDTO{}\n\treturn &this\n}", "id": 21162, "concepts": ["constructor", "struct initialization"], "_raw_llm_output": "constructor, struct initialization"}
{"seed": "// isSpace reports whether r is a space character.\nfunc isSpace(r rune) bool {\n\treturn r == ' ' || r == '\\t' || r == '\\n'\n}", "id": 21167, "concepts": ["rune handling", "character comparison", "rune literals"], "_raw_llm_output": "rune handling, character comparison, rune literals"}
{"seed": "// WithHostname sets the X-Machine-Name header to the passed in hostname.\nfunc WithHostname(hostname string) Option {\n\treturn func(c *Client) {\n\t\tc.machineNameHeader = hostname\n\t}\n}", "id": 21176, "concepts": ["function composition", "function options", "function composition"], "_raw_llm_output": "function composition, function options, function composition"}
{"seed": "// VerifyIdentitySignature verifies a base64URL encoded ECDSA256 signature in the identity\n// against the identity itself using the sender's public key.\nfunc VerifyIdentitySignature(ident *types.PublisherIdentityMessage, pubKey *ecdsa.PublicKey) error {\n\t// the signing took place with the signature field empty\n\tidentCopy := *ident\n\tidentCopy.IdentitySignature = \"\"\n\tpayload, _ := json.Marshal(identCopy)\n\n\terr := VerifyEcdsaSignature(payload, ident.IdentitySignature, pubKey)\n\n\t// signingKey := jose.SigningKey{Algorithm: jose.ES256, Key: privKey}\n\t// joseSigner, _ := jose.NewSigner(signingKey, nil)\n\n\t// jwsObject, _ := joseSigner.Verify(payload)\n\t// sig := jwsObject.Signatures[0].Signature\n\t// sigStr := base64.URLEncoding.EncodeToString(sig)\n\t// return sigStr\n\treturn err\n}", "id": 21199, "concepts": ["ECDSA signature verification", "JSON marshaling", "JSON unmarshaling", "base64 encoding", "string formatting", "pointer handling", "error handling", "JSON library usage"], "_raw_llm_output": "ECDSA signature verification, JSON marshaling, JSON unmarshaling, base64 encoding, string formatting, pointer handling, error handling, JSON library usage"}
{"seed": "// NewEmphasisParser return a new InlineParser that parses emphasises.\nfunc NewEmphasisParser() InlineParser {\n\treturn defaultEmphasisParser\n}", "id": 21224, "concepts": ["interface", "method", "anonymous function", "function composition"], "_raw_llm_output": "interface, method, anonymous function, function composition"}
{"seed": "// SocialTypeEQ applies the EQ predicate on the \"social_type\" field.\nfunc SocialTypeEQ(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldSocialType), v))\n\t})\n}", "id": 21225, "concepts": ["sql.Selector", "sql.EQ", "sql.C", "predicate.User", "anonymous function"], "_raw_llm_output": "sql.Selector, sql.EQ, sql.C, predicate.User, anonymous function"}
{"seed": "// Version returns package version\nfunc Version() string {\n\treturn \"0.2.0\"\n}", "id": 21226, "concepts": ["basic function definition", "string concatenation"], "_raw_llm_output": "basic function definition, string concatenation"}
{"seed": "// GetRelease gets an existing Release resource's state with the given name, ID, and optional\n// state properties that are used to uniquely qualify the lookup (nil if not required).\nfunc GetRelease(ctx *pulumi.Context,\n\tname string, id pulumi.IDInput, state *ReleaseState, opts ...pulumi.ResourceOption) (*Release, error) {\n\tvar resource Release\n\terr := ctx.ReadResource(\"google-native:firebaserules/v1:Release\", name, id, state, &resource, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &resource, nil\n}", "id": 21228, "concepts": ["resource state", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", "resource state mutation", "resource state access", ""], "_raw_llm_output": "resource state, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access, resource state mutation, resource state access,"}
{"seed": "// SocialPayloadHasPrefix applies the HasPrefix predicate on the \"social_payload\" field.\nfunc SocialPayloadHasPrefix(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.HasPrefix(s.C(FieldSocialPayload), v))\n\t})\n}", "id": 21237, "concepts": ["sql package usage", "sql.Selector", "sql.C", "sql.HasPrefix", "predicate.User"], "_raw_llm_output": "sql package usage, sql.Selector, sql.C, sql.HasPrefix, predicate.User"}
{"seed": "// NewGetDeploymentTargetOperatingSystemNamesListAllParamsWithHTTPClient creates a new GetDeploymentTargetOperatingSystemNamesListAllParams object\n// with the default values initialized, and the ability to set a custom HTTPClient for a request\nfunc NewGetDeploymentTargetOperatingSystemNamesListAllParamsWithHTTPClient(client *http.Client) *GetDeploymentTargetOperatingSystemNamesListAllParams {\n\n\treturn &GetDeploymentTargetOperatingSystemNamesListAllParams{\n\t\tHTTPClient: client,\n\t}\n}", "id": 21257, "concepts": ["http client usage"], "_raw_llm_output": "http client usage"}
{"seed": "// getEtcdAPIVersion gets the latest supported API version.\n// If etcd cluster version >= 3.1, \"3\" will be returned.\n// Otherwise, \"2\" will be returned.\nfunc getEtcdAPIVersion(c client.Client) (string, error) {\n\tv, err := c.GetVersion(context.Background())\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tsv, err := semver.NewVersion(v.Cluster)\n\tif err != nil {\n\t\treturn \"\", nil\n\t}\n\n\tif sv.LessThan(*semver.Must(semver.NewVersion(\"3.1.0\"))) {\n\t\treturn \"2\", nil\n\t}\n\n\treturn \"3\", nil\n}", "id": 21259, "concepts": ["semver package usage", "semver version comparison", "semver version parsing", "semver version string manipulation"], "_raw_llm_output": "semver package usage, semver version comparison, semver version parsing, semver version string manipulation"}
{"seed": "// MustItem returns the Item for the given code. It will panic if it doesn't exist.\nfunc MustItem(code string, lang codes.Language) codes.Item {\n\titem, ok := all[code]\n\tif !ok {\n\t\tpanic(fmt.Errorf(\"no item with code: %q\", code))\n\t}\n\tif lang == codes.Norwegian {\n\t\treturn codes.Item{Code: code, Label: item.labelNo, Notes: item.notesNo}\n\t}\n\treturn codes.Item{Code: code, Label: item.labelEn, Notes: item.notesEn}\n\n}", "id": 21260, "concepts": ["panic", "map lookup", "struct composition", "language-specific code"], "_raw_llm_output": "panic, map lookup, struct composition, language-specific code"}
{"seed": "// NewInt32With creates a list of Int32's filled with given\n// values.\nfunc NewInt32With(values ...int32) *Int32 {\n\treturn &Int32{\n\t\tvalues: values,\n\t}\n}", "id": 21262, "concepts": ["struct definition", "struct field definition", "struct field initialization"], "_raw_llm_output": "struct definition, struct field definition, struct field initialization"}
{"seed": "// DialKeepAliveTimeout is the time that the client waits for a response for the\n// keep-alive probe. If the response is not received in this time, the connection is closed.\nfunc DialKeepAliveTimeout(v time.Duration) Configer {\n\treturn func(c *clientv3.Config) {\n\t\tc.DialKeepAliveTimeout = v\n\t}\n}", "id": 21273, "concepts": ["Configer interface", "Configer function", "time package usage"], "_raw_llm_output": "Configer interface, Configer function, time package usage"}
{"seed": "// DBTableIter iterates over all tables returned by db.GetTableNames() calling cb for each one until all tables have\n// been processed, or an error is returned from the callback, or the cont flag is false when returned from the callback.\nfunc DBTableIter(ctx *Context, db Database, cb func(Table) (cont bool, err error)) error {\n\tnames, err := db.GetTableNames(ctx)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, name := range names {\n\t\ttbl, ok, err := db.GetTableInsensitive(ctx, name)\n\n\t\tif err != nil {\n\t\t\treturn err\n\t\t} else if !ok {\n\t\t\treturn ErrTableNotFound.New(name)\n\t\t}\n\n\t\tcont, err := cb(tbl)\n\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif !cont {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn nil\n}", "id": 21288, "concepts": ["error handling (idiomatic `if err != nil`", "`errors.Is`", "`errors.As`)", "error wrapping", "error handling (error chaining)", "error handling (error wrapping)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling"], "_raw_llm_output": "error handling (idiomatic `if err != nil`, `errors.Is`, `errors.As`), error wrapping, error handling (error chaining), error handling (error wrapping), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling"}
{"seed": "// HeroPlayedNEQ applies the NEQ predicate on the \"hero_played\" field.\nfunc HeroPlayedNEQ(v uint) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldHeroPlayed), v))\n\t})\n}", "id": 21289, "concepts": ["predicate.User", "sql.NEQ", "sql.Selector"], "_raw_llm_output": "predicate.User, sql.NEQ, sql.Selector"}
{"seed": "// Wrap wraps given http.ResponseWriter and returns a response object which\n// implements JResponseWriter interface.\n//\n// If given parameter already implements JResponseWriter \"Wrap\" returns it\n// instead of wrapping it again.\nfunc Wrap(w http.ResponseWriter) JResponseWriter {\n\tif w, ok := w.(JResponseWriter); ok {\n\t\treturn w\n\t}\n\n\tif w.Header().Get(\"Content-Type\") == \"\" {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t}\n\n\treturn &Response{rw: w, fields: make(map[string]interface{})}\n}", "id": 21292, "concepts": ["interface implementation", "http.ResponseWriter usage", "map usage"], "_raw_llm_output": "interface implementation, http.ResponseWriter usage, map usage"}
{"seed": "// MaxCountOf will count number of occurrence of each element of\n// classes in data and return the class with maximum count.\n//\n// If `classes` is empty, it will return -1 and false.\n// If `data` is empty, it will return -2 and false.\n// If classes has the same count value, then the first max in the class will be\n// returned.\n//\n// For example, given a data [5, 6, 5, 6, 5] and classes [5, 6, 7], the\n// function will count 5 as 3, 6 as 2, and 7 as 0.\n// Since frequency of 5 is greater than 6 and 7, then it will return `5` and\n// `true`.\nfunc MaxCountOf(d, classes []float64) (float64, bool) {\n\tif len(classes) == 0 {\n\t\treturn -1, false\n\t}\n\tif len(d) == 0 {\n\t\treturn -2, false\n\t}\n\n\tcounts := Counts(d, classes)\n\n\t_, maxi, _ := ints.Max(counts)\n\n\treturn classes[maxi], true\n}", "id": 21296, "concepts": ["slice iteration (range loop)", "slice manipulation", "integer summation", "struct definition", "struct field access", "map iteration", "map manipulation", "slice manipulation", "integer comparison", "integer summation", "integer division", "integer comparison", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", ""], "_raw_llm_output": "slice iteration (range loop), slice manipulation, integer summation,\nstruct definition, struct field access, map iteration, map manipulation,\nslice manipulation, integer comparison, integer summation, integer division,\ninteger comparison, integer division, integer division, integer division,\ninteger division, integer division, integer division, integer division,\ninteger division, integer division, integer division, integer division,\ninteger division, integer division, integer division, integer division,\ninteger division, integer division, integer division, integer division,\ninteger division, integer division, integer division, integer division,\ninteger division, integer division, integer division, integer division,\ninteger division, integer division, integer division, integer division,\ninteger division, integer division, integer division, integer division,\ninteger division, integer division, integer division, integer division,\ninteger division, integer division, integer division, integer division,\ninteger division, integer division, integer division, integer division,\ninteger division, integer division, integer division, integer division,\ninteger division, integer division, integer division, integer division,\ninteger division, integer division, integer division, integer division,\ninteger division, integer division, integer division, integer division,\ninteger division,"}
{"seed": "// PossibleHeaderActionTypeValues returns an array of possible values for the HeaderActionType const type.\nfunc PossibleHeaderActionTypeValues() []HeaderActionType {\n\treturn []HeaderActionType{HeaderActionTypeAppend, HeaderActionTypeDelete, HeaderActionTypeOverwrite}\n}", "id": 21299, "concepts": ["const type", "array", "array iteration"], "_raw_llm_output": "const type, array, array iteration"}
{"seed": "// DropOptionalGTE applies the GTE predicate on the \"drop_optional\" field.\nfunc DropOptionalGTE(v string) predicate.User {\n\treturn predicate.User(sql.FieldGTE(FieldDropOptional, v))\n}", "id": 21300, "concepts": ["sql package usage", "predicate.User", "sql.FieldGTE"], "_raw_llm_output": "sql package usage, predicate.User, sql.FieldGTE"}
{"seed": "// labelsForEnvoyIngress returns the labels for selecting the resources\n// belonging to the given kafka CR name.\nfunc labelsForEnvoyIngress(crName, eLName string) map[string]string {\n\treturn map[string]string{v1beta1.AppLabelKey: \"envoyingress\", \"eListenerName\": eLName, v1beta1.KafkaCRLabelKey: crName}\n}", "id": 21301, "concepts": ["map", "struct", "string formatting", "label selection"], "_raw_llm_output": "map, struct, string formatting, label selection"}
{"seed": "// Checks if actual != expected.\nfunc NotEqual(values ...interface{}) (failureMessage string) {\n\tif values[0] == values[1] {\n\t\tfailureMessage = fmt.Sprintf(\"Expected `%v` to not equal `%v`\", values[0], values[1])\n\t}\n\treturn\n}", "id": 21308, "concepts": ["interface", "type assertion", "basic function definition"], "_raw_llm_output": "interface, type assertion, basic function definition"}
{"seed": "// Size returns testchain initial validators amount.\nfunc Size() int {\n\treturn ValidatorsCount\n}", "id": 21311, "concepts": ["constant definition", "basic function definition"], "_raw_llm_output": "constant definition, basic function definition"}
{"seed": "// NewDNSProvider returns a DNSProvider instance configured for domeneshop.\n// Credentials must be passed in the environment variables:\n// DOMENESHOP_API_TOKEN, DOMENESHOP_API_SECRET.\nfunc NewDNSProvider() (*DNSProvider, error) {\n\tvalues, err := env.Get(EnvAPIToken, EnvAPISecret)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"domeneshop: %w\", err)\n\t}\n\n\tconfig := NewDefaultConfig()\n\tconfig.APIToken = values[EnvAPIToken]\n\tconfig.APISecret = values[EnvAPISecret]\n\n\treturn NewDNSProviderConfig(config)\n}", "id": 21314, "concepts": ["environment variable usage", "configuration", "error handling", "function definition", "struct definition", "struct initialization", "struct field access", "struct method definition", "struct method call", "struct method call with receiver", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call"], "_raw_llm_output": "environment variable usage, configuration, error handling, function definition, struct definition, struct initialization, struct field access, struct method definition, struct method call, struct method call with receiver, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call"}
{"seed": "// NewNoMDEntriesRepeatingGroup returns an initialized, NoMDEntriesRepeatingGroup\nfunc NewNoMDEntriesRepeatingGroup() NoMDEntriesRepeatingGroup {\n\treturn NoMDEntriesRepeatingGroup{\n\t\tquickfix.NewRepeatingGroup(tag.NoMDEntries,\n\t\t\tquickfix.GroupTemplate{quickfix.GroupElement(tag.MDEntryType), quickfix.GroupElement(tag.MDEntryPx), quickfix.GroupElement(tag.Currency), quickfix.GroupElement(tag.MDEntrySize), quickfix.GroupElement(tag.MDEntryDate), quickfix.GroupElement(tag.MDEntryTime), quickfix.GroupElement(tag.TickDirection), quickfix.GroupElement(tag.MDMkt), quickfix.GroupElement(tag.TradingSessionID), quickfix.GroupElement(tag.QuoteCondition), quickfix.GroupElement(tag.TradeCondition), quickfix.GroupElement(tag.MDEntryOriginator), quickfix.GroupElement(tag.LocationID), quickfix.GroupElement(tag.DeskID), quickfix.GroupElement(tag.OpenCloseSettleFlag), quickfix.GroupElement(tag.TimeInForce), quickfix.GroupElement(tag.ExpireDate), quickfix.GroupElement(tag.ExpireTime), quickfix.GroupElement(tag.MinQty), quickfix.GroupElement(tag.ExecInst), quickfix.GroupElement(tag.SellerDays), quickfix.GroupElement(tag.OrderID), quickfix.GroupElement(tag.QuoteEntryID), quickfix.GroupElement(tag.MDEntryBuyer), quickfix.GroupElement(tag.MDEntrySeller), quickfix.GroupElement(tag.NumberOfOrders), quickfix.GroupElement(tag.MDEntryPositionNo), quickfix.GroupElement(tag.Text), quickfix.GroupElement(tag.EncodedTextLen), quickfix.GroupElement(tag.EncodedText)}),\n\t}\n}", "id": 21316, "concepts": ["quickfix package usage", "repeating group", "group template", "group element", "basic function definition"], "_raw_llm_output": "quickfix package usage, repeating group, group template, group element, basic function definition"}
{"seed": "// NewFromImage generates a new generator with the initial template being the\n// given ispec.Image.\nfunc NewFromImage(image ispec.Image) (*Generator, error) {\n\tg := &Generator{\n\t\timage: image,\n\t}\n\n\tg.init()\n\treturn g, nil\n}", "id": 21318, "concepts": ["struct definition", "struct field initialization", "error handling"], "_raw_llm_output": "struct definition, struct field initialization, error handling"}
{"seed": "// FindContentUnitDerivation retrieves a single record by ID with an executor.\n// If selectCols is empty Find will return all columns.\nfunc FindContentUnitDerivation(exec boil.Executor, sourceID int64, derivedID int64, selectCols ...string) (*ContentUnitDerivation, error) {\n\tcontentUnitDerivationObj := &ContentUnitDerivation{}\n\n\tsel := \"*\"\n\tif len(selectCols) > 0 {\n\t\tsel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), \",\")\n\t}\n\tquery := fmt.Sprintf(\n\t\t\"select %s from \\\"content_unit_derivations\\\" where \\\"source_id\\\"=$1 AND \\\"derived_id\\\"=$2\", sel,\n\t)\n\n\tq := queries.Raw(query, sourceID, derivedID)\n\n\terr := q.Bind(nil, exec, contentUnitDerivationObj)\n\tif err != nil {\n\t\tif errors.Cause(err) == sql.ErrNoRows {\n\t\t\treturn nil, sql.ErrNoRows\n\t\t}\n\t\treturn nil, errors.Wrap(err, \"mdbmodels: unable to select from content_unit_derivations\")\n\t}\n\n\treturn contentUnitDerivationObj, nil\n}", "id": 21321, "concepts": ["string formatting", "sql.ErrNoRows", "error handling (errors.Cause)", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows", "sql.ErrNoRows"], "_raw_llm_output": "string formatting, sql.ErrNoRows, error handling (errors.Cause), sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows, sql.ErrNoRows"}
{"seed": "// NewSearchLimits creates a new empty Limits\n// instance and returns a pointer to it\nfunc NewSearchLimits() *Limits {\n\treturn &Limits{}\n}", "id": 21334, "concepts": ["struct definition", "pointer usage", "basic function definition"], "_raw_llm_output": "struct definition, pointer usage, basic function definition"}
{"seed": "// IndexByte returns the index of first c in s or -1 if there is no c in s.\nfunc IndexByte(s string, c byte) int {\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == c {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}", "id": 21365, "concepts": ["string manipulation", "string iteration", "character comparison"], "_raw_llm_output": "string manipulation, string iteration, character comparison"}
{"seed": "// \u56fe\u7247_\u7f6e\u900f\u660e\u8272\u6269\u5c55, \u6307\u5b9a\u56fe\u7247\u900f\u660e\u989c\u8272\u53ca\u900f\u660e\u5ea6\n// hImage: \u56fe\u7247\u53e5\u67c4.\n// color: RGB\u989c\u8272.\n// tranColor: \u900f\u660e\u8272\u7684\u900f\u660e\u5ea6.\nfunc XImage_SetTranColorEx(hImage int, color int, tranColor uint8) int {\n\tr, _, _ := xImage_SetTranColorEx.Call(uintptr(hImage), uintptr(color), uintptr(tranColor))\n\treturn int(r)\n}", "id": 21372, "concepts": ["function definition", "function call", "function argument", "function return value", "function pointer", "function signature", "function pointer usage", "function pointer definition", "function pointer call", "function pointer argument", "function pointer return value"], "_raw_llm_output": "function definition, function call, function argument, function return value, function pointer, function signature, function pointer usage, function pointer definition, function pointer call, function pointer argument, function pointer return value"}
{"seed": "// New creates a new RotateLogs object. A log filename pattern\n// must be passed. Optional `Option` parameters may be passed\nfunc New(pattern string, options ...Option) (*RotateLogs, error) {\n\tglobPattern := pattern\n\tfor _, re := range patternConversionRegexps {\n\t\tglobPattern = re.ReplaceAllString(globPattern, \"*\")\n\t}\n\n\tstrfobj, err := strftime.New(pattern)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, `invalid strftime pattern`)\n\t}\n\n\tvar rl RotateLogs\n\trl.clock = Local\n\trl.globPattern = globPattern\n\trl.pattern = strfobj\n\trl.rotationTime = 24 * time.Hour\n\trl.maxAge = 7 * 24 * time.Hour\n\tfor _, opt := range options {\n\t\topt.Configure(&rl)\n\t}\n\n\treturn &rl, nil\n}", "id": 21375, "concepts": ["strftime package usage", "error handling (errors.Wrap)", "function definition", "function composition"], "_raw_llm_output": "strftime package usage, error handling (errors.Wrap), function definition, function composition"}
{"seed": "// Returns an io.ReadCloser for given file, such that the bytes read are\n// ready for upload: specifically, if encryption is enabled, the contents\n// are encrypted with the given key and the initialization vector is\n// prepended to the returned bytes. Otherwise, the contents of the file are\n// returned directly.\nfunc getFileContentsReaderForUpload(path string, encrypt bool,\n\tiv []byte) (io.ReadCloser, int64, error) {\n\tf, err := os.Open(path)\n\tif err != nil {\n\t\treturn f, 0, err\n\t}\n\n\tstat, err := os.Stat(path)\n\tif err != nil {\n\t\treturn nil, 0, err\n\t}\n\tfileSize := stat.Size()\n\n\tif encrypt {\n\t\tif key == nil {\n\t\t\tkey, err = decryptEncryptionKey()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, 0, err\n\t\t\t}\n\t\t}\n\n\t\tr := makeEncrypterReader(key, iv, f)\n\n\t\t// Prepend the initialization vector to the returned bytes.\n\t\tr = io.MultiReader(bytes.NewReader(iv[:aes.BlockSize]), r)\n\n\t\treturn &FileCloser{R: r, C: f}, fileSize + aes.BlockSize, nil\n\t}\n\treturn f, fileSize, nil\n}", "id": 21387, "concepts": ["io.Reader", "io.ReaderAt", "io.ReaderFrom", "io.Writer", "io.WriterAt", "io.WriterTo", "io.Closer", "io.MultiReader", "io.MultiWriter", "io.LimitReader", "io.LimitWriter", "io.TeeReader", "io.TeeWriter", "io.SectionReader", "io.SectionWriter", "io.Copy", "io.CopyN", "io.Pipe", "io.PipeReader", "io.PipeWriter", "io.LimitedReader", "io.LimitedWriter", "io.ReaderAt", "io.ReaderFrom", "io.WriterAt", "io.WriterTo", "os.File", "os.FileStat", "os.FileInfo", "os.FileMode", "os.FileError", "os.FileHandle", "os.FileDir", "os.FilePipe", "os.FileOther", "os.FileSymlink", "os.FileDevice", "os.FileSocket", "os.FileNamedPipe", "os.FileTemporary", "os.FileDeleteOnClose", "os.FileCreate", "os.FileExclusive", "os.FileAppend", "os.FileSync", "os.FileAsync", "os.FileRead", "os.FileWrite", "os.FileReadPosix", "os.FileWritePosix", ""], "_raw_llm_output": "io.Reader, io.ReaderAt, io.ReaderFrom, io.Writer, io.WriterAt, io.WriterTo, io.Closer, io.MultiReader, io.MultiWriter, io.LimitReader, io.LimitWriter, io.TeeReader, io.TeeWriter, io.SectionReader, io.SectionWriter, io.Copy, io.CopyN, io.Pipe, io.PipeReader, io.PipeWriter, io.LimitedReader, io.LimitedWriter, io.ReaderAt, io.ReaderFrom, io.WriterAt, io.WriterTo, os.File, os.FileStat, os.FileInfo, os.FileMode, os.FileError, os.FileHandle, os.FileDir, os.FilePipe, os.FileOther, os.FileSymlink, os.FileDevice, os.FileSocket, os.FileNamedPipe, os.FileTemporary, os.FileDeleteOnClose, os.FileCreate, os.FileExclusive, os.FileAppend, os.FileSync, os.FileAsync, os.FileRead, os.FileWrite, os.FileReadPosix, os.FileWritePosix,"}
{"seed": "// NewGetCountersParamsWithContext creates a new GetCountersParams object\n// with the ability to set a context for a request.\nfunc NewGetCountersParamsWithContext(ctx context.Context) *GetCountersParams {\n\treturn &GetCountersParams{\n\t\tContext: ctx,\n\t}\n}", "id": 21394, "concepts": ["context package usage", "function definition", "method definition"], "_raw_llm_output": "context package usage, function definition, method definition"}
{"seed": "// AddOrUpdateStatusConditions appends the new conditions to the condition slice. If there is already a condition\n// with the same type in the current condition array then the condition is updated in the result slice.\n// If the condition is not changed then the same unmodified slice is returned.\n// Also returns a bool flag which indicates if the conditions where updated/added\nfunc AddOrUpdateStatusConditions(conditions []toolchainv1alpha1.Condition, newConditions ...toolchainv1alpha1.Condition) ([]toolchainv1alpha1.Condition, bool) {\n\tvar atLeastOneUpdated bool\n\tvar updated bool\n\tfor _, cond := range newConditions {\n\t\tconditions, updated = addOrUpdateStatusCondition(conditions, cond)\n\t\tatLeastOneUpdated = atLeastOneUpdated || updated\n\t}\n\n\treturn conditions, atLeastOneUpdated\n}", "id": 21398, "concepts": ["slice iteration (range loop)", "slice append", "slice update", "basic function definition"], "_raw_llm_output": "slice iteration (range loop), slice append, slice update, basic function definition"}
{"seed": "// coriolisFrequency calculates the coriolis factor for a given latitude.\n//\n// latDeg: latitude in degrees\n//\n// return coriolis factor in hr^-1\nfunc coriolisFrequency(latDeg float64) float64 {\n\tw := 2.0 * math.Pi / 24\n\treturn 2.0 * w * math.Sin(latDeg * math.Pi / 180.0)\n}", "id": 21407, "concepts": ["math package usage", "floating point arithmetic", "mathematical constants"], "_raw_llm_output": "math package usage, floating point arithmetic, mathematical constants"}
{"seed": "// EncodeHeaders returns the HTTP Headers from the response, encoded into a\n// Byte buffer. The buffer will not exceed the maximum size of HeaderMaxOctets\n// Returns the buffer, along with a flag set true if the headers were truncated to fit the\n// buffer. Truncation occurs at the end of each Header\nfunc EncodeHeaders(headers http.Header) ([]byte, bool) {\n\ttruncated := false\n\tvar b bytes.Buffer\n\tidx := 0\n\tfor name, values := range headers {\n\t\tvar s strings.Builder\n\t\tif idx > 0 {\n\t\t\ts.WriteString(\"\\n\")\n\t\t}\n\t\tidx++\n\t\ts.WriteString(name)\n\t\ts.WriteString(\"=\")\n\t\t// If a header has >1 value, separate them by \", \"\n\t\tfor i, value := range values {\n\t\t\tif i == 0 {\n\t\t\t\ts.WriteString(value)\n\t\t\t} else {\n\t\t\t\ts.WriteString(\", \")\n\t\t\t\ts.WriteString(value)\n\t\t\t}\n\t\t}\n\n\t\t// Bail if we are going to exceed the maximum size\n\t\tif s.Len()+b.Len() > HeaderMaxOctets {\n\t\t\ttruncated = true\n\t\t\tbreak\n\t\t}\n\t\tb.WriteString(s.String())\n\t}\n\treturn b.Bytes(), truncated\n}", "id": 21414, "concepts": ["http.Header", "string manipulation", "string concatenation", "byte buffer", "integer comparison"], "_raw_llm_output": "http.Header, string manipulation, string concatenation, byte buffer, integer comparison"}
{"seed": "// ParseDataNL reads from a file named filename and returns the scope and data map of the parsed\n// data file. This version doesn't add labels as variables, but return them separately as a slice.\nfunc ParseDataNL(filename string) (map[int]learn.Variable, []map[int]int, []int) {\n\tfile, err := os.Open(filename)\n\tif err != nil {\n\t\tfmt.Printf(\"Error. Could not open file [%s].\\n\", filename)\n\t\tpanic(err)\n\t}\n\tdefer file.Close()\n\n\tsc := make(map[int]learn.Variable)\n\n\tscanner := bufio.NewScanner(file)\n\n\tvar line string\n\n\t// Get variable definitions.\n\tfor {\n\t\tif !scanner.Scan() {\n\t\t\tbreak\n\t\t}\n\t\tline = scanner.Text()\n\t\tif line[0] != 'v' {\n\t\t\tbreak\n\t\t}\n\t\tvar varid, cats int\n\t\tfmt.Sscanf(line, \"var %d %d\", &varid, &cats)\n\t\tsc[varid] = learn.Variable{Varid: varid, Categories: cats}\n\t}\n\n\tn := len(sc) - 1\n\tvar data [][]int\n\n\tdelete(sc, n)\n\tvar lbls []int\n\n\tregex := regexp.MustCompile(\"[\\\\,\\\\s]+\")\n\t// We assume complete data.\n\tk := 0\n\tfor i := 0; scanner.Scan(); i++ {\n\t\tdata = append(data, make([]int, n))\n\t\ts := regex.Split(line, -1)\n\t\tfor j := 0; j < n; j++ {\n\t\t\tdata[i][j], err = strconv.Atoi(s[j])\n\t\t\tif err != nil {\n\t\t\t\tfmt.Printf(\"Invalid string \\\"%s\\\" found in data file [%s].\\n\", s[j], filename)\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t}\n\t\tlbl, _ := strconv.Atoi(s[n])\n\t\tlbls = append(lbls, lbl)\n\t\tline = scanner.Text()\n\t\tk++\n\t}\n\n\tdata = append(data, make([]int, n))\n\ts := regex.Split(line, -1)\n\tfor i := 0; i < n; i++ {\n\t\tdata[k][i], err = strconv.Atoi(s[i])\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Invalid string \\\"%s\\\" found in data file [%s].\\n\", s[i], filename)\n\t\t\tpanic(err)\n\t\t}\n\t}\n\tlbl, _ := strconv.Atoi(s[n])\n\tlbls = append(lbls, lbl)\n\n\tm, n := len(data), len(data[0])\n\tcvntmap := make([]map[int]int, m)\n\tfor i := 0; i < m; i++ {\n\t\tcvntmap[i] = make(map[int]int)\n\t\tfor j := 0; j < n; j++ {\n\t\t\tcvntmap[i][j] = data[i][j]\n\t\t}\n\t}\n\n\treturn sc, cvntmap, lbls\n}", "id": 21441, "concepts": ["file reading", "string splitting", "string parsing", "map iteration", "map creation", "map deletion", "map key iteration", "map value iteration", "map key/value iteration", "map creation", "map deletion", "map key iteration", "map value iteration", "map key/value iteration", "map creation", "map deletion", "map key iteration", "map value iteration", "map key/value iteration", "map creation", "map deletion", "map key iteration", "map value iteration", "map key/value iteration", "map creation", "map deletion", "map key iteration", "map value iteration", "map key/value iteration", "map creation", "map deletion", "map key iteration", "map value iteration", "map key/value iteration", "map creation", "map deletion", "map key iteration", "map value iteration", "map key/value iteration", "map creation", "map deletion", "map key iteration", "map value iteration", "map key/value iteration", "map creation", "map deletion", "map key iteration", "map value iteration", "map key/value iteration", "map creation", "map deletion", "map key iteration", "map value iteration", "map key/value iteration", "map creation", "map deletion", "map key iteration", "map value iteration", "map key/value iteration", "map creation", "map deletion", "map key iteration", "map value iteration", "map key/value iteration", "map creation", ""], "_raw_llm_output": "file reading, string splitting, string parsing, map iteration, map creation, map deletion, map key iteration, map value iteration, map key/value iteration, map creation, map deletion, map key iteration, map value iteration, map key/value iteration, map creation, map deletion, map key iteration, map value iteration, map key/value iteration, map creation, map deletion, map key iteration, map value iteration, map key/value iteration, map creation, map deletion, map key iteration, map value iteration, map key/value iteration, map creation, map deletion, map key iteration, map value iteration, map key/value iteration, map creation, map deletion, map key iteration, map value iteration, map key/value iteration, map creation, map deletion, map key iteration, map value iteration, map key/value iteration, map creation, map deletion, map key iteration, map value iteration, map key/value iteration, map creation, map deletion, map key iteration, map value iteration, map key/value iteration, map creation, map deletion, map key iteration, map value iteration, map key/value iteration, map creation, map deletion, map key iteration, map value iteration, map key/value iteration, map creation,"}
{"seed": "// NewPonger returns a new `Ponger` object.\nfunc NewPonger() Ponger {\n\treturn Ponger{}\n}", "id": 21442, "concepts": ["struct definition", "struct initialization", "method definition"], "_raw_llm_output": "struct definition, struct initialization, method definition"}
{"seed": "// Newf returns a new exception by `Sprintf`ing the format and the args.\nfunc Newf(classFormat string, args ...interface{}) *Ex {\n\treturn &Ex{class: fmt.Sprintf(classFormat, args...), stack: callers()}\n}", "id": 21445, "concepts": ["fmt.Sprintf", "exception handling", "call stack"], "_raw_llm_output": "fmt.Sprintf, exception handling, call stack"}
{"seed": "// RiskDetailPUserPerformedSecuredPasswordChange returns a pointer to RiskDetailVUserPerformedSecuredPasswordChange\nfunc RiskDetailPUserPerformedSecuredPasswordChange() *RiskDetail {\n\tv := RiskDetailVUserPerformedSecuredPasswordChange\n\treturn &v\n}", "id": 21452, "concepts": ["pointer usage", "struct definition", "struct initialization"], "_raw_llm_output": "pointer usage, struct definition, struct initialization"}
{"seed": "// IsMapPtr reports whether v is a map ptr type.\nfunc IsMapPtr(v interface{}) bool {\n\tt := reflect.TypeOf(v)\n\treturn t.Kind() == reflect.Ptr && t.Elem().Kind() == reflect.Map\n}", "id": 21466, "concepts": ["reflection", "interface", "pointer", "type comparison"], "_raw_llm_output": "reflection, interface, pointer, type comparison"}
{"seed": "// The 'stateTransition' is the state transition\n// function of the finite automaton.\n// So, it is given one state of current and\n// one operator. If the given 'currentState' can\n// accept the Operator 'op' and the 'currentState'\n// can be properly changed into the next state,\n// this function will returns 'nextState'.\n// Otherwise, it should report error by 'ok' of false.\nfunc stateTransition(currentState State, op Operator) (nextState State, ok bool) {\n\n\tvar from, to *RiverSide\n\n\tif currentState.boat == \"left\" {\n\t\tfrom, to = &currentState.left, &currentState.right\n\t\tnextState.boat = \"right\"\n\t\tnextState.right = RiverSide{ to.m + op.m, to.c + op.c }\n\t\tnextState.left = RiverSide{ from.m - op.m, from.c - op.c }\n\t} else {\n\t\tfrom, to = &currentState.right, &currentState.left\n\t\tnextState.boat = \"left\"\n\t\tnextState.left = RiverSide{ to.m + op.m, to.c + op.c }\n\t\tnextState.right = RiverSide{ from.m - op.m, from.c - op.c }\n\t}\n\n\tok = valid(nextState)\n\n\treturn\n}", "id": 21467, "concepts": ["finite automaton", "state transition", "state handling"], "_raw_llm_output": "finite automaton, state transition, state handling"}
{"seed": "// BulkCreditSameday applies equality check predicate on the \"bulkCreditSameday\" field. It's identical to BulkCreditSamedayEQ.\nfunc BulkCreditSameday(v float64) predicate.Bulk {\n\treturn predicate.Bulk(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldBulkCreditSameday), v))\n\t})\n}", "id": 21474, "concepts": ["sql package usage", "sql.Selector", "sql.C", "sql.EQ", "sql.Where", "sql.FieldBulkCreditSameday", "sql.Bulk", "sql.Predicate"], "_raw_llm_output": "sql package usage, sql.Selector, sql.C, sql.EQ, sql.Where, sql.FieldBulkCreditSameday, sql.Bulk, sql.Predicate"}
{"seed": "// RadixEnvironmentNamespace builds a namespace from a RadixApplication and environment name\nfunc RadixEnvironmentNamespace(ra *v1.RadixApplication, envName string) NamespaceFunc {\n\treturn func() string {\n\t\treturn k8sObjectUtils.GetEnvironmentNamespace(ra.Name, envName)\n\t}\n}", "id": 21475, "concepts": ["string formatting", "function definition", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", "function application", "function composition", ""], "_raw_llm_output": "string formatting, function definition, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition, function application, function composition,"}
{"seed": "// PossibleMatchVariableValues returns an array of possible values for the MatchVariable const type.\nfunc PossibleMatchVariableValues() []MatchVariable {\n\treturn []MatchVariable{MatchVariableCookies, MatchVariablePostArgs, MatchVariableQueryString, MatchVariableRemoteAddr, MatchVariableRequestBody, MatchVariableRequestHeader, MatchVariableRequestMethod, MatchVariableRequestURI, MatchVariableSocketAddr}\n}", "id": 21496, "concepts": ["type definition", "type conversion", "type assertion", "type switch", "type definition"], "_raw_llm_output": "type definition, type conversion, type assertion, type switch, type definition"}
{"seed": "// Init checks for Vulkan support on the platform and obtains PFNs for global Vulkan API functions.\n// Either SetGetInstanceProcAddr or SetDefaultGetInstanceProcAddr must have been called prior to\n// calling Init.\nfunc Init() error {\n\tif C.isProcAddrSet() == 0 {\n\t\treturn errors.New(\"vulkan: GetInstanceProcAddr is not set\")\n\t}\n\tret := C.vkInit()\n\tif ret < 0 {\n\t\treturn errors.New(\"vkInit failed\")\n\t}\n\treturn nil\n}", "id": 21510, "concepts": ["C.isProcAddrSet", "C.vkInit", "errors.New", "error handling"], "_raw_llm_output": "C.isProcAddrSet, C.vkInit, errors.New, error handling"}
{"seed": "// FindMergedEnabledProjectRefsByRepoAndBranch finds ProjectRefs with matching repo/branch\n// that are enabled, and merges repo information.\nfunc FindMergedEnabledProjectRefsByRepoAndBranch(owner, repoName, branch string) ([]ProjectRef, error) {\n\tprojectRefs := []ProjectRef{}\n\n\tpipeline := []bson.M{{\"$match\": byOwnerRepoAndBranch(owner, repoName, branch)}}\n\tpipeline = append(pipeline, projectRefPipelineForValueIsBool(ProjectRefEnabledKey, RepoRefEnabledKey, true)...)\n\terr := db.Aggregate(ProjectRefCollection, pipeline, &projectRefs)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn addLoggerAndRepoSettingsToProjects(projectRefs)\n}", "id": 21515, "concepts": ["bson.M", "bson.D", "bson.M", "bson.D", "bson.M", "bson.D", "bson.M", "bson.D", "bson.M", "bson.D", "bson.M", "bson.D", "bson.M", "bson.D", "bson.M", "bson.D", "bson.M", "bson.D", "bson.M", "bson.D", "bson.M", "bson.D", "bson.M", "bson.D", "bson.M", "bson.D", "bson.M", "bson.D", "bson.M", "bson.D", "bson.M", "bson.D", "bson.M", "bson.D", "bson.M", "bson.D", "bson.M", "bson.D", "bson.M", "bson.D", "bson.M", "bson.D", "bson.M", "bson.D", "bson.M", "bson.D", "bson.M", "bson.D", "bson.M", "bson.D", "bson.M", "bson.D", "bson.M", "bson.D", "bson.M", "bson.D", "bson.M", "bson.D", "bson.M", "bson.D", "bson.M", "bson.D", "bson.M", "bson.D"], "_raw_llm_output": "bson.M, bson.D, bson.M, bson.D, bson.M, bson.D, bson.M, bson.D, bson.M, bson.D, bson.M, bson.D, bson.M, bson.D, bson.M, bson.D, bson.M, bson.D, bson.M, bson.D, bson.M, bson.D, bson.M, bson.D, bson.M, bson.D, bson.M, bson.D, bson.M, bson.D, bson.M, bson.D, bson.M, bson.D, bson.M, bson.D, bson.M, bson.D, bson.M, bson.D, bson.M, bson.D, bson.M, bson.D, bson.M, bson.D, bson.M, bson.D, bson.M, bson.D, bson.M, bson.D, bson.M, bson.D, bson.M, bson.D, bson.M, bson.D, bson.M, bson.D, bson.M, bson.D, bson.M, bson.D"}
{"seed": "// StatusIsNil applies the IsNil predicate on the \"status\" field.\nfunc StatusIsNil() predicate.User {\n\treturn predicate.User(sql.FieldIsNull(FieldStatus))\n}", "id": 21523, "concepts": ["sql.FieldIsNull", "sql.FieldIsNotNil", "sql.FieldIsEqual", "sql.FieldIsNotEqual", "sql.FieldIsGreaterThan", "sql.FieldIsGreaterThanOrEqual", "sql.FieldIsLessThan", "sql.FieldIsLessThanOrEqual", "sql.FieldIsBetween", "sql.FieldIsLike", "sql.FieldIsNotLike", "sql.FieldIsBetween", "sql.FieldIsBetweenOrEqual", "sql.FieldIsBetweenOrEqual", "sql.FieldIsBetweenOrEqual", "sql.FieldIsBetweenOrEqual", "sql.FieldIsBetweenOrEqual", "sql.FieldIsBetweenOrEqual", "sql.FieldIsBetweenOrEqual", "sql.FieldIsBetweenOrEqual", "sql.FieldIsBetweenOrEqual", "sql.FieldIsBetweenOrEqual", "sql.FieldIsBetweenOrEqual", "sql.FieldIsBetweenOrEqual", "sql.FieldIsBetweenOrEqual", "sql.FieldIsBetweenOrEqual", "sql.FieldIsBetweenOrEqual", "sql.FieldIsBetweenOrEqual", "sql.FieldIsBetweenOrEqual", "sql.FieldIsBetweenOrEqual", "sql.FieldIsBetweenOrEqual", "sql.FieldIsBetweenOrEqual", "sql.FieldIsBetweenOrEqual", "sql.FieldIsBetweenOrEqual", "sql.FieldIsBetweenOrEqual", "sql.FieldIsBetweenOrEqual", "sql.FieldIsBetweenOrEqual", "sql.FieldIsBetweenOrEqual", ""], "_raw_llm_output": "sql.FieldIsNull, sql.FieldIsNotNil, sql.FieldIsEqual, sql.FieldIsNotEqual, sql.FieldIsGreaterThan, sql.FieldIsGreaterThanOrEqual, sql.FieldIsLessThan, sql.FieldIsLessThanOrEqual, sql.FieldIsBetween, sql.FieldIsLike, sql.FieldIsNotLike, sql.FieldIsBetween, sql.FieldIsBetweenOrEqual, sql.FieldIsBetweenOrEqual, sql.FieldIsBetweenOrEqual, sql.FieldIsBetweenOrEqual, sql.FieldIsBetweenOrEqual, sql.FieldIsBetweenOrEqual, sql.FieldIsBetweenOrEqual, sql.FieldIsBetweenOrEqual, sql.FieldIsBetweenOrEqual, sql.FieldIsBetweenOrEqual, sql.FieldIsBetweenOrEqual, sql.FieldIsBetweenOrEqual, sql.FieldIsBetweenOrEqual, sql.FieldIsBetweenOrEqual, sql.FieldIsBetweenOrEqual, sql.FieldIsBetweenOrEqual, sql.FieldIsBetweenOrEqual, sql.FieldIsBetweenOrEqual, sql.FieldIsBetweenOrEqual, sql.FieldIsBetweenOrEqual, sql.FieldIsBetweenOrEqual, sql.FieldIsBetweenOrEqual, sql.FieldIsBetweenOrEqual, sql.FieldIsBetweenOrEqual, sql.FieldIsBetweenOrEqual, sql.FieldIsBetweenOrEqual,"}
{"seed": "// NewIpamNetworkDataData instantiates a new IpamNetworkDataData object\n// This constructor will assign default values to properties that have it defined,\n// and makes sure properties required by API are set, but the set of arguments\n// will change when the set of required properties is changed\nfunc NewIpamNetworkDataData() *IpamNetworkDataData {\n\tthis := IpamNetworkDataData{}\n\treturn &this\n}", "id": 21552, "concepts": ["constructor", "method definition", "basic function definition", "struct definition"], "_raw_llm_output": "constructor, method definition, basic function definition, struct definition"}
{"seed": "// WorkplaceIsNil applies the IsNil predicate on the \"workplace\" field.\nfunc WorkplaceIsNil() predicate.User {\n\treturn predicate.User(sql.FieldIsNull(FieldWorkplace))\n}", "id": 21567, "concepts": ["sql.FieldIsNull", "sql.FieldIsNotNil", "sql.FieldIsBlank", "sql.FieldIsNotBlank", "sql.FieldIsPresent", "sql.FieldIsBlank", "sql.FieldIsNotNil", "sql.FieldIsNull", "sql.FieldIsPresent", "sql.FieldIsBlank", "sql.FieldIsNotNil", "sql.FieldIsBlank", "sql.FieldIsNotNil", "sql.FieldIsNull", "sql.FieldIsBlank", "sql.FieldIsBlank", "sql.FieldIsNotNil", "sql.FieldIsBlank", "sql.FieldIsBlank", "sql.FieldIsBlank", "sql.FieldIsBlank", "sql.FieldIsBlank", "sql.FieldIsBlank", "sql.FieldIsBlank", "sql.FieldIsBlank", "sql.FieldIsBlank", "sql.FieldIsBlank", "sql.FieldIsBlank", "sql.FieldIsBlank", "sql.FieldIsBlank", "sql.FieldIsBlank", "sql.FieldIsBlank", "sql.FieldIsBlank", "sql.FieldIsBlank", "sql.FieldIsBlank", "sql.FieldIsBlank", "sql.FieldIsBlank", "sql.FieldIsBlank", "sql.FieldIsBlank", "sql.FieldIsBlank", "sql.FieldIsBlank", "sql.FieldIsBlank", "sql.FieldIsBlank", ""], "_raw_llm_output": "sql.FieldIsNull, sql.FieldIsNotNil, sql.FieldIsBlank, sql.FieldIsNotBlank, sql.FieldIsPresent, sql.FieldIsBlank, sql.FieldIsNotNil, sql.FieldIsNull, sql.FieldIsPresent, sql.FieldIsBlank, sql.FieldIsNotNil, sql.FieldIsBlank, sql.FieldIsNotNil, sql.FieldIsNull, sql.FieldIsBlank, sql.FieldIsBlank, sql.FieldIsNotNil, sql.FieldIsBlank, sql.FieldIsBlank, sql.FieldIsBlank, sql.FieldIsBlank, sql.FieldIsBlank, sql.FieldIsBlank, sql.FieldIsBlank, sql.FieldIsBlank, sql.FieldIsBlank, sql.FieldIsBlank, sql.FieldIsBlank, sql.FieldIsBlank, sql.FieldIsBlank, sql.FieldIsBlank, sql.FieldIsBlank, sql.FieldIsBlank, sql.FieldIsBlank, sql.FieldIsBlank, sql.FieldIsBlank, sql.FieldIsBlank, sql.FieldIsBlank, sql.FieldIsBlank, sql.FieldIsBlank, sql.FieldIsBlank, sql.FieldIsBlank, sql.FieldIsBlank,"}
{"seed": "// WithMaxReleaseHistory specifies the maximum size of the Helm release history maintained\n// on upgrades/rollbacks. Zero (default) means unlimited.\nfunc WithMaxReleaseHistory(maxHistory int) Option {\n\treturn func(r *Reconciler) error {\n\t\tif maxHistory < 0 {\n\t\t\treturn errors.New(\"maximum Helm release history size must not be negative\")\n\t\t}\n\t\tr.maxHistory = maxHistory\n\t\treturn nil\n\t}\n}", "id": 21574, "concepts": ["error handling (errors.New)", "Option pattern", "integer comparison"], "_raw_llm_output": "error handling (errors.New), Option pattern, integer comparison"}
{"seed": "// CopyPrefix copies the bucket at from to the bucket at to for the given prefix.\n//\n// Copies done concurrently.\n// Paths from the source bucket will be transformed before being added to the destination bucket.\n// Returns the number of files copied.\nfunc CopyPrefix(\n\tctx context.Context,\n\tfrom ReadBucket,\n\tto ReadWriteBucket,\n\tprefix string,\n\toptions ...normalpath.TransformerOption,\n) (int, error) {\n\treturn copyPaths(\n\t\tctx,\n\t\tfrom,\n\t\tto,\n\t\twalkBucketFunc(from, prefix),\n\t\toptions,\n\t\tfalse,\n\t)\n}", "id": 21599, "concepts": ["context package usage", "concurrency", "error handling", "standard library usage", "function definition"], "_raw_llm_output": "context package usage, concurrency, error handling, standard library usage, function definition"}
{"seed": "// GetAllPalettes returns the names of all palettes that are compiled\n// into the package as well as their inverts.\nfunc GetAllPalettes() []string {\n\tvar all []string\n\tfor key := range palettes {\n\t\tall = append(all, string(key), \"-\"+string(key))\n\t}\n\tsort.Strings(all)\n\treturn all\n}", "id": 21601, "concepts": ["map iteration (range loop)", "string concatenation", "sort.Strings"], "_raw_llm_output": "map iteration (range loop), string concatenation, sort.Strings"}
{"seed": "// NewClientFromFlagsAndMetadata returns a Client with credentials obtained\n// from a combination of flags and metadata, depending on whether the program\n// is running in local mode.\nfunc NewClientFromFlagsAndMetadata(local bool) (*Client, error) {\n\tif !local {\n\t\tuserMeta, err := metadata.ProjectGet(metadata.INFLUXDB_NAME)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpassMeta, err := metadata.ProjectGet(metadata.INFLUXDB_PASSWORD)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\t*user = userMeta\n\t\t*password = passMeta\n\t}\n\treturn NewClientFromFlags()\n}", "id": 21603, "concepts": ["metadata package usage", "conditional execution"], "_raw_llm_output": "metadata package usage, conditional execution"}
{"seed": "// NewItem creates an Item with its Name, Price, and InStock\n// properties initialized with the given parameters.\nfunc NewItem(name string, price float64, inStock int) *Item {\n\tvar item Item\n\titem = Item{Name: name, Price: price, InStock: inStock}\n\treturn &item\n}", "id": 21606, "concepts": ["struct initialization", "pointer usage", "struct definition"], "_raw_llm_output": "struct initialization, pointer usage, struct definition"}
{"seed": "// NewSynchronizeUserV1ParamsWithTimeout creates a new SynchronizeUserV1Params object\n// with the default values initialized, and the ability to set a timeout on a request\nfunc NewSynchronizeUserV1ParamsWithTimeout(timeout time.Duration) *SynchronizeUserV1Params {\n\tvar ()\n\treturn &SynchronizeUserV1Params{\n\n\t\ttimeout: timeout,\n\t}\n}", "id": 21617, "concepts": ["function definition", "timeout handling", "time package usage"], "_raw_llm_output": "function definition, timeout handling, time package usage"}
{"seed": "// PossibleFeaturesPolicyValues returns the possible values for the FeaturesPolicy const type.\nfunc PossibleFeaturesPolicyValues() []FeaturesPolicy {\n\treturn []FeaturesPolicy{\n\t\tFeaturesPolicyAll,\n\t\tFeaturesPolicyAny,\n\t}\n}", "id": 21618, "concepts": ["const declaration", "type definition", "type conversion"], "_raw_llm_output": "const declaration, type definition, type conversion"}
{"seed": "// AssertNCHandleUplinkMACCommandRequest asserts the given mac-command request.\nfunc AssertNCHandleUplinkMACCommandRequest(req nc.HandleUplinkMACCommandRequest) Assertion {\n\treturn func(assert *require.Assertions, ts *IntegrationTestSuite) {\n\t\tr := <-ts.NCClient.HandleDataUpMACCommandChan\n\t\tif !proto.Equal(&r, &req) {\n\t\t\tassert.Equal(req, r)\n\t\t}\n\t}\n}", "id": 21628, "concepts": ["proto package usage", "channel handling", "assertion"], "_raw_llm_output": "proto package usage, channel handling, assertion"}
{"seed": "// WithPreHook is an Option that configures the reconciler to run the given\n// PreHook just before performing any actions (e.g. install, upgrade, uninstall,\n// or reconciliation).\nfunc WithPreHook(h hook.PreHook) Option {\n\treturn func(r *Reconciler) error {\n\t\tr.preHooks = append(r.preHooks, h)\n\t\treturn nil\n\t}\n}", "id": 21649, "concepts": ["function definition", "function composition", "function composition with Option pattern", "function composition with Option pattern", "function composition with Option pattern"], "_raw_llm_output": "function definition, function composition, function composition with Option pattern, function composition with Option pattern, function composition with Option pattern"}
{"seed": "// NewContentProviderReadDetailedWithDefaults instantiates a new ContentProviderReadDetailed object\n// This constructor will only assign default values to properties that have it defined,\n// but it doesn't guarantee that properties required by API are set\nfunc NewContentProviderReadDetailedWithDefaults() *ContentProviderReadDetailed {\n\tthis := ContentProviderReadDetailed{}\n\tvar enable bool = true\n\tthis.Enable = &enable\n\treturn &this\n}", "id": 21652, "concepts": ["struct definition", "struct initialization", "pointer usage"], "_raw_llm_output": "struct definition, struct initialization, pointer usage"}
{"seed": "// AssetsPath returns the path to the folder\n// where the application may store data. If\n// CADDYPATH env variable is set, that value\n// is used. Otherwise, the path is the result\n// of evaluating \"$HOME/.caddy\".\nfunc AssetsPath() string {\n\tif caddyPath := os.Getenv(\"CADDYPATH\"); caddyPath != \"\" {\n\t\treturn caddyPath\n\t}\n\treturn filepath.Join(userHomeDir(), \".caddy\")\n}", "id": 21657, "concepts": ["os.Getenv", "filepath.Join", "os.UserHomeDir"], "_raw_llm_output": "os.Getenv, filepath.Join, os.UserHomeDir"}
{"seed": "// successStatus returns true if the argument is a successful HTTP response\n// code (in the range 200 - 399 inclusive).\nfunc successStatus(status int) bool {\n\treturn status >= 200 && status <= 399\n}", "id": 21666, "concepts": ["integer comparison", "basic function definition", "basic if statement"], "_raw_llm_output": "integer comparison, basic function definition, basic if statement"}
{"seed": "// Unpack returns the values packed in string s (see Pack) according to the\n// format string. An optional pos marks where to start reading in s (default\n// is 1). After the read values, this function also returns the index of the\n// first unread byte in s.\nfunc Unpack(format string, values ...interface{}) (int, error) {\n\tp, err := newState(format)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn p.Unpack(values...)\n}", "id": 21679, "concepts": ["string formatting", "fmt package usage", "error handling (errors.New)", "interface conversion"], "_raw_llm_output": "string formatting, fmt package usage, error handling (errors.New), interface conversion"}
{"seed": "// NewMsgServerImpl returns an implementation of the wasm MsgServer interface\n// for the provided Keeper.\nfunc NewMsgServerImpl(keeper Keeper) types.MsgServer {\n\treturn &msgServer{Keeper: keeper}\n}", "id": 21692, "concepts": ["interface implementation", "Keeper", "MsgServer", "function definition"], "_raw_llm_output": "interface implementation, Keeper, MsgServer, function definition"}
{"seed": "// getNamespaces takes the path and returns the namespace hierarchy, with the first element being\n// the root namespaces and the last element being the leaf. If it returns an empty list, that means\n// that this object is not in the `namespaces/` directory and should be ignored.\nfunc getNamespaces(path string) ([]string, error) {\n\tsegs := strings.Split(path, \"/\")\n\n\t// We only care about objects in the 'namespaces' directory.\n\tif segs[0] != \"namespaces\" {\n\t\treturn nil, nil\n\t}\n\n\t// There shouldn't be any objects directly in the namespaces directory.\n\tif len(segs) < 3 {\n\t\treturn nil, fmt.Errorf(\"file %q is directly under 'namespaces/' but should be in a namespace directory\", path)\n\t}\n\n\t// After stripping off the 'namespaces/' and the filename, what remains is the list of namespaces\n\t// from root to leaf.\n\treturn segs[1:len(segs)-1], nil\n}", "id": 21699, "concepts": ["string manipulation", "string splitting", "string comparison", "error handling", "error wrapping"], "_raw_llm_output": "string manipulation, string splitting, string comparison, error handling, error wrapping"}
{"seed": "// parsePackageLock parses a package.lock and returns the discovered JavaScript packages.\nfunc parsePackageLock(_ string, reader io.Reader) ([]pkg.Package, error) {\n\tpackages := make([]pkg.Package, 0)\n\tdec := json.NewDecoder(reader)\n\n\tfor {\n\t\tvar lock PackageLock\n\t\tif err := dec.Decode(&lock); err == io.EOF {\n\t\t\tbreak\n\t\t} else if err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to parse package-lock.json file: %w\", err)\n\t\t}\n\t\tfor name, pkgMeta := range lock.Dependencies {\n\t\t\tpackages = append(packages, pkg.Package{\n\t\t\t\tName:     name,\n\t\t\t\tVersion:  pkgMeta.Version,\n\t\t\t\tLanguage: pkg.JavaScript,\n\t\t\t\tType:     pkg.NpmPkg,\n\t\t\t})\n\t\t}\n\t}\n\n\treturn packages, nil\n}", "id": 21700, "concepts": ["JSON parsing", "JSON decoding", "map iteration", "map lookup", "basic function definition", "basic type definition", "basic control flow"], "_raw_llm_output": "JSON parsing, JSON decoding, map iteration, map lookup, basic function definition, basic type definition, basic control flow"}
{"seed": "// NewTimerTimersResponseWithDefaults instantiates a new TimerTimersResponse object\n// This constructor will only assign default values to properties that have it defined,\n// but it doesn't guarantee that properties required by API are set\nfunc NewTimerTimersResponseWithDefaults() *TimerTimersResponse {\n\tthis := TimerTimersResponse{}\n\treturn &this\n}", "id": 21710, "concepts": ["constructor", "struct definition", "property assignment"], "_raw_llm_output": "constructor, struct definition, property assignment"}
{"seed": "// ParseDeleteInstancePoolResponse parses an HTTP response from a DeleteInstancePoolWithResponse call\nfunc ParseDeleteInstancePoolResponse(rsp *http.Response) (*DeleteInstancePoolResponse, error) {\n\tbodyBytes, err := ioutil.ReadAll(rsp.Body)\n\tdefer rsp.Body.Close()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse := &DeleteInstancePoolResponse{\n\t\tBody:         bodyBytes,\n\t\tHTTPResponse: rsp,\n\t}\n\n\tswitch {\n\tcase strings.Contains(rsp.Header.Get(\"Content-Type\"), \"json\") && rsp.StatusCode == 200:\n\t\tvar dest Operation\n\t\tif err := json.Unmarshal(bodyBytes, &dest); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresponse.JSON200 = &dest\n\n\t}\n\n\treturn response, nil\n}", "id": 21718, "concepts": ["HTTP response parsing", "JSON parsing", "HTTP response handling", "error handling"], "_raw_llm_output": "HTTP response parsing, JSON parsing, HTTP response handling, error handling"}
{"seed": "// NewSynchronizeUserV1ParamsWithHTTPClient creates a new SynchronizeUserV1Params object\n// with the default values initialized, and the ability to set a custom HTTPClient for a request\nfunc NewSynchronizeUserV1ParamsWithHTTPClient(client *http.Client) *SynchronizeUserV1Params {\n\tvar ()\n\treturn &SynchronizeUserV1Params{\n\t\tHTTPClient: client,\n\t}\n}", "id": 21720, "concepts": ["http.Client usage", "function definition", "pointer types"], "_raw_llm_output": "http.Client usage, function definition, pointer types"}
{"seed": "// getMsgReplyHeader gets message ID and context from the message reply header\n//\n// Message reply has the following structure:\n//\n//\ttype msgReplyHeader struct {\n//\t    MsgID       uint16\n//\t    Context     uint32\n//\t}\nfunc getMsgReplyHeader(msg []byte) (msgID uint16, context uint32) {\n\tmsgID = binary.BigEndian.Uint16(msg[0:2])\n\tcontext = binary.BigEndian.Uint32(msg[2:6])\n\treturn\n}", "id": 21724, "concepts": ["binary encoding", "binary decoding", "binary.BigEndian", "binary.LittleEndian", "struct definition", "struct field access", "struct field definition", "struct field initialization", "struct field type", "struct field value", "struct initialization", "struct type", "struct value"], "_raw_llm_output": "binary encoding, binary decoding, binary.BigEndian, binary.LittleEndian, struct definition, struct field access, struct field definition, struct field initialization, struct field type, struct field value, struct initialization, struct type, struct value"}
{"seed": "// Create a random lower case alphanumerical string of a specified size.\n//\n// Implementation comes from:\n// http://stackoverflow.com/questions/22892120/how-to-generate-a-random-string-of-a-fixed-lenght-in-golang\nfunc SecureRandomString(n int) string {\n\tb := make([]byte, n)\n\t// A src.Int63() generates 63 random bits, enough for letterIdxMax characters!\n\tfor i, cache, remain := n-1, src.Int63(), letterIdxMax; i >= 0; {\n\t\tif remain == 0 {\n\t\t\tcache, remain = src.Int63(), letterIdxMax\n\t\t}\n\t\tif idx := int(cache & letterIdxMask); idx < len(letterBytes) {\n\t\t\tb[i] = letterBytes[idx]\n\t\t\ti--\n\t\t}\n\t\tcache >>= letterIdxBits\n\t\tremain--\n\t}\n\n\treturn string(b)\n}", "id": 21738, "concepts": ["crypto/rand", "random string generation"], "_raw_llm_output": "crypto/rand, random string generation"}
{"seed": "// checkErr as defined in https://datasheets.maximintegrated.com/en/ds/MAX31855.pdf\nfunc checkErr(bits uint32) error {\n\thasErr := (bits & 0x10000) != 0     // fault bit, D16\n\topenCircuit := (bits & 0b1) != 0    // OC bit, D0\n\tshortToGround := (bits & 0b10) != 0 // SCG bit, D1\n\tshortToVCC := (bits & 0b100) != 0   // SCV bit, D2\n\n\tif !hasErr {\n\t\treturn nil\n\t}\n\tif openCircuit {\n\t\treturn errors.New(\"open circuit\")\n\t}\n\tif shortToGround {\n\t\treturn errors.New(\"short to ground\")\n\t}\n\tif shortToVCC {\n\t\treturn errors.New(\"short to vcc\")\n\t}\n\treturn errors.New(\"unknown error\")\n}", "id": 21739, "concepts": ["bitwise operations", "error handling (errors.New)", "error handling (errors.Is)", "error handling (errors.As)"], "_raw_llm_output": "bitwise operations, error handling (errors.New), error handling (errors.Is), error handling (errors.As)"}
{"seed": "// IsValueNil returns true if either value is nil, or has dynamic type {ptr,\n// map, slice} with value nil.\nfunc IsValueNil(value interface{}) bool {\n\tif value == nil {\n\t\treturn true\n\t}\n\tswitch kindOf(value) {\n\tcase reflect.Slice, reflect.Ptr, reflect.Map:\n\t\treturn reflect.ValueOf(value).IsNil()\n\t}\n\treturn false\n}", "id": 21741, "concepts": ["reflect package usage", "type assertion", "type switch", "nil handling"], "_raw_llm_output": "reflect package usage, type assertion, type switch, nil handling"}
{"seed": "// MixedStringHasPrefix applies the HasPrefix predicate on the \"mixed_string\" field.\nfunc MixedStringHasPrefix(v string) predicate.User {\n\treturn predicate.User(sql.FieldHasPrefix(FieldMixedString, v))\n}", "id": 21748, "concepts": ["sql package usage", "predicate.User usage"], "_raw_llm_output": "sql package usage, predicate.User usage"}
{"seed": "// UnixMilli returns a Unix time, the number of millisecond elapsed\n// since January 1, 1970 UTC.\nfunc UnixMilli() int64 {\n\treturn time.Now().UnixNano() / int64(time.Millisecond)\n}", "id": 21756, "concepts": ["time package usage", "time.Now()", "time.UnixNano()", "time.Unix()", "time.UnixMilli()", "time.UnixMicro()", "time.UnixNanosecond()", "time.Date()", "time.Parse()", "time.ParseDuration()", "time.Since()", "time.Now().Unix()", "time.Now().UnixNano()", "time.Now().UnixMilli()", "time.Now().UnixMicro()", "time.Now().UnixNano()", "time.Now().UTC()", "time.Now().UTC().Unix()", "time.Now().UTC().UnixNano()", "time.Now().UTC().UnixMilli()", "time.Now().UTC().UnixMicro()", "time.Now().UTC().UnixNano()", "time.Now().UTC().Unix()", "time.Now().UTC().UnixNano()", "time.Now().UTC().UnixMilli()", "time.Now().UTC().UnixMicro()", "time.Now().UTC().UnixNano()", "time.Now().UTC().Unix()", "time.Now().UTC().UnixNano()", "time.Now().UTC().UnixMilli()", "time.Now().UTC().UnixMicro()", "time.Now().UTC().UnixNano()", "time.Now().UTC().Unix()", "time.Now().UTC().UnixNano()", "time.Now().UTC().UnixMilli()", "time.Now().UTC()."], "_raw_llm_output": "time package usage, time.Now(), time.UnixNano(), time.Unix(), time.UnixMilli(), time.UnixMicro(), time.UnixNanosecond(), time.Date(), time.Parse(), time.ParseDuration(), time.Since(), time.Now().Unix(), time.Now().UnixNano(), time.Now().UnixMilli(), time.Now().UnixMicro(), time.Now().UnixNano(), time.Now().UTC(), time.Now().UTC().Unix(), time.Now().UTC().UnixNano(), time.Now().UTC().UnixMilli(), time.Now().UTC().UnixMicro(), time.Now().UTC().UnixNano(), time.Now().UTC().Unix(), time.Now().UTC().UnixNano(), time.Now().UTC().UnixMilli(), time.Now().UTC().UnixMicro(), time.Now().UTC().UnixNano(), time.Now().UTC().Unix(), time.Now().UTC().UnixNano(), time.Now().UTC().UnixMilli(), time.Now().UTC().UnixMicro(), time.Now().UTC().UnixNano(), time.Now().UTC().Unix(), time.Now().UTC().UnixNano(), time.Now().UTC().UnixMilli(), time.Now().UTC()."}
{"seed": "// BulkCreditSamedayFeeNotIn applies the NotIn predicate on the \"bulkCreditSamedayFee\" field.\nfunc BulkCreditSamedayFeeNotIn(vs ...float64) predicate.Bulk {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.Bulk(func(s *sql.Selector) {\n\t\t// if not arguments were provided, append the FALSE constants,\n\t\t// since we can't apply \"IN ()\". This will make this predicate falsy.\n\t\tif len(v) == 0 {\n\t\t\ts.Where(sql.False())\n\t\t\treturn\n\t\t}\n\t\ts.Where(sql.NotIn(s.C(FieldBulkCreditSamedayFee), v...))\n\t})\n}", "id": 21761, "concepts": ["sql.Selector", "sql.NotIn", "sql.False", "sql.Where", "sql.C", "sql.In", "sql.NotIn", "sql.Where", "sql.In", "sql.NotIn", "sql.Where", "sql.In", "sql.NotIn", "sql.Where", "sql.In", "sql.NotIn", "sql.Where", "sql.In", "sql.NotIn", "sql.Where", "sql.In", "sql.NotIn", "sql.Where", "sql.In", "sql.NotIn", "sql.Where", "sql.In", "sql.NotIn", "sql.Where", "sql.In", "sql.NotIn", "sql.Where", "sql.In", "sql.NotIn", "sql.Where", "sql.In", "sql.NotIn", "sql.Where", "sql.In", "sql.NotIn", "sql.Where", "sql.In", "sql.NotIn", "sql.Where", "sql.In", "sql.NotIn", "sql.Where", "sql.In", "sql.NotIn", "sql.Where", "sql.In", "sql.NotIn", "sql.Where", "sql.In", "sql.NotIn", "sql.Where", "sql.In", "sql.NotIn", "sql.Where", "sql.In", "sql.NotIn", "sql.Where", "sql.In", "sql.NotIn"], "_raw_llm_output": "sql.Selector, sql.NotIn, sql.False, sql.Where, sql.C, sql.In, sql.NotIn, sql.Where, sql.In, sql.NotIn, sql.Where, sql.In, sql.NotIn, sql.Where, sql.In, sql.NotIn, sql.Where, sql.In, sql.NotIn, sql.Where, sql.In, sql.NotIn, sql.Where, sql.In, sql.NotIn, sql.Where, sql.In, sql.NotIn, sql.Where, sql.In, sql.NotIn, sql.Where, sql.In, sql.NotIn, sql.Where, sql.In, sql.NotIn, sql.Where, sql.In, sql.NotIn, sql.Where, sql.In, sql.NotIn, sql.Where, sql.In, sql.NotIn, sql.Where, sql.In, sql.NotIn, sql.Where, sql.In, sql.NotIn, sql.Where, sql.In, sql.NotIn, sql.Where, sql.In, sql.NotIn, sql.Where, sql.In, sql.NotIn, sql.Where, sql.In, sql.NotIn"}
{"seed": "// isBeforeV1 reports if a version is prio to v1.0.0, according to semver.\r\n// v0.9.0 and v1.0.0-alpha are examples of versions before v1.0.0.\r\nfunc isBeforeV1(version string) bool {\r\n\treturn semver.IsValid(version) && semver.Compare(version, \"v1.0.0\") < 0\r\n}", "id": 21786, "concepts": ["semver", "semver.IsValid", "semver.Compare"], "_raw_llm_output": "semver, semver.IsValid, semver.Compare"}
{"seed": "// DefaultExprsHasPrefix applies the HasPrefix predicate on the \"default_exprs\" field.\nfunc DefaultExprsHasPrefix(v string) predicate.User {\n\treturn predicate.User(sql.FieldHasPrefix(FieldDefaultExprs, v))\n}", "id": 21787, "concepts": ["sql.FieldHasPrefix", "predicate.User", "sql.Field"], "_raw_llm_output": "sql.FieldHasPrefix, predicate.User, sql.Field"}
{"seed": "// ResolverEndpointDirection_Values returns all elements of the ResolverEndpointDirection enum\nfunc ResolverEndpointDirection_Values() []string {\n\treturn []string{\n\t\tResolverEndpointDirectionInbound,\n\t\tResolverEndpointDirectionOutbound,\n\t}\n}", "id": 21789, "concepts": ["enum", "string formatting", "standard library usage"], "_raw_llm_output": "enum, string formatting, standard library usage"}
{"seed": "// RTWithResourceNamer specifies a function which will be used to\n// obtain the resource name for a given request.\nfunc RTWithResourceNamer(namer func(req *http.Request) string) RoundTripperOption {\n\treturn func(cfg *roundTripperConfig) {\n\t\tcfg.resourceNamer = namer\n\t}\n}", "id": 21804, "concepts": ["function composition", "function composition with function options"], "_raw_llm_output": "function composition, function composition with function options"}
{"seed": "// Groups all keys based on what server they are stored on.\n// The grouped values are then used to send batch requests to each server.\nfunc groupKeysByServer(numServers int, keys []KeyValue) [][]KeyValue {\n\tserverKeys := initServerKeys(numServers)\n\tfor _, k := range keys {\n\t\tif k.Encoding == \"binary\" {\n\t\t\tk.Data = base64.StdEncoding.EncodeToString([]byte(k.Data))\n\t\t}\n\t\tserverIndex := hash(k.Data) % numServers\n\t\tserverKeys[serverIndex] = append(serverKeys[serverIndex], k)\n\t}\n\treturn serverKeys\n}", "id": 21806, "concepts": ["hashing", "string manipulation", "binary data encoding", "slice initialization", "slice iteration (range loop)", "map initialization", "map iteration (range loop)", "function definition", "function call", "function return", "function parameters", "function arguments", "function scope", "function closure", "function recursion"], "_raw_llm_output": "hashing, string manipulation, binary data encoding, slice initialization, slice iteration (range loop), map initialization, map iteration (range loop), function definition, function call, function return, function parameters, function arguments, function scope, function closure, function recursion"}
{"seed": "// NewNameGTE applies the GTE predicate on the \"new_name\" field.\nfunc NewNameGTE(v string) predicate.User {\n\treturn predicate.User(sql.FieldGTE(FieldNewName, v))\n}", "id": 21814, "concepts": ["sql package usage", "sql.FieldGTE", "sql.FieldLTE", "sql.FieldEQ", "sql.FieldLT", "sql.FieldGT", "sql.FieldNE", "sql.FieldIN", "sql.FieldNotIn", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldIs", "sql.FieldIsNot", "sql.FieldIsNull", "sql.FieldIsNotNull", "sql.FieldBetween", "sql.FieldNotBetween", "sql.FieldRegexp", "sql.FieldNotRegexp", "sql.FieldExists", "sql.FieldNotExists", "sql.FieldRaw", "sql.FieldRawSQL", "sql.FieldRawBytes", "sql.FieldRawBytesEq", "sql.FieldRawBytesNeq", "sql.FieldRawBytesGt", "sql.FieldRawBytesGte", "sql.FieldRawBytesLt", "sql.FieldRawBytesLte", "sql.FieldRawBytesIn", "sql.FieldRawBytesNotIn", "sql.FieldRawBytesLike", "sql.FieldRawBytesNotLike", "sql.FieldRawBytesRegexp", "sql.FieldRawBytesNotRegexp", "sql.FieldRawBytesExists", "sql.FieldRawBytesNotExists", "sql.FieldRawBytesBetween", "sql.FieldRawBytesNotBetween", "sql.FieldRawBytesIs", "sql.Field"], "_raw_llm_output": "sql package usage, sql.FieldGTE, sql.FieldLTE, sql.FieldEQ, sql.FieldLT, sql.FieldGT, sql.FieldNE, sql.FieldIN, sql.FieldNotIn, sql.FieldLike, sql.FieldNotLike, sql.FieldIs, sql.FieldIsNot, sql.FieldIsNull, sql.FieldIsNotNull, sql.FieldBetween, sql.FieldNotBetween, sql.FieldRegexp, sql.FieldNotRegexp, sql.FieldExists, sql.FieldNotExists, sql.FieldRaw, sql.FieldRawSQL, sql.FieldRawBytes, sql.FieldRawBytesEq, sql.FieldRawBytesNeq, sql.FieldRawBytesGt, sql.FieldRawBytesGte, sql.FieldRawBytesLt, sql.FieldRawBytesLte, sql.FieldRawBytesIn, sql.FieldRawBytesNotIn, sql.FieldRawBytesLike, sql.FieldRawBytesNotLike, sql.FieldRawBytesRegexp, sql.FieldRawBytesNotRegexp, sql.FieldRawBytesExists, sql.FieldRawBytesNotExists, sql.FieldRawBytesBetween, sql.FieldRawBytesNotBetween, sql.FieldRawBytesIs, sql.Field"}
{"seed": "// TransfertobankaccountIsNil applies the IsNil predicate on the \"transfertobankaccount\" field.\nfunc TransfertobankaccountIsNil() predicate.Bulk {\n\treturn predicate.Bulk(func(s *sql.Selector) {\n\t\ts.Where(sql.IsNull(s.C(FieldTransfertobankaccount)))\n\t})\n}", "id": 21837, "concepts": ["sql.Selector", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull", "sql.IsNull"], "_raw_llm_output": "sql.Selector, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull, sql.IsNull"}
{"seed": "// projectRefPipelineForMatchingTrigger is an aggregation pipeline to find projects that are\n// 1) explicitly enabled, or that default to the repo which is enabled, and\n// 2) they have triggers defined for this project, or they default to the repo, which has a trigger for this project defined.\nfunc projectRefPipelineForMatchingTrigger(project string) []bson.M {\n\treturn []bson.M{\n\t\tlookupRepoStep,\n\t\t{\"$match\": bson.M{\n\t\t\t\"$and\": []bson.M{\n\t\t\t\t{\"$or\": []bson.M{\n\t\t\t\t\t{ProjectRefEnabledKey: true},\n\t\t\t\t\t{ProjectRefEnabledKey: bson.M{\"$ne\": false}, bsonutil.GetDottedKeyName(\"repo_ref\", RepoRefEnabledKey): true},\n\t\t\t\t}},\n\t\t\t\t{\"$or\": []bson.M{\n\t\t\t\t\t{\n\t\t\t\t\t\tbsonutil.GetDottedKeyName(projectRefTriggersKey, triggerDefinitionProjectKey): project,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tprojectRefTriggersKey: nil,\n\t\t\t\t\t\tbsonutil.GetDottedKeyName(\"repo_ref\", RepoRefTriggersKey, triggerDefinitionProjectKey): project,\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n}", "id": 21839, "concepts": ["aggregation pipeline", "bson.M", "bson.A", "bson.D", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", "bson.M", ""], "_raw_llm_output": "aggregation pipeline, bson.M, bson.A, bson.D, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M, bson.M,"}
{"seed": "// RecoveryBackupConfigPolicyAsRecoveryBackupConfigPolicyRelationship is a convenience function that returns RecoveryBackupConfigPolicy wrapped in RecoveryBackupConfigPolicyRelationship\nfunc RecoveryBackupConfigPolicyAsRecoveryBackupConfigPolicyRelationship(v *RecoveryBackupConfigPolicy) RecoveryBackupConfigPolicyRelationship {\n\treturn RecoveryBackupConfigPolicyRelationship{\n\t\tRecoveryBackupConfigPolicy: v,\n\t}\n}", "id": 21861, "concepts": ["struct embedding", "struct composition"], "_raw_llm_output": "struct embedding, struct composition"}
{"seed": "// NewMockWriteBufferJsonBased creates a new instance of MockWriteBufferJsonBased. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.\n// The first argument is typically a *testing.T value.\nfunc NewMockWriteBufferJsonBased(t interface {\n\tmock.TestingT\n\tCleanup(func())\n}) *MockWriteBufferJsonBased {\n\tmock := &MockWriteBufferJsonBased{}\n\tmock.Mock.Test(t)\n\n\tt.Cleanup(func() { mock.AssertExpectations(t) })\n\n\treturn mock\n}", "id": 21867, "concepts": ["testing interface", "testing.T", "cleanup function", "mocking", "testing.T.Cleanup"], "_raw_llm_output": "testing interface, testing.T, cleanup function, mocking, testing.T.Cleanup"}
{"seed": "// FallbackFormatKey formats key in a standard way as a string slice.\n// If the ctx id is <= 1 then that ctx id is skipped due to\n// being reduntant and that key is used as-is. Otherwise each entry\n// has the form key[ctxId].\nfunc FallbackFormatKey(key []FallbackKey) []string {\n\tv := make([]string, len(key))\n\tfor i := range key {\n\t\tif key[i].CtxId <= 1 {\n\t\t\tv[i] = key[i].Key\n\t\t} else {\n\t\t\tv[i] = fmt.Sprintf(\"%s[%d]\", key[i].Key, key[i].CtxId)\n\t\t}\n\t}\n\treturn v\n}", "id": 21868, "concepts": ["slice iteration (range loop)", "string formatting", "fmt package usage"], "_raw_llm_output": "slice iteration (range loop), string formatting, fmt package usage"}
{"seed": "// Import an Application defined either outside the CDK, or in a different CDK Stack.\n//\n// Returns: a Construct representing a reference to an existing Application\n// Experimental.\nfunc EcsApplication_FromEcsApplicationName(scope constructs.Construct, id *string, ecsApplicationName *string) IEcsApplication {\n\t_init_.Initialize()\n\n\tvar returns IEcsApplication\n\n\t_jsii_.StaticInvoke(\n\t\t\"monocdk.aws_codedeploy.EcsApplication\",\n\t\t\"fromEcsApplicationName\",\n\t\t[]interface{}{scope, id, ecsApplicationName},\n\t\t&returns,\n\t)\n\n\treturn returns\n}", "id": 21881, "concepts": ["cdk.Construct", "CDK", "CDK Construct", "CDK Construct Library", "CDK Construct Library Construct", "CDK Construct Library Construct Library", "CDK Construct Library Construct Library Construct", "CDK Construct Library Construct Library Construct Library", "CDK Construct Library Construct Library Construct Library Construct", "CDK Construct Library Construct Library Construct Library Construct Library", "CDK Construct Library Construct Library Construct Library Construct Library Construct", "CDK Construct Library Construct Library Construct Library Construct Library Construct Library", "CDK Construct Library Construct Library Construct Library Construct Library Construct Library Construct", "CDK Construct Library Construct Library Construct Library Construct Library Construct Library Construct Library", "CDK Construct Library Construct Library Construct Library Construct Library Construct Library Construct Library Construct", "CDK Construct Library Construct Library Construct Library Construct Library Construct Library Construct Library Construct Library", "CDK Construct Library Construct Library Construct Library Construct Library Construct Library Construct Library Construct Library Construct", "CDK Construct Library Construct Library Construct Library Construct Library Construct Library Construct Library Construct Library Construct Library", "CDK Construct Library Construct Library Construct Library Construct Library Construct Library Construct Library Construct Library Construct Library Construct", "CDK Construct Library Construct Library Construct Library Construct Library Construct Library Construct Library Construct Library Construct Library Construct Library", "CDK Construct Library Construct Library Construct Library Construct Library Construct Library Construct Library Construct Library Construct Library Construct Library Construct", "C"], "_raw_llm_output": "cdk.Construct, CDK, CDK Construct, CDK Construct Library, CDK Construct Library Construct, CDK Construct Library Construct Library, CDK Construct Library Construct Library Construct, CDK Construct Library Construct Library Construct Library, CDK Construct Library Construct Library Construct Library Construct, CDK Construct Library Construct Library Construct Library Construct Library, CDK Construct Library Construct Library Construct Library Construct Library Construct, CDK Construct Library Construct Library Construct Library Construct Library Construct Library, CDK Construct Library Construct Library Construct Library Construct Library Construct Library Construct, CDK Construct Library Construct Library Construct Library Construct Library Construct Library Construct Library, CDK Construct Library Construct Library Construct Library Construct Library Construct Library Construct Library Construct, CDK Construct Library Construct Library Construct Library Construct Library Construct Library Construct Library Construct Library, CDK Construct Library Construct Library Construct Library Construct Library Construct Library Construct Library Construct Library Construct, CDK Construct Library Construct Library Construct Library Construct Library Construct Library Construct Library Construct Library Construct Library, CDK Construct Library Construct Library Construct Library Construct Library Construct Library Construct Library Construct Library Construct Library Construct, CDK Construct Library Construct Library Construct Library Construct Library Construct Library Construct Library Construct Library Construct Library Construct Library, CDK Construct Library Construct Library Construct Library Construct Library Construct Library Construct Library Construct Library Construct Library Construct Library Construct, C"}
{"seed": "// WithPage middleware parses the optional \"page\" query parameter, validates it, and then stores its\n// value into ctx.Locals under the key \"page\"\nfunc WithPage() func(*fiber.Ctx) error {\n\treturn func(ctx *fiber.Ctx) error {\n\t\tpage, err := strconv.Atoi(ctx.Query(\"page\", \"1\"))\n\t\tif err != nil || page <= 0 {\n\t\t\treturn newErrBadRequest(\"Invalid page\")\n\t\t}\n\t\tctx.Locals(\"page\", page)\n\t\treturn ctx.Next()\n\t}\n}", "id": 21884, "concepts": ["middleware", "fiber.Ctx", "strconv.Atoi", "strconv.FormatInt", "fiber.Locals", "fiber.Next", "fiber.Query", "fiber.Status", "fiber.StatusText", "fiber.Error"], "_raw_llm_output": "middleware, fiber.Ctx, strconv.Atoi, strconv.FormatInt, fiber.Locals, fiber.Next, fiber.Query, fiber.Status, fiber.StatusText, fiber.Error"}
{"seed": "// CredentialCreationResponseToProto converts a CredentialCreationResponse to\n// its proto counterpart.\nfunc CredentialCreationResponseToProto(ccr *CredentialCreationResponse) *wantypes.CredentialCreationResponse {\n\tif ccr == nil {\n\t\treturn nil\n\t}\n\treturn &wantypes.CredentialCreationResponse{\n\t\tType:  ccr.Type,\n\t\tRawId: ccr.RawID,\n\t\tResponse: &wantypes.AuthenticatorAttestationResponse{\n\t\t\tClientDataJson:    ccr.AttestationResponse.ClientDataJSON,\n\t\t\tAttestationObject: ccr.AttestationResponse.AttestationObject,\n\t\t},\n\t\tExtensions: outputExtensionsToProto(ccr.Extensions),\n\t}\n}", "id": 21889, "concepts": ["conversion", "pointer handling", "map iteration", "struct iteration"], "_raw_llm_output": "conversion, pointer handling, map iteration, struct iteration"}
{"seed": "// PossibleCreatedByTypeValues returns the possible values for the CreatedByType const type.\nfunc PossibleCreatedByTypeValues() []CreatedByType {\n\treturn []CreatedByType{\n\t\tCreatedByTypeApplication,\n\t\tCreatedByTypeKey,\n\t\tCreatedByTypeManagedIdentity,\n\t\tCreatedByTypeUser,\n\t}\n}", "id": 21918, "concepts": ["const declaration", "type definition", "type assertion", "type switch"], "_raw_llm_output": "const declaration, type definition, type assertion, type switch"}
{"seed": "// D logs message under tag with priority PriorityDebug to w.\nfunc D(w Writer, tag Tag, message string) error {\n\treturn w.Write(PriorityDebug, tag, message)\n}", "id": 21932, "concepts": ["interface implementation", "interface usage", "type assertion", "type switch"], "_raw_llm_output": "interface implementation, interface usage, type assertion, type switch"}
{"seed": "// CreateARMSQueryDataSetRequest creates a request to invoke ARMSQueryDataSet API\nfunc CreateARMSQueryDataSetRequest() (request *ARMSQueryDataSetRequest) {\n\trequest = &ARMSQueryDataSetRequest{\n\t\tRpcRequest: &requests.RpcRequest{},\n\t}\n\trequest.InitWithApiInfo(\"ARMS4FINANCE\", \"2017-11-30\", \"ARMSQueryDataSet\", \"arms4finance\", \"openAPI\")\n\treturn\n}", "id": 21933, "concepts": ["struct definition", "struct field definition", "struct initialization", "struct pointer", "struct method definition", "struct method invocation", "struct method call", "struct method call with pointer receiver", "struct method call with pointer receiver and pointer receiver"], "_raw_llm_output": "struct definition, struct field definition, struct initialization, struct pointer, struct method definition, struct method invocation, struct method call, struct method call with pointer receiver, struct method call with pointer receiver and pointer receiver"}
{"seed": "// segmentPattern creates a regular expression that matches strings containing the\n// given path segment (surrounded by path separators or occurring at the head or tail).\nfunc segmentPattern(pattern *regexp.Regexp) *regexp.Regexp {\n\treturn regexp.MustCompile(\"(^|/)\" + pattern.String() + \"($|/)\")\n}", "id": 21955, "concepts": ["regexp package usage", "regexp.MustCompile", "regexp.Regexp", "string concatenation"], "_raw_llm_output": "regexp package usage, regexp.MustCompile, regexp.Regexp, string concatenation"}
{"seed": "// BigPow10 give 10**n\nfunc BigPow10(n int) *big.Int {\n\treturn new(big.Int).Exp(big.NewInt(10), big.NewInt(int64(n)), new(big.Int))\n}", "id": 21961, "concepts": ["big.Int package usage", "integer exponentiation"], "_raw_llm_output": "big.Int package usage, integer exponentiation"}
{"seed": "/*\nCollateItems takes a map of keys and values, discards all keys which are not UUIDS (that is, part or assembly IDs), and discards all values less than 1. Returns a map[string]int\n*/\nfunc CollateItems(input map[string][]string) (results map[string]int) {\n\tresults = make(map[string]int)\n\tfor key, value := range input {\n\t\t// 32 HEX and 4 hyphens\n\t\tif len(key) == 36 {\n\t\t\tq, _ := strconv.Atoi(value[0])\n\t\t\tif q > 0 {\n\t\t\t\tresults[key] = q\n\t\t\t}\n\t\t}\n\t}\n\treturn\n}", "id": 21973, "concepts": ["map iteration", "string manipulation", "string conversion", "string comparison", "integer conversion", "integer comparison"], "_raw_llm_output": "map iteration, string manipulation, string conversion, string comparison, integer conversion, integer comparison"}
{"seed": "// NewRunner creates a new bosh runner instance, env should contain the\n// environment variables necessary to connect to the bosh instance.\nfunc NewRunner(env []string) *Runner {\n\treturn &Runner{\n\t\tenv: env,\n\t}\n}", "id": 21985, "concepts": ["struct definition", "function definition", "basic function definition"], "_raw_llm_output": "struct definition, function definition, basic function definition"}
{"seed": "// SocketWantPath returns the systemd sockets.target.wants symlink path for the\n// given app name.\nfunc SocketWantPath(root string, appName types.ACName) string {\n\treturn filepath.Join(common.Stage1RootfsPath(root), socketsWantsDir, SocketUnitName(appName))\n}", "id": 22004, "concepts": ["filepath handling", "string manipulation", "standard library usage"], "_raw_llm_output": "filepath handling, string manipulation, standard library usage"}
{"seed": "// TrimmedLines takes a string, splits it into lines, and trims each line of starting\n// and ending whitespace.\nfunc TrimmedLines(s string) []string {\n\tresult := strings.Split(strings.TrimSpace(s), \"\\n\")\n\tfor i, r := range result {\n\t\tresult[i] = strings.TrimSpace(r)\n\t}\n\treturn result\n}", "id": 22011, "concepts": ["string manipulation", "string splitting", "string trimming"], "_raw_llm_output": "string manipulation, string splitting, string trimming"}
{"seed": "// GetRegionKeyChromStartPos get the CHROM + START POS encoding from RegionKey.\nfunc GetRegionKeyChromStartPos(rk uint64) uint64 {\n\treturn uint64(C.get_regionkey_chrom_startpos(C.uint64_t(rk)))\n}", "id": 22012, "concepts": ["C interop", "bitwise operations", "bit shifting", "bit masking", "bitwise AND", "bitwise OR", "bitwise XOR"], "_raw_llm_output": "C interop, bitwise operations, bit shifting, bit masking, bitwise AND, bitwise OR, bitwise XOR"}
{"seed": "// AgeNotIn applies the NotIn predicate on the \"age\" field.\nfunc AgeNotIn(vs ...int) predicate.User {\n\treturn predicate.User(sql.FieldNotIn(FieldAge, vs...))\n}", "id": 22020, "concepts": ["interface", "sql.FieldNotIn", "sql.FieldIn", "sql.FieldEq", "sql.FieldGt", "sql.FieldLt", "sql.FieldGte", "sql.FieldLte", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldBetween", "sql.FieldNotBetween", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldIsNull", "sql.FieldIsNotNull", "sql.FieldEq", "sql.FieldNotEq", "sql.FieldGt", "sql.FieldLt", "sql.FieldGte", "sql.FieldLte", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldBetween", "sql.FieldNotBetween", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldIsNull", "sql.FieldIsNotNull", "sql.FieldEq", "sql.FieldNotEq", "sql.FieldGt", "sql.FieldLt", "sql.FieldGte", "sql.FieldLte", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldBetween", "sql.FieldNotBetween", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldIsNull", "sql.FieldIsNotNull", "sql.FieldEq", "sql.FieldNotEq", "sql.FieldGt", "sql.FieldLt", "sql.Field"], "_raw_llm_output": "interface, sql.FieldNotIn, sql.FieldIn, sql.FieldEq, sql.FieldGt, sql.FieldLt, sql.FieldGte, sql.FieldLte, sql.FieldLike, sql.FieldNotLike, sql.FieldBetween, sql.FieldNotBetween, sql.FieldIn, sql.FieldNotIn, sql.FieldIsNull, sql.FieldIsNotNull, sql.FieldEq, sql.FieldNotEq, sql.FieldGt, sql.FieldLt, sql.FieldGte, sql.FieldLte, sql.FieldLike, sql.FieldNotLike, sql.FieldBetween, sql.FieldNotBetween, sql.FieldIn, sql.FieldNotIn, sql.FieldIsNull, sql.FieldIsNotNull, sql.FieldEq, sql.FieldNotEq, sql.FieldGt, sql.FieldLt, sql.FieldGte, sql.FieldLte, sql.FieldLike, sql.FieldNotLike, sql.FieldBetween, sql.FieldNotBetween, sql.FieldIn, sql.FieldNotIn, sql.FieldIsNull, sql.FieldIsNotNull, sql.FieldEq, sql.FieldNotEq, sql.FieldGt, sql.FieldLt, sql.Field"}
{"seed": "// UpdatedAtNotNil applies the NotNil predicate on the \"updated_at\" field.\nfunc UpdatedAtNotNil() predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.NotNull(s.C(FieldUpdatedAt)))\n\t})\n}", "id": 22026, "concepts": ["sql package usage", "sql.Selector", "sql.C", "sql.NotNull", "sql.Where", "predicate.User"], "_raw_llm_output": "sql package usage, sql.Selector, sql.C, sql.NotNull, sql.Where, predicate.User"}
{"seed": "// BulkCreditSamedayFeeNEQ applies the NEQ predicate on the \"bulkCreditSamedayFee\" field.\nfunc BulkCreditSamedayFeeNEQ(v float64) predicate.Bulk {\n\treturn predicate.Bulk(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldBulkCreditSamedayFee), v))\n\t})\n}", "id": 22028, "concepts": ["sql.Selector", "sql.NEQ", "sql.C", "sql.Where", "sql.Predicate", "sql.Field", "sql.Predicate.Bulk"], "_raw_llm_output": "sql.Selector, sql.NEQ, sql.C, sql.Where, sql.Predicate, sql.Field, sql.Predicate.Bulk"}
{"seed": "// DefaultExprsNEQ applies the NEQ predicate on the \"default_exprs\" field.\nfunc DefaultExprsNEQ(v string) predicate.User {\n\treturn predicate.User(sql.FieldNEQ(FieldDefaultExprs, v))\n}", "id": 22033, "concepts": ["sql.FieldNEQ", "predicate.User", "sql package usage"], "_raw_llm_output": "sql.FieldNEQ, predicate.User, sql package usage"}
{"seed": "// New parses the given template using the given startTag and endTag\n// as tag start and tag end.\n//\n// The returned template can be executed by concurrently running goroutines\n// using Execute* methods.\n//\n// New panics if the given template cannot be parsed. Use NewTemplate instead\n// if template may contain errors.\nfunc New(template, startTag, endTag string) *Template {\n\tt, err := NewTemplate(template, startTag, endTag)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn t\n}", "id": 22037, "concepts": ["template parsing", "template execution", "concurrency", "error handling"], "_raw_llm_output": "template parsing, template execution, concurrency, error handling"}
{"seed": "// NewTestEmailConfigurationParamsWithContext creates a new TestEmailConfigurationParams object\n// with the ability to set a context for a request.\nfunc NewTestEmailConfigurationParamsWithContext(ctx context.Context) *TestEmailConfigurationParams {\n\treturn &TestEmailConfigurationParams{\n\t\tContext: ctx,\n\t}\n}", "id": 22043, "concepts": ["context usage", "function definition", "method definition"], "_raw_llm_output": "context usage, function definition, method definition"}
{"seed": "// MustParseInts parses a string of separated ints into a slice of ints,\n// or panics.\nfunc MustParseInts(commaString string, separator string) []int {\n\tints, err := ParseInts(commaString, separator)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn ints\n}", "id": 22050, "concepts": ["panic", "error handling (idiomatic if err != nil)", "string parsing"], "_raw_llm_output": "panic, error handling (idiomatic if err != nil), string parsing"}
{"seed": "// PossibleLanguageExtensionNameValues returns an array of possible values for the LanguageExtensionName const type.\nfunc PossibleLanguageExtensionNameValues() []LanguageExtensionName {\n\treturn []LanguageExtensionName{PYTHON, R}\n}", "id": 22099, "concepts": ["const type", "array", "basic function definition"], "_raw_llm_output": "const type, array, basic function definition"}
{"seed": "// PopulateRequestContext returns a function that calls InjectTrustedContext\n// with the HeaderTrustHandler you pass to it. The function that this produces\n// implements go-kit's http.RequestFunc interface and can be passed to go-kit's\n// http.ServerBefore ServerOption.\nfunc PopulateRequestContext(t HeaderTrustHandler) httpgk.RequestFunc {\n\treturn func(ctx context.Context, r *http.Request) context.Context {\n\t\treturn InjectTrustedContext(ctx, t, r)\n\t}\n}", "id": 22100, "concepts": ["http.RequestFunc", "http.Request", "context.Context", "go-kit's http.ServerBefore ServerOption"], "_raw_llm_output": "http.RequestFunc, http.Request, context.Context, go-kit's http.ServerBefore ServerOption"}
{"seed": "// CopyCRConfigStat makes a deep copy of a slice of CRConfigStats.\nfunc CopyCRConfigStat(old []CRConfigStat) []CRConfigStat {\n\tnewStats := make([]CRConfigStat, len(old))\n\tcopy(newStats, old)\n\treturn newStats\n}", "id": 22107, "concepts": ["slice copy", "slice definition"], "_raw_llm_output": "slice copy, slice definition"}
{"seed": "// NewSuperKeyRequest instantiates a new SuperKeyRequest object\n// This constructor will assign default values to properties that have it defined,\n// and makes sure properties required by API are set, but the set of arguments\n// will change when the set of required properties is changed\nfunc NewSuperKeyRequest() *SuperKeyRequest {\n\tthis := SuperKeyRequest{}\n\treturn &this\n}", "id": 22124, "concepts": ["constructor", "struct initialization", "struct field initialization"], "_raw_llm_output": "constructor, struct initialization, struct field initialization"}
{"seed": "// Int64ToBytes converts uint64 to bytes.\nfunc Int64ToBytes(n uint64) []byte {\n\tvar res [8]byte\n\tbinary.LittleEndian.PutUint64(res[:], n)\n\treturn res[:]\n}", "id": 22133, "concepts": ["byte conversion", "binary.LittleEndian usage", "basic function definition"], "_raw_llm_output": "byte conversion, binary.LittleEndian usage, basic function definition"}
{"seed": "// RecentTasksActivityCreatedAtASC function sorts data by CreatedAt field in ascending order\n// sorting layers: CreatedAt(ASC)  > Name(ASC)\n// function chain according to sorting layers: RecentTasksActivityCreatedAtASC > subsortingByNameASC\nfunc RecentTasksActivityCreatedAtASC(p1, p2 interface{}) bool {\n\tp1CreatedAt := p1.(RecentTasksActivity).Task.CreatedAt.Truncate(time.Minute)\n\tp2CreatedAt := p2.(RecentTasksActivity).Task.CreatedAt.Truncate(time.Minute)\n\n\tif p1CreatedAt == p2CreatedAt {\n\t\treturn subsortingByNameASC(p1, p2)\n\t}\n\n\treturn p1CreatedAt.Before(p2CreatedAt)\n}", "id": 22153, "concepts": ["interface", "sorting", "sorting by multiple fields"], "_raw_llm_output": "interface, sorting, sorting by multiple fields"}
{"seed": "//\n// \u4e0e\u6709\u5e8f\u6570\u7ec4\u76f8\u5173\u7684\u641c\u7d22\uff0c\u5e94\u5f53\u4f18\u5148\u8054\u60f3\u5230\u4e8c\u5206\u67e5\u627e\u7684\u601d\u8def\n// \u65cb\u8f6c\u7684\u672c\u8d28\u662f\u6539\u53d8\u90e8\u5206\u5e8f\u5217\u7684\u6392\u5e8f\u89c4\u5219\uff0c\u5e94\u5f53\u53d1\u73b0\u4ee5\u4e0b\u89c4\u5f8b\uff1a\n// \u6700\u5de6\u8fb9\u6570 < \u4e2d\u95f4\u6570\u5219\u5de6\u4fa7\u6709\u5e8f\uff0c\u6700\u53f3\u8fb9\u6570 > \u4e2d\u95f4\u6570\u5219\u53f3\u4fa7\u6709\u5e8f\uff0c\u518d\u5229\u7528\u4e8c\u5206\u67e5\u627e\u7684\u601d\u8def\u5373\u53ef\n//\nfunc search(nums []int, target int) int {\n\tleft, right := 0, len(nums)-1\n\tfor left <= right {\n\t\tmid := left + (right-left)/2\n\t\tswitch {\n\t\tcase nums[mid] == target:\n\t\t\treturn mid\n\t\tcase nums[mid] < nums[right]: // \u53f3\u4fa7\u6709\u5e8f\n\t\t\tif nums[mid] < target && nums[right] >= target {\n\t\t\t\tleft = mid + 1 // \u5728\u53f3\u4fa7\u6709\u5e8f\u533a\n\t\t\t} else {\n\t\t\t\tright = mid - 1 // \u8fdb\u5165\u5de6\u4fa7\u65e0\u5e8f\u533a\u67e5\u627e\n\t\t\t}\n\t\tcase nums[mid] >= nums[left]: // \u5de6\u4fa7\u6709\u5e8f\n\t\t\tif nums[mid] > target && nums[left] <= target {\n\t\t\t\tright = mid - 1 // \u5728\u5de6\u4fa7\u6709\u5e8f\u533a\n\t\t\t} else {\n\t\t\t\tleft = mid + 1 // \u8fdb\u5165\u53f3\u4fa7\u65e0\u5e8f\u533a\u67e5\u627e\n\t\t\t}\n\t\t}\n\t}\n\treturn -1\n}", "id": 22185, "concepts": ["binary search", "array", "rotation"], "_raw_llm_output": "binary search, array, rotation"}
{"seed": "// IsEndpointDisabled indicates if err is ErrEndpointDisabled.\nfunc IsEndpointDisabled(err error) bool {\n\treturn unwrapError(err) == ErrEndpointDisabled\n}", "id": 22203, "concepts": ["error wrapping (errors.Wrap)", "error unwrapping (errors.Is)"], "_raw_llm_output": "error wrapping (errors.Wrap), error unwrapping (errors.Is)"}
{"seed": "// ExtractDicomFromGoogleStorage fetches a dicom from within a zipped file in\n// Google Storage and returns it as a native go image.Image, optionally with the\n// overlay displayed on top.\nfunc ExtractDicomFromGoogleStorage(zipPath, dicomName string, includeOverlay bool, storageClient *storage.Client) (image.Image, error) {\n\t// Read the zip file handle into memory still compressed and turn it into an\n\t// io.ReaderAt which is appropriate for consumption by the zip reader -\n\t// either from a local file, or from Google storage, depending on the prefix\n\t// you provide.\n\tf, nbytes, err := MaybeOpenFromGoogleStorage(zipPath, storageClient)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trc, err := zip.NewReader(f, nbytes)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Now we have our compressed zip data in an zip.Reader, regardless of its\n\t// origin.\n\treturn ExtractDicomFromZipReader(rc, dicomName, includeOverlay)\n}", "id": 22220, "concepts": ["zip file handling", "io.ReaderAt", "zip.NewReader", "io.Reader", "image.Image", "image.Decode"], "_raw_llm_output": "zip file handling, io.ReaderAt, zip.NewReader, io.Reader, image.Image, image.Decode"}
{"seed": "// CreativeItems returns a list with all items that have been registered as a creative item. These items will\n// be accessible by players in-game who have creative mode enabled.\nfunc CreativeItems() []Stack {\n\treturn creativeItemStacks\n}", "id": 22223, "concepts": ["slice", "slice iteration (range loop)", "slice definition", "slice append"], "_raw_llm_output": "slice, slice iteration (range loop), slice definition, slice append"}
{"seed": "// WrapTException wraps an error into TException.\n//\n// If err is nil or already TException, it's returned as-is.\n// Otherwise it will be wraped into TException with TExceptionType() returning\n// TExceptionTypeUnknown, and Unwrap() returning the original error.\nfunc WrapTException(err error) TException {\n\tif err == nil {\n\t\treturn nil\n\t}\n\n\tif te, ok := err.(TException); ok {\n\t\treturn te\n\t}\n\n\treturn wrappedTException{\n\t\terr:            err,\n\t\tmsg:            err.Error(),\n\t\ttExceptionType: TExceptionTypeUnknown,\n\t}\n}", "id": 22228, "concepts": ["error wrapping", "interface implementation", "type assertion", "type switch", "type casting"], "_raw_llm_output": "error wrapping, interface implementation, type assertion, type switch, type casting"}
{"seed": "// ServerOptions returns a set of common options that should be used in bblfsh server.\n//\n// It automatically enables OpenTrace if a global tracer is set.\nfunc ServerOptions() []grpc.ServerOption {\n\topts := []grpc.ServerOption{\n\t\tgrpc.MaxSendMsgSize(DefaultGRPCMaxMessageBytes),\n\t\tgrpc.MaxRecvMsgSize(DefaultGRPCMaxMessageBytes),\n\t}\n\ttracer := opentracing.GlobalTracer()\n\tif _, ok := tracer.(opentracing.NoopTracer); ok {\n\t\treturn opts\n\t}\n\topts = append(opts,\n\t\tgrpc.UnaryInterceptor(otgrpc.OpenTracingServerInterceptor(tracer)),\n\t\tgrpc.StreamInterceptor(otgrpc.OpenTracingStreamServerInterceptor(tracer)),\n\t)\n\treturn opts\n}", "id": 22243, "concepts": ["grpc server options", "grpc server interceptor", "grpc stream interceptor", "opentracing", "opentracing grpc server interceptor", "global tracer"], "_raw_llm_output": "grpc server options, grpc server interceptor, grpc stream interceptor, opentracing, opentracing grpc server interceptor, global tracer"}
{"seed": "// ExternalMemoryData returns a pointer to the ExternalMemoryData structure in the\n// CmdExtras, or nil if there are no observations in the CmdExtras.\nfunc GetExternalMemoryData(e *api.CmdExtras) *ExternalMemoryData {\n\tfor _, o := range e.All() {\n\t\tif o, ok := o.(*ExternalMemoryData); ok {\n\t\t\treturn o\n\t\t}\n\t}\n\treturn nil\n}", "id": 22246, "concepts": ["interface usage", "pointer handling", "nil pointer handling", "type assertion"], "_raw_llm_output": "interface usage, pointer handling, nil pointer handling, type assertion"}
{"seed": "// logName returns a new log file name with start time t, and the name\n// for the symlink.\nfunc logName(prefix string, t time.Time) (name, link string) {\n\t// Replace the ':'s in the time format with '_'s to allow for log files in\n\t// Windows.\n\ttFormatted := strings.Replace(t.Format(time.RFC3339), \":\", \"_\", -1)\n\n\tname = fmt.Sprintf(\"%s.%s.%s.%s.%06d.log\",\n\t\tremovePeriods(prefix),\n\t\tremovePeriods(host),\n\t\tremovePeriods(userName),\n\t\ttFormatted,\n\t\tpid)\n\treturn name, removePeriods(prefix) + \".log\"\n}", "id": 22251, "concepts": ["string manipulation", "time formatting", "string removal"], "_raw_llm_output": "string manipulation, time formatting, string removal"}
{"seed": "// Restart runs a rollout restart on a given resource type for a namespace\n// For example, `Restart(\"deployments\", \"some-app\")` will restart _all_ deployments in that namespace\nfunc Restart(resource string, namespace string, args ...string) (err error) {\n\trestart := []string{\"rollout\", \"restart\", resource, \"-n\", namespace}\n\t_, err = kubectl(append(restart, args...)...)\n\treturn\n}", "id": 22257, "concepts": ["command execution (kubectl)", "command line argument handling", "string manipulation"], "_raw_llm_output": "command execution (kubectl), command line argument handling, string manipulation"}
{"seed": "// ResolverQueryLogConfigStatus_Values returns all elements of the ResolverQueryLogConfigStatus enum\nfunc ResolverQueryLogConfigStatus_Values() []string {\n\treturn []string{\n\t\tResolverQueryLogConfigStatusCreating,\n\t\tResolverQueryLogConfigStatusCreated,\n\t\tResolverQueryLogConfigStatusDeleting,\n\t\tResolverQueryLogConfigStatusFailed,\n\t}\n}", "id": 22268, "concepts": ["enum usage", "string formatting", "string manipulation"], "_raw_llm_output": "enum usage, string formatting, string manipulation"}
{"seed": "// NewGetIPAMsubnetsParamsWithTimeout creates a new GetIPAMsubnetsParams object\n// with the default values initialized, and the ability to set a timeout on a request\nfunc NewGetIPAMsubnetsParamsWithTimeout(timeout time.Duration) *GetIPAMsubnetsParams {\n\tvar ()\n\treturn &GetIPAMsubnetsParams{\n\n\t\ttimeout: timeout,\n\t}\n}", "id": 22269, "concepts": ["function definition", "timeout handling", "struct definition", "method definition"], "_raw_llm_output": "function definition, timeout handling, struct definition, method definition"}
{"seed": "// DialOptions returns a set of common options that should be used when dialing bblfsh server.\n//\n// It automatically enables OpenTrace if a global tracer is set.\nfunc DialOptions() []grpc.DialOption {\n\topts := []grpc.DialOption{grpc.WithDefaultCallOptions(\n\t\tgrpc.MaxCallSendMsgSize(DefaultGRPCMaxMessageBytes),\n\t\tgrpc.MaxCallRecvMsgSize(DefaultGRPCMaxMessageBytes),\n\t)}\n\ttracer := opentracing.GlobalTracer()\n\tif _, ok := tracer.(opentracing.NoopTracer); ok {\n\t\treturn opts\n\t}\n\topts = append(opts,\n\t\tgrpc.WithUnaryInterceptor(otgrpc.OpenTracingClientInterceptor(tracer)),\n\t\tgrpc.WithStreamInterceptor(otgrpc.OpenTracingStreamClientInterceptor(tracer)),\n\t)\n\treturn opts\n}", "id": 22280, "concepts": ["grpc.DialOption", "grpc.WithUnaryInterceptor", "grpc.WithStreamInterceptor", "grpc.WithDefaultCallOptions", "grpc.MaxCallSendMsgSize", "grpc.MaxCallRecvMsgSize", "opentracing.GlobalTracer", "opentracing.NoopTracer"], "_raw_llm_output": "grpc.DialOption, grpc.WithUnaryInterceptor, grpc.WithStreamInterceptor, grpc.WithDefaultCallOptions, grpc.MaxCallSendMsgSize, grpc.MaxCallRecvMsgSize, opentracing.GlobalTracer, opentracing.NoopTracer"}
{"seed": "// ParseDeleteLoadBalancerServiceResponse parses an HTTP response from a DeleteLoadBalancerServiceWithResponse call\nfunc ParseDeleteLoadBalancerServiceResponse(rsp *http.Response) (*DeleteLoadBalancerServiceResponse, error) {\n\tbodyBytes, err := ioutil.ReadAll(rsp.Body)\n\tdefer rsp.Body.Close()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse := &DeleteLoadBalancerServiceResponse{\n\t\tBody:         bodyBytes,\n\t\tHTTPResponse: rsp,\n\t}\n\n\tswitch {\n\tcase strings.Contains(rsp.Header.Get(\"Content-Type\"), \"json\") && rsp.StatusCode == 200:\n\t\tvar dest Operation\n\t\tif err := json.Unmarshal(bodyBytes, &dest); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresponse.JSON200 = &dest\n\n\t}\n\n\treturn response, nil\n}", "id": 22286, "concepts": ["HTTP response parsing", "JSON parsing", "error handling", "HTTP status code handling", "standard library usage"], "_raw_llm_output": "HTTP response parsing, JSON parsing, error handling, HTTP status code handling, standard library usage"}
{"seed": "// MapHandler will return an http.HandlerFunc (which also\n// implements http.Handler) that will attempt to map any\n// paths (keys in the map) to their corresponding URL (values\n// that each key in the map points to, in string format).\n// If the path is not provided in the map, then the fallback\n// http.Handler will be called instead.\nfunc MapHandler(pathsToUrls map[string]string, fallback http.Handler) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\ttargetURL, ok := pathsToUrls[html.EscapeString(r.URL.Path)]\n\t\tif ok {\n\t\t\thttp.Redirect(w, r, targetURL, http.StatusFound)\n\t\t\treturn\n\t\t}\n\t\tfallback.ServeHTTP(w, r)\n\t\treturn\n\t}\n}", "id": 22296, "concepts": ["map", "http.HandlerFunc", "http.Handler", "http.Redirect", "url.PathEscape"], "_raw_llm_output": "map, http.HandlerFunc, http.Handler, http.Redirect, url.PathEscape"}
{"seed": "// NewCatalogProductRepositoryV1SavePutParams creates a new CatalogProductRepositoryV1SavePutParams object\n// with the default values initialized.\nfunc NewCatalogProductRepositoryV1SavePutParams() *CatalogProductRepositoryV1SavePutParams {\n\tvar ()\n\treturn &CatalogProductRepositoryV1SavePutParams{\n\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 22297, "concepts": ["struct initialization", "default values", "method definition"], "_raw_llm_output": "struct initialization, default values, method definition"}
{"seed": "// DefaultExprIn applies the In predicate on the \"default_expr\" field.\nfunc DefaultExprIn(vs ...string) predicate.User {\n\treturn predicate.User(sql.FieldIn(FieldDefaultExpr, vs...))\n}", "id": 22302, "concepts": ["sql.FieldIn", "predicate.User", "sql.Field", "sql.Field", "sql.Field", "sql.Field"], "_raw_llm_output": "sql.FieldIn, predicate.User, sql.Field, sql.Field, sql.Field, sql.Field"}
{"seed": "// EncodeConfirmUserRequest encodes internal request into a grpc request type\nfunc EncodeConfirmUserRequest(_ context.Context, r interface{}) (interface{}, error) {\n\treq := r.(ConfirmUserRequest)\n\treturn &pb.ConfirmUserRequest{\n\t\tUsername: req.Username,\n\t\tCode:     req.Code,\n\t}, nil\n}", "id": 22318, "concepts": ["grpc", "protobuf", "interface", "anonymous function", "encoding/json"], "_raw_llm_output": "grpc, protobuf, interface, anonymous function, encoding/json"}
{"seed": "// Unmount unmounts the filesystem at mountPath.\n//\n// Unmount may start one or more underlying processes. By default, stdout and stderr of these\n// processes is discarded. To modify this behavior, consider using OptUnmountStdout and/or\n// OptUnmountStderr.\n//\n// By default, Unmount searches for a fusermount binary in the directories named by the PATH\n// environment variable. To override this behavior, consider using OptUnmountFusermountPath().\nfunc Unmount(ctx context.Context, mountPath string, opts ...UnmountOpt) error {\n\tuo := unmountOpts{\n\t\tfusermountPath: \"fusermount\",\n\t}\n\n\tfor _, opt := range opts {\n\t\tif err := opt(&uo); err != nil {\n\t\t\treturn fmt.Errorf(\"%w\", err)\n\t\t}\n\t}\n\n\treturn unmountSquashFS(ctx, mountPath, uo)\n}", "id": 22322, "concepts": ["context", "function definition", "package import", "struct definition", "function call", "function return", "function parameter", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value", "function return value"], "_raw_llm_output": "context, function definition, package import, struct definition, function call, function return, function parameter, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value, function return value"}
{"seed": "// Extended version of strconv.ParseInt.\n// Also accepts binary forms with \"0b\" prefix.\nfunc parseIntEx(s string, bitSize int) (int64, error) {\n\tif s[0:2] == \"0b\" {\n\t\treturn strconv.ParseInt(s[2:], 2, bitSize)\n\t} else {\n\t\treturn strconv.ParseInt(s, 0, bitSize)\n\t}\n}", "id": 22330, "concepts": ["string manipulation", "strconv package usage", "bitwise operations"], "_raw_llm_output": "string manipulation, strconv package usage, bitwise operations"}
{"seed": "// ParseGetDomainResponse parses an HTTP response from a GetDomainWithResponse call\nfunc ParseGetDomainResponse(rsp *http.Response) (*GetDomainResponse, error) {\n\tbodyBytes, err := ioutil.ReadAll(rsp.Body)\n\tdefer rsp.Body.Close()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse := &GetDomainResponse{\n\t\tBody:         bodyBytes,\n\t\tHTTPResponse: rsp,\n\t}\n\n\tswitch {\n\tcase strings.Contains(rsp.Header.Get(\"Content-Type\"), \"json\") && rsp.StatusCode == 200:\n\t\tvar dest ScalewayDomainV2alpha2GetDomainResponse\n\t\tif err := json.Unmarshal(bodyBytes, &dest); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresponse.JSON200 = &dest\n\n\t}\n\n\treturn response, nil\n}", "id": 22336, "concepts": ["HTTP response parsing", "JSON parsing", "error handling", "switch statement", "HTTP status code handling"], "_raw_llm_output": "HTTP response parsing, JSON parsing, error handling, switch statement, HTTP status code handling"}
{"seed": "// BlockOverrideDnsType_Values returns all elements of the BlockOverrideDnsType enum\nfunc BlockOverrideDnsType_Values() []string {\n\treturn []string{\n\t\tBlockOverrideDnsTypeCname,\n\t}\n}", "id": 22339, "concepts": ["enum handling", "string manipulation"], "_raw_llm_output": "enum handling, string manipulation"}
{"seed": "// PossibleSKULocationInfoTypeValues returns the possible values for the SKULocationInfoType const type.\nfunc PossibleSKULocationInfoTypeValues() []SKULocationInfoType {\n\treturn []SKULocationInfoType{\n\t\tSKULocationInfoTypeArcZone,\n\t\tSKULocationInfoTypeEdgeZone,\n\t\tSKULocationInfoTypeNotSpecified,\n\t}\n}", "id": 22342, "concepts": ["const type", "const declaration", "const value assignment"], "_raw_llm_output": "const type, const declaration, const value assignment"}
{"seed": "// NewGetIPAMsubnetsParamsWithHTTPClient creates a new GetIPAMsubnetsParams object\n// with the default values initialized, and the ability to set a custom HTTPClient for a request\nfunc NewGetIPAMsubnetsParamsWithHTTPClient(client *http.Client) *GetIPAMsubnetsParams {\n\tvar ()\n\treturn &GetIPAMsubnetsParams{\n\t\tHTTPClient: client,\n\t}\n}", "id": 22345, "concepts": ["struct initialization", "pointer receivers", "HTTPClient usage"], "_raw_llm_output": "struct initialization, pointer receivers, HTTPClient usage"}
{"seed": "// CorrectionNotIn applies the NotIn predicate on the \"correction\" field.\nfunc CorrectionNotIn(vs ...string) predicate.TradeCorrection {\n\treturn predicate.TradeCorrection(sql.FieldNotIn(FieldCorrection, vs...))\n}", "id": 22348, "concepts": ["predicate.TradeCorrection", "sql.FieldNotIn"], "_raw_llm_output": "predicate.TradeCorrection, sql.FieldNotIn"}
{"seed": "// CreateGetTaxationInfoRequest creates a request to invoke GetTaxationInfo API\nfunc CreateGetTaxationInfoRequest() (request *GetTaxationInfoRequest) {\n\trequest = &GetTaxationInfoRequest{\n\t\tRpcRequest: &requests.RpcRequest{},\n\t}\n\trequest.InitWithApiInfo(\"companyreg\", \"2020-10-22\", \"GetTaxationInfo\", \"companyreg\", \"openAPI\")\n\trequest.Method = requests.GET\n\treturn\n}", "id": 22353, "concepts": ["struct definition", "pointer usage", "method definition", "struct initialization", "method invocation"], "_raw_llm_output": "struct definition, pointer usage, method definition, struct initialization, method invocation"}
{"seed": "// RelEnvFilePath returns the path to the environment file for the given\n// app name relative to the pod's root.\nfunc RelEnvFilePath(appName types.ACName) string {\n\treturn filepath.Join(envDir, appName.String())\n}", "id": 22380, "concepts": ["filepath.Join", "string concatenation", "filepath.Base", "filepath.Dir", "filepath.Ext", "filepath.IsAbs", "filepath.Join", "filepath.Split", "filepath.SplitList", "filepath.SplitPath", "filepath.SplitPathExt", "filepath.SplitSuffix", "filepath.VolumeName", "filepath.VolumeNameSeparator", "filepath.VolumeNameValid", "filepath.VolumeNameValidSeparator", "filepath.VolumeNameValidSeparator", "filepath.Walk", "filepath.WalkDir", "filepath.WalkFunc", "filepath.WalkPrefix", "filepath.WalkPrefixFunc", "filepath.WalkPrefixSep", "filepath.WalkSep", "filepath.WalkSeparator", "filepath.WalkSeparator", "filepath.WalkSeparator", "filepath.WalkSeparator", "filepath.WalkSeparator", "filepath.WalkSeparator", "filepath.WalkSeparator", "filepath.WalkSeparator", "filepath.WalkSeparator", "filepath.WalkSeparator", "filepath.WalkSeparator", "filepath.WalkSeparator", "filepath.WalkSeparator", "filepath.WalkSeparator", "filepath.WalkSeparator", "filepath.WalkSeparator", "filepath.WalkSeparator", "filepath.WalkSeparator", "filepath.WalkSeparator", "filepath.WalkSeparator", "filepath.WalkSeparator", "filepath.WalkSeparator", "filepath.WalkSeparator", "filepath.WalkSeparator", "filepath.WalkSeparator", "filepath.WalkSeparator", "filepath.WalkSeparator"], "_raw_llm_output": "filepath.Join, string concatenation, filepath.Base, filepath.Dir, filepath.Ext, filepath.IsAbs, filepath.Join, filepath.Split, filepath.SplitList, filepath.SplitPath, filepath.SplitPathExt, filepath.SplitSuffix, filepath.VolumeName, filepath.VolumeNameSeparator, filepath.VolumeNameValid, filepath.VolumeNameValidSeparator, filepath.VolumeNameValidSeparator, filepath.Walk, filepath.WalkDir, filepath.WalkFunc, filepath.WalkPrefix, filepath.WalkPrefixFunc, filepath.WalkPrefixSep, filepath.WalkSep, filepath.WalkSeparator, filepath.WalkSeparator, filepath.WalkSeparator, filepath.WalkSeparator, filepath.WalkSeparator, filepath.WalkSeparator, filepath.WalkSeparator, filepath.WalkSeparator, filepath.WalkSeparator, filepath.WalkSeparator, filepath.WalkSeparator, filepath.WalkSeparator, filepath.WalkSeparator, filepath.WalkSeparator, filepath.WalkSeparator, filepath.WalkSeparator, filepath.WalkSeparator, filepath.WalkSeparator, filepath.WalkSeparator, filepath.WalkSeparator, filepath.WalkSeparator, filepath.WalkSeparator, filepath.WalkSeparator, filepath.WalkSeparator, filepath.WalkSeparator, filepath.WalkSeparator, filepath.WalkSeparator"}
{"seed": "// InitTestClient initializes a controller-runtime client. This is a no-op if\n// it has already been called. It should be called prior to any test execution.\nfunc InitTestClient() error {\n\terr := cassdcapi.AddToScheme(scheme.Scheme)\n\tif err != nil {\n\t\treturn err\n\t}\n\tconfig, err := ctrl.GetConfig()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"cannot contact Kind test cluster: %w\", err)\n\t}\n\ttestClient, err = client.New(config, client.Options{Scheme: scheme.Scheme})\n\n\treturn err\n}", "id": 22392, "concepts": ["client.New", "client.Options", "client.AddToScheme", "ctrl.GetConfig", "standard library usage"], "_raw_llm_output": "client.New, client.Options, client.AddToScheme, ctrl.GetConfig, standard library usage"}
{"seed": "// GetSupervisorCheckDelay returns the time delay in seconds between each supervisor check at startup\nfunc GetSupervisorCheckDelay() (time.Duration, error) {\n\tvalue, err := strconv.Atoi(getEnv(\"ENM_SUPERVISOR_CHECK_DELAY\", \"1\"))\n\treturn time.Duration(value) * time.Second, err\n}", "id": 22394, "concepts": ["string to integer conversion", "environment variable usage", "time duration"], "_raw_llm_output": "string to integer conversion, environment variable usage, time duration"}
{"seed": "// BetterHeroScoreAtEQ applies the EQ predicate on the \"better_hero_score_at\" field.\nfunc BetterHeroScoreAtEQ(v time.Time) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldBetterHeroScoreAt), v))\n\t})\n}", "id": 22404, "concepts": ["sql.Selector", "sql.EQ", "sql.Where", "sql.C", "sql.Predicate", "sql.Field", "time.Time", "sql.NullTime", "sql.NullBool", "sql.NullInt64", "sql.NullFloat64", "sql.NullString", "sql.NullBytes", "sql.NullTime", "sql.NullBool", "sql.NullInt64", "sql.NullFloat64", "sql.NullString", "sql.NullBytes", "sql.NullTime", "sql.NullBool", "sql.NullInt64", "sql.NullFloat64", "sql.NullString", "sql.NullBytes", "sql.NullTime", "sql.NullBool", "sql.NullInt64", "sql.NullFloat64", "sql.NullString", "sql.NullBytes", "sql.NullTime", "sql.NullBool", "sql.NullInt64", "sql.NullFloat64", "sql.NullString", "sql.NullBytes", "sql.NullTime", "sql.NullBool", "sql.NullInt64", "sql.NullFloat64", "sql.NullString", "sql.NullBytes", "sql.NullTime", "sql.NullBool", "sql.NullInt64", "sql.NullFloat64"], "_raw_llm_output": "sql.Selector, sql.EQ, sql.Where, sql.C, sql.Predicate, sql.Field, time.Time, sql.NullTime, sql.NullBool, sql.NullInt64, sql.NullFloat64, sql.NullString, sql.NullBytes, sql.NullTime, sql.NullBool, sql.NullInt64, sql.NullFloat64, sql.NullString, sql.NullBytes, sql.NullTime, sql.NullBool, sql.NullInt64, sql.NullFloat64, sql.NullString, sql.NullBytes, sql.NullTime, sql.NullBool, sql.NullInt64, sql.NullFloat64, sql.NullString, sql.NullBytes, sql.NullTime, sql.NullBool, sql.NullInt64, sql.NullFloat64, sql.NullString, sql.NullBytes, sql.NullTime, sql.NullBool, sql.NullInt64, sql.NullFloat64, sql.NullString, sql.NullBytes, sql.NullTime, sql.NullBool, sql.NullInt64, sql.NullFloat64"}
{"seed": "// ComparatorInt provides a basic comparison on int.\nfunc ComparatorInt(a, b interface{}) int {\n\treturn qn_conv.Int(a) - qn_conv.Int(b)\n}", "id": 22421, "concepts": ["interface", "type conversion", "basic function definition"], "_raw_llm_output": "interface, type conversion, basic function definition"}
{"seed": "// IsNodeExists returns true if the err parameter is a Zookeeper error representing an already existing node\nfunc IsNodeExists(err error) bool {\n\tze := filterErr(err)\n\tif ze == nil {\n\t\treturn false\n\t}\n\treturn ze.Code == zookeeper.ZNODEEXISTS\n}", "id": 22448, "concepts": ["error handling (type assertion)", "error handling (type switch)", "error handling (error wrapping)"], "_raw_llm_output": "error handling (type assertion), error handling (type switch), error handling (error wrapping)"}
{"seed": "// NewSecretClient creates a new instance of SecretClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.\nfunc NewSecretClient(t mockConstructorTestingTNewSecretClient) *SecretClient {\n\tmock := &SecretClient{}\n\tmock.Mock.Test(t)\n\n\tt.Cleanup(func() { mock.AssertExpectations(t) })\n\n\treturn mock\n}", "id": 22450, "concepts": ["mocking", "testing", "interface", "cleanup function"], "_raw_llm_output": "mocking, testing, interface, cleanup function"}
{"seed": "// BadRequest is a convenience function for building HTTP 400 Bad Request\n// responses. If data is nil, a default serializer will be used.\nfunc BadRequest(data Serializer, logging ...interface{}) Response {\n\tif data == nil {\n\t\tdata = String(\"400 Bad Request\")\n\t}\n\treturn Response{\n\t\tStatus:  http.StatusBadRequest,\n\t\tData:    data,\n\t\tLogging: logging,\n\t}\n}", "id": 22454, "concepts": ["http package usage", "standard library usage", "function definition", "function return"], "_raw_llm_output": "http package usage, standard library usage, function definition, function return"}
{"seed": "// FailingStartEx is a replacement for measurementkit.StartEx that\n// returns an error immediately.\nfunc FailingStartEx(\n\tsettings measurementkit.Settings, logger model.Logger,\n) (<-chan measurementkit.Event, error) {\n\treturn nil, errors.New(\"fail immediately\")\n}", "id": 22458, "concepts": ["error handling (errors.New)", "function definition"], "_raw_llm_output": "error handling (errors.New), function definition"}
{"seed": "// NewRegistryBuilder creates a new bsoncodec.RegistryBuilder configured with the default encoders and\n// decoders from the bsoncodec.DefaultValueEncoders and bsoncodec.DefaultValueDecoders types and the\n// PrimitiveCodecs type in this package.\nfunc NewRegistryBuilder() *bsoncodec.RegistryBuilder {\n\trb := bsoncodec.NewRegistryBuilder()\n\tbsoncodec.DefaultValueEncoders{}.RegisterDefaultEncoders(rb)\n\tbsoncodec.DefaultValueDecoders{}.RegisterDefaultDecoders(rb)\n\tbson.PrimitiveCodecs{}.RegisterPrimitiveCodecs(rb)\n\n\tstructcodec, _ := bsoncodec.NewStructCodec(bsoncodec.DefaultStructTagParser,\n\t\tbsonoptions.StructCodec().\n\t\t\tSetDecodeZeroStruct(true).\n\t\t\tSetEncodeOmitDefaultStruct(true).\n\t\t\tSetOverwriteDuplicatedInlinedFields(false).\n\t\t\tSetAllowUnexportedFields(true))\n\temptyInterCodec := bsoncodec.NewEmptyInterfaceCodec(\n\t\tbsonoptions.EmptyInterfaceCodec().\n\t\t\tSetDecodeBinaryAsSlice(true))\n\tmapCodec := bsoncodec.NewMapCodec(\n\t\tbsonoptions.MapCodec().\n\t\t\tSetDecodeZerosMap(true).\n\t\t\tSetEncodeNilAsEmpty(true).\n\t\t\tSetEncodeKeysWithStringer(true))\n\tuintcodec := bsoncodec.NewUIntCodec(bsonoptions.UIntCodec().SetEncodeToMinSize(true))\n\n\trb.RegisterTypeDecoder(tEmpty, emptyInterCodec).\n\t\tRegisterDefaultDecoder(reflect.String, bsoncodec.NewStringCodec(bsonoptions.StringCodec().SetDecodeObjectIDAsHex(false))).\n\t\tRegisterDefaultDecoder(reflect.Struct, structcodec).\n\t\tRegisterDefaultDecoder(reflect.Map, mapCodec).\n\t\tRegisterTypeEncoder(tByteSlice, bsoncodec.NewByteSliceCodec(bsonoptions.ByteSliceCodec().SetEncodeNilAsEmpty(true))).\n\t\tRegisterDefaultEncoder(reflect.Struct, structcodec).\n\t\tRegisterDefaultEncoder(reflect.Slice, bsoncodec.NewSliceCodec(bsonoptions.SliceCodec().SetEncodeNilAsEmpty(true))).\n\t\tRegisterDefaultEncoder(reflect.Map, mapCodec).\n\t\tRegisterDefaultEncoder(reflect.Uint, uintcodec).\n\t\tRegisterDefaultEncoder(reflect.Uint8, uintcodec).\n\t\tRegisterDefaultEncoder(reflect.Uint16, uintcodec).\n\t\tRegisterDefaultEncoder(reflect.Uint32, uintcodec).\n\t\tRegisterDefaultEncoder(reflect.Uint64, uintcodec).\n\t\tRegisterTypeMapEntry(bsontype.Int32, tInt).\n\t\tRegisterTypeMapEntry(bsontype.DateTime, tTime).\n\t\tRegisterTypeMapEntry(bsontype.Array, tInterfaceSlice).\n\t\tRegisterTypeMapEntry(bsontype.Type(0), tM).\n\t\tRegisterTypeMapEntry(bsontype.EmbeddedDocument, tM).\n\t\tRegisterHookEncoder(tGetter, bsoncodec.ValueEncoderFunc(GetterEncodeValue)).\n\t\tRegisterHookDecoder(tSetter, bsoncodec.ValueDecoderFunc(SetterDecodeValue))\n\n\treturn rb\n}", "id": 22463, "concepts": ["bsoncodec.RegistryBuilder", "bsoncodec.DefaultValueEncoders", "bsoncodec.DefaultValueDecoders", "bsoncodec.NewStructCodec", "bsoncodec.NewEmptyInterfaceCodec", "bsoncodec.NewMapCodec", "bsoncodec.NewUIntCodec", "bsoncodec.NewStringCodec", "bsoncodec.NewByteSliceCodec", "bsoncodec.NewSliceCodec", "bsoncodec.NewStructCodec", "bsoncodec.NewMapCodec", "bsoncodec.NewUIntCodec", "bsoncodec.NewSliceCodec", "bsoncodec.NewEmptyInterfaceCodec", "bsoncodec.NewMapCodec", "bsoncodec.NewUIntCodec", "bsoncodec.NewStringCodec", "bsoncodec.NewByteSliceCodec", "bsoncodec.NewSliceCodec", "bsoncodec.NewStructCodec", "bsoncodec.NewMapCodec", "bsoncodec.NewUIntCodec", "bsoncodec.NewSliceCodec", "bsoncodec.NewEmptyInterfaceCodec", "bsoncodec.NewMapCodec", "bsoncodec.NewUIntCodec", "bsoncodec.NewStringCodec", "bsoncodec.NewByteSliceCodec", "bsoncodec.NewSliceCodec", "bsoncodec.NewStructCodec", "bsoncodec.NewMapCodec", "bsoncodec.NewUIntCodec", "bsoncodec.NewSliceCodec", "bsoncodec.NewEmptyInterfaceCodec", "bsoncodec.New"], "_raw_llm_output": "bsoncodec.RegistryBuilder, bsoncodec.DefaultValueEncoders, bsoncodec.DefaultValueDecoders, bsoncodec.NewStructCodec, bsoncodec.NewEmptyInterfaceCodec, bsoncodec.NewMapCodec, bsoncodec.NewUIntCodec, bsoncodec.NewStringCodec, bsoncodec.NewByteSliceCodec, bsoncodec.NewSliceCodec, bsoncodec.NewStructCodec, bsoncodec.NewMapCodec, bsoncodec.NewUIntCodec, bsoncodec.NewSliceCodec, bsoncodec.NewEmptyInterfaceCodec, bsoncodec.NewMapCodec, bsoncodec.NewUIntCodec, bsoncodec.NewStringCodec, bsoncodec.NewByteSliceCodec, bsoncodec.NewSliceCodec, bsoncodec.NewStructCodec, bsoncodec.NewMapCodec, bsoncodec.NewUIntCodec, bsoncodec.NewSliceCodec, bsoncodec.NewEmptyInterfaceCodec, bsoncodec.NewMapCodec, bsoncodec.NewUIntCodec, bsoncodec.NewStringCodec, bsoncodec.NewByteSliceCodec, bsoncodec.NewSliceCodec, bsoncodec.NewStructCodec, bsoncodec.NewMapCodec, bsoncodec.NewUIntCodec, bsoncodec.NewSliceCodec, bsoncodec.NewEmptyInterfaceCodec, bsoncodec.New"}
{"seed": "// NewListInstancesParamsWithHTTPClient creates a new ListInstancesParams object\n// with the default values initialized, and the ability to set a custom HTTPClient for a request\nfunc NewListInstancesParamsWithHTTPClient(client *http.Client) *ListInstancesParams {\n\tvar ()\n\treturn &ListInstancesParams{\n\t\tHTTPClient: client,\n\t}\n}", "id": 22467, "concepts": ["struct initialization", "pointer receivers", "HTTPClient usage"], "_raw_llm_output": "struct initialization, pointer receivers, HTTPClient usage"}
{"seed": "// Frame represents the HTML element 'frame'.\n// For more information visit https://www.w3schools.com/tags/tag_frame.asp.\nfunc Frame(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"frame\", Attributes: attrs, Children: children}\n}", "id": 22473, "concepts": ["HTML generation", "HTML tree traversal", "HTML element definition", "HTML attribute definition"], "_raw_llm_output": "HTML generation, HTML tree traversal, HTML element definition, HTML attribute definition"}
{"seed": "// MapHTTPHeadersToClientMetadataMuxOptionFxOption adds a Grpc Gateway server mux option\n// that maps incoming HTTP Headers to gRPC Context by checking if they match a list of prefixes.\n// List of prefixes is controlled by config key: `mortar.middleware.map.httpHeaders`\nfunc MapHTTPHeadersToClientMetadataMuxOptionFxOption() fx.Option {\n\treturn fx.Provide(\n\t\tfx.Annotated{\n\t\t\tGroup:  groups.GRPCGatewayMuxOptions,\n\t\t\tTarget: grpcgateway.MapHTTPHeadersToClientMetadataMuxOption,\n\t\t})\n}", "id": 22476, "concepts": ["fx.Option", "fx.Annotated", "grpcgateway.MapHTTPHeadersToClientMetadataMuxOption", ""], "_raw_llm_output": "fx.Option, fx.Annotated, grpcgateway.MapHTTPHeadersToClientMetadataMuxOption,"}
{"seed": "// IsValueSlice reports whether v is a slice type.\nfunc IsValueSlice(v reflect.Value) bool {\n\treturn v.Kind() == reflect.Slice\n}", "id": 22480, "concepts": ["reflection", "reflect.Value", "type checking"], "_raw_llm_output": "reflection, reflect.Value, type checking"}
{"seed": "// NewHttpDeliveryOptionsWithDefaults instantiates a new HttpDeliveryOptions object\n// This constructor will only assign default values to properties that have it defined,\n// but it doesn't guarantee that properties required by API are set\nfunc NewHttpDeliveryOptionsWithDefaults() *HttpDeliveryOptions {\n\tthis := HttpDeliveryOptions{}\n\tvar value DeliveryOverrideType = DELIVERYOVERRIDETYPE_DEFAULT\n\tthis.Value = value\n\treturn &this\n}", "id": 22481, "concepts": ["struct definition", "struct field definition", "struct field initialization", "struct field assignment", "struct field access"], "_raw_llm_output": "struct definition, struct field definition, struct field initialization, struct field assignment, struct field access"}
{"seed": "// GenerateKey takes a password and some salt, and generates a salted key of length 64 bytes.\n// Use the ExternalSalt as salt and the original, unaltered password. The function\n// use Blake2b-512 for key derivation.\nfunc GenerateKey(password string, salt []byte, params *Params) *saltedKey {\n\tunsalted := blake2b.Sum512([]byte(password))\n\tsalted := saltedKey{pwd: append(salt, unsalted[:]...), sel: salt, p: params}\n\treturn &salted\n}", "id": 22499, "concepts": ["cryptography", "salted key generation", "blake2b-512", "crypto/blake2b package usage"], "_raw_llm_output": "cryptography, salted key generation, blake2b-512, crypto/blake2b package usage"}
{"seed": "// There are a number of cases where the Google Drive API returns an error\n// code but where it's possible to recover from the error; examples include\n// 401 errors when the OAuth2 token expires after an hour, or 403/500 errors\n// when we make too many API calls too quickly and we get a rate limit error.\n// This function takes an error returned by a Drive API call and the number\n// of times that we've tried to call the API entrypoint already and does\n// its best to handle the error.\n//\n// If it thinks it may have been successful, it returns nil, and the caller\n// should try the call again. For unrecoverable errors (or too many errors\n// in a row), it returns the error code back and the caller should stop trying.\nfunc tryToHandleDriveAPIError(err error, ntries int) error {\n\tdebug.Printf(\"tryToHandleDriveAPIError: ntries %d error %T %+v\",\n\t\tntries, err, err)\n\n\tmaxAPIRetries := 6\n\tif ntries == maxAPIRetries {\n\t\treturn err\n\t}\n\tswitch err := err.(type) {\n\tcase *googleapi.Error:\n\t\tif err.Code == 401 {\n\t\t\t// After an hour, the OAuth2 token expires and needs to\n\t\t\t// be refreshed.\n\t\t\tdebug.Printf(\"Trying OAuth2 token refresh.\")\n\t\t\tif err := oAuthTransport.Refresh(); err == nil {\n\t\t\t\t// Success\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\t// Otherwise fall through to sleep/backoff...\n\t\t}\n\t}\n\n\texponentialBackoff(ntries, nil, err)\n\treturn nil\n}", "id": 22504, "concepts": ["error handling (type assertion)", "error handling (error wrapping)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling (error handling)", "error handling ("], "_raw_llm_output": "error handling (type assertion), error handling (error wrapping), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling (error handling), error handling ("}
{"seed": "// SocialPayloadNEQ applies the NEQ predicate on the \"social_payload\" field.\nfunc SocialPayloadNEQ(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldSocialPayload), v))\n\t})\n}", "id": 22530, "concepts": ["sql.Selector", "sql.NEQ", "sql.Where", "sql.C", "predicate.User", "sql.Query"], "_raw_llm_output": "sql.Selector, sql.NEQ, sql.Where, sql.C, predicate.User, sql.Query"}
{"seed": "// MapFloat64StrPtr takes two inputs -\n// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list\nfunc MapFloat64StrPtr(f func(*float64) *string, list []*float64) []*string {\n\tif f == nil {\n\t\treturn []*string{}\n\t}\n\tnewList := make([]*string, len(list))\n\tfor i, v := range list {\n\t\tnewList[i] = f(v)\n\t}\n\treturn newList\n}", "id": 22532, "concepts": ["function definition", "function pointer", "function composition", "function composition with anonymous function", "function composition with function pointer", "function composition with function pointer and function pointer", "function composition with function pointer and function pointer", "function composition with function pointer and function pointer and function pointer", "function composition with function pointer and function pointer and function pointer and function pointer", "function composition with function pointer and function pointer and function pointer and function pointer and function pointer", "function composition with function pointer and function pointer and function pointer and function pointer and function pointer and function pointer", "function composition with function pointer and function pointer and function pointer and function pointer and function pointer and function pointer and function pointer", "function composition with function pointer and function pointer and function pointer and function pointer and function pointer and function pointer and function pointer and function pointer", "function composition with function pointer and function pointer and function pointer and function pointer and function pointer and function pointer and function pointer and function pointer and function pointer", "function composition with function pointer and function pointer and function pointer and function pointer and function pointer and function pointer and function pointer and function pointer and function pointer and function pointer", "function composition with function pointer and function pointer and function pointer and function pointer and function pointer and function pointer and function pointer and function pointer and function pointer and function pointer and function pointer", ""], "_raw_llm_output": "function definition, function pointer, function composition, function composition with anonymous function, function composition with function pointer, function composition with function pointer and function pointer, function composition with function pointer and function pointer, function composition with function pointer and function pointer and function pointer, function composition with function pointer and function pointer and function pointer and function pointer, function composition with function pointer and function pointer and function pointer and function pointer and function pointer, function composition with function pointer and function pointer and function pointer and function pointer and function pointer and function pointer, function composition with function pointer and function pointer and function pointer and function pointer and function pointer and function pointer and function pointer, function composition with function pointer and function pointer and function pointer and function pointer and function pointer and function pointer and function pointer and function pointer, function composition with function pointer and function pointer and function pointer and function pointer and function pointer and function pointer and function pointer and function pointer and function pointer, function composition with function pointer and function pointer and function pointer and function pointer and function pointer and function pointer and function pointer and function pointer and function pointer and function pointer, function composition with function pointer and function pointer and function pointer and function pointer and function pointer and function pointer and function pointer and function pointer and function pointer and function pointer and function pointer,"}
{"seed": "// ListenAndServeTLS acts identically to ListenAndServe, except that it\n// expects HTTPS connections. Additionally, files containing a certificate and\n// matching private key for the server must be provided. If the certificate\n// is signed by a certificate authority, the certFile should be the concatenation\n// of the server's certificate, any intermediates, and the CA's certificate.\nfunc ListenAndServeTLS(addr, certFile, keyFile string, handler Handler) error {\n\tserver := &Server{Addr: addr, Handler: handler}\n\treturn server.ListenAndServeTLS(certFile, keyFile)\n}", "id": 22557, "concepts": ["net/http package usage", "TLS certificate handling", "server configuration"], "_raw_llm_output": "net/http package usage, TLS certificate handling, server configuration"}
{"seed": "// saveUniqueUserImage saves an image file, making sure there is always\n// only one for that user, overwritting the previous one.\n// It uses a sub-directory named after the user ID that is systematically\n// replaced.\n//\n// It returns the URL to access this image via GET requests.\nfunc saveUniqueUserImage(userID, filename string, file io.Reader) (string, error) {\n\tdirpath := joinPath(env[\"STORAGE_FILE_PATH\"], userID)\n\treturn saveUniqueFileInDir(dirpath, filename, file)\n}", "id": 22564, "concepts": ["string manipulation", "file system handling", "concurrency", "error handling", "standard library usage"], "_raw_llm_output": "string manipulation, file system handling, concurrency, error handling, standard library usage"}
{"seed": "// H5 represents the HTML element 'h5'.\n// For more information visit https://www.w3schools.com/tags/tag_h5.asp.\nfunc H5(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"h5\", Attributes: attrs, Children: children}\n}", "id": 22567, "concepts": ["HTML generation", "HTML tree building", "HTML tree traversal"], "_raw_llm_output": "HTML generation, HTML tree building, HTML tree traversal"}
{"seed": "// NewNetworkLicenseFile instantiates a new NetworkLicenseFile object\n// This constructor will assign default values to properties that have it defined,\n// and makes sure properties required by API are set, but the set of arguments\n// will change when the set of required properties is changed\nfunc NewNetworkLicenseFile(classId string, objectType string) *NetworkLicenseFile {\n\tthis := NetworkLicenseFile{}\n\tthis.ClassId = classId\n\tthis.ObjectType = objectType\n\treturn &this\n}", "id": 22572, "concepts": ["constructor", "default value assignment", "API usage"], "_raw_llm_output": "constructor, default value assignment, API usage"}
{"seed": "// Given a moment, return the moment that would be after a gigasecond has\n// passed.\n//\n// A gigasecond is 10^9 (1,000,000,000) seconds.\n//\nfunc AddGigasecond(t time.Time) time.Time {\n\treturn t.Add(time.Second * 1e9)\n}", "id": 22575, "concepts": ["time package usage", "time.Time", "time.Duration", "time.Second", "time.Add"], "_raw_llm_output": "time package usage, time.Time, time.Duration, time.Second, time.Add"}
{"seed": "// modURI returns the URI for the go.mod file contained in root.\nfunc modURI(root span.URI) span.URI {\n\treturn span.URIFromPath(filepath.Join(root.Filename(), \"go.mod\"))\n}", "id": 22583, "concepts": ["filepath.Join", "URI handling"], "_raw_llm_output": "filepath.Join, URI handling"}
{"seed": "// NewCreateNetworkingV1beta1NamespacedIngressCreated creates CreateNetworkingV1beta1NamespacedIngressCreated with default headers values\nfunc NewCreateNetworkingV1beta1NamespacedIngressCreated() *CreateNetworkingV1beta1NamespacedIngressCreated {\n\n\treturn &CreateNetworkingV1beta1NamespacedIngressCreated{}\n}", "id": 22590, "concepts": ["struct definition", "default value assignment", "basic function definition"], "_raw_llm_output": "struct definition, default value assignment, basic function definition"}
{"seed": "// GetKeyLifecycleStateEnumValues Enumerates the set of values for KeyLifecycleStateEnum\nfunc GetKeyLifecycleStateEnumValues() []KeyLifecycleStateEnum {\n\tvalues := make([]KeyLifecycleStateEnum, 0)\n\tfor _, v := range mappingKeyLifecycleStateEnum {\n\t\tvalues = append(values, v)\n\t}\n\treturn values\n}", "id": 22593, "concepts": ["enumerations", "mapping", "basic function definition"], "_raw_llm_output": "enumerations, mapping, basic function definition"}
{"seed": "// FGetURINamesFromPEM retrieves URIs from the SAN extension of a\n// PEM-encoded X.509 certificate, whose content is in the provided io.Reader.\nfunc FGetURINamesFromPEM(f io.Reader) (uris []string, err error) {\n\tblob, err := ioutil.ReadAll(f)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn uriNamesFromPEM(blob)\n}", "id": 22603, "concepts": ["io.Reader", "io.Writer", "ioutil.ReadAll", "PEM encoding", "X.509 certificate", "SAN extension", "URI handling"], "_raw_llm_output": "io.Reader, io.Writer, ioutil.ReadAll, PEM encoding, X.509 certificate, SAN extension, URI handling"}
{"seed": "// XYToD converts a two-dimensional cell position with coordinates\n// (x, y) to a one-dimensional distance (d) along a discrete Hilbert\n// curve. The curve is constructed by dividing a square into n X n\n// cells.\n//\n// The cell count n must be a power of 2, and the coordinates x and y\n// must range from (0, 0) representing the cell at the lower left-hand\n// corner of the square, to (n-1, n-1) representing the cell at the\n// upper right-hand corner of the square.\n//\n// The return value d is a number in the range [0, n^2-1].\n//\n// The complementary function DToXY performs the inverse mapping from\n// one-dimensional distance (d) back to two-dimensional position (x, y).\nfunc XYToD(n, x, y int) (d int) {\n\tfor s:=n/2; s>0; s/=2 {\n\t\tvar rx, ry int\n\t\tif x&s > 0 {\n\t\t\trx = 1\n\t\t}\n\t\tif y&s > 0 {\n\t\t\try = 1\n\t\t}\n\t\td += s * s * ((3 * rx) ^ ry)\n\t\trot(s, rx, ry, &x, &y)\n\t}\n\treturn\n}", "id": 22606, "concepts": ["integer division", "bitwise operations", "Hilbert curve", "one-dimensional to two-dimensional mapping"], "_raw_llm_output": "integer division, bitwise operations, Hilbert curve, one-dimensional to two-dimensional mapping"}
{"seed": "// \u722c\u697c\u68af\uff0c\u4e00\u6b21\u53ef\u4ee5\u722c1\u7ea7\u62162\u7ea7\uff0c\u95ee\u722c\u5230\u7b2cn\u7ea7\u6709\u591a\u5c11\u79cd\u65b9\u6cd5\nfunc stair(n int) int {\n\t// dp[n] = dp[n-1] + dp[n-2]\n\t// \u6700\u5c0f\u95ee\u9898 \u4e0d\u80fd\u518d\u5206\u89e3\n\tif n == 1 {\n\t\treturn 1\n\t}\n\tif n == 2 {\n\t\treturn 2\n\t}\n\n\treturn stair(n-1) + stair(n-2)\n}", "id": 22609, "concepts": ["recursion", "base case handling", "mathematical series"], "_raw_llm_output": "recursion, base case handling, mathematical series"}
{"seed": "// Bgsound represents the HTML element 'bgsound'.\n// For more information visit https://www.w3schools.com/tags/tag_bgsound.asp.\nfunc Bgsound(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"bgsound\", Attributes: attrs, Children: children}\n}", "id": 22626, "concepts": ["HTML generation", "HTML tree", "HTML element definition"], "_raw_llm_output": "HTML generation, HTML tree, HTML element definition"}
{"seed": "// NewGetStoresParamsWithContext creates a new GetStoresParams object\n// with the default values initialized, and the ability to set a context for a request\nfunc NewGetStoresParamsWithContext(ctx context.Context) *GetStoresParams {\n\tvar ()\n\treturn &GetStoresParams{\n\n\t\tContext: ctx,\n\t}\n}", "id": 22631, "concepts": ["context package usage", "function definition", "context.Context", "method definition"], "_raw_llm_output": "context package usage, function definition, context.Context, method definition"}
{"seed": "// NewRenewOrganizationLicensesSeatsParamsWithHTTPClient creates a new RenewOrganizationLicensesSeatsParams object\n// with the default values initialized, and the ability to set a custom HTTPClient for a request\nfunc NewRenewOrganizationLicensesSeatsParamsWithHTTPClient(client *http.Client) *RenewOrganizationLicensesSeatsParams {\n\tvar ()\n\treturn &RenewOrganizationLicensesSeatsParams{\n\t\tHTTPClient: client,\n\t}\n}", "id": 22647, "concepts": ["http.Client usage", "function definition", "function parameter", "function return value"], "_raw_llm_output": "http.Client usage, function definition, function parameter, function return value"}
{"seed": "// NewEntryUnpacker creates a new EntryUnpacker with the given parameters, metadata decrypter, and\n// storage.DocumentStorerLoader.\nfunc NewEntryUnpacker(\n\tparams *print.Parameters,\n\tmetadataDec enc.MetadataDecrypter,\n\tdocSL storage.DocumentSLD,\n) EntryUnpacker {\n\tpageL := page.NewStorerLoader(docSL)\n\treturn &entryUnpacker{\n\t\tparams:      params,\n\t\tmetadataDec: metadataDec,\n\t\tscanner:     print.NewScanner(params, pageL),\n\t}\n}", "id": 22653, "concepts": ["enc.MetadataDecrypter", "page.NewStorerLoader", "print.NewScanner", "print.Parameters", "storage.DocumentSLD", "*entryUnpacker"], "_raw_llm_output": "enc.MetadataDecrypter, page.NewStorerLoader, print.NewScanner, print.Parameters, storage.DocumentSLD, *entryUnpacker"}
{"seed": "// WithQueues allows to override queues to run.\nfunc WithQueues(queues []string) Option {\n\treturn func(opts *Options) {\n\t\topts.Queues = queues\n\t}\n}", "id": 22659, "concepts": ["function definition", "function composition", "function options", "function composition"], "_raw_llm_output": "function definition, function composition, function options, function composition"}
{"seed": "// Track represents the HTML void element 'track'.\n// For more information visit https://www.w3schools.com/tags/tag_track.asp.\nfunc Track(attrs []htmlgo.Attribute) HTML {\n\treturn &htmlgo.Tree{Tag: \"track\", Attributes: attrs, SelfClosing: true}\n}", "id": 22660, "concepts": ["HTML generation", "HTML tree representation", "HTML void element", "HTML attribute"], "_raw_llm_output": "HTML generation, HTML tree representation, HTML void element, HTML attribute"}
{"seed": "// ThemeColor returns the color for the address bar or/and the browser color.\n// https://developer.mozilla.org/en-US/docs/Web/Manifest#theme_color\n// https://developers.google.com/web/tools/lighthouse/audits/address-bar\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta/name/theme-color\nfunc ThemeColor(theme, colorScheme string) string {\n\tswitch theme {\n\tcase \"dark_serif\", \"dark_sans_serif\":\n\t\treturn \"#222\"\n\tcase \"system_serif\", \"system_sans_serif\":\n\t\tif colorScheme == \"dark\" {\n\t\t\treturn \"#222\"\n\t\t}\n\n\t\treturn \"#fff\"\n\tdefault:\n\t\treturn \"#fff\"\n\t}\n}", "id": 22662, "concepts": ["switch statement", "string comparison", "string manipulation", "string formatting"], "_raw_llm_output": "switch statement, string comparison, string manipulation, string formatting"}
{"seed": "// ColorSamplingPointsForStillColorsVideo returns a map of points that are considered to be\n// interesting in the rendering of the still-colors-*.mp4 test videos. The key in the map is\n// a name for the corresponding point. There are two categories of points:\n//\n// - Outer corners: the four absolute corners of the video offset by 1 to ignore acceptable\n//   color blending artifacts on the edges. However, the outer bottom-right is not offset\n//   because we never expect blending artifacts there.\n//\n// - Inner corners: 4 stencils (one for each corner of the video). Each stencil is composed\n//   of 4 sampling points arranged as a square. The expectation is that for each stencil, 3\n//   of its points fall on the interior border of the test video while the remaining point\n//   falls inside one of the color rectangles. This helps us detect undesired\n//   stretching/shifting/rotation/mirroring. The naming convention for each point of a\n//   stencil is as follows:\n//\n//     inner_Y_X_00: the corner of the stencil closest to the Y-X corner of the video.\n//     inner_Y_X_01: the corner of the stencil that's in the interior X border of the video.\n//     inner_Y_X_10: the corner of the stencil that's in the interior Y border of the video.\n//     inner_Y_X_11: the only corner of the stencil that's not on the border strip.\n//\n//   For example, the top-right corner of the test video looks like this:\n//\n//     MMMMMMMMMMMMMMMM\n//     MMMMMMMMMM2MMM0M\n//     MMMMMMMMMMMMMMMM\n//               3  M1M\n//                  MMM\n//\n//   Where 'M' is the magenta interior border. So the names of each of the points 0, 1, 2, 3\n//   are:\n//\n//     0: inner_top_right_00\n//     1: inner_top_right_01\n//     2: inner_top_right_10\n//     3: inner_top_right_11\nfunc ColorSamplingPointsForStillColorsVideo(videoW, videoH int) map[string]image.Point {\n\touterCorners := map[string]image.Point{\n\t\t\"outer_top_left\":     {1, 1},\n\t\t\"outer_top_right\":    {(videoW - 1) - 1, 1},\n\t\t\"outer_bottom_right\": {videoW - 1, videoH - 1},\n\t\t\"outer_bottom_left\":  {1, (videoH - 1) - 1},\n\t}\n\tedgeOffset := 5\n\tstencilW := 5\n\tinnerCorners := map[string]image.Point{\n\t\t\"inner_top_left_00\":     {edgeOffset, edgeOffset},\n\t\t\"inner_top_left_01\":     {edgeOffset, edgeOffset + stencilW},\n\t\t\"inner_top_left_10\":     {edgeOffset + stencilW, edgeOffset},\n\t\t\"inner_top_left_11\":     {edgeOffset + stencilW, edgeOffset + stencilW},\n\t\t\"inner_top_right_00\":    {(videoW - 1) - edgeOffset, edgeOffset},\n\t\t\"inner_top_right_01\":    {(videoW - 1) - edgeOffset, edgeOffset + stencilW},\n\t\t\"inner_top_right_10\":    {(videoW - 1) - edgeOffset - stencilW, edgeOffset},\n\t\t\"inner_top_right_11\":    {(videoW - 1) - edgeOffset - stencilW, edgeOffset + stencilW},\n\t\t\"inner_bottom_right_00\": {(videoW - 1) - edgeOffset, (videoH - 1) - edgeOffset},\n\t\t\"inner_bottom_right_01\": {(videoW - 1) - edgeOffset, (videoH - 1) - edgeOffset - stencilW},\n\t\t\"inner_bottom_right_10\": {(videoW - 1) - edgeOffset - stencilW, (videoH - 1) - edgeOffset},\n\t\t\"inner_bottom_right_11\": {(videoW - 1) - edgeOffset - stencilW, (videoH - 1) - edgeOffset - stencilW},\n\t\t\"inner_bottom_left_00\":  {edgeOffset, (videoH - 1) - edgeOffset},\n\t\t\"inner_bottom_left_01\":  {edgeOffset, (videoH - 1) - edgeOffset - stencilW},\n\t\t\"inner_bottom_left_10\":  {edgeOffset + stencilW, (videoH - 1) - edgeOffset},\n\t\t\"inner_bottom_left_11\":  {edgeOffset + stencilW, (videoH - 1) - edgeOffset - stencilW},\n\t}\n\tsamples := map[string]image.Point{}\n\tfor k, v := range innerCorners {\n\t\tsamples[k] = v\n\t}\n\tfor k, v := range outerCorners {\n\t\tsamples[k] = v\n\t}\n\treturn samples\n}", "id": 22680, "concepts": ["map", "map iteration", "map key access", "map value access", "map key creation", "map value creation", "map key deletion", "map value deletion", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map value existence check", "map key existence check", "map"], "_raw_llm_output": "map, map iteration, map key access, map value access, map key creation, map value creation, map key deletion, map value deletion, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map value existence check, map key existence check, map"}
{"seed": "// SortByDistance takes a KeySpace, a center Key, and a list of Keys toSort.\n// It returns a new list, where the Keys toSort have been sorted by their\n// distance to the center Key.\nfunc SortByDistance(sp KeySpace, center Key, toSort []Key) []Key {\n\ttoSortCopy := make([]Key, len(toSort))\n\tcopy(toSortCopy, toSort)\n\tbdtc := &byDistanceToCenter{\n\t\tCenter: center,\n\t\tKeys:   toSortCopy, // copy\n\t}\n\tsort.Sort(bdtc)\n\treturn bdtc.Keys\n}", "id": 22686, "concepts": ["sort.Sort", "sort.Interface", "sort.Reverse", "sort.Float64Slice", "sort.IntSlice", "sort.StringSlice"], "_raw_llm_output": "sort.Sort, sort.Interface, sort.Reverse, sort.Float64Slice, sort.IntSlice, sort.StringSlice"}
{"seed": "// Fieldset represents the HTML element 'fieldset'.\n// For more information visit https://www.w3schools.com/tags/tag_fieldset.asp.\nfunc Fieldset(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"fieldset\", Attributes: attrs, Children: children}\n}", "id": 22696, "concepts": ["HTML generation", "HTML tree traversal", "HTML element definition"], "_raw_llm_output": "HTML generation, HTML tree traversal, HTML element definition"}
{"seed": "// GzipAssetInfo loads and returns the asset info for the given name.\n// It returns an error if the asset could not be found or could not be loaded.\nfunc GzipAssetInfo(name string) (os.FileInfo, error) {\n\tcannonicalName := strings.Replace(name, \"\\\\\", \"/\", -1)\n\tif f, ok := _gzipbindata[cannonicalName]; ok {\n\t\ta, err := f()\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"GzipAssetInfo %s can't read by error: %v\", name, err)\n\t\t}\n\t\treturn a.info, nil\n\t}\n\treturn nil, &os.PathError{Op: \"open\", Path: name, Err: os.ErrNotExist}\n}", "id": 22705, "concepts": ["string manipulation", "map lookup", "error handling (idiomatic `if err != nil`", "`errors.Is`", "`errors.As`)", "standard library usage (like `fmt`", "`net/http`", "`encoding/json`", "`os`", "`sync`", "`errors`)", "concurrency patterns (goroutines", "channels", "mutexes)", "error handling (idiomatic `if err != nil`", "`errors.Is`", "`errors.As`)", "types (structs", "interfaces", "slices", "maps)", "common Go idioms (like `defer`)", "pointers", "and control flow."], "_raw_llm_output": "string manipulation, map lookup, error handling (idiomatic `if err != nil`, `errors.Is`, `errors.As`), standard library usage (like `fmt`, `net/http`, `encoding/json`, `os`, `sync`, `errors`), concurrency patterns (goroutines, channels, mutexes), error handling (idiomatic `if err != nil`, `errors.Is`, `errors.As`), types (structs, interfaces, slices, maps), common Go idioms (like `defer`), pointers, and control flow."}
{"seed": "/*\nIfWithShortStatement - Like for, the if statement can start with a short statement to execute before the condition.\nVariables declared by the statement are only in scope until the end of the if.\n\n(Try using v in the last return statement.)\n*/\nfunc IfWithShortStatement(x, n, lim float64) float64 {\n\tfmt.Printf(\"\\n****Running flowcontrol.IfWithShortStatement(), if with short statement \")\n\tif v := math.Pow(x, n); v < lim {\n\t\treturn v\n\t}\n\t// can't use v here\n\treturn lim\n}", "id": 22731, "concepts": ["short statement", "scope", "math.Pow"], "_raw_llm_output": "short statement, scope, math.Pow"}
{"seed": "// LessThan creates an Constraint which an instance will be\n// declared as valid if its value is less than refValue.\nfunc LessThan[\n\tValueT typecons.Ordered,\n](refValue ValueT) OrderedConstraint[ValueT] {\n\treturn &relOpConstraint[ValueT]{ref: refValue, op: relOpLess}\n}", "id": 22742, "concepts": ["type constraint", "type constraint implementation", "type constraint usage"], "_raw_llm_output": "type constraint, type constraint implementation, type constraint usage"}
{"seed": "// WithTclk sets the clock period for the ADC.\n//\n// Note that this is the half-cycle period.\nfunc WithTclk(tclk time.Duration) Option {\n\treturn func(a *ADC0832) {\n\t\ta.s.Tclk = tclk\n\t}\n}", "id": 22743, "concepts": ["time.Duration", "Option pattern", "function definition", "function composition"], "_raw_llm_output": "time.Duration, Option pattern, function definition, function composition"}
{"seed": "// NewGetConfigsClusterParamsWithHTTPClient creates a new GetConfigsClusterParams object\n// with the default values initialized, and the ability to set a custom HTTPClient for a request\nfunc NewGetConfigsClusterParamsWithHTTPClient(client *http.Client) *GetConfigsClusterParams {\n\tvar ()\n\treturn &GetConfigsClusterParams{\n\t\tHTTPClient: client,\n\t}\n}", "id": 22749, "concepts": ["http.Client usage", "function definition", "function parameters"], "_raw_llm_output": "http.Client usage, function definition, function parameters"}
{"seed": "// NewDeleteFreeIpaByEnvironmentV1ParamsWithContext creates a new DeleteFreeIpaByEnvironmentV1Params object\n// with the default values initialized, and the ability to set a context for a request\nfunc NewDeleteFreeIpaByEnvironmentV1ParamsWithContext(ctx context.Context) *DeleteFreeIpaByEnvironmentV1Params {\n\tvar (\n\t\tforcedDefault = bool(false)\n\t)\n\treturn &DeleteFreeIpaByEnvironmentV1Params{\n\t\tForced: &forcedDefault,\n\n\t\tContext: ctx,\n\t}\n}", "id": 22756, "concepts": ["context package usage", "function definition", "pointer handling"], "_raw_llm_output": "context package usage, function definition, pointer handling"}
{"seed": "// PossiblePolicyResourceStateValues returns an array of possible values for the PolicyResourceState const type.\nfunc PossiblePolicyResourceStateValues() []PolicyResourceState {\n\treturn []PolicyResourceState{PolicyResourceStateCreating, PolicyResourceStateDeleting, PolicyResourceStateDisabled, PolicyResourceStateDisabling, PolicyResourceStateEnabled, PolicyResourceStateEnabling}\n}", "id": 22758, "concepts": ["const", "array", "type conversion"], "_raw_llm_output": "const, array, type conversion"}
{"seed": "// IsStruct reports whether value is a struct type\nfunc IsStruct(value interface{}) bool {\n\treturn kindOf(value) == reflect.Struct\n}", "id": 22769, "concepts": ["reflection", "type checking", "struct handling"], "_raw_llm_output": "reflection, type checking, struct handling"}
{"seed": "// NewSecurityMonitoringSignalStateFromValue returns a pointer to a valid SecurityMonitoringSignalState\n// for the value passed as argument, or an error if the value passed is not allowed by the enum.\nfunc NewSecurityMonitoringSignalStateFromValue(v string) (*SecurityMonitoringSignalState, error) {\n\tev := SecurityMonitoringSignalState(v)\n\tif ev.IsValid() {\n\t\treturn &ev, nil\n\t}\n\treturn nil, fmt.Errorf(\"invalid value '%v' for SecurityMonitoringSignalState: valid values are %v\", v, allowedSecurityMonitoringSignalStateEnumValues)\n}", "id": 22777, "concepts": ["enum", "pointer", "error handling"], "_raw_llm_output": "enum, pointer, error handling"}
{"seed": "// NewSlice creates a Slice with 0 elements.\n// Can use \"EnsureCapacity\" to initialize with a given capacity.\nfunc NewSlice() Slice {\n\torig := []otlpcommon.AnyValue(nil)\n\treturn Slice(internal.NewSlice(&orig))\n}", "id": 22789, "concepts": ["slice creation", "slice capacity", "internal package usage"], "_raw_llm_output": "slice creation, slice capacity, internal package usage"}
{"seed": "// PhoneHasPrefix applies the HasPrefix predicate on the \"phone\" field.\nfunc PhoneHasPrefix(v string) predicate.User {\n\treturn predicate.User(sql.FieldHasPrefix(FieldPhone, v))\n}", "id": 22794, "concepts": ["predicate.User", "sql.FieldHasPrefix"], "_raw_llm_output": "predicate.User, sql.FieldHasPrefix"}
{"seed": "// Determine if it's a process dir by checking if the dirname is an int\nfunc isProc(path string) bool {\n\tbasename := filepath.Base(path)\n\t_, err := strconv.Atoi(basename)\n\tif err != nil {\n\t\treturn false\n\t}\n\treturn true\n}", "id": 22810, "concepts": ["string manipulation", "strconv package usage", "filepath package usage"], "_raw_llm_output": "string manipulation, strconv package usage, filepath package usage"}
{"seed": "// NewRecovery creates a Recovery instance.\nfunc NewRecovery() *Recovery {\n\treturn &Recovery{}\n}", "id": 22815, "concepts": ["struct definition", "function definition", "basic syntax"], "_raw_llm_output": "struct definition, function definition, basic syntax"}
{"seed": "// NewNoneOptional creates a new instance of Optional[T] without any value set.\nfunc NewNoneOptional[T any]() Optional[T] {\n\treturn Optional[T]{}\n}", "id": 22827, "concepts": ["type aliasing", "empty struct", "type definition"], "_raw_llm_output": "type aliasing, empty struct, type definition"}
{"seed": "// Position is used to set where in window the resulting value should be inserted.\n// Valid values: start/center/end\n// Default value: center\nfunc Position(p string) ConfigFunc {\n\treturn func(c *Config) {\n\t\tc.Position = p\n\t}\n}", "id": 22836, "concepts": ["function composition", "function definition", "function composition"], "_raw_llm_output": "function composition, function definition, function composition"}
{"seed": "// UpdateSlicePtr updates an entry at index in the parent, which must be a slice ptr, with the given value.\nfunc UpdateSlicePtr(parentSlice interface{}, index int, value interface{}) error {\n\tscope.Debugf(\"UpdateSlicePtr parent=\\n%s\\n, index=%d, value=\\n%v\", pretty.Sprint(parentSlice), index, value)\n\tpv := reflect.ValueOf(parentSlice)\n\tv := reflect.ValueOf(value)\n\n\tif !IsSliceInterfacePtr(parentSlice) {\n\t\treturn fmt.Errorf(\"updateSlicePtr parent type is %T, must be *[]interface{}\", parentSlice)\n\t}\n\n\tpvv := pv.Elem()\n\tif pvv.Kind() == reflect.Interface {\n\t\tpv.Elem().Elem().Index(index).Set(v)\n\t\treturn nil\n\t}\n\tpv.Elem().Index(index).Set(v)\n\n\treturn nil\n}", "id": 22837, "concepts": ["reflect package usage", "interface conversion", "slice indexing", "pointer dereferencing"], "_raw_llm_output": "reflect package usage, interface conversion, slice indexing, pointer dereferencing"}
{"seed": "// UnstructuredsToObjMetas returns a slice of ObjMetadata translated from\n// a slice of Unstructured objects.\nfunc UnstructuredsToObjMetas(objs []*unstructured.Unstructured) []ObjMetadata {\n\tobjMetas := make([]ObjMetadata, 0, len(objs))\n\tfor _, obj := range objs {\n\t\tobjMetas = append(objMetas, ObjMetadata{\n\t\t\tName:      obj.GetName(),\n\t\t\tNamespace: obj.GetNamespace(),\n\t\t\tGroupKind: obj.GroupVersionKind().GroupKind(),\n\t\t})\n\t}\n\treturn objMetas\n}", "id": 22843, "concepts": ["slice iteration (range loop)", "map iteration (range loop)", "struct composition", "struct embedding", "interface conversion", "standard library usage"], "_raw_llm_output": "slice iteration (range loop), map iteration (range loop), struct composition, struct embedding, interface conversion, standard library usage"}
{"seed": "// SocialUserIDLT applies the LT predicate on the \"social_user_id\" field.\nfunc SocialUserIDLT(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.LT(s.C(FieldSocialUserID), v))\n\t})\n}", "id": 22849, "concepts": ["sql.Selector", "sql.LT", "sql.C", "sql.Where", "sql.Predicate"], "_raw_llm_output": "sql.Selector, sql.LT, sql.C, sql.Where, sql.Predicate"}
{"seed": "// NewNotebookNotebooksResponse instantiates a new NotebookNotebooksResponse object\n// This constructor will assign default values to properties that have it defined,\n// and makes sure properties required by API are set, but the set of arguments\n// will change when the set of required properties is changed\nfunc NewNotebookNotebooksResponse() *NotebookNotebooksResponse {\n\tthis := NotebookNotebooksResponse{}\n\treturn &this\n}", "id": 22860, "concepts": ["constructor", "struct definition", "struct initialization", "struct field declaration"], "_raw_llm_output": "constructor, struct definition, struct initialization, struct field declaration"}
{"seed": "// Clone the provided IP and return the copy\nfunc cloneIP(ip net.IP) net.IP {\n\tclone := make(net.IP, len(ip))\n\tcopy(clone, ip)\n\treturn clone\n}", "id": 22865, "concepts": ["net.IP", "make", "copy", "standard library usage"], "_raw_llm_output": "net.IP, make, copy, standard library usage"}
{"seed": "// AllowSUID allows set-user-identifier or set-group-identifier bits to take\n// effect.\nfunc AllowSUID() MountOption {\n\treturn func(conf *mountConfig) error {\n\t\tconf.options[\"suid\"] = \"\"\n\t\treturn nil\n\t}\n}", "id": 22871, "concepts": ["MountOption", "MountOption function definition", "MountOption function usage"], "_raw_llm_output": "MountOption, MountOption function definition, MountOption function usage"}
{"seed": "// DescriptionEQ applies the EQ predicate on the \"description\" field.\nfunc DescriptionEQ(v string) predicate.User {\n\treturn predicate.User(sql.FieldEQ(FieldDescription, v))\n}", "id": 22889, "concepts": ["predicate.User", "sql.FieldEQ", "sql.Field"], "_raw_llm_output": "predicate.User, sql.FieldEQ, sql.Field"}
{"seed": "// SocialEmailContainsFold applies the ContainsFold predicate on the \"social_email\" field.\nfunc SocialEmailContainsFold(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.ContainsFold(s.C(FieldSocialEmail), v))\n\t})\n}", "id": 22903, "concepts": ["sql.Selector", "sql.ContainsFold", "predicate.User", "function definition"], "_raw_llm_output": "sql.Selector, sql.ContainsFold, predicate.User, function definition"}
{"seed": "// NewAttributeValueNull creates a new AttributeValue with a null value.\nfunc NewAttributeValueNull() AttributeValue {\n\torig := &otlpcommon.AnyValue{}\n\treturn AttributeValue{orig: orig}\n}", "id": 22912, "concepts": ["struct definition", "pointer usage", "nil value handling"], "_raw_llm_output": "struct definition, pointer usage, nil value handling"}
{"seed": "// CheckAndUnSetReloadProcess unsets the reloadProcess flag.\n// Returns its previous value.\nfunc CheckAndUnSetReloadProcess() bool {\n\treloadMutex.Lock()\n\tdefer reloadMutex.Unlock()\n\tretval := reloadProcess\n\treloadProcess = false\n\treturn retval\n}", "id": 22919, "concepts": ["mutex", "boolean flag", "function definition"], "_raw_llm_output": "mutex, boolean flag, function definition"}
{"seed": "// NewCrossDeviceOnboarded creates a fixture that logs in to CrOS, pairs it with an Android device,\n// and ensures the features in the \"Connected devices\" section of OS Settings are ready to use (Smart Lock, Phone Hub, etc.).\n// Note that crossdevice fixtures inherit from crossdeviceAndroidSetup.\nfunc NewCrossDeviceOnboarded(opt FixtureOptions, fOpt chrome.OptionsCallback) testing.FixtureImpl {\n\treturn &crossdeviceFixture{\n\t\tfOpt:                fOpt,\n\t\tallFeatures:         opt.allFeatures,\n\t\tsaveScreenRecording: opt.saveScreenRecording,\n\t\tlockFixture:         opt.lockFixture,\n\t\tnoSignIn:            opt.noSignIn,\n\t}\n}", "id": 22921, "concepts": ["struct", "interface", "method definition", "anonymous struct", "method call", "method chaining", "method composition", "method overriding", "method delegation", "method composition", "method chaining", "method composition", "method overriding", "method delegation", "method composition", "method chaining", "method composition", "method overriding", "method delegation", "method composition", "method chaining", "method composition", "method overriding", "method delegation", "method composition", "method chaining", "method composition", "method overriding", "method delegation", "method composition", "method chaining", "method composition", "method overriding", "method delegation", "method composition", "method chaining", "method composition", "method overriding", "method delegation", "method composition", "method chaining", "method composition", "method overriding", "method delegation", "method composition", "method chaining", "method composition", "method overriding", "method delegation", "method composition", "method chaining", "method composition", "method overriding", "method delegation", "method composition", "method chaining", "method composition", "method overriding", "method delegation", "method composition", "method chaining", "method composition", "method overriding", "method delegation", "method composition", "method chaining", "method composition", "method overriding", "method delegation", "method composition", "method chaining", "method composition", "method overriding", "method delegation", "method composition", "method chaining", "method composition", "method overriding", "method delegation", "method composition", "method chaining"], "_raw_llm_output": "struct, interface, method definition, anonymous struct, method call, method chaining, method composition, method overriding, method delegation, method composition, method chaining, method composition, method overriding, method delegation, method composition, method chaining, method composition, method overriding, method delegation, method composition, method chaining, method composition, method overriding, method delegation, method composition, method chaining, method composition, method overriding, method delegation, method composition, method chaining, method composition, method overriding, method delegation, method composition, method chaining, method composition, method overriding, method delegation, method composition, method chaining, method composition, method overriding, method delegation, method composition, method chaining, method composition, method overriding, method delegation, method composition, method chaining, method composition, method overriding, method delegation, method composition, method chaining, method composition, method overriding, method delegation, method composition, method chaining, method composition, method overriding, method delegation, method composition, method chaining, method composition, method overriding, method delegation, method composition, method chaining, method composition, method overriding, method delegation, method composition, method chaining, method composition, method overriding, method delegation, method composition, method chaining"}
{"seed": "// fillFields loads field data from `jsonPath` to fill in\n// form data in `inputPath` and outputs as PDF in `outputPath`.\n// The output PDF form is flattened.\nfunc fillFields(inputPath, jsonPath, outputPath string) error {\n\tfdata, err := fjson.LoadFromJSONFile(jsonPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tf, err := os.Open(inputPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\n\tpdfReader, err := model.NewPdfReader(f)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// set custom font\n\tfieldAppearance := annotator.FieldAppearance{OnlyIfMissing: true, RegenerateTextFields: true}\n\n\t// set font using standard font\n\tdefaultFontReplacement, err := model.NewStandard14Font(model.HelveticaObliqueName)\n\n\t// set font using ttf font file\n\tfontReplacement, err := model.NewPdfFontFromTTFFile(\"./DoHyeon-Regular.ttf\")\n\n\t// use composite ttf font file\n\t// refer to `text/pdf_using_cjk_font.go` example file for more information\n\tcjkFont, err := model.NewCompositePdfFontFromTTFFile(\"./rounded-mplus-1p-regular.ttf\")\n\n\tif err != nil {\n\t\tlog.Fatalf(\"Error %s\", err)\n\t}\n\n\t// replace email field's font using `fontReplacement`\n\t// and set the other field's font using `defaultFontReplacement`\n\tstyle := fieldAppearance.Style()\n\tstyle.Fonts = &annotator.AppearanceFontStyle{\n\t\tFallback: &annotator.AppearanceFont{\n\t\t\tFont: defaultFontReplacement,\n\t\t\tName: defaultFontReplacement.FontDescriptor().FontName.String(),\n\t\t\tSize: 0,\n\t\t},\n\t\tFieldFallbacks: map[string]*annotator.AppearanceFont{\n\t\t\t\"email4\": {\n\t\t\t\tFont: fontReplacement,\n\t\t\t\tName: fontReplacement.FontDescriptor().FontName.String(),\n\t\t\t\tSize: 0,\n\t\t\t},\n\t\t\t\"address5[addr_line1]\": {\n\t\t\t\tFont: cjkFont,\n\t\t\t\tName: cjkFont.FontDescriptor().FontName.String(),\n\t\t\t\tSize: 0,\n\t\t\t},\n\t\t\t\"address5[addr_line2]\": {\n\t\t\t\tFont: cjkFont,\n\t\t\t\tName: cjkFont.FontDescriptor().FontName.String(),\n\t\t\t\tSize: 0,\n\t\t\t},\n\t\t\t\"address5[city]\": {\n\t\t\t\tFont: cjkFont,\n\t\t\t\tName: cjkFont.FontDescriptor().FontName.String(),\n\t\t\t\tSize: 0,\n\t\t\t},\n\t\t\t\"address5[state]\": {\n\t\t\t\tFont: cjkFont,\n\t\t\t\tName: cjkFont.FontDescriptor().FontName.String(),\n\t\t\t\tSize: 0,\n\t\t\t},\n\t\t\t\"address5[postal]\": {\n\t\t\t\tFont: cjkFont,\n\t\t\t\tName: cjkFont.FontDescriptor().FontName.String(),\n\t\t\t\tSize: 0,\n\t\t\t},\n\t\t},\n\t\tForceReplace: true,\n\t}\n\n\tfieldAppearance.SetStyle(style)\n\n\t// Populate the form data.\n\terr = pdfReader.AcroForm.FillWithAppearance(fdata, fieldAppearance)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Flatten form.\n\terr = pdfReader.FlattenFields(true, fieldAppearance)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// The document AcroForm field is no longer needed.\n\topt := &model.ReaderToWriterOpts{\n\t\tSkipAcroForm: true,\n\t}\n\n\t// Generate a PdfWriter instance from existing PdfReader.\n\tpdfWriter, err := pdfReader.ToWriter(opt)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Subset the composite font file to reduce pdf file size.\n\t// Refer to `text/pdf_using_cjk_font.go` example file for more information\n\tcjkFont.SubsetRegistered()\n\n\t// Write to file.\n\terr = pdfWriter.WriteToFile(outputPath)\n\treturn err\n}", "id": 22925, "concepts": ["PDF manipulation", "PDF form manipulation", "PDF font manipulation", "PDF reader", "PDF writer", "PDF reader/writer", "PDF reader/writer options", "PDF reader/writer options", "PDF reader/writer options", "PDF reader/writer options", "PDF reader/writer options", "PDF reader/writer options", "PDF reader/writer options", "PDF reader/writer options", "PDF reader/writer options", "PDF reader/writer options", "PDF reader/writer options", "PDF reader/writer options", "PDF reader/writer options", "PDF reader/writer options", "PDF reader/writer options", "PDF reader/writer options", "PDF reader/writer options", "PDF reader/writer options", "PDF reader/writer options", "PDF reader/writer options", "PDF reader/writer options", "PDF reader/writer options", "PDF reader/writer options", "PDF reader/writer options", "PDF reader/writer options", "PDF reader/writer options", "PDF reader/writer options", "PDF reader/writer options", "PDF reader/writer options", "PDF reader/writer options", "PDF reader/writer options", "PDF reader/writer options", "PDF reader/writer options", "PDF reader/writer options", "PDF reader/writer options", "PDF reader/writer options", "PDF reader/writer options", "PDF reader/writer options", "PDF reader/writer options"], "_raw_llm_output": "PDF manipulation, PDF form manipulation, PDF font manipulation, PDF reader, PDF writer, PDF reader/writer, PDF reader/writer options, PDF reader/writer options, PDF reader/writer options, PDF reader/writer options, PDF reader/writer options, PDF reader/writer options, PDF reader/writer options, PDF reader/writer options, PDF reader/writer options, PDF reader/writer options, PDF reader/writer options, PDF reader/writer options, PDF reader/writer options, PDF reader/writer options, PDF reader/writer options, PDF reader/writer options, PDF reader/writer options, PDF reader/writer options, PDF reader/writer options, PDF reader/writer options, PDF reader/writer options, PDF reader/writer options, PDF reader/writer options, PDF reader/writer options, PDF reader/writer options, PDF reader/writer options, PDF reader/writer options, PDF reader/writer options, PDF reader/writer options, PDF reader/writer options, PDF reader/writer options, PDF reader/writer options, PDF reader/writer options, PDF reader/writer options, PDF reader/writer options, PDF reader/writer options, PDF reader/writer options, PDF reader/writer options, PDF reader/writer options"}
{"seed": "// NewAlertGetMonitorGroupAlertsParams creates a new AlertGetMonitorGroupAlertsParams object\n// with the default values initialized.\nfunc NewAlertGetMonitorGroupAlertsParams() *AlertGetMonitorGroupAlertsParams {\n\tvar (\n\t\tincludeRemindersDefault = bool(false)\n\t\tpresetPeriodDefault     = string(\"Last24Hours\")\n\t\tsortingDefault          = string(\"Descending\")\n\t\ttakeDefault             = int32(100)\n\t)\n\treturn &AlertGetMonitorGroupAlertsParams{\n\t\tIncludeReminders: &includeRemindersDefault,\n\t\tPresetPeriod:     &presetPeriodDefault,\n\t\tSorting:          &sortingDefault,\n\t\tTake:             &takeDefault,\n\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 22930, "concepts": ["struct initialization", "pointer usage", "default values", "method definition"], "_raw_llm_output": "struct initialization, pointer usage, default values, method definition"}
{"seed": "// hasAngularDependency returns true if the given rule depends on a Angular\n// build rule.\nfunc hasAngularDependency(r *build.Rule) bool {\n\te := r.Attr(\"deps\")\n\tfor _, li := range edit.AllLists(e) {\n\t\tfor _, elem := range li.List {\n\t\t\tstr, ok := elem.(*build.StringExpr)\n\t\t\tif ok && strings.HasPrefix(str.Value, \"//third_party/javascript/angular2\") {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}", "id": 22947, "concepts": ["build.Rule", "build.StringExpr", "edit.AllLists", "string manipulation"], "_raw_llm_output": "build.Rule, build.StringExpr, edit.AllLists, string manipulation"}
{"seed": "// isUppercase returns true if input's ASCII-Hex code is\r\n// between 0x41 \"A\" and 0x5A \"Z\" (inclusive)\r\n// Params:\r\n//      char: byte char to be evaluated\r\n//\r\n// Return: true if char is uppercase and false if not\r\nfunc isUppercase(char byte) bool {\r\n\treturn ((0x41 <= char) && (char <= 0x5A))\r\n}", "id": 22987, "concepts": ["byte handling", "ASCII-Hex code", "character comparison"], "_raw_llm_output": "byte handling, ASCII-Hex code, character comparison"}
{"seed": "// NewDocumentIdentifier creates a new Document from ssm.DocumentIdentifier.\nfunc NewDocumentIdentifier(ssmDocument *ssm.DocumentIdentifier) *DocumentIdentifier {\n\treturn &DocumentIdentifier{\n\t\tName:            aws.StringValue(ssmDocument.Name),\n\t\tOwner:           aws.StringValue(ssmDocument.Owner),\n\t\tDocumentVersion: aws.StringValue(ssmDocument.DocumentVersion),\n\t\tDocumentFormat:  aws.StringValue(ssmDocument.DocumentFormat),\n\t\tDocumentType:    aws.StringValue(ssmDocument.DocumentType),\n\t\tSchemaVersion:   aws.StringValue(ssmDocument.SchemaVersion),\n\t\tTargetType:      aws.StringValue(ssmDocument.TargetType),\n\t}\n}", "id": 22994, "concepts": ["struct definition", "struct field access", "pointer usage"], "_raw_llm_output": "struct definition, struct field access, pointer usage"}
{"seed": "// ParseHex parses a 16 digit HEX string and returns the 64 bit unsigned number.\nfunc ParseHex(s string) uint64 {\n\tb := StringToNTBytes(s)\n\tp := unsafe.Pointer(&b[0]) // #nosec\n\treturn uint64(C.parse_variantkey_hex((*C.char)(p)))\n}", "id": 22999, "concepts": ["unsafe package usage", "string to byte conversion", "pointer arithmetic", "CGO usage"], "_raw_llm_output": "unsafe package usage, string to byte conversion, pointer arithmetic, CGO usage"}
{"seed": "// NewTHSRAPIDailyTrainInfo21233Status299 creates a THSRAPIDailyTrainInfo21233Status299 with default headers values\nfunc NewTHSRAPIDailyTrainInfo21233Status299() *THSRAPIDailyTrainInfo21233Status299 {\n\treturn &THSRAPIDailyTrainInfo21233Status299{}\n}", "id": 23004, "concepts": ["struct definition", "struct initialization", "struct field access"], "_raw_llm_output": "struct definition, struct initialization, struct field access"}
{"seed": "// ParseListSnapshotsResponse parses an HTTP response from a ListSnapshotsWithResponse call\nfunc ParseListSnapshotsResponse(rsp *http.Response) (*ListSnapshotsResponse, error) {\n\tbodyBytes, err := ioutil.ReadAll(rsp.Body)\n\tdefer rsp.Body.Close()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse := &ListSnapshotsResponse{\n\t\tBody:         bodyBytes,\n\t\tHTTPResponse: rsp,\n\t}\n\n\tswitch {\n\tcase strings.Contains(rsp.Header.Get(\"Content-Type\"), \"json\") && rsp.StatusCode == 200:\n\t\tvar dest struct {\n\t\t\tSnapshots *[]Snapshot `json:\"snapshots,omitempty\"`\n\t\t}\n\t\tif err := json.Unmarshal(bodyBytes, &dest); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresponse.JSON200 = &dest\n\n\t}\n\n\treturn response, nil\n}", "id": 23014, "concepts": ["HTTP response handling", "JSON parsing", "error handling"], "_raw_llm_output": "HTTP response handling, JSON parsing, error handling"}
{"seed": "// FindExchangeCurrency retrieves a single record by ID with an executor.\n// If selectCols is empty Find will return all columns.\nfunc FindExchangeCurrency(exec boil.Executor, iD int, selectCols ...string) (*ExchangeCurrency, error) {\n\texchangeCurrencyObj := &ExchangeCurrency{}\n\n\tsel := \"*\"\n\tif len(selectCols) > 0 {\n\t\tsel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), \",\")\n\t}\n\tquery := fmt.Sprintf(\n\t\t\"select %s from \\\"exchange_currency\\\" where \\\"id\\\"=$1\", sel,\n\t)\n\n\tq := queries.Raw(query, iD)\n\n\terr := q.Bind(nil, exec, exchangeCurrencyObj)\n\tif err != nil {\n\t\tif errors.Cause(err) == sql.ErrNoRows {\n\t\t\treturn nil, sql.ErrNoRows\n\t\t}\n\t\treturn nil, errors.Wrap(err, \"models: unable to select from exchange_currency\")\n\t}\n\n\treturn exchangeCurrencyObj, nil\n}", "id": 23025, "concepts": ["boil package usage", "sql package usage", "sql.ErrNoRows", "error wrapping"], "_raw_llm_output": "boil package usage, sql package usage, sql.ErrNoRows, error wrapping"}
{"seed": "// NewAtomicSwapClaimFulfillment creates an unsigned atomic swap fulfillment,\n// as to spend an output as a claim (meaning redeeming the money as the receiver).\n//\n// Returned fulfillment still has to be signed, as to add the signature,\n// with the parent transaction as the input as well as the matching private key.\n//\n// Note that this fulfillment will fail if the current time is\n// equal to or past the timestamp specified as time lock in the parent output.\nfunc NewAtomicSwapClaimFulfillment(pk PublicKey, secret AtomicSwapSecret) *AtomicSwapFulfillment {\n\treturn &AtomicSwapFulfillment{\n\t\tPublicKey: pk,\n\t\tSecret:    secret,\n\t}\n}", "id": 23031, "concepts": ["struct definition", "anonymous function", "pointer usage"], "_raw_llm_output": "struct definition, anonymous function, pointer usage"}
{"seed": "// NewStorageTargetsClient creates a new instance of StorageTargetsClient with the specified values.\n//   - subscriptionID - The ID of the target subscription.\n//   - credential - used to authorize requests. Usually a credential from azidentity.\n//   - options - pass nil to accept the default values.\nfunc NewStorageTargetsClient(subscriptionID string, credential azcore.TokenCredential, options *arm.ClientOptions) (*StorageTargetsClient, error) {\n\tcl, err := arm.NewClient(moduleName+\".StorageTargetsClient\", moduleVersion, credential, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tclient := &StorageTargetsClient{\n\t\tsubscriptionID: subscriptionID,\n\t\tinternal:       cl,\n\t}\n\treturn client, nil\n}", "id": 23032, "concepts": ["azcore.TokenCredential", "arm.NewClient", "anonymous function", "function definition", "struct definition", "standard library usage"], "_raw_llm_output": "azcore.TokenCredential, arm.NewClient, anonymous function, function definition, struct definition, standard library usage"}
{"seed": "// NextIndex sets ix to the lexicographically next value,\n// such that for each i>0, 0 <= ix[i] < lens.\nfunc NextIndex(ix []int, lens int) {\n\tfor j := len(ix) - 1; j >= 0; j-- {\n\t\tix[j]++\n\t\tif j == 0 || ix[j] < lens {\n\t\t\treturn\n\t\t}\n\t\tix[j] = 0\n\t}\n}", "id": 23040, "concepts": ["slice iteration (for loop)", "slice indexing", "slice length"], "_raw_llm_output": "slice iteration (for loop), slice indexing, slice length"}
{"seed": "// ParseListDNSZoneNameserversResponse parses an HTTP response from a ListDNSZoneNameserversWithResponse call\nfunc ParseListDNSZoneNameserversResponse(rsp *http.Response) (*ListDNSZoneNameserversResponse, error) {\n\tbodyBytes, err := ioutil.ReadAll(rsp.Body)\n\tdefer rsp.Body.Close()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse := &ListDNSZoneNameserversResponse{\n\t\tBody:         bodyBytes,\n\t\tHTTPResponse: rsp,\n\t}\n\n\tswitch {\n\tcase strings.Contains(rsp.Header.Get(\"Content-Type\"), \"json\") && rsp.StatusCode == 200:\n\t\tvar dest ScalewayDomainV2alpha2ListDNSZoneNameserversResponse\n\t\tif err := json.Unmarshal(bodyBytes, &dest); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresponse.JSON200 = &dest\n\n\t}\n\n\treturn response, nil\n}", "id": 23046, "concepts": ["HTTP response parsing", "JSON parsing", "HTTP response status code handling", "standard library usage"], "_raw_llm_output": "HTTP response parsing, JSON parsing, HTTP response status code handling, standard library usage"}
{"seed": "// internalKeyPath returns the relative internal derivation path /0/1/index.\nfunc internalKeyPath(index uint32) waddrmgr.DerivationPath {\n\treturn waddrmgr.DerivationPath{\n\t\tAccount: waddrmgr.DefaultAccountNum,\n\t\tBranch:  waddrmgr.InternalBranch,\n\t\tIndex:   index,\n\t}\n}", "id": 23050, "concepts": ["derivation path", "waddrmgr package usage"], "_raw_llm_output": "derivation path, waddrmgr package usage"}
{"seed": "// copyFilePermissions copies file ownership and permissions from \"src\" to \"dst\",\n// ignoring any error during the process.\nfunc copyFilePermissions(src, dst string) {\n\tvar (\n\t\tmode     os.FileMode = 0o600\n\t\tuid, gid int\n\t)\n\n\tfi, err := os.Stat(src)\n\tif err != nil {\n\t\treturn\n\t}\n\tif fi.Mode().IsRegular() {\n\t\tmode = fi.Mode()\n\t}\n\tif err := os.Chmod(dst, mode); err != nil {\n\t\treturn\n\t}\n\n\tuid = int(fi.Sys().(*syscall.Stat_t).Uid)\n\tgid = int(fi.Sys().(*syscall.Stat_t).Gid)\n\n\tif uid > 0 && gid > 0 {\n\t\t_ = os.Chown(dst, uid, gid)\n\t}\n}", "id": 23069, "concepts": ["os.Stat", "syscall.Stat_t", "syscall.Stat", "os.Chmod", "os.Chown", "syscall.Chown"], "_raw_llm_output": "os.Stat, syscall.Stat_t, syscall.Stat, os.Chmod, os.Chown, syscall.Chown"}
{"seed": "// newSettings creates a new Settings with default values.\n//\n// See also: webkit_settings_new at\n// http://webkitgtk.org/reference/webkit2gtk/stable/WebKitSettings.html#webkit-settings-new.\nfunc newSettings(settings *C.WebKitSettings) *Settings {\n\treturn &Settings{&glib.Object{glib.ToGObject(unsafe.Pointer(settings))}, settings}\n}", "id": 23086, "concepts": ["C.WebKitSettings", "C.GObject", "glib.ToGObject", "glib.Object", "basic function definition"], "_raw_llm_output": "C.WebKitSettings, C.GObject, glib.ToGObject, glib.Object, basic function definition"}
{"seed": "// Returns the passed in key as a null terminated byte array\n// if it is not already null terminated.\nfunc ensureNullTerminatedKey(key []byte) []byte {\n\tindex := bytes.Index(key, []byte{0})\n\n\t// Is there a null terminated character?\n\tif index < 0 {\n\n\t\t// Append one.\n\t\tkey = append(key, byte(0))\n\n\t}\n\n\treturn key\n}", "id": 23097, "concepts": ["byte array handling", "byte array indexing", "byte array appending", "byte array comparison"], "_raw_llm_output": "byte array handling, byte array indexing, byte array appending, byte array comparison"}
{"seed": "// MethodHandler adds the request method as a field to the context's logger\n// using fieldKey as field key.\nfunc MethodHandler(fieldKey string) func(next httpserver.Handler) httpserver.Handler {\n\treturn func(next httpserver.Handler) httpserver.Handler {\n\t\treturn httpserver.HandlerFunc(func(w http.ResponseWriter, r *http.Request) (int, error) {\n\t\t\tlog := zerolog.Ctx(r.Context())\n\t\t\tlog.UpdateContext(func(c zerolog.Context) zerolog.Context {\n\t\t\t\treturn c.Str(fieldKey, r.Method)\n\t\t\t})\n\t\t\treturn next.ServeHTTP(w, r)\n\t\t})\n\t}\n}", "id": 23107, "concepts": ["http.ResponseWriter", "http.Request", "http.Method", "zerolog.Context", "zerolog.UpdateContext"], "_raw_llm_output": "http.ResponseWriter, http.Request, http.Method, zerolog.Context, zerolog.UpdateContext"}
{"seed": "// Wrap a string at word boundaries with a maximum line length of width. Each\n// newline-delimited line in the text is trimmed of whitespace before being\n// added to the block for wrapping, which means strings can be declared in the\n// source code with whatever leading indentation looks best in context. For\n// example,\n//\n//\tWrap(`\n//\t    Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do\n//\t    eiusmod tempor incididunt ut labore et dolore magna aliqua. Dolor\n//\t    sed viverra ipsum nunc aliquet bibendum enim. In massa tempor nec\n//\t    feugiat.\n//\t`, 40)\n//\n// Produces the output string\n//\n//\tLorem ipsum dolor sit amet, consectetur\n//\tadipiscing elit, sed do eiusmod tempor\n//\tincididunt ut labore et dolore magna\n//\taliqua. Dolor sed viverra ipsum nunc\n//\taliquet bibendum enim. In massa tempor\n//\tnec feugiat.\nfunc Wrap(text string, width uint) string {\n\tvar b strings.Builder\n\ts := bufio.NewScanner(strings.NewReader(text))\n\tfor s.Scan() {\n\t\tline := strings.TrimSpace(s.Text())\n\t\tif line == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tb.WriteString(line + \" \")\n\t}\n\treturn wordwrap.WrapString(strings.TrimSpace(b.String()), width)\n}", "id": 23114, "concepts": ["string manipulation", "bufio package usage", "wordwrap package usage"], "_raw_llm_output": "string manipulation, bufio package usage, wordwrap package usage"}
{"seed": "// NewPacketCaptureList creates a new (zeroed) PacketCaptureList struct with the TypeMetadata initialised to the current\n// version.\nfunc NewPacketCaptureList() *PacketCaptureList {\n\treturn &PacketCaptureList{\n\t\tTypeMeta: metav1.TypeMeta{\n\t\t\tKind:       KindPacketCaptureList,\n\t\t\tAPIVersion: GroupVersionCurrent,\n\t\t},\n\t}\n}", "id": 23144, "concepts": ["struct definition", "struct initialisation", "struct field initialisation", "struct field access", "struct field type"], "_raw_llm_output": "struct definition, struct initialisation, struct field initialisation, struct field access, struct field type"}
{"seed": "// IsYes returns true if the response is some form of yes or y\nfunc IsYes(s string) bool {\n\toptions := []string{\"yes\", \"y\"}\n\tok, _ := validateOptions(strings.ToLower(s), options)\n\treturn ok\n}", "id": 23149, "concepts": ["string manipulation", "string comparison", "string validation"], "_raw_llm_output": "string manipulation, string comparison, string validation"}
{"seed": "// ParseAddRuleToSecurityGroupResponse parses an HTTP response from a AddRuleToSecurityGroupWithResponse call\nfunc ParseAddRuleToSecurityGroupResponse(rsp *http.Response) (*AddRuleToSecurityGroupResponse, error) {\n\tbodyBytes, err := ioutil.ReadAll(rsp.Body)\n\tdefer rsp.Body.Close()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse := &AddRuleToSecurityGroupResponse{\n\t\tBody:         bodyBytes,\n\t\tHTTPResponse: rsp,\n\t}\n\n\tswitch {\n\tcase strings.Contains(rsp.Header.Get(\"Content-Type\"), \"json\") && rsp.StatusCode == 200:\n\t\tvar dest Operation\n\t\tif err := json.Unmarshal(bodyBytes, &dest); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresponse.JSON200 = &dest\n\n\t}\n\n\treturn response, nil\n}", "id": 23154, "concepts": ["HTTP response handling", "JSON parsing", "JSON unmarshaling", "HTTP response parsing", "HTTP response handling"], "_raw_llm_output": "HTTP response handling, JSON parsing, JSON unmarshaling, HTTP response parsing, HTTP response handling"}
{"seed": "// ConnectionDirectionPInbound returns a pointer to ConnectionDirectionVInbound\nfunc ConnectionDirectionPInbound() *ConnectionDirection {\n\tv := ConnectionDirectionVInbound\n\treturn &v\n}", "id": 23155, "concepts": ["pointer", "pointer dereference", "pointer assignment"], "_raw_llm_output": "pointer, pointer dereference, pointer assignment"}
{"seed": "// Listing_ is a convenience wrapper for Listing without the attrs argument.\nfunc Listing_(children ...HTML) HTML {\n  return Listing(nil, children...)\n}", "id": 23156, "concepts": ["variadic function definition", "function composition"], "_raw_llm_output": "variadic function definition, function composition"}
{"seed": "// confirms returns the number of confirmations for a transaction in a block at\n// height txHeight (or -1 for an unconfirmed tx) given the chain height\n// curHeight.\nfunc confirms(txHeight, curHeight int32) int32 {\n\tswitch {\n\tcase txHeight == -1, txHeight > curHeight:\n\t\treturn 0\n\tdefault:\n\t\treturn curHeight - txHeight + 1\n\t}\n}", "id": 23157, "concepts": ["integer comparison", "switch statement", "basic function definition"], "_raw_llm_output": "integer comparison, switch statement, basic function definition"}
{"seed": "// WorkplaceNotNil applies the NotNil predicate on the \"workplace\" field.\nfunc WorkplaceNotNil() predicate.User {\n\treturn predicate.User(sql.FieldNotNull(FieldWorkplace))\n}", "id": 23163, "concepts": ["predicate", "sql.FieldNotNull", "sql.Field"], "_raw_llm_output": "predicate, sql.FieldNotNull, sql.Field"}
{"seed": "// WithHTTPClient configures a [Client] to perform HTTP requests with httpClient.\nfunc WithHTTPClient(httpClient *http.Client) ClientOption {\n\treturn func(client *Client) {\n\t\tclient.httpClient = httpClient\n\t}\n}", "id": 23179, "concepts": ["function composition", "function definition", "function option", "function option composition", "function option application"], "_raw_llm_output": "function composition, function definition, function option, function option composition, function option application"}
{"seed": "// NewScriptInfo constructs a new script in a given Isolate with the given runtime ID and code body\nfunc NewScriptInfo(iso *IsolateInfo, id int, code string, activeOrigin *Origin) *ScriptInfo {\n\treturn &ScriptInfo{\n\t\tIsolate:     iso,\n\t\tID:          id,\n\t\tCode:        code,\n\t\tCodeHash:    NewScriptHash(code),\n\t\tFirstOrigin: activeOrigin,\n\t}\n}", "id": 23182, "concepts": ["struct definition", "function definition", "pointer usage", "basic function definition"], "_raw_llm_output": "struct definition, function definition, pointer usage, basic function definition"}
{"seed": "// stateG1 is the state after reading a non-zero integer during a number,\n// such as after reading `1` or `100` but not `0`.\nfunc stateG1(s *scanner, c byte) int {\n\tif '0' <= c && c <= '9' {\n\t\ts.step = stateG1\n\t\treturn scanContinue\n\t}\n\treturn stateG0(s, c)\n}", "id": 23203, "concepts": ["state machine", "state transition", "state handling", "integer parsing"], "_raw_llm_output": "state machine, state transition, state handling, integer parsing"}
{"seed": "// NewDerivedLoggerWithField returns a logger that inherits all properties of the parent logger,\n// and add the given fields for each log entry.\n//\n// Panics if parent logger is nil.\nfunc NewDerivedLoggerWithField(parentLogger Logger, key string, value interface{}) Logger {\n\tif parentLogger == nil {\n\t\tpanic(\"parent logger should not be nil\")\n\t}\n\treturn parentLogger.WithField(key, value)\n}", "id": 23205, "concepts": ["interface", "method overriding", "method chaining", "method composition", "method delegation", "method composition", "method chaining", "method composition", "method chaining", "method composition", "method chaining", "method composition", "method chaining", "method composition", "method chaining", "method composition", "method chaining", "method composition", "method chaining", "method composition", "method chaining", "method composition", "method chaining", "method composition", "method chaining", "method composition", "method chaining", "method composition", "method chaining", "method composition", "method chaining", "method composition", "method chaining", "method composition", "method chaining", "method composition", "method chaining", "method composition", "method chaining", "method composition", "method chaining", "method composition", "method chaining", "method composition", "method chaining", "method composition", "method chaining", "method composition", "method chaining", "method composition", "method chaining", "method composition", "method chaining", "method composition", "method chaining", "method composition", "method chaining", "method composition", "method chaining", "method composition", "method chaining", "method composition", "method chaining", "method composition", "method chaining", "method composition", "method chaining", "method composition", "method chaining", "method composition", "method chaining", "method composition", "method chaining", "method composition", "method chaining", "method composition", "method chaining", "method composition", "method chaining", "method composition", "method chaining", "method composition", "method chaining", "method composition", "method chaining", ""], "_raw_llm_output": "interface, method overriding, method chaining, method composition, method delegation, method composition, method chaining, method composition, method chaining, method composition, method chaining, method composition, method chaining, method composition, method chaining, method composition, method chaining, method composition, method chaining, method composition, method chaining, method composition, method chaining, method composition, method chaining, method composition, method chaining, method composition, method chaining, method composition, method chaining, method composition, method chaining, method composition, method chaining, method composition, method chaining, method composition, method chaining, method composition, method chaining, method composition, method chaining, method composition, method chaining, method composition, method chaining, method composition, method chaining, method composition, method chaining, method composition, method chaining, method composition, method chaining, method composition, method chaining, method composition, method chaining, method composition, method chaining, method composition, method chaining, method composition, method chaining, method composition, method chaining, method composition, method chaining, method composition, method chaining, method composition, method chaining, method composition, method chaining, method composition, method chaining, method composition, method chaining, method composition, method chaining, method composition, method chaining, method composition, method chaining,"}
{"seed": "// MakeBadRequest builds a goa.ServiceError from an error.\nfunc MakeBadRequest(err error) *goa.ServiceError {\n\treturn &goa.ServiceError{\n\t\tName:    \"bad-request\",\n\t\tID:      goa.NewErrorID(),\n\t\tMessage: err.Error(),\n\t}\n}", "id": 23219, "concepts": ["error handling (goa.ServiceError)", "error ID generation"], "_raw_llm_output": "error handling (goa.ServiceError), error ID generation"}
{"seed": "// RunExpr runs all tests in the provided rel.Expr and returns a slice of Result. It returns an error if\n// the arr.ai code failed to evaluate.\nfunc RunExpr(ctx context.Context, expr rel.Expr) ([]Result, error) {\n\tresult, err := expr.Eval(ctx, rel.Scope{})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresults := make([]Result, 0)\n\tForeachLeaf(result, \"\", func(val rel.Value, path string) {\n\t\tresult := Result{\n\t\t\tName: path,\n\t\t}\n\n\t\tif isLiteralTrue(val) {\n\t\t\tresult.Outcome = Passed\n\t\t} else if isLiteralFalse(val) {\n\t\t\tresult.Outcome = Failed\n\t\t\tresult.Message = \"Expected: true. Actual: false.\"\n\t\t} else {\n\t\t\tresult.Outcome = Invalid\n\t\t\tresult.Message = fmt.Sprintf(\"Could not determine test Outcome due to non-boolean result of type %s: %s\",\n\t\t\t\trel.ValueTypeAsString(val), val.String())\n\n\t\t\tif _, ok := val.(rel.GenericSet); ok {\n\t\t\t\tresult.Message = fmt.Sprintf(\"Sets are not allowed as test containers. Please use tuples, \" +\n\t\t\t\t\t\"dictionaries or arrays.\")\n\t\t\t}\n\t\t}\n\n\t\tresults = append(results, result)\n\t})\n\n\treturn results, nil\n}", "id": 23223, "concepts": ["context", "rel.Expr", "rel.Value", "rel.ValueTypeAsString", "rel.Scope", "rel.GenericSet", "rel.ForeachLeaf", "rel.Value.String", "rel.Value.IsLiteralTrue", "rel.Value.IsLiteralFalse", "rel.Value.IsLiteralFalse", "fmt.Sprintf", "fmt.Errorf", "fmt.Println", "sync.WaitGroup", "sync.WaitGroup.Add", "sync.WaitGroup.Wait", "sync.WaitGroup.Done", "sync.WaitGroup.Add", "sync.WaitGroup.Wait", "sync.WaitGroup.Done", "sync.WaitGroup.Add", "sync.WaitGroup.Wait", "sync.WaitGroup.Done", "sync.WaitGroup.Add", "sync.WaitGroup.Wait", "sync.WaitGroup.Done", "sync.WaitGroup.Add", "sync.WaitGroup.Wait", "sync.WaitGroup.Done", "sync.WaitGroup.Add", "sync.WaitGroup.Wait", "sync.WaitGroup.Done", "sync.WaitGroup.Add", "sync.WaitGroup.Wait", "sync.WaitGroup.Done", "sync.WaitGroup.Add", "sync.WaitGroup.Wait", "sync.WaitGroup.Done", "sync.WaitGroup.Add", "sync.Wait"], "_raw_llm_output": "context, rel.Expr, rel.Value, rel.ValueTypeAsString, rel.Scope, rel.GenericSet, rel.ForeachLeaf, rel.Value.String, rel.Value.IsLiteralTrue, rel.Value.IsLiteralFalse, rel.Value.IsLiteralFalse, fmt.Sprintf, fmt.Errorf, fmt.Println, sync.WaitGroup, sync.WaitGroup.Add, sync.WaitGroup.Wait, sync.WaitGroup.Done, sync.WaitGroup.Add, sync.WaitGroup.Wait, sync.WaitGroup.Done, sync.WaitGroup.Add, sync.WaitGroup.Wait, sync.WaitGroup.Done, sync.WaitGroup.Add, sync.WaitGroup.Wait, sync.WaitGroup.Done, sync.WaitGroup.Add, sync.WaitGroup.Wait, sync.WaitGroup.Done, sync.WaitGroup.Add, sync.WaitGroup.Wait, sync.WaitGroup.Done, sync.WaitGroup.Add, sync.WaitGroup.Wait, sync.WaitGroup.Done, sync.WaitGroup.Add, sync.WaitGroup.Wait, sync.WaitGroup.Done, sync.WaitGroup.Add, sync.Wait"}
{"seed": "// extensionPattern creates a regular expression that matches paths with the given\n// extension. The extension separator is added automatically.\nfunc extensionPattern(pattern *regexp.Regexp) *regexp.Regexp {\n\treturn suffixPattern(regexp.MustCompile(\"(^|/)[^/]+.\" + pattern.String()))\n}", "id": 23224, "concepts": ["regexp", "regular expression", "string manipulation", "regexp.MustCompile", "regexp.Regexp"], "_raw_llm_output": "regexp, regular expression, string manipulation, regexp.MustCompile, regexp.Regexp"}
{"seed": "// runFile runs all tests in File.Source and fills File.Results and File.WallTime. It returns an error if\n// the arr.ai code failed to evaluate.\nfunc runFile(ctx context.Context, file *File) error {\n\tctx = importcache.WithNewImportCache(ctx)\n\texpr, err := syntax.Compile(ctx, file.Path, file.Source)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed compiling tests file '%s': %v\", file.Path, err)\n\t}\n\n\tstart := time.Now()\n\tresults, err := RunExpr(ctx, expr)\n\tfile.WallTime = time.Since(start)\n\tfile.Results = results\n\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed evaluating tests file '%s': %v\", file.Path, err)\n\t}\n\n\treturn nil\n}", "id": 23245, "concepts": ["context", "context cancellation", "error handling", "import caching", "syntax package usage", "time package usage"], "_raw_llm_output": "context, context cancellation, error handling, import caching, syntax package usage, time package usage"}
{"seed": "// CreatedAtGTE applies the GTE predicate on the \"created_at\" field.\nfunc CreatedAtGTE(v time.Time) predicate.User {\n\treturn predicate.User(sql.FieldGTE(FieldCreatedAt, v))\n}", "id": 23249, "concepts": ["predicate.User", "sql.FieldGTE", "time.Time"], "_raw_llm_output": "predicate.User, sql.FieldGTE, time.Time"}
{"seed": "// LatestHeroScoreLTE applies the LTE predicate on the \"latest_hero_score\" field.\nfunc LatestHeroScoreLTE(v int) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.LTE(s.C(FieldLatestHeroScore), v))\n\t})\n}", "id": 23255, "concepts": ["sql.Selector", "sql.C", "sql.LTE", "sql.Where", "sql.Predicate", "sql.Field", "sql.Query", "sql.Queryer", "sql.QueryerContext", "sql.QueryContext", "sql.QueryRow", "sql.QueryRowContext", "sql.QueryRower", "sql.QueryRowerContext", "sql.QueryRowScan", "sql.QueryRowScanContext", "sql.QueryRowScanner", "sql.QueryRowScannerContext", "sql.QueryRowScanContext", "sql.QueryRowScannerContext", "sql.QueryRowScannerContext", "sql.QueryRowScannerContext", "sql.QueryRowScannerContext", "sql.QueryRowScannerContext", "sql.QueryRowScannerContext", "sql.QueryRowScannerContext", "sql.QueryRowScannerContext", "sql.QueryRowScannerContext", "sql.QueryRowScannerContext", "sql.QueryRowScannerContext", "sql.QueryRowScannerContext", "sql.QueryRowScannerContext", "sql.QueryRowScannerContext", "sql.QueryRowScannerContext", "sql.QueryRowScannerContext", "sql.QueryRowScannerContext", "sql.QueryRowScannerContext", "sql.QueryRowScannerContext", "sql.QueryRowScannerContext", "sql.QueryRowScannerContext", "sql.QueryRowScannerContext", ""], "_raw_llm_output": "sql.Selector, sql.C, sql.LTE, sql.Where, sql.Predicate, sql.Field, sql.Query, sql.Queryer, sql.QueryerContext, sql.QueryContext, sql.QueryRow, sql.QueryRowContext, sql.QueryRower, sql.QueryRowerContext, sql.QueryRowScan, sql.QueryRowScanContext, sql.QueryRowScanner, sql.QueryRowScannerContext, sql.QueryRowScanContext, sql.QueryRowScannerContext, sql.QueryRowScannerContext, sql.QueryRowScannerContext, sql.QueryRowScannerContext, sql.QueryRowScannerContext, sql.QueryRowScannerContext, sql.QueryRowScannerContext, sql.QueryRowScannerContext, sql.QueryRowScannerContext, sql.QueryRowScannerContext, sql.QueryRowScannerContext, sql.QueryRowScannerContext, sql.QueryRowScannerContext, sql.QueryRowScannerContext, sql.QueryRowScannerContext, sql.QueryRowScannerContext, sql.QueryRowScannerContext, sql.QueryRowScannerContext, sql.QueryRowScannerContext, sql.QueryRowScannerContext, sql.QueryRowScannerContext, sql.QueryRowScannerContext,"}
{"seed": "// RequireFromPath is similar to FromPath except that instead of returning an\n// error on malformed input, it panics. It should only be used when the input\n// is statically verifiable.\nfunc RequireFromPath(td TrustDomain, path string) ID {\n\tid, err := FromPath(td, path)\n\tpanicOnErr(err)\n\treturn id\n}", "id": 23256, "concepts": ["panicOnErr", "panic", "error handling"], "_raw_llm_output": "panicOnErr, panic, error handling"}
{"seed": "// New returns a new Stargate instance with the ID preset to\n// an RFC4122 unique ID (See https://tools.ietf.org/html/rfc4122).\nfunc New() *Stargate {\n\t// Generate a UUID using V1 which incorporates both\n\t// timestamp and MAC address, and convert to string.\n\tuuid := uuid.NewV1().String()\n\n\treturn &Stargate{\n\t\tID:             uuid,\n\t\tUpdatePeriod:   5,\n\t\tPrunePeriod:    10,\n\t\tStaleThreshold: 20,\n\t}\n}", "id": 23271, "concepts": ["uuid generation", "string formatting", "struct definition", "basic function definition"], "_raw_llm_output": "uuid generation, string formatting, struct definition, basic function definition"}
{"seed": "// PropValAtom transforms a GetPropertyReply struct into an ATOM name.\n// The property reply must be in 32 bit format.\nfunc PropValAtom(xu *xgbutil.XUtil, reply *xproto.GetPropertyReply,\n\terr error) (string, error) {\n\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif reply.Format != 32 {\n\t\treturn \"\", fmt.Errorf(\"PropValAtom: Expected format 32 but got %d\",\n\t\t\treply.Format)\n\t}\n\n\treturn AtomName(xu, xproto.Atom(xgb.Get32(reply.Value)))\n}", "id": 23298, "concepts": ["xproto package usage", "xgb package usage", "xproto.Atom", "xproto.GetPropertyReply", "xproto.GetPropertyReply.Format", "xgbutil.XUtil", "xgbutil.XUtil.Get32", "xgbutil.XUtil.GetAtomName"], "_raw_llm_output": "xproto package usage, xgb package usage, xproto.Atom, xproto.GetPropertyReply, xproto.GetPropertyReply.Format, xgbutil.XUtil, xgbutil.XUtil.Get32, xgbutil.XUtil.GetAtomName"}
{"seed": "// mergeText merges buildbot summary texts, which sometimes separates\n// words that should be merged together, this combines them into a single\n// line.\nfunc mergeText(text []string) []string {\n\tresult := make([]string, 0, len(text))\n\tmerge := false\n\tfor _, line := range text {\n\t\tif merge {\n\t\t\tmerge = false\n\t\t\tresult[len(result)-1] += \" \" + line\n\t\t\tcontinue\n\t\t}\n\t\tresult = append(result, line)\n\t\tswitch line {\n\t\tcase \"build\", \"failed\", \"exception\":\n\t\t\tmerge = true\n\t\tdefault:\n\t\t\tmerge = false\n\t\t}\n\t}\n\n\t// We can remove error messages about the step \"steps\" if it's part of a longer\n\t// message because this step is an artifact of running on recipes and it's\n\t// not important to users.\n\tif len(result) > 1 {\n\t\tswitch result[0] {\n\t\tcase \"failed steps\", \"exception steps\":\n\t\t\tresult = result[1:]\n\t\t}\n\t}\n\treturn result\n}", "id": 23305, "concepts": ["string manipulation", "string concatenation", "string comparison", "string splitting", "string joining", "string trimming", "string iteration", "string indexing", "string slicing", "string length", "string concatenation", "string comparison", "string splitting", "string joining", "string trimming", "string iteration", "string indexing", "string slicing", "string length", "string concatenation", "string comparison", "string splitting", "string joining", "string trimming", "string iteration", "string indexing", "string slicing", "string length", "string concatenation", "string comparison", "string splitting", "string joining", "string trimming", "string iteration", "string indexing", "string slicing", "string length", "string concatenation", "string comparison", "string splitting", "string joining", "string trimming", "string iteration", "string indexing", "string slicing", "string length", "string concatenation", "string comparison", "string splitting", "string joining", "string trimming", "string iteration", "string indexing", "string slicing", "string length", "string concatenation", "string comparison", "string splitting", "string joining", "string trimming", "string iteration", "string indexing", "string slicing", "string length", "string concatenation", "string comparison", "string splitting", "string joining", "string trimming", "string iteration", "string indexing", "string slicing", "string length", "string concatenation", ""], "_raw_llm_output": "string manipulation, string concatenation, string comparison, string splitting, string joining, string trimming, string iteration, string indexing, string slicing, string length, string concatenation, string comparison, string splitting, string joining, string trimming, string iteration, string indexing, string slicing, string length, string concatenation, string comparison, string splitting, string joining, string trimming, string iteration, string indexing, string slicing, string length, string concatenation, string comparison, string splitting, string joining, string trimming, string iteration, string indexing, string slicing, string length, string concatenation, string comparison, string splitting, string joining, string trimming, string iteration, string indexing, string slicing, string length, string concatenation, string comparison, string splitting, string joining, string trimming, string iteration, string indexing, string slicing, string length, string concatenation, string comparison, string splitting, string joining, string trimming, string iteration, string indexing, string slicing, string length, string concatenation, string comparison, string splitting, string joining, string trimming, string iteration, string indexing, string slicing, string length, string concatenation,"}
{"seed": "// \u0424\u0443\u043d\u043a\u0446\u0438\u044f, \u0438\u043c\u0435\u044e\u0449\u0430\u044f \u0432\u0445\u043e\u0434\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0438 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u044e\u0449\u0430\u044f \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u043e \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439\nfunc learnMultiple(x, y int) (sum, prod int) {\n\treturn x + y, x * y // \u0432\u043e\u0437\u0432\u0440\u0430\u0442 \u0434\u0432\u0443\u0445 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439\n}", "id": 23310, "concepts": ["multiple return values", "function definition"], "_raw_llm_output": "multiple return values, function definition"}
{"seed": "// NewJSONUnmarshaler returns a new Unmarshaler for json.\n//\n// resolver can be nil if unknown and are only needed for extensions.\nfunc NewJSONUnmarshaler(resolver Resolver) Unmarshaler {\n\treturn newJSONUnmarshaler(resolver)\n}", "id": 23312, "concepts": ["function definition", "function composition", "function composition with anonymous function", "function composition with function composition", "function composition with function composition with anonymous function", "function composition with function composition with function composition with anonymous function", "function composition with function composition with function composition with function composition with anonymous function", "function composition with function composition with function composition with function composition with function composition with anonymous function", "function composition with function composition with function composition with function composition with function composition with function composition with anonymous function", "function composition with function composition with function composition with function composition with function composition with function composition with function composition with anonymous function", "function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition with anonymous function", "function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition with anonymous function", "function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition with anonymous function", "function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition with anonymous function", "function composition with function composition with function composition with function composition with"], "_raw_llm_output": "function definition, function composition, function composition with anonymous function, function composition with function composition, function composition with function composition with anonymous function, function composition with function composition with function composition with anonymous function, function composition with function composition with function composition with function composition with anonymous function, function composition with function composition with function composition with function composition with function composition with anonymous function, function composition with function composition with function composition with function composition with function composition with function composition with anonymous function, function composition with function composition with function composition with function composition with function composition with function composition with function composition with anonymous function, function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition with anonymous function, function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition with anonymous function, function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition with anonymous function, function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition with function composition with anonymous function, function composition with function composition with function composition with function composition with"}
{"seed": "// newDeployer generates a new github.Deployer implementation for the given\n// options.\nfunc newDeployer(e *empire.Empire, options Options) github.Deployer {\n\ted := github.NewEmpireDeployer(e)\n\ted.ImageBuilder = options.GitHub.Deployments.ImageBuilder\n\n\tvar d github.Deployer = ed\n\n\t// Enables the Tugboat integration, which will send logs to a Tugboat\n\t// instance.\n\tif url := options.GitHub.Deployments.TugboatURL; url != \"\" {\n\t\td = github.NotifyTugboat(d, url)\n\t}\n\n\t// Perform the deployment within a go routine so we don't timeout\n\t// githubs webhook requests.\n\td = github.DeployAsync(d)\n\n\treturn d\n}", "id": 23317, "concepts": ["struct composition", "interface composition", "anonymous function", "concurrency", "standard library usage"], "_raw_llm_output": "struct composition, interface composition, anonymous function, concurrency, standard library usage"}
{"seed": "// NewGetMachineRolesListAllSpacesParamsWithHTTPClient creates a new GetMachineRolesListAllSpacesParams object\n// with the default values initialized, and the ability to set a custom HTTPClient for a request\nfunc NewGetMachineRolesListAllSpacesParamsWithHTTPClient(client *http.Client) *GetMachineRolesListAllSpacesParams {\n\tvar ()\n\treturn &GetMachineRolesListAllSpacesParams{\n\t\tHTTPClient: client,\n\t}\n}", "id": 23322, "concepts": ["http.Client", "function definition", "function parameter", "function return value", "function parameter type", "function parameter value", "function parameter initialization", "function parameter assignment", "function parameter pointer", "function parameter pointer dereference", "function parameter pointer assignment", "function parameter pointer value", "function parameter pointer value assignment", "function parameter pointer value assignment", "function parameter pointer value assignment", "function parameter pointer value assignment", "function parameter pointer value assignment", "function parameter pointer value assignment", "function parameter pointer value assignment", "function parameter pointer value assignment", "function parameter pointer value assignment", "function parameter pointer value assignment", "function parameter pointer value assignment", "function parameter pointer value assignment", "function parameter pointer value assignment", "function parameter pointer value assignment", "function parameter pointer value assignment", "function parameter pointer value assignment", "function parameter pointer value assignment", "function parameter pointer value assignment", "function parameter pointer value assignment", "function parameter pointer value assignment", "function parameter pointer value assignment", "function parameter pointer value assignment", "function parameter pointer value assignment", "function parameter pointer value assignment", "function parameter pointer value assignment", "function parameter pointer value assignment", "function parameter pointer value assignment", "function parameter pointer value assignment", "function parameter pointer value assignment", "function parameter pointer value assignment", "function parameter pointer value assignment", "function parameter pointer value assignment", "function parameter pointer value assignment", "function parameter pointer value assignment", "function"], "_raw_llm_output": "http.Client, function definition, function parameter, function return value, function parameter type, function parameter value, function parameter initialization, function parameter assignment, function parameter pointer, function parameter pointer dereference, function parameter pointer assignment, function parameter pointer value, function parameter pointer value assignment, function parameter pointer value assignment, function parameter pointer value assignment, function parameter pointer value assignment, function parameter pointer value assignment, function parameter pointer value assignment, function parameter pointer value assignment, function parameter pointer value assignment, function parameter pointer value assignment, function parameter pointer value assignment, function parameter pointer value assignment, function parameter pointer value assignment, function parameter pointer value assignment, function parameter pointer value assignment, function parameter pointer value assignment, function parameter pointer value assignment, function parameter pointer value assignment, function parameter pointer value assignment, function parameter pointer value assignment, function parameter pointer value assignment, function parameter pointer value assignment, function parameter pointer value assignment, function parameter pointer value assignment, function parameter pointer value assignment, function parameter pointer value assignment, function parameter pointer value assignment, function parameter pointer value assignment, function parameter pointer value assignment, function parameter pointer value assignment, function parameter pointer value assignment, function parameter pointer value assignment, function parameter pointer value assignment, function parameter pointer value assignment, function parameter pointer value assignment, function"}
{"seed": "// Import an Lambda Deployment Group defined either outside the CDK app, or in a different AWS region.\n//\n// Returns: a Construct representing a reference to an existing Deployment Group\n// Experimental.\nfunc LambdaDeploymentGroup_FromLambdaDeploymentGroupAttributes(scope constructs.Construct, id *string, attrs *LambdaDeploymentGroupAttributes) ILambdaDeploymentGroup {\n\t_init_.Initialize()\n\n\tvar returns ILambdaDeploymentGroup\n\n\t_jsii_.StaticInvoke(\n\t\t\"monocdk.aws_codedeploy.LambdaDeploymentGroup\",\n\t\t\"fromLambdaDeploymentGroupAttributes\",\n\t\t[]interface{}{scope, id, attrs},\n\t\t&returns,\n\t)\n\n\treturn returns\n}", "id": 23323, "concepts": ["cdk.Construct", "cdk.aws_codedeploy.LambdaDeploymentGroup", "cdk.aws_codedeploy.ILambdaDeploymentGroup", "cdk.aws_codedeploy.LambdaDeploymentGroupAttributes", "cdk.aws_codedeploy.LambdaDeploymentGroup_FromLambdaDeploymentGroupAttributes"], "_raw_llm_output": "cdk.Construct, cdk.aws_codedeploy.LambdaDeploymentGroup, cdk.aws_codedeploy.ILambdaDeploymentGroup, cdk.aws_codedeploy.LambdaDeploymentGroupAttributes, cdk.aws_codedeploy.LambdaDeploymentGroup_FromLambdaDeploymentGroupAttributes"}
{"seed": "// DefaultExprsNotIn applies the NotIn predicate on the \"default_exprs\" field.\nfunc DefaultExprsNotIn(vs ...string) predicate.User {\n\treturn predicate.User(sql.FieldNotIn(FieldDefaultExprs, vs...))\n}", "id": 23333, "concepts": ["sql.FieldNotIn", "sql.FieldIn", "sql.FieldEq", "sql.FieldNotEq", "sql.FieldGt", "sql.FieldGte", "sql.FieldLt", "sql.FieldLte", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldIs", "sql.FieldIsNot", "sql.FieldIsNull", "sql.FieldIsNotNull", "sql.FieldBetween", "sql.FieldNotBetween", "sql.FieldRegexp", "sql.FieldNotRegexp", "sql.FieldExpr", "sql.FieldNotExpr", "sql.FieldAnd", "sql.FieldOr", "sql.FieldNot", "sql.FieldXor", "sql.FieldEq", "sql.FieldNotEq", "sql.FieldGt", "sql.FieldGte", "sql.FieldLt", "sql.FieldLte", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldIs", "sql.FieldIsNot", "sql.FieldIsNull", "sql.FieldIsNotNull", "sql.FieldBetween", "sql.FieldNotBetween", "sql.FieldRegexp", "sql.FieldNotRegexp", "sql.FieldExpr", "sql.FieldNotExpr", "sql.FieldAnd", "sql.FieldOr", "sql"], "_raw_llm_output": "sql.FieldNotIn, sql.FieldIn, sql.FieldEq, sql.FieldNotEq, sql.FieldGt, sql.FieldGte, sql.FieldLt, sql.FieldLte, sql.FieldLike, sql.FieldNotLike, sql.FieldIn, sql.FieldNotIn, sql.FieldIs, sql.FieldIsNot, sql.FieldIsNull, sql.FieldIsNotNull, sql.FieldBetween, sql.FieldNotBetween, sql.FieldRegexp, sql.FieldNotRegexp, sql.FieldExpr, sql.FieldNotExpr, sql.FieldAnd, sql.FieldOr, sql.FieldNot, sql.FieldXor, sql.FieldEq, sql.FieldNotEq, sql.FieldGt, sql.FieldGte, sql.FieldLt, sql.FieldLte, sql.FieldLike, sql.FieldNotLike, sql.FieldIn, sql.FieldNotIn, sql.FieldIs, sql.FieldIsNot, sql.FieldIsNull, sql.FieldIsNotNull, sql.FieldBetween, sql.FieldNotBetween, sql.FieldRegexp, sql.FieldNotRegexp, sql.FieldExpr, sql.FieldNotExpr, sql.FieldAnd, sql.FieldOr, sql"}
{"seed": "// SocialPayloadContainsFold applies the ContainsFold predicate on the \"social_payload\" field.\nfunc SocialPayloadContainsFold(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.ContainsFold(s.C(FieldSocialPayload), v))\n\t})\n}", "id": 23347, "concepts": ["sql.Selector", "sql.ContainsFold", "predicate.User", "sql.C", "sql.Where"], "_raw_llm_output": "sql.Selector, sql.ContainsFold, predicate.User, sql.C, sql.Where"}
{"seed": "// NewCreateAuthorizationV1beta1NamespacedLocalSubjectAccessReviewUnauthorized creates CreateAuthorizationV1beta1NamespacedLocalSubjectAccessReviewUnauthorized with default headers values\nfunc NewCreateAuthorizationV1beta1NamespacedLocalSubjectAccessReviewUnauthorized() *CreateAuthorizationV1beta1NamespacedLocalSubjectAccessReviewUnauthorized {\n\n\treturn &CreateAuthorizationV1beta1NamespacedLocalSubjectAccessReviewUnauthorized{}\n}", "id": 23356, "concepts": ["struct definition", "function definition", "basic function definition", "basic function call", "basic function call with arguments", "basic function call with named arguments", "basic function call with named arguments and return values", "basic function call with named arguments and return values", "basic function call with named arguments and return values", "basic function call with named arguments and return values", "basic function call with named arguments and return values", "basic function call with named arguments and return values", "basic function call with named arguments and return values", "basic function call with named arguments and return values", "basic function call with named arguments and return values", "basic function call with named arguments and return values", "basic function call with named arguments and return values", "basic function call with named arguments and return values", "basic function call with named arguments and return values", "basic function call with named arguments and return values", "basic function call with named arguments and return values", "basic function call with named arguments and return values", "basic function call with named arguments and return values", "basic function call with named arguments and return values", "basic function call with named arguments and return values", "basic function call with named arguments and return values", "basic function call with named arguments and return values", "basic function call with named arguments and return values", "basic function call with named arguments and return"], "_raw_llm_output": "struct definition, function definition, basic function definition, basic function call, basic function call with arguments, basic function call with named arguments, basic function call with named arguments and return values, basic function call with named arguments and return values, basic function call with named arguments and return values, basic function call with named arguments and return values, basic function call with named arguments and return values, basic function call with named arguments and return values, basic function call with named arguments and return values, basic function call with named arguments and return values, basic function call with named arguments and return values, basic function call with named arguments and return values, basic function call with named arguments and return values, basic function call with named arguments and return values, basic function call with named arguments and return values, basic function call with named arguments and return values, basic function call with named arguments and return values, basic function call with named arguments and return values, basic function call with named arguments and return values, basic function call with named arguments and return values, basic function call with named arguments and return values, basic function call with named arguments and return values, basic function call with named arguments and return values, basic function call with named arguments and return values, basic function call with named arguments and return"}
{"seed": "// NewSuperKeyRequestWithDefaults instantiates a new SuperKeyRequest object\n// This constructor will only assign default values to properties that have it defined,\n// but it doesn't guarantee that properties required by API are set\nfunc NewSuperKeyRequestWithDefaults() *SuperKeyRequest {\n\tthis := SuperKeyRequest{}\n\treturn &this\n}", "id": 23363, "concepts": ["struct definition", "struct initialization", "struct field assignment"], "_raw_llm_output": "struct definition, struct initialization, struct field assignment"}
{"seed": "// StateNEQ applies the NEQ predicate on the \"state\" field.\nfunc StateNEQ(v State) predicate.User {\n\treturn predicate.User(sql.FieldNEQ(FieldState, v))\n}", "id": 23370, "concepts": ["predicate", "predicate.User", "FieldNEQ", "sql.FieldNEQ"], "_raw_llm_output": "predicate, predicate.User, FieldNEQ, sql.FieldNEQ"}
{"seed": "// NewColumnFamilyMetricsTotalDiskSpaceUsedByNameGetParamsWithContext creates a new ColumnFamilyMetricsTotalDiskSpaceUsedByNameGetParams object\n// with the ability to set a context for a request.\nfunc NewColumnFamilyMetricsTotalDiskSpaceUsedByNameGetParamsWithContext(ctx context.Context) *ColumnFamilyMetricsTotalDiskSpaceUsedByNameGetParams {\n\treturn &ColumnFamilyMetricsTotalDiskSpaceUsedByNameGetParams{\n\t\tContext: ctx,\n\t}\n}", "id": 23374, "concepts": ["context package usage", "function definition", "function composition"], "_raw_llm_output": "context package usage, function definition, function composition"}
{"seed": "// ActionFromInt reverses action.AsInt, but only for the 4 bits that compose the action. Other bits are ignored.\n// This only works for a 2-player game.\nfunc ActionFromInt(st int) Action {\n\tact := Action{}\n\tif st%2 == 1 {\n\t\tact.PlayRecent = true\n\t}\n\n\tst = (st & 0xF) >> 1\n\t// Now st is the TargetPlayerOffset or SelectedCard. We don't know which, but if *any* card was selected,\n\t// then the other player must be targeted (since the played card is a guard), so for 2 players the offset is 1.\n\tif st > 0 {\n\t\tact.TargetPlayerOffset = 1\n\t}\n\tact.SelectedCard = Card(st + 1)\n\treturn act\n}", "id": 23387, "concepts": ["bitwise operations", "bit shifting", "bit masking", "integer manipulation"], "_raw_llm_output": "bitwise operations, bit shifting, bit masking, integer manipulation"}
{"seed": "// Style_ is a convenience wrapper for Style without the attrs argument.\nfunc Style_(children ...HTML) HTML {\n  return Style(nil, children...)\n}", "id": 23398, "concepts": ["HTML struct definition", "HTML struct field definition", "HTML struct field initialization", "HTML struct field access", "HTML struct field assignment", "HTML struct field method definition", "HTML struct field method call", "HTML struct field method call with arguments", "HTML struct field method call with named arguments", "HTML struct field method call with named arguments and arguments", "HTML struct field method call with named arguments and arguments", "HTML struct field method call with named arguments and arguments", "HTML struct field method call with named arguments and arguments", "HTML struct field method call with named arguments and arguments", "HTML struct field method call with named arguments and arguments", "HTML struct field method call with named arguments and arguments", "HTML struct field method call with named arguments and arguments", "HTML struct field method call with named arguments and arguments", "HTML struct field method call with named arguments and arguments", "HTML struct field method call with named arguments and arguments", "HTML struct field method call with named arguments and arguments", "HTML struct field method call with named arguments and arguments", "HTML struct field method call with named arguments and arguments", "HTML struct field method call with named arguments and arguments", "HTML struct field method call with named arguments and arguments", "HTML struct field method call with named arguments and arguments", "HTML struct field method call with named arguments and arguments", "HTML struct field method"], "_raw_llm_output": "HTML struct definition, HTML struct field definition, HTML struct field initialization, HTML struct field access, HTML struct field assignment, HTML struct field method definition, HTML struct field method call, HTML struct field method call with arguments, HTML struct field method call with named arguments, HTML struct field method call with named arguments and arguments, HTML struct field method call with named arguments and arguments, HTML struct field method call with named arguments and arguments, HTML struct field method call with named arguments and arguments, HTML struct field method call with named arguments and arguments, HTML struct field method call with named arguments and arguments, HTML struct field method call with named arguments and arguments, HTML struct field method call with named arguments and arguments, HTML struct field method call with named arguments and arguments, HTML struct field method call with named arguments and arguments, HTML struct field method call with named arguments and arguments, HTML struct field method call with named arguments and arguments, HTML struct field method call with named arguments and arguments, HTML struct field method call with named arguments and arguments, HTML struct field method call with named arguments and arguments, HTML struct field method call with named arguments and arguments, HTML struct field method call with named arguments and arguments, HTML struct field method call with named arguments and arguments, HTML struct field method"}
{"seed": "// RunTests runs all arr.ai tests in a given path. It returns an error if the path is invalid, contains no test files or\n// has invalid arr.ai code in any of them.\nfunc RunTests(ctx context.Context, w io.Writer, path string) error {\n\tif path == \"\" || path == \".\" {\n\t\tvar err error\n\t\tpath, err = os.Getwd()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tfiles, err := getTestFiles(ctx, path)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor i := range files {\n\t\terr = runFile(ctx, &files[i])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\terr = Report(w, files)\n\treturn err\n}", "id": 23405, "concepts": ["os.Getwd", "os.Stat", "io.Writer", "io.Reader", "os.File", "os.Open", "filepath.Walk", "context.Context", "concurrency", "standard library usage"], "_raw_llm_output": "os.Getwd, os.Stat, io.Writer, io.Reader, os.File, os.Open, filepath.Walk, context.Context, concurrency, standard library usage"}
{"seed": "// checksizeAndPad checks the size of the plaintext and pads it if necessary.\n// Blowfish is a block cipher, thus the plaintext needs to be padded to\n// a multiple of the algorithms blocksize (8 bytes).\n// return the multiple-of-blowfish.BlockSize-sized plaintext\nfunc checksizeAndPad(plaintext []byte) []byte {\n\n\t// calculate modulus of plaintext to blowfish's cipher block size\n\t// if result is not 0, then we need to pad\n\n\tmodulus := len(plaintext) % blowfish.BlockSize\n\tif modulus != 0 {\n\t\t// calc bytes we need to pad to make plaintext a multiple of block size\n\t\tpadlen := blowfish.BlockSize - modulus\n\n\t\t// add required padding\n\t\tfor i := 0; i < padlen; i++ {\n\t\t\tplaintext = append(plaintext, 0)\n\t\t}\n\t}\n\n\treturn plaintext\n}", "id": 23416, "concepts": ["slice iteration (range loop)", "slice append", "slice length", "slice modulus", "slice padding"], "_raw_llm_output": "slice iteration (range loop), slice append, slice length, slice modulus, slice padding"}
{"seed": "/*\nPutObject stores the data into the ugit objects repository. An object type is added before the content inside the file.\nWe hash the whole to return it as the oid\n*/\nfunc PutObject(data string, objectType ...ObjectType) (oid string, err error) {\n\t_type := BLOB\n\tif len(objectType) > 0 {\n\t\t_type = objectType[0]\n\t}\n\tencoded := []byte(string(_type) + string(BYTE_SEPARATOR) + data)\n\toid = string(HashObject(encoded))\n\tobjectPath := fmt.Sprintf(\"%s/%s/%s\", UGIT_DIR, OBJECTS_DIR, oid)\n\terr = ioutil.WriteFile(objectPath, encoded, 0777)\n\treturn oid, err\n}", "id": 23427, "concepts": ["string manipulation", "byte manipulation", "file manipulation", "io.ioutil", "io.Writer", "io.Reader", "io.ReadWriter", "io.EOF", "io.Seeker", "io.SeekStart", "io.SeekCurrent", "io.SeekEnd", "io.ReadSeeker", "io.ReadCloser", "io.WriteCloser", "io.ReadWriteCloser", "io.ReadWriteSeeker", "io.ReadWriteSeeker", "io.ReadWriteSeeker", "io.ReadWriteSeeker", "io.ReadWriteSeeker", "io.ReadWriteSeeker", "io.ReadWriteSeeker", "io.ReadWriteSeeker", "io.ReadWriteSeeker", "io.ReadWriteSeeker", "io.ReadWriteSeeker", "io.ReadWriteSeeker", "io.ReadWriteSeeker", "io.ReadWriteSeeker", "io.ReadWriteSeeker", "io.ReadWriteSeeker", "io.ReadWriteSeeker", "io.ReadWriteSeeker", "io.ReadWriteSeeker", "io.ReadWriteSeeker", "io.ReadWriteSeeker", "io.ReadWriteSeeker", "io.ReadWriteSeeker", "io.ReadWriteSeeker", "io.ReadWriteSeeker", "io.ReadWriteSeeker", "io.ReadWriteSeeker", "io.ReadWriteSeeker", "io.ReadWriteSeeker", "io.ReadWriteSeeker", "io.ReadWriteSeek"], "_raw_llm_output": "string manipulation, byte manipulation, file manipulation, io.ioutil, io.Writer, io.Reader, io.ReadWriter, io.EOF, io.Seeker, io.SeekStart, io.SeekCurrent, io.SeekEnd, io.ReadSeeker, io.ReadCloser, io.WriteCloser, io.ReadWriteCloser, io.ReadWriteSeeker, io.ReadWriteSeeker, io.ReadWriteSeeker, io.ReadWriteSeeker, io.ReadWriteSeeker, io.ReadWriteSeeker, io.ReadWriteSeeker, io.ReadWriteSeeker, io.ReadWriteSeeker, io.ReadWriteSeeker, io.ReadWriteSeeker, io.ReadWriteSeeker, io.ReadWriteSeeker, io.ReadWriteSeeker, io.ReadWriteSeeker, io.ReadWriteSeeker, io.ReadWriteSeeker, io.ReadWriteSeeker, io.ReadWriteSeeker, io.ReadWriteSeeker, io.ReadWriteSeeker, io.ReadWriteSeeker, io.ReadWriteSeeker, io.ReadWriteSeeker, io.ReadWriteSeeker, io.ReadWriteSeeker, io.ReadWriteSeeker, io.ReadWriteSeeker, io.ReadWriteSeeker, io.ReadWriteSeeker, io.ReadWriteSeek"}
{"seed": "// WithNodeLabels configures a builder to use specified Kubernetes node labels\nfunc WithNodeLabels(nodeLabels map[string]string) BuilderOption {\n\treturn func(b *builder) error {\n\t\tb.nodeLabels = map[string]string{}\n\t\tfor k, v := range nodeLabels {\n\t\t\tk, v := hostinfo.LabelPreprocessor(k, v)\n\t\t\tb.nodeLabels[k] = v\n\t\t}\n\t\treturn nil\n\t}\n}", "id": 23429, "concepts": ["map iteration (range loop)", "map key/value iteration (range loop)", "map key/value assignment", "map key/value lookup", "map key/value deletion", "map key/value assignment", "map key/value assignment", "map key/value assignment", "map key/value assignment", "map key/value assignment", "map key/value assignment", "map key/value assignment", "map key/value assignment", "map key/value assignment", "map key/value assignment", "map key/value assignment", "map key/value assignment", "map key/value assignment", "map key/value assignment", "map key/value assignment", "map key/value assignment", "map key/value assignment", "map key/value assignment", "map key/value assignment", "map key/value assignment", "map key/value assignment", "map key/value assignment", "map key/value assignment", "map key/value assignment", "map key/value assignment", "map key/value assignment", "map key/value assignment", "map key/value assignment", "map key/value assignment", "map key/value assignment", "map key/value assignment", "map key/value assignment", "map key/value assignment", "map key/value assignment", "map key/value assignment", "map key/value assignment", "map key/value assignment", ""], "_raw_llm_output": "map iteration (range loop), map key/value iteration (range loop), map key/value assignment, map key/value lookup, map key/value deletion, map key/value assignment, map key/value assignment, map key/value assignment, map key/value assignment, map key/value assignment, map key/value assignment, map key/value assignment, map key/value assignment, map key/value assignment, map key/value assignment, map key/value assignment, map key/value assignment, map key/value assignment, map key/value assignment, map key/value assignment, map key/value assignment, map key/value assignment, map key/value assignment, map key/value assignment, map key/value assignment, map key/value assignment, map key/value assignment, map key/value assignment, map key/value assignment, map key/value assignment, map key/value assignment, map key/value assignment, map key/value assignment, map key/value assignment, map key/value assignment, map key/value assignment, map key/value assignment, map key/value assignment, map key/value assignment, map key/value assignment, map key/value assignment, map key/value assignment,"}
{"seed": "// insertFourBits inserts the last four bits (0x0F) of in\n// at position 0 in dest, and returns a byte with the last four bits\n// (0x0F) of dest shifted up.\nfunc insertFourBits(dest []byte, in byte) (out byte) {\n\treturn insertFourBitsGo(dest, in)\n}", "id": 23431, "concepts": ["byte manipulation", "bitwise operations"], "_raw_llm_output": "byte manipulation, bitwise operations"}
{"seed": "// NewPutParamsWithContext creates a new PutParams object\n// with the default values initialized, and the ability to set a context for a request\nfunc NewPutParamsWithContext(ctx context.Context) *PutParams {\n\tvar ()\n\treturn &PutParams{\n\n\t\tContext: ctx,\n\t}\n}", "id": 23433, "concepts": ["context package usage", "function definition", "struct initialization"], "_raw_llm_output": "context package usage, function definition, struct initialization"}
{"seed": "// NicknameEqualFold applies the EqualFold predicate on the \"nickname\" field.\nfunc NicknameEqualFold(v string) predicate.User {\n\treturn predicate.User(sql.FieldEqualFold(FieldNickname, v))\n}", "id": 23437, "concepts": ["predicate.User", "sql.FieldEqualFold", "sql.Field", "predicate.FieldEqualFold", "predicate.Field", "predicate.FieldEqualFold", "predicate.FieldEqualFold", "predicate.FieldEqualFold", "predicate.FieldEqualFold", "predicate.FieldEqualFold", "predicate.FieldEqualFold", "predicate.FieldEqualFold", "predicate.FieldEqualFold", "predicate.FieldEqualFold", "predicate.FieldEqualFold", "predicate.FieldEqualFold", "predicate.FieldEqualFold", "predicate.FieldEqualFold", "predicate.FieldEqualFold", "predicate.FieldEqualFold", "predicate.FieldEqualFold", "predicate.FieldEqualFold", "predicate.FieldEqualFold", "predicate.FieldEqualFold", "predicate.FieldEqualFold", "predicate.FieldEqualFold", "predicate.FieldEqualFold", "predicate.FieldEqualFold", "predicate.FieldEqualFold", "predicate.FieldEqualFold", "predicate.FieldEqualFold", "predicate.FieldEqualFold", "predicate.FieldEqualFold", "predicate.FieldEqualFold", "predicate.FieldEqualFold", "predicate.FieldEqualFold", "predicate.FieldEqualFold", "predicate.FieldEqualFold", "predicate.FieldEqualFold", "predicate.FieldEqualFold", "predicate.FieldEqualFold", "predicate.FieldEqualFold", "predicate.FieldEqualFold", "predicate.Field"], "_raw_llm_output": "predicate.User, sql.FieldEqualFold, sql.Field, predicate.FieldEqualFold, predicate.Field, predicate.FieldEqualFold, predicate.FieldEqualFold, predicate.FieldEqualFold, predicate.FieldEqualFold, predicate.FieldEqualFold, predicate.FieldEqualFold, predicate.FieldEqualFold, predicate.FieldEqualFold, predicate.FieldEqualFold, predicate.FieldEqualFold, predicate.FieldEqualFold, predicate.FieldEqualFold, predicate.FieldEqualFold, predicate.FieldEqualFold, predicate.FieldEqualFold, predicate.FieldEqualFold, predicate.FieldEqualFold, predicate.FieldEqualFold, predicate.FieldEqualFold, predicate.FieldEqualFold, predicate.FieldEqualFold, predicate.FieldEqualFold, predicate.FieldEqualFold, predicate.FieldEqualFold, predicate.FieldEqualFold, predicate.FieldEqualFold, predicate.FieldEqualFold, predicate.FieldEqualFold, predicate.FieldEqualFold, predicate.FieldEqualFold, predicate.FieldEqualFold, predicate.FieldEqualFold, predicate.FieldEqualFold, predicate.FieldEqualFold, predicate.FieldEqualFold, predicate.FieldEqualFold, predicate.FieldEqualFold, predicate.FieldEqualFold, predicate.Field"}
{"seed": "// PossibleLinkedActionValues returns the possible values for the LinkedAction const type.\nfunc PossibleLinkedActionValues() []LinkedAction {\n\treturn []LinkedAction{\n\t\tLinkedActionBlocked,\n\t\tLinkedActionEnabled,\n\t\tLinkedActionNotSpecified,\n\t\tLinkedActionValidate,\n\t}\n}", "id": 23445, "concepts": ["constant definition", "type definition", "array definition"], "_raw_llm_output": "constant definition, type definition, array definition"}
{"seed": "// Prompt prints the supplied message, waits for input on stdin,\n// then passes the input over to the supplied parser. The actual\n// prompt displayed to the user is \"{msg} \".\nfunc Prompt(msg string, parser InputParser) (interface{}, error) {\n\tstderrMux.Lock()\n\tdefer stderrMux.Unlock()\n\n\tvar input string\n\tfmt.Fprintf(Stderr, \"%s \", msg)\n\t_, err := fmt.Scanln(&input)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn parser(input)\n}", "id": 23447, "concepts": ["fmt.Scanln usage", "fmt.Fprintf usage", "fmt.Scan usage", "fmt.Println usage", "fmt.Fprint usage", "fmt.Printf usage", "fmt.Sprintf usage", "fmt.Sprintln usage", "fmt.Sscanf usage", "fmt.Fscanf usage", "fmt.Fscan usage", "fmt.Fscanln usage", "fmt.Scan usage", "fmt.Scanf usage", "fmt.Scanln usage", "fmt.Scanln usage", "fmt.Scanln usage", "fmt.Scanln usage", "fmt.Scanln usage", "fmt.Scanln usage", "fmt.Scanln usage", "fmt.Scanln usage", "fmt.Scanln usage", "fmt.Scanln usage", "fmt.Scanln usage", "fmt.Scanln usage", "fmt.Scanln usage", "fmt.Scanln usage", "fmt.Scanln usage", "fmt.Scanln usage", "fmt.Scanln usage", "fmt.Scanln usage", "fmt.Scanln usage", "fmt.Scanln usage", "fmt.Scanln usage", "fmt.Scanln usage", "fmt.Scanln usage", "fmt.Scanln usage", "fmt.Scanln usage", "fmt.Scanln usage", "fmt.Scanln usage", "fmt.Scanln usage", "fmt.Scanln usage", "fmt."], "_raw_llm_output": "fmt.Scanln usage, fmt.Fprintf usage, fmt.Scan usage, fmt.Println usage, fmt.Fprint usage, fmt.Printf usage, fmt.Sprintf usage, fmt.Sprintln usage, fmt.Sscanf usage, fmt.Fscanf usage, fmt.Fscan usage, fmt.Fscanln usage, fmt.Scan usage, fmt.Scanf usage, fmt.Scanln usage, fmt.Scanln usage, fmt.Scanln usage, fmt.Scanln usage, fmt.Scanln usage, fmt.Scanln usage, fmt.Scanln usage, fmt.Scanln usage, fmt.Scanln usage, fmt.Scanln usage, fmt.Scanln usage, fmt.Scanln usage, fmt.Scanln usage, fmt.Scanln usage, fmt.Scanln usage, fmt.Scanln usage, fmt.Scanln usage, fmt.Scanln usage, fmt.Scanln usage, fmt.Scanln usage, fmt.Scanln usage, fmt.Scanln usage, fmt.Scanln usage, fmt.Scanln usage, fmt.Scanln usage, fmt.Scanln usage, fmt.Scanln usage, fmt.Scanln usage, fmt.Scanln usage, fmt."}
{"seed": "// MakeObjectMeta returns an ObjectMeta struct with values filled in from input VirtualMachineService. Also sets the VM operator annotations.\nfunc MakeObjectMeta(vmService *vmopv1alpha1.VirtualMachineService) metav1.ObjectMeta {\n\tom := metav1.ObjectMeta{\n\t\tNamespace:   vmService.Namespace,\n\t\tName:        vmService.Name,\n\t\tLabels:      vmService.Labels,\n\t\tAnnotations: vmService.Annotations,\n\t\tOwnerReferences: []metav1.OwnerReference{\n\t\t\t{\n\t\t\t\tUID:                vmService.UID,\n\t\t\t\tName:               vmService.Name,\n\t\t\t\tController:         pointer.BoolPtr(true),\n\t\t\t\tBlockOwnerDeletion: pointer.BoolPtr(true),\n\t\t\t\tKind:               ServiceOwnerRefKind,\n\t\t\t\tAPIVersion:         ServiceOwnerRefVersion,\n\t\t\t},\n\t\t},\n\t}\n\tpkg.AddAnnotations(&om)\n\n\treturn om\n}", "id": 23452, "concepts": ["struct definition", "struct field assignment", "struct field initialization", "struct field pointer assignment", "struct field pointer dereference", "struct field pointer nil check", "struct field pointer nil value check", "struct field pointer nil value check", "struct field pointer nil value check", "struct field pointer nil value check", "struct field pointer nil value check", "struct field pointer nil value check", "struct field pointer nil value check", "struct field pointer nil value check", "struct field pointer nil value check", "struct field pointer nil value check", "struct field pointer nil value check", "struct field pointer nil value check", "struct field pointer nil value check", "struct field pointer nil value check", "struct field pointer nil value check", "struct field pointer nil value check", "struct field pointer nil value check", "struct field pointer nil value check", "struct field pointer nil value check", "struct field pointer nil value check", "struct field pointer nil value check", "struct field pointer nil value check", "struct field pointer nil value check", "struct field pointer nil value check", "struct field pointer nil value check", "struct field pointer nil value check", "struct field pointer nil value check", "struct field pointer nil value check", "struct field pointer nil value check", "struct field pointer nil value check", "struct field pointer nil value check", "struct field pointer nil value check", "struct field pointer"], "_raw_llm_output": "struct definition, struct field assignment, struct field initialization, struct field pointer assignment, struct field pointer dereference, struct field pointer nil check, struct field pointer nil value check, struct field pointer nil value check, struct field pointer nil value check, struct field pointer nil value check, struct field pointer nil value check, struct field pointer nil value check, struct field pointer nil value check, struct field pointer nil value check, struct field pointer nil value check, struct field pointer nil value check, struct field pointer nil value check, struct field pointer nil value check, struct field pointer nil value check, struct field pointer nil value check, struct field pointer nil value check, struct field pointer nil value check, struct field pointer nil value check, struct field pointer nil value check, struct field pointer nil value check, struct field pointer nil value check, struct field pointer nil value check, struct field pointer nil value check, struct field pointer nil value check, struct field pointer nil value check, struct field pointer nil value check, struct field pointer nil value check, struct field pointer nil value check, struct field pointer nil value check, struct field pointer nil value check, struct field pointer nil value check, struct field pointer nil value check, struct field pointer nil value check, struct field pointer"}
{"seed": "// NewRenewOrganizationLicensesSeatsParamsWithTimeout creates a new RenewOrganizationLicensesSeatsParams object\n// with the default values initialized, and the ability to set a timeout on a request\nfunc NewRenewOrganizationLicensesSeatsParamsWithTimeout(timeout time.Duration) *RenewOrganizationLicensesSeatsParams {\n\tvar ()\n\treturn &RenewOrganizationLicensesSeatsParams{\n\n\t\ttimeout: timeout,\n\t}\n}", "id": 23454, "concepts": ["function definition", "timeout handling", "default parameter values"], "_raw_llm_output": "function definition, timeout handling, default parameter values"}
{"seed": "// Checks if actual != nil.\nfunc Exist(values ...interface{}) (failureMessage string) {\n\treturn NotEqual(values[0], nil)\n}", "id": 23468, "concepts": ["interface", "nil handling", "basic function definition"], "_raw_llm_output": "interface, nil handling, basic function definition"}
{"seed": "// CompressWithGzip takes an io.Reader as input and pipes\n// it through a gzip.Writer returning an io.Reader containing\n// the gzipped data.\n// An error is returned if passing data to the gzip.Writer fails\nfunc CompressWithGzip(data io.Reader) (io.Reader, error) {\n\tpipeReader, pipeWriter := io.Pipe()\n\tgzipWriter := gzip.NewWriter(pipeWriter)\n\n\tvar err error\n\tgo func() {\n\t\t_, err = io.Copy(gzipWriter, data)\n\t\tgzipWriter.Close()\n\t\t// subsequent reads from the read half of the pipe will\n\t\t// return no bytes and the error err, or EOF if err is nil.\n\t\tpipeWriter.CloseWithError(err)\n\t}()\n\n\treturn pipeReader, err\n}", "id": 23474, "concepts": ["io.Pipe", "io.Copy", "gzip.Writer", "goroutines", "error handling"], "_raw_llm_output": "io.Pipe, io.Copy, gzip.Writer, goroutines, error handling"}
{"seed": "// NewPutMeAccessRestrictionSmsIDParamsWithContext creates a new PutMeAccessRestrictionSmsIDParams object\n// with the default values initialized, and the ability to set a context for a request\nfunc NewPutMeAccessRestrictionSmsIDParamsWithContext(ctx context.Context) *PutMeAccessRestrictionSmsIDParams {\n\tvar ()\n\treturn &PutMeAccessRestrictionSmsIDParams{\n\n\t\tContext: ctx,\n\t}\n}", "id": 23478, "concepts": ["context package usage", "basic function definition"], "_raw_llm_output": "context package usage, basic function definition"}
{"seed": "// ValidateLocalSubjectAccessReview validates a LocalSubjectAccessReview and returns an\n// ErrorList with any errors.\nfunc ValidateLocalSubjectAccessReview(sar *authorizationapi.LocalSubjectAccessReview) field.ErrorList {\n\tallErrs := ValidateSubjectAccessReviewSpec(sar.Spec, field.NewPath(\"spec\"))\n\n\tobjectMetaShallowCopy := sar.ObjectMeta\n\tobjectMetaShallowCopy.Namespace = \"\"\n\tobjectMetaShallowCopy.ManagedFields = nil\n\tif !apiequality.Semantic.DeepEqual(metav1.ObjectMeta{}, objectMetaShallowCopy) {\n\t\tallErrs = append(allErrs, field.Invalid(field.NewPath(\"metadata\"), sar.ObjectMeta, `must be empty except for namespace`))\n\t}\n\n\tif sar.Spec.ResourceAttributes != nil && sar.Spec.ResourceAttributes.Namespace != sar.Namespace {\n\t\tallErrs = append(allErrs, field.Invalid(field.NewPath(\"spec.resourceAttributes.namespace\"), sar.Spec.ResourceAttributes.Namespace, `must match metadata.namespace`))\n\t}\n\tif sar.Spec.NonResourceAttributes != nil {\n\t\tallErrs = append(allErrs, field.Invalid(field.NewPath(\"spec.nonResourceAttributes\"), sar.Spec.NonResourceAttributes, `disallowed on this kind of request`))\n\t}\n\n\treturn allErrs\n}", "id": 23480, "concepts": ["field.ErrorList", "metav1.ObjectMeta", "apiequality.Semantic", "errors.New"], "_raw_llm_output": "field.ErrorList, metav1.ObjectMeta, apiequality.Semantic, errors.New"}
{"seed": "// -----------------------------------------------------------------------------\n\n// Set equality: Two sets are equal if they have the same elements.\nfunc Equals(oneSet, otherSet Set) bool {\n\n\tif len(oneSet.mem) != len(otherSet.mem) {\n\t\treturn false\n\t}\n\t/* Obviously, if the sets have different numbers of elements, they are not\n\tequal. */\n\n\tfor k := range oneSet.mem {\n\t\tif otherSet.mem[k] == false {\n\t\t\treturn false\n\t\t}\n\t}\n\t/* If the sets have an equal number of elements and an element in one of the\n\tsets is not in the other set, they are not equal. */\n\n\treturn true\n}", "id": 23481, "concepts": ["map iteration (range loop)", "set equality"], "_raw_llm_output": "map iteration (range loop), set equality"}
{"seed": "// NewListTaskNexusParamsWithContext creates a new ListTaskNexusParams object\n// with the default values initialized, and the ability to set a context for a request\nfunc NewListTaskNexusParamsWithContext(ctx context.Context) *ListTaskNexusParams {\n\n\treturn &ListTaskNexusParams{\n\n\t\tContext: ctx,\n\t}\n}", "id": 23498, "concepts": ["context package usage", "basic function definition"], "_raw_llm_output": "context package usage, basic function definition"}
{"seed": "// Ident registers the provided identities for service discovery.\n//\n// Most identities will be implemented by Handlers and do not need to be\n// registered again, Ident is just for features that should be advertised but do\n// not have any corresponding handler.\nfunc Ident(iter info.IdentityIter) Option {\n\tif iter == nil {\n\t\tpanic(\"mux: nil info.IdentityIter\")\n\t}\n\treturn func(m *ServeMux) {\n\t\tm.idents = append(m.idents, iter)\n\t}\n}", "id": 23501, "concepts": ["function definition", "function composition", "function option", "option pattern"], "_raw_llm_output": "function definition, function composition, function option, option pattern"}
{"seed": "// Decode an input using mapstruct decoder with strictness enabled, errors will be returned in\n// the case of unused fields.\nfunc strictDecode(input, out interface{}) error {\n\tstrictDecoder, err := mapstructure.NewDecoder(&mapstructure.DecoderConfig{\n\t\tErrorUnused: true,\n\t\tResult:      out,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn strictDecoder.Decode(input)\n}", "id": 23513, "concepts": ["mapstruct package usage", "strictness handling", "error handling"], "_raw_llm_output": "mapstruct package usage, strictness handling, error handling"}
{"seed": "// Optgroup_ is a convenience wrapper for Optgroup without the attrs argument.\nfunc Optgroup_(children ...HTML) HTML {\n  return Optgroup(nil, children...)\n}", "id": 23515, "concepts": ["struct composition", "anonymous function", "function composition"], "_raw_llm_output": "struct composition, anonymous function, function composition"}
{"seed": "// Rank returns a preconfigured all-round rank-based selection strategy, using\n// SUS (stochastic universal sampling) selection and MapRankToScore as mapping\n// function.\nfunc Rank[T any]() RankBased[T] {\n\treturn RankBased[T]{\n\t\tSelector: SUS[T]{},\n\t\tMap:      MapRankToScore,\n\t}\n}", "id": 23516, "concepts": ["generic programming", "SUS selection", "MapRankToScore mapping function"], "_raw_llm_output": "generic programming, SUS selection, MapRankToScore mapping function"}
{"seed": "// PossibleNotificationModeValues returns the possible values for the NotificationMode const type.\nfunc PossibleNotificationModeValues() []NotificationMode {\n\treturn []NotificationMode{\n\t\tNotificationModeEventHub,\n\t\tNotificationModeNotSpecified,\n\t\tNotificationModeWebHook,\n\t}\n}", "id": 23528, "concepts": ["const type", "possible values"], "_raw_llm_output": "const type, possible values"}
{"seed": "// NewSyncGroupsClient creates a new instance of SyncGroupsClient with the specified values.\n// subscriptionID - The subscription ID that identifies an Azure subscription.\n// credential - used to authorize requests. Usually a credential from azidentity.\n// options - pass nil to accept the default values.\nfunc NewSyncGroupsClient(subscriptionID string, credential azcore.TokenCredential, options *arm.ClientOptions) *SyncGroupsClient {\n\tcp := arm.ClientOptions{}\n\tif options != nil {\n\t\tcp = *options\n\t}\n\tif len(cp.Endpoint) == 0 {\n\t\tcp.Endpoint = arm.AzurePublicCloud\n\t}\n\tclient := &SyncGroupsClient{\n\t\tsubscriptionID: subscriptionID,\n\t\thost:           string(cp.Endpoint),\n\t\tpl:             armruntime.NewPipeline(moduleName, moduleVersion, credential, runtime.PipelineOptions{}, &cp),\n\t}\n\treturn client\n}", "id": 23533, "concepts": ["azure authentication", "azure SDK usage", "azure SDK initialization"], "_raw_llm_output": "azure authentication, azure SDK usage, azure SDK initialization"}
{"seed": "// ParseUpdatePrivateNetworkResponse parses an HTTP response from a UpdatePrivateNetworkWithResponse call\nfunc ParseUpdatePrivateNetworkResponse(rsp *http.Response) (*UpdatePrivateNetworkResponse, error) {\n\tbodyBytes, err := ioutil.ReadAll(rsp.Body)\n\tdefer rsp.Body.Close()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse := &UpdatePrivateNetworkResponse{\n\t\tBody:         bodyBytes,\n\t\tHTTPResponse: rsp,\n\t}\n\n\tswitch {\n\tcase strings.Contains(rsp.Header.Get(\"Content-Type\"), \"json\") && rsp.StatusCode == 200:\n\t\tvar dest Operation\n\t\tif err := json.Unmarshal(bodyBytes, &dest); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresponse.JSON200 = &dest\n\n\t}\n\n\treturn response, nil\n}", "id": 23535, "concepts": ["HTTP response parsing", "JSON parsing", "error handling"], "_raw_llm_output": "HTTP response parsing, JSON parsing, error handling"}
{"seed": "// NewLineRouteParamsWithContext creates a new LineRouteParams object\n// with the default values initialized, and the ability to set a context for a request\nfunc NewLineRouteParamsWithContext(ctx context.Context) *LineRouteParams {\n\tvar ()\n\treturn &LineRouteParams{\n\n\t\tContext: ctx,\n\t}\n}", "id": 23550, "concepts": ["context package usage", "struct definition", "method definition"], "_raw_llm_output": "context package usage, struct definition, method definition"}
{"seed": "// NewListInstancesParamsWithTimeout creates a new ListInstancesParams object\n// with the default values initialized, and the ability to set a timeout on a request\nfunc NewListInstancesParamsWithTimeout(timeout time.Duration) *ListInstancesParams {\n\tvar ()\n\treturn &ListInstancesParams{\n\n\t\ttimeout: timeout,\n\t}\n}", "id": 23551, "concepts": ["timeout handling", "function definition", "function return value", "function parameter"], "_raw_llm_output": "timeout handling, function definition, function return value, function parameter"}
{"seed": "// newChainsORM returns an chainsORM backed by q, for the table <prefix>_chains.\nfunc newChainsORM[I ID, C Config](q pg.Q, prefix string) *chainsORM[I, C] {\n\treturn &chainsORM[I, C]{q: q, prefix: prefix}\n}", "id": 23552, "concepts": ["generic type definition", "type alias", "type constraints", "type parameters"], "_raw_llm_output": "generic type definition, type alias, type constraints, type parameters"}
{"seed": "// PossibleCustomHTTPSProvisioningStateValues returns an array of possible values for the CustomHTTPSProvisioningState const type.\nfunc PossibleCustomHTTPSProvisioningStateValues() []CustomHTTPSProvisioningState {\n\treturn []CustomHTTPSProvisioningState{CustomHTTPSProvisioningStateDisabled, CustomHTTPSProvisioningStateDisabling, CustomHTTPSProvisioningStateEnabled, CustomHTTPSProvisioningStateEnabling, CustomHTTPSProvisioningStateFailed}\n}", "id": 23553, "concepts": ["enum", "const", "string comparison"], "_raw_llm_output": "enum, const, string comparison"}
{"seed": "/*\n\tNewTransferFromJson cria um objeto do tipo Transfer a partir de um json contendo os mesmos campos do tipo Transfer\n\n\tentrada:\n\t\t- json.Decoder\n\n\tsaida:\n\t\t- ponteiro para um Transfer\n\t\t- error\n*/\nfunc NewTransferFromJson(jsonDecoder *json.Decoder, token string) (*Transfer, error) {\n\n\tvar transfer Transfer\n\n\t// tenta decodificar o json da requsii\u00e7\u00e3o no objeto Transfer\n\tif err := jsonDecoder.Decode(&transfer); err != nil {\n\n\t\treturn &Transfer{}, fmt.Errorf(\"error to decode the json to the Transfer object: %s\", err.Error())\n\t}\n\n\t// verifica se a conta de destino realmente existe, se nao retorna erro\n\tif !(transfer.CheckIfAccountDestinationExists()) {\n\n\t\treturn &Transfer{}, fmt.Errorf(\"Account destination does not exists\")\n\t}\n\n\t// verifica se o ammount desejado \u00e9 maior que zero, afinal, quem realiza transf TIRA dinheiro da sua conta para outra, se nao retorna erro\n\tif !(transfer.CheckIfAmmountIsValid()) {\n\n\t\treturn &Transfer{}, fmt.Errorf(\"ammount desired to transfer is invalid. Provide an ammount greater than zero\")\n\t}\n\n\t// recupera a conta de origem, se nao retorna erro\n\tif err := transfer.FillAccountOriginId(token); err != nil {\n\n\t\treturn &Transfer{}, fmt.Errorf(\"cannot get the account origin from token: %s\", err.Error())\n\t}\n\n\t// como a transfer\u00eancia se inicia sempre por quem vai debitar, seta, ent\u00e3o, o ammount como negativo\n\ttransfer.Ammount = -transfer.Ammount\n\n\treturn &transfer, nil\n}", "id": 23558, "concepts": ["json decoding", "error handling", "pointer usage", "if statement", "function definition", "function return", "function call", "function definition", "function return", "function call", "function definition", "function return", "function call", "function definition", "function return", "function call", "function definition", "function return", "function call", "function definition", "function return", "function call", "function definition", "function return", "function call", "function definition", "function return", "function call", "function definition", "function return", "function call", "function definition", "function return", "function call", "function definition", "function return", "function call", "function definition", "function return", "function call", "function definition", "function return", "function call", "function definition", "function return", "function call", "function definition", "function return", "function call", "function definition", "function return", "function call", "function definition", "function return", "function call", "function definition", "function return", "function call", "function definition", "function return", "function call", "function definition", "function return", "function call", "function definition", "function return", "function call", "function definition", "function return", "function call", "function definition", "function return", "function call", "function definition", "function return", "function call", "function definition", "function return", "function call", "function definition", "function return", "function call", "function definition", "function return", "function call", ""], "_raw_llm_output": "json decoding, error handling, pointer usage, if statement, function definition, function return, function call, function definition, function return, function call, function definition, function return, function call, function definition, function return, function call, function definition, function return, function call, function definition, function return, function call, function definition, function return, function call, function definition, function return, function call, function definition, function return, function call, function definition, function return, function call, function definition, function return, function call, function definition, function return, function call, function definition, function return, function call, function definition, function return, function call, function definition, function return, function call, function definition, function return, function call, function definition, function return, function call, function definition, function return, function call, function definition, function return, function call, function definition, function return, function call, function definition, function return, function call, function definition, function return, function call, function definition, function return, function call, function definition, function return, function call, function definition, function return, function call, function definition, function return, function call, function definition, function return, function call,"}
{"seed": "// H3_ is a convenience wrapper for H3 without the attrs argument.\nfunc H3_(children ...HTML) HTML {\n  return H3(nil, children...)\n}", "id": 23560, "concepts": ["HTML", "HTML tag definition", "HTML tag usage", "HTML tag attribute definition", "HTML tag attribute usage"], "_raw_llm_output": "HTML, HTML tag definition, HTML tag usage, HTML tag attribute definition, HTML tag attribute usage"}
{"seed": "// SHA256 returns the SHA2-256 checksum of the data.\nfunc SHA256(data []byte) []byte {\n\tb := sha256.Sum256(data)\n\treturn b[:]\n}", "id": 23564, "concepts": ["cryptography", "SHA256 hashing", "crypto/sha256 package usage"], "_raw_llm_output": "cryptography, SHA256 hashing, crypto/sha256 package usage"}
{"seed": "// PossibleSKUScaleTypeValues returns the possible values for the SKUScaleType const type.\nfunc PossibleSKUScaleTypeValues() []SKUScaleType {\n\treturn []SKUScaleType{\n\t\tSKUScaleTypeAutomatic,\n\t\tSKUScaleTypeManual,\n\t\tSKUScaleTypeNone,\n\t}\n}", "id": 23577, "concepts": ["const type", "type conversion", "type assertion"], "_raw_llm_output": "const type, type conversion, type assertion"}
{"seed": "// GetPriorityLevelConfigurationPatch gets an existing PriorityLevelConfigurationPatch resource's state with the given name, ID, and optional\n// state properties that are used to uniquely qualify the lookup (nil if not required).\nfunc GetPriorityLevelConfigurationPatch(ctx *pulumi.Context,\n\tname string, id pulumi.IDInput, state *PriorityLevelConfigurationPatchState, opts ...pulumi.ResourceOption) (*PriorityLevelConfigurationPatch, error) {\n\tvar resource PriorityLevelConfigurationPatch\n\terr := ctx.ReadResource(\"kubernetes:flowcontrol.apiserver.k8s.io/v1beta3:PriorityLevelConfigurationPatch\", name, id, state, &resource, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &resource, nil\n}", "id": 23579, "concepts": ["resource definition", "resource state", "resource property access", "resource lookup", "resource creation", "resource deletion"], "_raw_llm_output": "resource definition, resource state, resource property access, resource lookup, resource creation, resource deletion"}
{"seed": "// BoolToString creates a binding that connects a Bool data item to a String.\n// Changes to the Bool will be pushed to the String and setting the string will parse and set the\n// Bool if the parse was successful.\n//\n// Since: 2.0\nfunc BoolToString(v Bool) String {\n\tstr := &stringFromBool{from: v}\n\tv.AddListener(str)\n\treturn str\n}", "id": 23583, "concepts": ["binding", "listener", "struct composition", "interface composition", "data type conversion"], "_raw_llm_output": "binding, listener, struct composition, interface composition, data type conversion"}
{"seed": "// BlobIsNil applies the IsNil predicate on the \"blob\" field.\nfunc BlobIsNil() predicate.User {\n\treturn predicate.User(sql.FieldIsNull(FieldBlob))\n}", "id": 23585, "concepts": ["predicate", "predicate.User", "sql.FieldIsNull", "sql.Field"], "_raw_llm_output": "predicate, predicate.User, sql.FieldIsNull, sql.Field"}
{"seed": "// RTWithErrorCheck specifies a function fn which determines whether the passed\n// error should be marked as an error. The fn is called whenever an http operation\n// finishes with an error\nfunc RTWithErrorCheck(fn func(err error) bool) RoundTripperOption {\n\treturn func(cfg *roundTripperConfig) {\n\t\tcfg.errCheck = fn\n\t}\n}", "id": 23587, "concepts": ["function definition", "function composition", "function options", "function options composition", "function options usage", "function options composition"], "_raw_llm_output": "function definition, function composition, function options, function options composition, function options usage, function options composition"}
{"seed": "// Dt_ is a convenience wrapper for Dt without the attrs argument.\nfunc Dt_(children ...HTML) HTML {\n  return Dt(nil, children...)\n}", "id": 23603, "concepts": ["HTML", "function definition", "function argument", "function return value", "function call"], "_raw_llm_output": "HTML, function definition, function argument, function return value, function call"}
{"seed": "// MaxBackground sets the maximum number of FUSE requests the kernel\n// will submit in the background. Background requests are used when an\n// immediate answer is not needed. This may help with request latency.\n//\n// On Linux, this can be adjusted on the fly with\n// /sys/fs/fuse/connections/CONN/max_background\nfunc MaxBackground(n uint16) MountOption {\n\treturn func(conf *mountConfig) error {\n\t\tconf.maxBackground = n\n\t\treturn nil\n\t}\n}", "id": 23613, "concepts": ["function definition", "function composition", "function options", "function composition", "function options", "function composition"], "_raw_llm_output": "function definition, function composition, function options, function composition, function options, function composition"}
{"seed": "// RefreshTokenRequest returns OAuth 2 access and refresh tokens, given the right details:\n//\n//\tbasically, a `refresh token` from `AccessTokenRequest`\nfunc RefreshTokenRequest(data utils.H) (utils.H, error) {\n\tvar user models.User\n\tvar client models.Client\n\n\tvar token string\n\tvar scope string\n\n\tif data[\"refresh_token\"] == nil || data[\"scope\"] == nil || data[\"client\"] == nil {\n\t\treturn invalidRequestResult(\"\")\n\t}\n\n\ttoken = data[\"refresh_token\"].(string)\n\tscope = data[\"scope\"].(string)\n\tclient = data[\"client\"].(models.Client)\n\n\trefreshSession := services.FindSessionByToken(token, models.RefreshToken)\n\tdefer services.InvalidateSession(refreshSession)\n\tif refreshSession.ID == 0 {\n\t\treturn invalidGrantResult(\"\")\n\t}\n\tuser = refreshSession.User\n\tuser = services.FindUserByPublicID(user.PublicID)\n\tif refreshSession.Client.ID != client.ID {\n\t\treturn invalidGrantResult(\"\")\n\t}\n\tif scope != refreshSession.Scopes {\n\t\treturn invalidScopeResult(\"\")\n\t}\n\n\taccessToken := services.CreateSession(user,\n\t\tclient,\n\t\trefreshSession.IP,\n\t\trefreshSession.UserAgent,\n\t\tscope,\n\t\tmodels.AccessToken)\n\trefreshToken := services.CreateSession(user,\n\t\tclient,\n\t\trefreshSession.IP,\n\t\trefreshSession.UserAgent,\n\t\tscope,\n\t\tmodels.RefreshToken)\n\n\tif accessToken.ID == 0 || refreshToken.ID == 0 {\n\t\treturn serverErrorResult(\"\")\n\t}\n\n\treturn utils.H{\n\t\t\"user_id\":       user.PublicID,\n\t\t\"access_token\":  accessToken.Token,\n\t\t\"token_type\":    \"Bearer\",\n\t\t\"expires_in\":    accessToken.ExpiresIn,\n\t\t\"refresh_token\": refreshToken.Token,\n\t\t\"scope\":         refreshSession.Scopes,\n\t}, nil\n}", "id": 23614, "concepts": ["error handling (errors.Is)", "string formatting", "map iteration", "map creation", "map lookup", "map update", "map deletion", "basic function definition", "basic function return", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function parameter", "basic function"], "_raw_llm_output": "error handling (errors.Is), string formatting, map iteration, map creation, map lookup, map update, map deletion, basic function definition, basic function return, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function parameter, basic function"}
{"seed": "// FloatEncode encodes a float64 from sign, fraction and exponent values.\nfunc FloatEncode(s int, f uint64, e int) float64 {\n\ts &= 1\n\texp := uint64(e+1023) & ((1 << 11) - 1)\n\tf &= (1 << 52) - 1\n\treturn math.Float64frombits(uint64(s)<<63 | exp<<52 | f)\n}", "id": 23620, "concepts": ["bitwise operations", "bit shifting", "bit masking", "integer encoding"], "_raw_llm_output": "bitwise operations, bit shifting, bit masking, integer encoding"}
{"seed": "// GetDeviceJSONInfo returns the device data in JSON format.\n// Returns an error if there is an ongoing reload.\nfunc GetDeviceJSONInfo(id string) ([]byte, error) {\n\tvar dev *device.SnmpDevice\n\tvar ok bool\n\tif CheckReloadProcess() == true {\n\t\tlog.Warning(\"There is a reload process running while trying to get device info\")\n\t\treturn nil, fmt.Errorf(\"There is a reload process running.... please wait until finished \")\n\t}\n\tmutex.RLock()\n\tdefer mutex.RUnlock()\n\tif dev, ok = devices[id]; !ok {\n\t\treturn nil, fmt.Errorf(\"there is not any device with id %s running\", id)\n\t}\n\treturn dev.ToJSON()\n}", "id": 23627, "concepts": ["map iteration (range loop)", "mutexes", "standard library usage (fmt", "errors)", "error handling (idiomatic if err != nil", "errors.Is", "errors.As)", "concurrency patterns (mutexes)", "concurrency", "error handling"], "_raw_llm_output": "map iteration (range loop), mutexes, standard library usage (fmt, errors), error handling (idiomatic if err != nil, errors.Is, errors.As), concurrency patterns (mutexes), concurrency, error handling"}
{"seed": "// IsMethodSafe reports whether the HTTP method is considered safe.\n// See https://datatracker.ietf.org/doc/html/rfc9110#section-9.2.1\nfunc IsMethodSafe(m string) bool {\n\tswitch m {\n\tcase MethodGet,\n\t\tMethodHead,\n\t\tMethodOptions,\n\t\tMethodTrace:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}", "id": 23632, "concepts": ["string comparison", "switch statement", "string manipulation"], "_raw_llm_output": "string comparison, switch statement, string manipulation"}
{"seed": "// Tally reads all scores from r and writes the final tournament table to w.\n// Returns an error for invalid input.\nfunc Tally(r io.Reader, w io.Writer) error {\n\tvar scores []score\n\tsc := bufio.NewScanner(r)\n\tfor sc.Scan() {\n\t\ttext := strings.TrimSpace(sc.Text())\n\t\tif len(text) == 0 || text[0] == '#' {\n\t\t\tcontinue // ignore empty lines and comment lines\n\t\t}\n\n\t\ts, err := parse(text)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tscores = append(scores, *s)\n\t}\n\n\tt := &tournament{internal: map[string]*teamScore{}}\n\tfor _, s := range scores {\n\t\tt.add(s)\n\t}\n\n\treturn t.print(w)\n}", "id": 23639, "concepts": ["string manipulation", "string parsing", "string trimming", "io.Reader", "io.Writer", "io.Scanner", "io.Writer", "map", "slice", "basic function definition"], "_raw_llm_output": "string manipulation, string parsing, string trimming, io.Reader, io.Writer, io.Scanner, io.Writer, map, slice, basic function definition"}
{"seed": "// LogToken records information about the token in the BigQuery.\n//\n// The signed token itself is not logged. Only first 16 bytes of its SHA256 hash\n// (aka 'fingerprint') is. It is used only to identify this particular token in\n// logs.\n//\n// On dev server, logs to the GAE log only, not to BigQuery (to avoid\n// accidentally pushing fake data to real BigQuery dataset).\nfunc LogToken(c context.Context, i *MintedTokenInfo) error {\n\trow := i.toBigQueryRow()\n\tif info.IsDevAppServer(c) {\n\t\tblob, err := json.MarshalIndent(row, \"\", \"  \")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tlogging.Debugf(c, \"BigQuery log row:\\n%s\", blob)\n\t\treturn nil\n\t}\n\treturn delegationTokensLog.Insert(c, bqlog.Entry{Data: row})\n}", "id": 23641, "concepts": ["context package usage", "BigQuery API usage", "JSON marshalling", "logging"], "_raw_llm_output": "context package usage, BigQuery API usage, JSON marshalling, logging"}
{"seed": "// BufferNotNil applies the NotNil predicate on the \"buffer\" field.\nfunc BufferNotNil() predicate.User {\n\treturn predicate.User(sql.FieldNotNull(FieldBuffer))\n}", "id": 23644, "concepts": ["sql package usage", "predicate.User", "sql.FieldNotNull"], "_raw_llm_output": "sql package usage, predicate.User, sql.FieldNotNull"}
{"seed": "// HMACHeader generates a X-Hub-Signature header given a secret token and the request body\n// See https://developer.github.com/webhooks/securing/#validating-payloads-from-github\nfunc HMACHeader(secret string, body []byte) (string, error) {\n\th := hmac.New(sha1.New, []byte(secret))\n\t_, err := h.Write(body)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn fmt.Sprintf(\"sha1=%s\", hex.EncodeToString(h.Sum(nil))), nil\n}", "id": 23652, "concepts": ["cryptography (hmac.New)", "cryptographic hash functions (sha1.New)", "cryptographic hash functions (hex.EncodeToString)", "basic function definition"], "_raw_llm_output": "cryptography (hmac.New), cryptographic hash functions (sha1.New), cryptographic hash functions (hex.EncodeToString), basic function definition"}
{"seed": "// WithSpanOptions defines a set of additional ddtrace.StartSpanOption to be added\n// to spans started by the integration.\nfunc WithSpanOptions(opts ...ddtrace.StartSpanOption) Option {\n\treturn func(cfg *config) {\n\t\tcfg.spanOpts = append(cfg.spanOpts, opts...)\n\t}\n}", "id": 23659, "concepts": ["ddtrace.StartSpanOption", "function definition", "function composition"], "_raw_llm_output": "ddtrace.StartSpanOption, function definition, function composition"}
{"seed": "// MapUintUint16Ptr takes two inputs -\n// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list\nfunc MapUintUint16Ptr(f func(*uint) *uint16, list []*uint) []*uint16 {\n\tif f == nil {\n\t\treturn []*uint16{}\n\t}\n\tnewList := make([]*uint16, len(list))\n\tfor i, v := range list {\n\t\tnewList[i] = f(v)\n\t}\n\treturn newList\n}", "id": 23661, "concepts": ["function definition", "function composition", "pointer handling", "function composition", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", "pointer handling", ""], "_raw_llm_output": "function definition, function composition, pointer handling, function composition, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling, pointer handling,"}
{"seed": "// GetDiagnosticsProfile converts a CAPZ Diagnostics option to a Azure SDK Diagnostics Profile.\nfunc GetDiagnosticsProfile(diagnostics *infrav1.Diagnostics) *compute.DiagnosticsProfile {\n\tif diagnostics != nil && diagnostics.Boot != nil {\n\t\tswitch diagnostics.Boot.StorageAccountType {\n\t\tcase infrav1.DisabledDiagnosticsStorage:\n\t\t\treturn &compute.DiagnosticsProfile{\n\t\t\t\tBootDiagnostics: &compute.BootDiagnostics{\n\t\t\t\t\tEnabled: ptr.To(false),\n\t\t\t\t},\n\t\t\t}\n\t\tcase infrav1.ManagedDiagnosticsStorage:\n\t\t\treturn &compute.DiagnosticsProfile{\n\t\t\t\tBootDiagnostics: &compute.BootDiagnostics{\n\t\t\t\t\tEnabled: ptr.To(true),\n\t\t\t\t},\n\t\t\t}\n\t\tcase infrav1.UserManagedDiagnosticsStorage:\n\t\t\treturn &compute.DiagnosticsProfile{\n\t\t\t\tBootDiagnostics: &compute.BootDiagnostics{\n\t\t\t\t\tEnabled:    ptr.To(true),\n\t\t\t\t\tStorageURI: &diagnostics.Boot.UserManaged.StorageAccountURI,\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}", "id": 23668, "concepts": ["switch statement", "pointer dereference", "pointer usage", "nil pointer dereference", "pointer comparison", "pointer assignment", "pointer equality", "pointer comparison", "pointer assignment", "pointer equality", "pointer comparison", "pointer assignment", "pointer equality", "pointer comparison", "pointer assignment", "pointer equality", "pointer comparison", "pointer assignment", "pointer equality", "pointer comparison", "pointer assignment", "pointer equality", "pointer comparison", "pointer assignment", "pointer equality", "pointer comparison", "pointer assignment", "pointer equality", "pointer comparison", "pointer assignment", "pointer equality", "pointer comparison", "pointer assignment", "pointer equality", "pointer comparison", "pointer assignment", "pointer equality", "pointer comparison", "pointer assignment", "pointer equality", "pointer comparison", "pointer assignment", "pointer equality", "pointer comparison", "pointer assignment", "pointer equality", "pointer comparison", "pointer assignment", "pointer equality", "pointer comparison", "pointer assignment", "pointer equality", "pointer comparison", "pointer assignment", "pointer equality", "pointer comparison", "pointer assignment", "pointer equality", "pointer comparison", "pointer assignment", "pointer equality", "pointer comparison", "pointer assignment", "pointer equality", "pointer comparison", "pointer assignment", "pointer equality", "pointer comparison", "pointer assignment", "pointer equality", "pointer comparison", "pointer assignment", "pointer equality", "pointer comparison", "pointer assignment", "pointer equality", "pointer comparison", "pointer assignment", "pointer equality", "pointer comparison", "pointer assignment", "pointer equality", "pointer comparison", "pointer assignment", ""], "_raw_llm_output": "switch statement, pointer dereference, pointer usage, nil pointer dereference, pointer comparison, pointer assignment, pointer equality, pointer comparison, pointer assignment, pointer equality, pointer comparison, pointer assignment, pointer equality, pointer comparison, pointer assignment, pointer equality, pointer comparison, pointer assignment, pointer equality, pointer comparison, pointer assignment, pointer equality, pointer comparison, pointer assignment, pointer equality, pointer comparison, pointer assignment, pointer equality, pointer comparison, pointer assignment, pointer equality, pointer comparison, pointer assignment, pointer equality, pointer comparison, pointer assignment, pointer equality, pointer comparison, pointer assignment, pointer equality, pointer comparison, pointer assignment, pointer equality, pointer comparison, pointer assignment, pointer equality, pointer comparison, pointer assignment, pointer equality, pointer comparison, pointer assignment, pointer equality, pointer comparison, pointer assignment, pointer equality, pointer comparison, pointer assignment, pointer equality, pointer comparison, pointer assignment, pointer equality, pointer comparison, pointer assignment, pointer equality, pointer comparison, pointer assignment, pointer equality, pointer comparison, pointer assignment, pointer equality, pointer comparison, pointer assignment, pointer equality, pointer comparison, pointer assignment, pointer equality, pointer comparison, pointer assignment, pointer equality, pointer comparison, pointer assignment, pointer equality, pointer comparison, pointer assignment,"}
{"seed": "// bigPow returns a ** b as a big integer.\nfunc bigPow(a, b int64) *big.Int {\n\tr := big.NewInt(a)\n\treturn r.Exp(r, big.NewInt(b), nil)\n}", "id": 23679, "concepts": ["big.Int package usage", "integer exponentiation"], "_raw_llm_output": "big.Int package usage, integer exponentiation"}
{"seed": "// CreateRunMedQAResponse creates a response to parse from RunMedQA response\nfunc CreateRunMedQAResponse() (response *RunMedQAResponse) {\n\tresponse = &RunMedQAResponse{\n\t\tBaseResponse: &responses.BaseResponse{},\n\t}\n\treturn\n}", "id": 23682, "concepts": ["struct definition", "struct initialization", "struct field access"], "_raw_llm_output": "struct definition, struct initialization, struct field access"}
{"seed": "// NewBasicRemainingPdbTracker returns a new instance of basicRemainingPdbTracker\nfunc NewBasicRemainingPdbTracker() *basicRemainingPdbTracker {\n\treturn &basicRemainingPdbTracker{}\n}", "id": 23690, "concepts": ["struct definition", "basic function definition"], "_raw_llm_output": "struct definition, basic function definition"}
{"seed": "// GetStandardInfraConfig gets an existing StandardInfraConfig resource's state with the given name, ID, and optional\n// state properties that are used to uniquely qualify the lookup (nil if not required).\nfunc GetStandardInfraConfig(ctx *pulumi.Context,\n\tname string, id pulumi.IDInput, state *StandardInfraConfigState, opts ...pulumi.ResourceOption) (*StandardInfraConfig, error) {\n\tvar resource StandardInfraConfig\n\terr := ctx.ReadResource(\"kubernetes:admin.enmasse.io/v1beta1:StandardInfraConfig\", name, id, state, &resource, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &resource, nil\n}", "id": 23693, "concepts": ["pulumi.ResourceOption", "pulumi.Resource", "pulumi.ResourceOption", "pulumi.Resource", "pulumi.ResourceOption", "pulumi.Resource", "pulumi.ResourceOption", "pulumi.Resource", "pulumi.ResourceOption", "pulumi.Resource", "pulumi.ResourceOption", "pulumi.Resource", "pulumi.ResourceOption", "pulumi.Resource", "pulumi.ResourceOption", "pulumi.Resource", "pulumi.ResourceOption", "pulumi.Resource", "pulumi.ResourceOption", "pulumi.Resource", "pulumi.ResourceOption", "pulumi.Resource", "pulumi.ResourceOption", "pulumi.Resource", "pulumi.ResourceOption", "pulumi.Resource", "pulumi.ResourceOption", "pulumi.Resource", "pulumi.ResourceOption", "pulumi.Resource", "pulumi.ResourceOption", "pulumi.Resource", "pulumi.ResourceOption", "pulumi.Resource", "pulumi.ResourceOption", "pulumi.Resource", "pulumi.ResourceOption", "pulumi.Resource", "pulumi.ResourceOption", "pulumi.Resource", "pulumi.ResourceOption", "pulumi.Resource", "pulumi.ResourceOption", "pulumi.Resource", "pulumi.ResourceOption", "pulumi.Resource", "pulumi.ResourceOption", "pulumi.Resource", "pulumi.ResourceOption", "pulumi.Resource", "pulumi.ResourceOption", "pulumi.Resource", "pulumi.ResourceOption", "pulumi.Resource", "pulumi.ResourceOption", "pulumi.Resource", "pulumi.Resource"], "_raw_llm_output": "pulumi.ResourceOption, pulumi.Resource, pulumi.ResourceOption, pulumi.Resource, pulumi.ResourceOption, pulumi.Resource, pulumi.ResourceOption, pulumi.Resource, pulumi.ResourceOption, pulumi.Resource, pulumi.ResourceOption, pulumi.Resource, pulumi.ResourceOption, pulumi.Resource, pulumi.ResourceOption, pulumi.Resource, pulumi.ResourceOption, pulumi.Resource, pulumi.ResourceOption, pulumi.Resource, pulumi.ResourceOption, pulumi.Resource, pulumi.ResourceOption, pulumi.Resource, pulumi.ResourceOption, pulumi.Resource, pulumi.ResourceOption, pulumi.Resource, pulumi.ResourceOption, pulumi.Resource, pulumi.ResourceOption, pulumi.Resource, pulumi.ResourceOption, pulumi.Resource, pulumi.ResourceOption, pulumi.Resource, pulumi.ResourceOption, pulumi.Resource, pulumi.ResourceOption, pulumi.Resource, pulumi.ResourceOption, pulumi.Resource, pulumi.ResourceOption, pulumi.Resource, pulumi.ResourceOption, pulumi.Resource, pulumi.ResourceOption, pulumi.Resource, pulumi.ResourceOption, pulumi.Resource, pulumi.ResourceOption, pulumi.Resource, pulumi.ResourceOption, pulumi.Resource, pulumi.ResourceOption, pulumi.Resource, pulumi.Resource"}
{"seed": "// NewGetFileSystemParametersInternalParamsWithTimeout creates a new GetFileSystemParametersInternalParams object\n// with the default values initialized, and the ability to set a timeout on a request\nfunc NewGetFileSystemParametersInternalParamsWithTimeout(timeout time.Duration) *GetFileSystemParametersInternalParams {\n\tvar (\n\t\tattachedClusterDefault = bool(false)\n\t\tsecureDefault          = bool(false)\n\t)\n\treturn &GetFileSystemParametersInternalParams{\n\t\tAttachedCluster: &attachedClusterDefault,\n\t\tSecure:          &secureDefault,\n\n\t\ttimeout: timeout,\n\t}\n}", "id": 23700, "concepts": ["struct definition", "pointer usage", "default values", "timeout handling"], "_raw_llm_output": "struct definition, pointer usage, default values, timeout handling"}
{"seed": "// SocialEmailLTE applies the LTE predicate on the \"social_email\" field.\nfunc SocialEmailLTE(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.LTE(s.C(FieldSocialEmail), v))\n\t})\n}", "id": 23714, "concepts": ["SQL query generation", "SQL query generation (predicate)", "SQL query generation (field)", "SQL query generation (comparison)"], "_raw_llm_output": "SQL query generation, SQL query generation (predicate), SQL query generation (field), SQL query generation (comparison)"}
{"seed": "// Int64s builds a chain from the given int64 values.\nfunc Int64s(xs ...int64) Chain {\n\treturn Chain(bigints.Int64s(xs...))\n}", "id": 23723, "concepts": ["big.Int", "big.Int.SetInt64", "big.Int.SetBytes", "big.Int.Bytes", "big.Int.String", "big.Int.SetBytes", "big.Int.Cmp", "big.Int.Add", "big.Int.Mul", "big.Int.Mod", "big.Int.ModInverse", "big.Int.ModSqrt", "big.Int.Exp", "big.Int.ExpMod", "big.Int.DivMod", "big.Int.GCD", "big.Int.Mod", "big.Int.ModInverse", "big.Int.ModSqrt", "big.Int.Exp", "big.Int.ExpMod", "big.Int.DivMod", "big.Int.GCD", "big.Int.Mod", "big.Int.ModInverse", "big.Int.ModSqrt", "big.Int.Exp", "big.Int.ExpMod", "big.Int.DivMod", "big.Int.GCD", "big.Int.Mod", "big.Int.ModInverse", "big.Int.ModSqrt", "big.Int.Exp", "big.Int.ExpMod", "big.Int.DivMod", "big.Int.GCD", "big.Int.Mod", "big.Int."], "_raw_llm_output": "big.Int, big.Int.SetInt64, big.Int.SetBytes, big.Int.Bytes, big.Int.String, big.Int.SetBytes, big.Int.Cmp, big.Int.Add, big.Int.Mul, big.Int.Mod, big.Int.ModInverse, big.Int.ModSqrt, big.Int.Exp, big.Int.ExpMod, big.Int.DivMod, big.Int.GCD, big.Int.Mod, big.Int.ModInverse, big.Int.ModSqrt, big.Int.Exp, big.Int.ExpMod, big.Int.DivMod, big.Int.GCD, big.Int.Mod, big.Int.ModInverse, big.Int.ModSqrt, big.Int.Exp, big.Int.ExpMod, big.Int.DivMod, big.Int.GCD, big.Int.Mod, big.Int.ModInverse, big.Int.ModSqrt, big.Int.Exp, big.Int.ExpMod, big.Int.DivMod, big.Int.GCD, big.Int.Mod, big.Int."}
{"seed": "// Lint runs List, Parse, Build, and LintMap with the given pkgSpec. The current\n// working dir helps create paths in the output that are short but can be opened\n// directly.\nfunc Lint(pkgSpec string, cwd string) ([]Failure, error) {\n\tpkgs, err := List(pkgSpec, cwd)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"List\")\n\t}\n\tmNoEscape, err := Parse(pkgs...)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"Parse\")\n\t}\n\n\tmEscape, err := Build(pkgs...)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"Build\")\n\t}\n\n\treturn LintMap(mNoEscape, mEscape), nil\n}", "id": 23728, "concepts": ["error handling (idiomatic `if err != nil`", "`errors.Wrap`)", "string manipulation", "map iteration", "map usage", "standard library usage"], "_raw_llm_output": "error handling (idiomatic `if err != nil`, `errors.Wrap`), string manipulation, map iteration, map usage, standard library usage"}
{"seed": "// WithFactions middleware finds factions according to the optional :commanderID URL parameter and\n// the optional \"page\" query parameter (falling back to 1), and sets them into ctx.Locals under the\n// key \"factions\". When present, it will also use the \"name\" and \"summary\" query parameters to\n// refine this search\nfunc WithFactions(r factions.Reader) func(*fiber.Ctx) error {\n\treturn func(ctx *fiber.Ctx) error {\n\t\tquery := factions.FindManyQuery{\n\t\t\tName:        ctx.Query(\"name\"),\n\t\t\tSummary:     ctx.Query(\"summary\"),\n\t\t\tCommanderID: commanderIDFromLocals(ctx),\n\t\t}\n\t\tfactions, pages, err := r.FindMany(query, pageFromLocals(ctx))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Set(\"x-pages\", fmt.Sprint(pages))\n\t\tctx.Locals(\"factions\", factions)\n\t\treturn ctx.Next()\n\t}\n}", "id": 23731, "concepts": ["middleware", "fiber package usage", "context", "query parameters", "local variables"], "_raw_llm_output": "middleware, fiber package usage, context, query parameters, local variables"}
{"seed": "// SupportsNativeDocker determines if the runtime OS support docker natively,\n// versus needing to run docker in a virtual machine\nfunc SupportsNativeDocker() bool {\n\treturn IsLinux()\n}", "id": 23732, "concepts": ["OS detection", "boolean logic"], "_raw_llm_output": "OS detection, boolean logic"}
{"seed": "// PropValStrs is the same as PropValStr, except that it returns a slice\n// of strings. The raw byte string is a sequence of null terminated strings,\n// which is translated into a slice of strings.\nfunc PropValStrs(reply *xproto.GetPropertyReply, err error) ([]string, error) {\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif reply.Format != 8 {\n\t\treturn nil, fmt.Errorf(\"PropValStrs: Expected format 8 but got %d\",\n\t\t\treply.Format)\n\t}\n\n\tvar strs []string\n\tsstart := 0\n\tfor i, c := range reply.Value {\n\t\tif c == 0 {\n\t\t\tstrs = append(strs, string(reply.Value[sstart:i]))\n\t\t\tsstart = i + 1\n\t\t}\n\t}\n\tif sstart < int(reply.ValueLen) {\n\t\tstrs = append(strs, string(reply.Value[sstart:]))\n\t}\n\treturn strs, nil\n}", "id": 23745, "concepts": ["slice definition", "slice iteration (range loop)", "string manipulation", "byte handling", "error handling"], "_raw_llm_output": "slice definition, slice iteration (range loop), string manipulation, byte handling, error handling"}
{"seed": "// Prefix sets the prefix to use.\n// Can be called multiple times to set multiple prefixes.\nfunc Prefix(s string) Option {\n\treturn optionFunc(func(l *lineWriter) {\n\t\tl.prefixes = append(l.prefixes, func() string { return s })\n\t})\n}", "id": 23750, "concepts": ["function composition", "function composition as a function argument", "function composition as a return value"], "_raw_llm_output": "function composition, function composition as a function argument, function composition as a return value"}
{"seed": "// Represents this tree\n// https://cdn-images-1.medium.com/max/1600/1*lSx54zw4tzOOE09uJdgltg.jpeg\nfunc fixtureOne() btree.BTree {\n\tnode4 := btree.Node{Keys: []int{4}, Children: []*btree.Node{}}\n\tnode815 := btree.Node{Keys: []int{8, 15}, Children: []*btree.Node{}}\n\tnode6 := btree.Node{Keys: []int{6}, Children: []*btree.Node{&node4, &node815}}\n\tnode4.Parent = &node6\n\tnode815.Parent = &node6\n\n\tnode25 := btree.Node{Keys: []int{25}, Children: []*btree.Node{}}\n\tnode31 := btree.Node{Keys: []int{31}, Children: []*btree.Node{}}\n\tnode29 := btree.Node{Keys: []int{29}, Children: []*btree.Node{&node25, &node31}}\n\tnode31.Parent = &node29\n\tnode25.Parent = &node29\n\n\tnode39 := btree.Node{Keys: []int{39}, Children: []*btree.Node{}}\n\tnode4850 := btree.Node{Keys: []int{48, 50}, Children: []*btree.Node{}}\n\tnode40 := btree.Node{Keys: []int{40}, Children: []*btree.Node{&node39, &node4850}}\n\tnode39.Parent = &node40\n\tnode4850.Parent = &node40\n\n\tnode2236 := btree.Node{Keys: []int{22, 36}, Children: []*btree.Node{&node6, &node29, &node40}}\n\tnode40.Parent = &node2236\n\tnode29.Parent = &node2236\n\tnode6.Parent = &node2236\n\n\treturn btree.BTree{3, &node2236}\n}", "id": 23752, "concepts": ["tree traversal", "tree traversal with recursion", "tree traversal with iteration", "tree traversal with pointers", "tree traversal with pointers and recursion", "tree traversal with pointers and iteration", "tree traversal with pointers and iteration and recursion", "tree traversal with pointers and iteration and recursion and pointers", "tree traversal with pointers and iteration and recursion and pointers and pointers", "tree traversal with pointers and iteration and recursion and pointers and pointers and pointers", "tree traversal with pointers and iteration and recursion and pointers and pointers and pointers and pointers", "tree traversal with pointers and iteration and recursion and pointers and pointers and pointers and pointers and pointers", "tree traversal with pointers and iteration and recursion and pointers and pointers and pointers and pointers and pointers and pointers", "tree traversal with pointers and iteration and recursion and pointers and pointers and pointers and pointers and pointers and pointers and pointers", "tree traversal with pointers and iteration and recursion and pointers and pointers and pointers and pointers and pointers and pointers and pointers and pointers", "tree traversal with pointers and iteration and recursion and pointers and pointers and pointers and pointers and pointers and pointers and pointers and pointers and pointers", "tree traversal with pointers and iteration and recursion and pointers and pointers and pointers and pointers and pointers and pointers and pointers and pointers and pointers and pointers", "tree traversal with pointers and iteration and recursion and pointers and pointers and pointers"], "_raw_llm_output": "tree traversal, tree traversal with recursion, tree traversal with iteration, tree traversal with pointers, tree traversal with pointers and recursion, tree traversal with pointers and iteration, tree traversal with pointers and iteration and recursion, tree traversal with pointers and iteration and recursion and pointers, tree traversal with pointers and iteration and recursion and pointers and pointers, tree traversal with pointers and iteration and recursion and pointers and pointers and pointers, tree traversal with pointers and iteration and recursion and pointers and pointers and pointers and pointers, tree traversal with pointers and iteration and recursion and pointers and pointers and pointers and pointers and pointers, tree traversal with pointers and iteration and recursion and pointers and pointers and pointers and pointers and pointers and pointers, tree traversal with pointers and iteration and recursion and pointers and pointers and pointers and pointers and pointers and pointers and pointers, tree traversal with pointers and iteration and recursion and pointers and pointers and pointers and pointers and pointers and pointers and pointers and pointers, tree traversal with pointers and iteration and recursion and pointers and pointers and pointers and pointers and pointers and pointers and pointers and pointers and pointers, tree traversal with pointers and iteration and recursion and pointers and pointers and pointers and pointers and pointers and pointers and pointers and pointers and pointers and pointers, tree traversal with pointers and iteration and recursion and pointers and pointers and pointers"}
{"seed": "// GetPlanFilename returns the filename (not the path) of the generated tf plan\n// given a workspace and project name.\nfunc GetPlanFilename(workspace string, projName string) string {\n\tif projName == \"\" {\n\t\treturn fmt.Sprintf(\"%s.tfplan\", workspace)\n\t}\n\tprojName = strings.Replace(projName, \"/\", planfileSlashReplace, -1)\n\treturn fmt.Sprintf(\"%s-%s.tfplan\", projName, workspace)\n}", "id": 23754, "concepts": ["string manipulation", "string concatenation", "string replacement"], "_raw_llm_output": "string manipulation, string concatenation, string replacement"}
{"seed": "// See 'Grayscale Image Display' under\n// https://dgobbi.github.io/vtk-dicom/doc/api/image_display.html . In addition,\n// we also scale the output so that it is appropriate for producing a 16-bit\n// grayscale image. E.g., if the native dicom is 8-bit, we still rescale the\n// output here for a 16-bit format. In the future, could produce 8-bit files\n// where possible, in which case this function would need to be changed.\nfunc ApplyOfficialWindowScaling(storedValue int, rescaleSlope, rescaleIntercept, windowWidth, windowCenter float64, bitsAllocated uint16) uint16 {\n\t// 1: StoredValue to ModalityValue\n\tvar modalityValue float64\n\tif rescaleSlope == 0 {\n\t\t// Via https://dgobbi.github.io/vtk-dicom/doc/api/image_display.html :\n\t\t// For modalities such as ultrasound and MRI that do not have any units,\n\t\t// the RescaleSlope and RescaleIntercept are absent and the Modality\n\t\t// Values are equal to the Stored Values.\n\t\tmodalityValue = float64(storedValue)\n\t} else {\n\t\t// Otherwise, we can apply the rescale slope and intercept to the stored\n\t\t// value.\n\t\tmodalityValue = float64(storedValue)*rescaleSlope + rescaleIntercept\n\t}\n\n\t// 2: ModalityValue to WindowedValue\n\n\t// The key here is that we're using bitsAllocated (e.g., 16 bits) instead of\n\t// bitsStored (e.g., 11 bits)\n\tvar grayLevels float64\n\tswitch bitsAllocated {\n\t// Precompute common cases so you're not exponentiating in the hot path\n\tcase 16:\n\t\tgrayLevels = 65536\n\tcase 8:\n\t\tgrayLevels = 256\n\tdefault:\n\t\tgrayLevels = math.Pow(2, float64(bitsAllocated))\n\t}\n\n\t// We are creating a 16-bit image, so we need to scale the modality value to\n\t// the range of 0-65535. Particularly if we're using 8-bit, then we need to\n\t// scale the 0-255 range to 0-65535, otherwise the images will look black.\n\tsixteenBitCorrection := math.MaxUint16 / uint16(grayLevels-1)\n\n\t// Via https://dgobbi.github.io/vtk-dicom/doc/api/image_display.html : For\n\t// ultrasound (and for 8-bit images in general) the WindowWidth and\n\t// WindowCenter may be absent from the file. If absent, they can be assumed\n\t// to be 256 and 128 respectively, which provides an 8-bit identity mapping.\n\t// Here, instead of assuming 8 bit, we use the grayLevels value.\n\tif windowWidth == 0 && windowCenter == 0 {\n\t\twindowWidth = grayLevels\n\t\twindowCenter = grayLevels / 2\n\t}\n\n\tw := windowWidth - 1.0\n\tc := windowCenter - 0.5\n\n\t// Below the lower bound of our window, draw black\n\tif modalityValue <= c-0.5*w {\n\t\treturn 0\n\t}\n\n\t// Above the upper bound of our window, draw white\n\tif modalityValue > c+0.5*w {\n\t\treturn uint16(grayLevels-1.0) * sixteenBitCorrection\n\t}\n\n\t// Within the window, return a scaled value\n\treturn uint16(((modalityValue-c)/w+0.5)*(grayLevels-1.0)) * sixteenBitCorrection\n\n}", "id": 23757, "concepts": ["floating point math", "bit shifting", "integer division", "integer multiplication", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer"], "_raw_llm_output": "floating point math, bit shifting, integer division, integer multiplication, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer"}
{"seed": "// GetRightIndex gets right child index for heap node\nfunc GetRightIndex(n int) int {\n\treturn 2*n + 2\n}", "id": 23763, "concepts": ["heap", "heap node", "heap node index"], "_raw_llm_output": "heap, heap node, heap node index"}
{"seed": "// Returns a bool indicates whether the given pod should be monitored.\n// Do not monitor pods running on nodes those are not monitored.\n// Do not monitor mirror pods or pods created by DaemonSets.\nfunc monitored(pod *api.Pod, notMonitoredNodes map[string]struct{}) bool {\n\tif _, exist := notMonitoredNodes[pod.Spec.NodeName]; exist {\n\t\treturn false\n\t}\n\n\tif isMirrorPod(pod) || isPodCreatedBy(pod, Kind_DaemonSet) {\n\t\treturn false\n\t}\n\treturn true\n}", "id": 23770, "concepts": ["struct", "pointer", "map", "interface", "function definition", "function call", "conditional statement", "basic control flow", "standard library usage"], "_raw_llm_output": "struct, pointer, map, interface, function definition, function call, conditional statement, basic control flow, standard library usage"}
{"seed": "// ThreeWay attempts a three-way merge between two candidates and a common ancestor. It considers the three of them recursively, applying some simple rules to identify conflicts:\n//  - If any of the three nodes are different NomsKinds: conflict\n//  - If we are dealing with a map:\n//    - If the same key is both removed and inserted wrt parent: conflict\n//    - If the same key is inserted wrt parent, but with different values: conflict\n//  - If we are dealing with a struct:\n//    - If the same field is both removed and inserted wrt parent: conflict\n//    - If the same field is inserted wrt parent, but with different values: conflict\n//  - If we are dealing with a list:\n//    - If the same index is both removed and inserted wrt parent: conflict\n//    - If the same index is inserted wrt parent, but with different values: conflict\n//  - If we are dealing with a set:\n//    - If the same object is both removed and inserted wrt parent: conflict\n//\n// All other modifications are allowed.\n// Currently, ThreeWay() only works on types.Map.\nfunc ThreeWay(a, b, parent types.Value, vwr types.ValueReadWriter) (merged types.Value, err error) {\n\tif a == nil && b == nil {\n\t\treturn parent, nil\n\t} else if a == nil {\n\t\treturn parent, newMergeConflict(\"Cannot merge nil Value with %s.\", b.Type().Describe())\n\t} else if b == nil {\n\t\treturn parent, newMergeConflict(\"Cannot merge %s with nil value.\", a.Type().Describe())\n\t} else if unmergeable(a, b) {\n\t\treturn parent, newMergeConflict(\"Cannot merge %s with %s.\", a.Type().Describe(), b.Type().Describe())\n\t}\n\n\treturn threeWayMerge(a, b, parent, vwr)\n}", "id": 23782, "concepts": ["recursion", "type comparison", "type handling", "type definition", "type conversion", "type comparison", "type definition", "type conversion", "type comparison", "type definition", "type conversion", "type comparison", "type definition", "type conversion", "type comparison", "type definition", "type conversion", "type comparison", "type definition", "type conversion", "type comparison", "type definition", "type conversion", "type comparison", "type definition", "type conversion", "type comparison", "type definition", "type conversion", "type comparison", "type definition", "type conversion", "type comparison", "type definition", "type conversion", "type comparison", "type definition", "type conversion", "type comparison", "type definition", "type conversion", "type comparison", "type definition", "type conversion", "type comparison", "type definition", "type conversion", "type comparison", "type definition", "type conversion", "type comparison", "type definition", "type conversion", "type comparison", "type definition", "type conversion", "type comparison", "type definition", "type conversion", "type comparison", "type definition", "type conversion", "type comparison", "type definition", "type conversion", "type comparison", "type definition", "type conversion", "type comparison", "type definition", "type conversion", "type comparison", "type definition", "type conversion", "type comparison", "type definition", "type conversion", "type comparison", "type definition", "type conversion", "type comparison", "type definition", "type conversion", "type comparison", "type definition", "type"], "_raw_llm_output": "recursion, type comparison, type handling, type definition, type conversion, type comparison, type definition, type conversion, type comparison, type definition, type conversion, type comparison, type definition, type conversion, type comparison, type definition, type conversion, type comparison, type definition, type conversion, type comparison, type definition, type conversion, type comparison, type definition, type conversion, type comparison, type definition, type conversion, type comparison, type definition, type conversion, type comparison, type definition, type conversion, type comparison, type definition, type conversion, type comparison, type definition, type conversion, type comparison, type definition, type conversion, type comparison, type definition, type conversion, type comparison, type definition, type conversion, type comparison, type definition, type conversion, type comparison, type definition, type conversion, type comparison, type definition, type conversion, type comparison, type definition, type conversion, type comparison, type definition, type conversion, type comparison, type definition, type conversion, type comparison, type definition, type conversion, type comparison, type definition, type conversion, type comparison, type definition, type conversion, type comparison, type definition, type conversion, type comparison, type definition, type conversion, type comparison, type definition, type"}
{"seed": "// BlueString is a convenient helper function to return a string with blue\n// foreground.\nfunc BlueString(format string, a ...interface{}) (s string) {\n\ts = colorString(FgBlue, format, a...)\n\treturn\n}", "id": 23785, "concepts": ["string formatting", "fmt package usage"], "_raw_llm_output": "string formatting, fmt package usage"}
{"seed": "// HeroPlayedNotIn applies the NotIn predicate on the \"hero_played\" field.\nfunc HeroPlayedNotIn(vs ...uint) predicate.User {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.User(func(s *sql.Selector) {\n\t\t// if not arguments were provided, append the FALSE constants,\n\t\t// since we can't apply \"IN ()\". This will make this predicate falsy.\n\t\tif len(vs) == 0 {\n\t\t\ts.Where(sql.False())\n\t\t\treturn\n\t\t}\n\t\ts.Where(sql.NotIn(s.C(FieldHeroPlayed), v...))\n\t})\n}", "id": 23796, "concepts": ["sql package usage", "predicate definition", "predicate usage", "predicate composition"], "_raw_llm_output": "sql package usage, predicate definition, predicate usage, predicate composition"}
{"seed": "// RolesIsNil applies the IsNil predicate on the \"roles\" field.\nfunc RolesIsNil() predicate.User {\n\treturn predicate.User(sql.FieldIsNull(FieldRoles))\n}", "id": 23799, "concepts": ["predicate.User", "sql.FieldIsNull", "basic function definition"], "_raw_llm_output": "predicate.User, sql.FieldIsNull, basic function definition"}
{"seed": "// NewTokenEqualFold applies the EqualFold predicate on the \"new_token\" field.\nfunc NewTokenEqualFold(v string) predicate.User {\n\treturn predicate.User(sql.FieldEqualFold(FieldNewToken, v))\n}", "id": 23817, "concepts": ["predicate.User", "sql.FieldEqualFold", "sql.Field"], "_raw_llm_output": "predicate.User, sql.FieldEqualFold, sql.Field"}
{"seed": "// Applies the rules of \"Pico y Placa\" to see if the vechicle is allowed in the\n// city.\n// NOTE: Holidays are not considered in this logic.\n// Reference: https://es.wikipedia.org/wiki/Pico_y_placa#Quito,_Ecuador\nfunc allowedInCity(lastDigit int, dateTime time.Time) bool {\n\tallowed := true\n\n\tweekday := dateTime.Weekday()\n\tdateString := dateTime.Format(\"2006-01-02\")\n\n\tmorningRestrictionStart, _ := time.Parse(time.RFC3339, dateString + \"T\" + \"07:00:00-05:00\")\n\tmorningRestrictionEnd, _ := time.Parse(time.RFC3339, dateString + \"T\" + \"09:30:00-05:00\")\n\n\teveningRestrictionStart, _ := time.Parse(time.RFC3339, dateString + \"T\" + \"16:00:00-05:00\")\n\teveningRestrictionEnd, _ := time.Parse(time.RFC3339, dateString + \"T\" + \"19:30:00-05:00\")\n\n\trestrictedMorningTime := dateTime.After(morningRestrictionStart) && dateTime.Before(morningRestrictionEnd)\n\trestrictedEveningTime := dateTime.After(eveningRestrictionStart) && dateTime.Before(eveningRestrictionEnd)\n\n\tif restrictedMorningTime || restrictedEveningTime {\n\t\tswitch weekday {\n\t\tcase time.Monday:\n\t\t\tif lastDigit == 1 || lastDigit == 2 {\n\t\t\t\tallowed = false\n\t\t\t}\n\t\tcase time.Tuesday:\n\t\t\tif lastDigit == 3 || lastDigit == 4 {\n\t\t\t\tallowed = false\n\t\t\t}\n\t\tcase time.Wednesday:\n\t\t\tif lastDigit == 5 || lastDigit == 6 {\n\t\t\t\tallowed = false\n\t\t\t}\n\t\tcase time.Thursday:\n\t\t\tif lastDigit == 7 || lastDigit == 8 {\n\t\t\t\tallowed = false\n\t\t\t}\n\t\tcase time.Friday:\n\t\t\tif lastDigit == 9 || lastDigit == 0 {\n\t\t\t\tallowed = false\n\t\t\t}\n\t\t}\n\t}\n\n\treturn allowed\n}", "id": 23822, "concepts": ["time package usage", "time formatting", "time comparison", "time arithmetic", "if-else statements", "switch statements", "basic function definition"], "_raw_llm_output": "time package usage, time formatting, time comparison, time arithmetic, if-else statements, switch statements, basic function definition"}
{"seed": "// SocialAvatarURLNEQ applies the NEQ predicate on the \"social_avatar_url\" field.\nfunc SocialAvatarURLNEQ(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldSocialAvatarURL), v))\n\t})\n}", "id": 23836, "concepts": ["sql.Selector", "sql.NEQ", "sql.Where", "sql.C"], "_raw_llm_output": "sql.Selector, sql.NEQ, sql.Where, sql.C"}
{"seed": "// IsExist will return true if value `v` exist in slice of `d`,\n// otherwise it will return false.\nfunc IsExist(d []float64, v float64) bool {\n\tfor _, x := range d {\n\t\tif v == x {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}", "id": 23839, "concepts": ["slice iteration (range loop)", "slice comparison", "basic function definition"], "_raw_llm_output": "slice iteration (range loop), slice comparison, basic function definition"}
{"seed": "// NewPayRatesGetParamsWithHTTPClient creates a new PayRatesGetParams object\n// with the default values initialized, and the ability to set a custom HTTPClient for a request\nfunc NewPayRatesGetParamsWithHTTPClient(client *http.Client) *PayRatesGetParams {\n\tvar ()\n\treturn &PayRatesGetParams{\n\t\tHTTPClient: client,\n\t}\n}", "id": 23856, "concepts": ["http client", "http request", "http response", "http client usage"], "_raw_llm_output": "http client, http request, http response, http client usage"}
{"seed": "// IsValidityError checks if an error is the `ValidityError` type.\nfunc IsValidityError(e error) bool {\n\t_, ok := e.(ValidityError)\n\treturn ok\n}", "id": 23859, "concepts": ["type assertion", "type assertion", "type assertion", "type assertion"], "_raw_llm_output": "type assertion, type assertion, type assertion, type assertion"}
{"seed": "// MakeGroupFromFullGroup returns the first element of an API group, ex. \"foo\" of \"foo.example.com\".\nfunc MakeGroupFromFullGroup(group string) string {\n\treturn getHalfBySep(group, \".\", 0)\n}", "id": 23861, "concepts": ["string manipulation", "string splitting"], "_raw_llm_output": "string manipulation, string splitting"}
{"seed": "// NatGateway_Spec_ARMGenerator returns a generator of NatGateway_Spec_ARM instances for property testing.\n// We first initialize natGateway_Spec_ARMGenerator with a simplified generator based on the\n// fields with primitive types then replacing it with a more complex one that also handles complex fields\n// to ensure any cycles in the object graph properly terminate.\nfunc NatGateway_Spec_ARMGenerator() gopter.Gen {\n\tif natGateway_Spec_ARMGenerator != nil {\n\t\treturn natGateway_Spec_ARMGenerator\n\t}\n\n\tgenerators := make(map[string]gopter.Gen)\n\tAddIndependentPropertyGeneratorsForNatGateway_Spec_ARM(generators)\n\tnatGateway_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(NatGateway_Spec_ARM{}), generators)\n\n\t// The above call to gen.Struct() captures the map, so create a new one\n\tgenerators = make(map[string]gopter.Gen)\n\tAddIndependentPropertyGeneratorsForNatGateway_Spec_ARM(generators)\n\tAddRelatedPropertyGeneratorsForNatGateway_Spec_ARM(generators)\n\tnatGateway_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(NatGateway_Spec_ARM{}), generators)\n\n\treturn natGateway_Spec_ARMGenerator\n}", "id": 23863, "concepts": ["struct", "map", "reflection", "property testing", "property-based testing"], "_raw_llm_output": "struct, map, reflection, property testing, property-based testing"}
{"seed": "// FindDMessageEmbedP retrieves a single record by ID with an executor, and panics on error.\nfunc FindDMessageEmbedP(exec boil.Executor, id int64, selectCols ...string) *DMessageEmbed {\n\tretobj, err := FindDMessageEmbed(exec, id, selectCols...)\n\tif err != nil {\n\t\tpanic(boil.WrapErr(err))\n\t}\n\n\treturn retobj\n}", "id": 23879, "concepts": ["panic", "boil", "sqlx usage", "error handling"], "_raw_llm_output": "panic, boil, sqlx usage, error handling"}
{"seed": "// HeroRepeatIn applies the In predicate on the \"hero_repeat\" field.\nfunc HeroRepeatIn(vs ...uint) predicate.User {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.User(func(s *sql.Selector) {\n\t\t// if not arguments were provided, append the FALSE constants,\n\t\t// since we can't apply \"IN ()\". This will make this predicate falsy.\n\t\tif len(vs) == 0 {\n\t\t\ts.Where(sql.False())\n\t\t\treturn\n\t\t}\n\t\ts.Where(sql.In(s.C(FieldHeroRepeat), v...))\n\t})\n}", "id": 23901, "concepts": ["sql.Selector", "sql.In", "sql.False", "sql.C", "sql.Where", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In", "sql.In"], "_raw_llm_output": "sql.Selector, sql.In, sql.False, sql.C, sql.Where, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In, sql.In"}
{"seed": "// Creates a UserIdentity object from JWT claims. Username and domain are\n// derived form the `sub` claim - the `@` symbol acts as a separator between\n// username and domain, example - 'sub': \"Admin@vshpere\" is converted to\n// 'username': \"Admin\", 'domain': \"vsphere\". UserIdentity.groups are corresponding\n// to the `group_names` claim.\nfunc createIdentityFromClaims(claims *JwtVapiClaims) *UserIdentity {\n\tuserDomainTuple := strings.SplitN((*claims)[CLAIM_SUBJECT].(string), \"@\", 2)\n\tvar domain = \"\"\n\tif len(userDomainTuple) == 2 {\n\t\tdomain = userDomainTuple[1]\n\t}\n\tuserIdentity := UserIdentity{userName: userDomainTuple[0], domain: &domain}\n\tgroups, _ := getClaimAsStringSlice(claims, CLAIM_GROUP_NAMES)\n\tuserIdentity.groups = groups\n\treturn &userIdentity\n}", "id": 23905, "concepts": ["string manipulation", "map iteration (range loop)", "string parsing", "string concatenation", "string comparison", "string formatting", "string slices", "string splitting", "string joining", "string to lowercase", "string to uppercase", "string length", "string to integer conversion", "string to float conversion", "string to boolean conversion", "string to rune conversion", "string to byte conversion", "string to byte slice conversion", "string to rune slice conversion", "string to rune slice conversion", "string to rune slice conversion", "string to rune slice conversion", "string to rune slice conversion", "string to rune slice conversion", "string to rune slice conversion", "string to rune slice conversion", "string to rune slice conversion", "string to rune slice conversion", "string to rune slice conversion", "string to rune slice conversion", "string to rune slice conversion", "string to rune slice conversion", "string to rune slice conversion", "string to rune slice conversion", "string to rune slice conversion", "string to rune slice conversion", "string to rune slice conversion", "string to rune slice conversion", "string to rune slice conversion", "string to rune slice conversion", "string to rune slice conversion", "string to rune slice conversion", "string to rune slice conversion", "string to rune slice conversion"], "_raw_llm_output": "string manipulation, map iteration (range loop), string parsing, string concatenation, string comparison, string formatting, string slices, string splitting, string joining, string to lowercase, string to uppercase, string length, string to integer conversion, string to float conversion, string to boolean conversion, string to rune conversion, string to byte conversion, string to byte slice conversion, string to rune slice conversion, string to rune slice conversion, string to rune slice conversion, string to rune slice conversion, string to rune slice conversion, string to rune slice conversion, string to rune slice conversion, string to rune slice conversion, string to rune slice conversion, string to rune slice conversion, string to rune slice conversion, string to rune slice conversion, string to rune slice conversion, string to rune slice conversion, string to rune slice conversion, string to rune slice conversion, string to rune slice conversion, string to rune slice conversion, string to rune slice conversion, string to rune slice conversion, string to rune slice conversion, string to rune slice conversion, string to rune slice conversion, string to rune slice conversion, string to rune slice conversion, string to rune slice conversion"}
{"seed": "// Encrypt encrypts plaintext and returns ciphertext.\n// plaintext's length must be a multiple of 8. key is a 24 byte key.\n// iv is an 8 byte initialization vector. If iv is nil, zeros\n// will be used as the initialization vector.\nfunc Encrypt(plaintext, key, iv []byte) ([]byte, error) {\n\n\tswitch {\n\tcase iv == nil:\n\t\tiv = defaultIV\n\tcase len(iv) != 8:\n\t\treturn nil, errors.New(\"invalid iv length\")\n\t}\n\n\t// check size and pad if necessary\n\tplaintext = checksizeAndPad(plaintext)\n\n\t// create the cipher\n\tecipher, err := blowfish.NewCipher(key)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// make ciphertext big enough to store len(plaintext) + blowfish.BlockSize\n\tciphertext := make([]byte, blowfish.BlockSize+len(plaintext))\n\n\t// make initialization vector to be the first 8 bytes of ciphertext\n\tiv = ciphertext[:blowfish.BlockSize]\n\n\t// create encrypter\n\tecbc := cipher.NewCBCEncrypter(ecipher, iv)\n\n\t// encrypt blocks\n\tecbc.CryptBlocks(ciphertext[blowfish.BlockSize:], plaintext)\n\n\t// return ciphertext\n\treturn ciphertext, nil\n}", "id": 23908, "concepts": ["cryptography", "blowfish", "encryption", "padding", "initialization vector"], "_raw_llm_output": "cryptography, blowfish, encryption, padding, initialization vector"}
{"seed": "// _escFSString is the string version of _escFSByte.\nfunc _escFSString(useLocal bool, name string) (string, error) {\n\tb, err := _escFSByte(useLocal, name)\n\treturn string(b), err\n}", "id": 23909, "concepts": ["byte slice", "string conversion", "_escFSByte function definition"], "_raw_llm_output": "byte slice, string conversion, _escFSByte function definition"}
{"seed": "// IsDeliveryFailure indicates if err is ErrDeliveryFailure\nfunc IsDeliveryFailure(err error) bool {\n\treturn unwrapError(err) == ErrDeliveryFailure\n}", "id": 23914, "concepts": ["error handling (error wrapping)", "error comparison"], "_raw_llm_output": "error handling (error wrapping), error comparison"}
{"seed": "// NewListHetznerSizesParamsWithHTTPClient creates a new ListHetznerSizesParams object\n// with the ability to set a custom HTTPClient for a request.\nfunc NewListHetznerSizesParamsWithHTTPClient(client *http.Client) *ListHetznerSizesParams {\n\treturn &ListHetznerSizesParams{\n\t\tHTTPClient: client,\n\t}\n}", "id": 23915, "concepts": ["http.Client usage", "function definition", "pointer usage"], "_raw_llm_output": "http.Client usage, function definition, pointer usage"}
{"seed": "// CalendarSharingActionImportancePSecondary returns a pointer to CalendarSharingActionImportanceVSecondary\nfunc CalendarSharingActionImportancePSecondary() *CalendarSharingActionImportance {\n\tv := CalendarSharingActionImportanceVSecondary\n\treturn &v\n}", "id": 23923, "concepts": ["pointer handling", "pointer dereference", "pointer assignment"], "_raw_llm_output": "pointer handling, pointer dereference, pointer assignment"}
{"seed": "// \u8d2a\u5fc3\u7b97\u6cd5\n// \u5982\u679c\u603b\u52a0\u6cb9\u91cf sum(gas) >= sum(cost) \u603b\u8017\u6cb9\u91cf\uff0c\u95ee\u9898\u4e00\u5b9a\u6709\u89e3\u3002\n// \u6211\u4eec\u4ece\u8d77\u70b9 0 \u5f00\u59cb\uff0c\u7d2f\u52a0\u6bcf\u4e2a\u7ad9\u70b9\u7684 gas[i]-cost[i]\uff0c\u5373 left(i)\n// \u5f53\u7ad9 i \u7d2f\u52a0\u5b8c left(i) \u540e\uff0c\u5982\u679c\u5c0f\u4e8e 0\uff0c\u5219\u7ad9 0 \u5230 \u7ad9 i \u90fd\u4e0d\u662f\u8d77\u70b9\uff0c[0,i] \u6bb5\u7684 \u2211left<0\n// \u6211\u4eec\u5c06 i+1 \u4f5c\u4e3a\u8d77\u70b9\uff0c\u91cd\u65b0\u7d2f\u52a0\u6bcf\u4e2a\u7ad9\u70b9\u7684 left(i)\n// \u5f53\u7ad9 j \u7d2f\u52a0\u5b8c left(j)\uff0c\u5982\u679c\u5c0f\u4e8e 0\uff0c\u5219\u7ad9 i+1 \u5230\u7ad9 j \u90fd\u4e0d\u662f\u8d77\u70b9\u3002[i+1,j] \u6bb5 \u2211left<0\n// \u7ee7\u7eed\u8003\u5bdf\u65b0\u8d77\u70b9......\u4e0d\u53ef\u80fd\u4e00\u76f4 \u2211left<0 \u4e0b\u53bb\n// \u56e0\u4e3a sum(gas) >= sum(cost)\uff0c\u5bf9\u4e8e\u6574\u4e2a\u6570\u7ec4\u6709 \u2211left>=0\n// \u56e0\u6b64\u5fc5\u7136\u6709\u4e00\u6bb5\u662f \u2211left>0\uff0c\u5047\u8bbe\u6b64\u65f6\u8d77\u70b9\u66f4\u65b0\u4e3a k\uff0c\u4ee5 k \u4e3a\u8d77\u70b9\u7684\u8fd9\u4e00\u6bb5\u80fd\u52a0\u5230\u8db3\u591f\u7684\u6cb9\uff0c\u8db3\u4ee5\u586b\u8865\u5176\u4ed6\u6bb5\u6b20\u7f3a\u7684\u91cf\u3002\nfunc canCompleteCircuit(gas []int, cost []int) int {\n\t// \u4f59\u91cf\uff0c\u521d\u59cb\u8d77\u70b9\n\tleft, start := 0, 0\n\ttotalGas, totalCost := 0, 0\n\tfor i := 0; i < len(gas); i++ {\n\t\ttotalGas += gas[i]\n\t\ttotalCost += cost[i]\n\t\t// \u7d2f\u52a0\u6bcf\u6b21\u7684\u4f59\u91cf\n\t\tleft += gas[i] - cost[i]\n\t\t// \u82e5\u4f59\u91cf\u5c0f\u4e8e0\uff0c\u8868\u793a\u53bb\u4e0d\u4e86\u4e0b\u4e00\u7ad9\uff0c\u52190\u5230i\u90fd\u4e0d\u80fd\u4f5c\u4e3a\u8d77\u70b9\n\t\tif left < 0 {\n\t\t\t// \u628ai+1\u4f5c\u4e3a\u8d77\u70b9\n\t\t\tstart = i + 1\n\t\t\t// \u4f59\u91cf\u5f520\n\t\t\tleft = 0\n\t\t}\n\t}\n\t// \u82e5\u603b\u6cb9\u91cf\u4e0d\u591f\uff0c\u80af\u5b9a\u65e0\u89e3\n\tif totalGas < totalCost {\n\t\treturn -1\n\t}\n\treturn start\n}", "id": 23929, "concepts": ["greedy algorithm", "array iteration", "integer summation"], "_raw_llm_output": "greedy algorithm, array iteration, integer summation"}
{"seed": "// PossibleProvisioningStateValues returns an array of possible values for the ProvisioningState const type.\nfunc PossibleProvisioningStateValues() []ProvisioningState {\n\treturn []ProvisioningState{Creating, Deleting, Failed, Moving, Running, Succeeded}\n}", "id": 23934, "concepts": ["const declaration", "array declaration", "array iteration"], "_raw_llm_output": "const declaration, array declaration, array iteration"}
{"seed": "// NewUntilExecutor returns a new Executor that executes the command until the assertions are met and returns its results and output\nfunc NewUntilExecutor(command string, resultTester result.Tester, outputTesters []output.Tester, timeout, interval time.Duration) Executor {\n\treturn &untilExecutor{\n\t\tcommand:       command,\n\t\tresultTester:  resultTester,\n\t\toutputTesters: outputTesters,\n\t\ttimeout:       timeout,\n\t\tinterval:      interval,\n\t}\n}", "id": 23947, "concepts": ["struct definition", "method definition", "anonymous function", "pointer usage", "time package usage", "channel usage"], "_raw_llm_output": "struct definition, method definition, anonymous function, pointer usage, time package usage, channel usage"}
{"seed": "// GetSystemResolvers returns resolvers discovered via\n// /etc/resolv.conf. If not valid resolvers are found, an empty array\n// is returned.\nfunc GetSystemResolvers() []string {\n\tresolvers, err := GetNameServersFromResolveConfig(defaultResolvConf)\n\tif err != nil {\n\t\treturn []string{}\n\t}\n\treturn resolvers\n}", "id": 23955, "concepts": ["os.File", "os.ReadFile", "os.Stat", "os.IsNotExist", "os.IsPermission", "os.Executable", "os.User", "os.UserFromId", "os.UserFromUid", "os.Getwd", "os.Chdir", "os.Mkdir", "os.MkdirAll", "os.RemoveAll", "os.Open", "os.OpenFile", "os.Create", "os.CreateTemp", "os.TempFile", "os.Rename", "os.Stat", "os.Lstat", "os.Readlink", "os.Symlink", "os.Readlink", "os.ReadlinkAll", "os.Chmod", "os.Chown", "os.Chtimes", "os.Truncate", "os.Remove", "os.RemoveAll", "os.Link", "os.Symlink", "os.Link", "os.Symlink", "os.Readlink", "os.ReadlinkAll", "os.Getwd", "os.Chdir", "os.Mkdir", "os.MkdirAll", "os.RemoveAll", "os.Open", "os.OpenFile", "os.Create", "os.CreateTemp", "os.TempFile", "os.Rename", "os.Stat", "os.Lstat", "os.Readlink", "os.Symlink", "os.Readlink", ""], "_raw_llm_output": "os.File, os.ReadFile, os.Stat, os.IsNotExist, os.IsPermission, os.Executable, os.User, os.UserFromId, os.UserFromUid, os.Getwd, os.Chdir, os.Mkdir, os.MkdirAll, os.RemoveAll, os.Open, os.OpenFile, os.Create, os.CreateTemp, os.TempFile, os.Rename, os.Stat, os.Lstat, os.Readlink, os.Symlink, os.Readlink, os.ReadlinkAll, os.Chmod, os.Chown, os.Chtimes, os.Truncate, os.Remove, os.RemoveAll, os.Link, os.Symlink, os.Link, os.Symlink, os.Readlink, os.ReadlinkAll, os.Getwd, os.Chdir, os.Mkdir, os.MkdirAll, os.RemoveAll, os.Open, os.OpenFile, os.Create, os.CreateTemp, os.TempFile, os.Rename, os.Stat, os.Lstat, os.Readlink, os.Symlink, os.Readlink,"}
{"seed": "//\u5305\n//go \u7684\u6bcf\u4e00\u4e2a\u6587\u4ef6\u90fd\u662f\u5c5e\u4e8e\u4e00\u4e2a\u5305\u7684\uff0c\u4e5f\u5c31\u662f\u8bf4 go \u662f\u4ee5\u5305\u7684\u5f62\u5f0f\u6765\u7ba1\u7406\u6587\u4ef6\u548c\u9879\u76ee\u76ee\u5f55\u7ed3\u6784\u7684\n//\u5305\u7684\u4f5c\u7528\n//1.\u533a\u5206\u76f8\u540c\u540d\u5b57\u7684\u51fd\u6570\u3001\u53d8\u91cf\u7b49\u6807\u8bc6\u7b26\n//2.\u5f53\u7a0b\u5e8f\u6587\u4ef6\u5f88\u591a\u65f6,\u53ef\u4ee5\u5f88\u597d\u7684\u7ba1\u7406\u9879\u76ee\n//3.\u63a7\u5236\u51fd\u6570\u3001\u53d8\u91cf\u7b49\u8bbf\u95ee\u8303\u56f4\uff0c\u5373\u4f5c\u7528\u57df\n//\u6253\u5305 package \"\u5305\u540d\"\n//\u5f15\u5305 import \"\u5305\u7684\u8def\u5f84\"\n//\u5305\u7ec6\u8282\u8bf4\u660e\n//1. \u5728\u7ed9\u4e00\u4e2a\u6587\u4ef6\u6253\u5305\u65f6\uff0c\u8be5\u5305\u5bf9\u5e94\u4e00\u4e2a\u6587\u4ef6\u5939\uff0c\u6bd4\u5982\u8fd9\u91cc\u7684 util \u6587\u4ef6\u5939\u5bf9\u5e94\u7684\u5305\u540d\u5c31\u662f util, \n//2. \u6587\u4ef6\u7684\u5305\u540d\u901a\u5e38\u548c\u6587\u4ef6\u6240\u5728\u7684\u6587\u4ef6\u5939\u540d\u4e00\u81f4\uff0c\u4e00\u822c\u4e3a\u5c0f\u5199\u5b57\u6bcd\n//3. \u5f53\u4e00\u4e2a\u6587\u4ef6\u8981\u4f7f\u7528\u5176\u5b83\u5305\u51fd\u6570\u6216\u53d8\u91cf\u65f6\uff0c\u9700\u8981\u5148\u5f15\u5165\u5bf9\u5e94\u7684\u5305\n//4. \u5728 import \u5305\u65f6\uff0c\u8def\u5f84\u4ece $GOPATH \u7684 src \u4e0b\u5f00\u59cb\uff0c\u4e0d\u7528\u5e26 src , \u7f16\u8bd1\u5668\u4f1a\u81ea\u52a8\u4ece src \u4e0b\u5f00\u59cb\u5f15\u5165\n//\u4e3a\u4e86\u8ba9\u5176\u5b83\u5305\u7684\u6587\u4ef6\uff0c\u53ef\u4ee5\u8bbf\u95ee\u5230\u672c\u5305\u7684\u51fd\u6570\uff0c\u5219\u8be5\u51fd\u6570\u540d\u7684\u9996\u5b57\u6bcd\u9700\u8981\u5927\u5199\uff0c\u7c7b\u4f3c\u5176\u5b83\u8bed\u8a00 \u7684 public ,\u8fd9\u6837\u624d\u80fd\u8de8\u5305\u8bbf\u95ee\u3002\n//\u6bd4\u5982 util.go \u7684Cal\n//5. \u5728\u8bbf\u95ee\u5176\u5b83\u5305\u51fd\u6570\uff0c\u53d8\u91cf\u65f6\uff0c\u5176\u8bed\u6cd5\u662f \u5305\u540d.\u51fd\u6570\u540d\uff0c \u6bd4\u5982\u8fd9\u91cc\u7684 main.go \u6587\u4ef6\u4e2d\n//6. \u5982\u679c\u5305\u540d\u8f83\u957f\uff0cGo \u652f\u6301\u7ed9\u5305\u53d6\u522b\u540d\uff0c \u6ce8\u610f\u7ec6\u8282:\u53d6\u522b\u540d\u540e\uff0c\u539f\u6765\u7684\u5305\u540d\u5c31\u4e0d\u80fd\u4f7f\u7528\u4e86\n//\u8bf4\u660e: \u5982\u679c\u7ed9\u5305\u53d6\u4e86\u522b\u540d\uff0c\u5219\u9700\u8981\u4f7f\u7528\u522b\u540d\u6765\u8bbf\u95ee\u8be5\u5305\u7684\u51fd\u6570\u548c\u53d8\u91cf\u3002\n//7. \u5728\u540c\u4e00\u5305\u4e0b\uff0c\u4e0d\u80fd\u6709\u76f8\u540c\u7684\u51fd\u6570\u540d(\u4e5f\u4e0d\u80fd\u6709\u76f8\u540c\u7684\u5168\u5c40\u53d8\u91cf\u540d)\uff0c\u5426\u5219\u62a5\u91cd\u590d\u5b9a\u4e49\n//8. \u5982\u679c\u4f60\u8981\u7f16\u8bd1\u6210\u4e00\u4e2a\u53ef\u6267\u884c\u7a0b\u5e8f\u6587\u4ef6\uff0c\u5c31\u9700\u8981\u5c06\u8fd9\u4e2a\u5305\u58f0\u660e\u4e3a main , \u5373 package main .\u8fd9\u4e2a\u5c31\n// \u662f\u4e00\u4e2a\u8bed\u6cd5\u89c4\u8303\uff0c\u5982\u679c\u4f60\u662f\u5199\u4e00\u4e2a\u5e93 \uff0c\u5305\u540d\u53ef\u4ee5\u81ea\u5b9a\u4e49\n\n//\u5173\u4e8e\u51fd\u6570\u8c03\u7528\u7684\u8bf4\u660e\n//1.\u5728\u8c03\u7528\u4e00\u4e2a\u51fd\u6570\u65f6\uff0c\u4f1a\u7ed9\u8be5\u51fd\u6570\u5206\u914d\u4e00\u4e2a\u65b0\u7684\u7a7a\u95f4\uff0c\u7f16\u8bd1\u5668\u4f1a\u901a\u8fc7\u81ea\u8eab\u7684\u5904\u7406\u8ba9\u8fd9\u4e2a\u65b0\u7684\u7a7a\u95f4 \u548c\u5176\u5b83\u7684\u6808\u7684\u7a7a\u95f4\u533a\u5206\u5f00\u6765\n//2. \u5728\u6bcf\u4e2a\u51fd\u6570\u5bf9\u5e94\u7684\u6808\u4e2d\uff0c\u6570\u636e\u7a7a\u95f4\u662f\u72ec\u7acb\u7684\uff0c\u4e0d\u4f1a\u6df7\u6dc6\n//3. \u5f53\u4e00\u4e2a\u51fd\u6570\u8c03\u7528\u5b8c\u6bd5\u4e4b\u540e\uff0c\u7a0b\u5e8f\u4f1a\u9500\u6bc1\u8fd9\u4e2a\u51fd\u6570\u5bf9\u5e94\u7684\u6808\u7a7a\u95f4\n\n//return \u8fd4\u56de\u503c\n//1. go\u51fd\u6570\u652f\u6301\u591a\u4e2a\u8fd4\u56de\u503c\uff0c\u8fd9\u4e00\u70b9\u662f\u5176\u4ed6\u7f16\u7a0b\u8bed\u8a00\u6ca1\u6709\u7684\u3002\nfunc getSumAndSub(n1 int, n2 int) (int, int) {\n\tsum := n1 + n2\n\tsub := n1 - n2\n\treturn sum, sub\n}", "id": 23956, "concepts": ["package", "import", "function definition", "function call", "function return value", "variable scope", "function scope", "function closure", "function parameter", "function return value", "function call", "function return value", "function call", "function return value", "function call", "function return value", "function call", "function return value", "function call", "function return value", "function call", "function return value", "function call", "function return value", "function call", "function return value", "function call", "function return value", "function call", "function return value", "function call", "function return value", "function call", "function return value", "function call", "function return value", "function call", "function return value", "function call", "function return value", "function call", "function return value", "function call", "function return value", "function call", "function return value", "function call", "function return value", "function call", "function return value", "function call", "function return value", "function call", "function return value", "function call", "function return value", "function call", "function return value", "function call", "function return value", "function call", "function return value", "function call", "function return value", "function call", "function return value", "function call", "function return value", "function call", "function return value", "function call", "function return value", "function call", "function return value", "function"], "_raw_llm_output": "package, import, function definition, function call, function return value, variable scope, function scope, function closure, function parameter, function return value, function call, function return value, function call, function return value, function call, function return value, function call, function return value, function call, function return value, function call, function return value, function call, function return value, function call, function return value, function call, function return value, function call, function return value, function call, function return value, function call, function return value, function call, function return value, function call, function return value, function call, function return value, function call, function return value, function call, function return value, function call, function return value, function call, function return value, function call, function return value, function call, function return value, function call, function return value, function call, function return value, function call, function return value, function call, function return value, function call, function return value, function call, function return value, function call, function return value, function call, function return value, function call, function return value, function call, function return value, function call, function return value, function"}
{"seed": "// Verse returns a single verse of the lyrics of 99 bottles of beer. The verse\n// numbers count backwards, so the first verse sung will be verse 99, and the\n// last will be verse 0\nfunc Verse(n int) (string, error) {\n\tresult := \"\"\n\tswitch {\n\tcase 0 > n || n > 99:\n\t\treturn \"\", fmt.Errorf(\"%d is not a valid verse\", n)\n\tcase n == 0:\n\t\tresult = \"No more bottles of beer on the wall, no more bottles of beer.\\nGo to the store and buy some more, 99 bottles of beer on the wall.\\n\"\n\tcase n == 1:\n\t\tresult = \"1 bottle of beer on the wall, 1 bottle of beer.\\nTake it down and pass it around, no more bottles of beer on the wall.\\n\"\n\tcase n == 2:\n\t\tresult = \"2 bottles of beer on the wall, 2 bottles of beer.\\nTake one down and pass it around, 1 bottle of beer on the wall.\\n\"\n\tdefault:\n\t\tresult = fmt.Sprintf(\"%d bottles of beer on the wall, %d bottles of beer.\\nTake one down and pass it around, %d bottles of beer on the wall.\\n\", n, n, n-1)\n\t}\n\treturn result, nil\n}", "id": 23962, "concepts": ["switch statement", "basic function definition", "error handling"], "_raw_llm_output": "switch statement, basic function definition, error handling"}
{"seed": "// IsStruct returns true if the given variable is a struct or a pointer to struct.\nfunc IsStruct(v interface{}) bool {\n\tt := reflect.TypeOf(v)\n\tif t.Kind() == reflect.Ptr {\n\t\tt = t.Elem()\n\t}\n\treturn t.Kind() == reflect.Struct\n}", "id": 23964, "concepts": ["reflection", "interface", "pointer", "struct", "type checking"], "_raw_llm_output": "reflection, interface, pointer, struct, type checking"}
{"seed": "// expandScopeHorizons ensures that the ScopeRecoveryState has an adequately\n// sized look ahead for both its internal and external branches. The keys\n// derived here are added to the scope's recovery state, but do not affect the\n// persistent state of the wallet. If any invalid child keys are detected, the\n// horizon will be properly extended such that our lookahead always includes the\n// proper number of valid child keys.\nfunc expandScopeHorizons(ns walletdb.ReadWriteBucket,\n\tscopedMgr *waddrmgr.ScopedKeyManager,\n\tscopeState *ScopeRecoveryState) er.R {\n\n\t// Compute the current external horizon and the number of addresses we\n\t// must derive to ensure we maintain a sufficient recovery window for\n\t// the external branch.\n\texHorizon, exWindow := scopeState.ExternalBranch.ExtendHorizon()\n\tcount, childIndex := uint32(0), exHorizon\n\tfor count < exWindow {\n\t\tkeyPath := externalKeyPath(childIndex)\n\t\taddr, err := scopedMgr.DeriveFromKeyPath(ns, keyPath)\n\t\tswitch {\n\t\tcase hdkeychain.ErrInvalidChild.Is(err):\n\t\t\t// Record the existence of an invalid child with the\n\t\t\t// external branch's recovery state. This also\n\t\t\t// increments the branch's horizon so that it accounts\n\t\t\t// for this skipped child index.\n\t\t\tscopeState.ExternalBranch.MarkInvalidChild(childIndex)\n\t\t\tchildIndex++\n\t\t\tcontinue\n\n\t\tcase err != nil:\n\t\t\treturn err\n\t\t}\n\n\t\t// Register the newly generated external address and child index\n\t\t// with the external branch recovery state.\n\t\tscopeState.ExternalBranch.AddAddr(childIndex, addr.Address())\n\n\t\tchildIndex++\n\t\tcount++\n\t}\n\n\t// Compute the current internal horizon and the number of addresses we\n\t// must derive to ensure we maintain a sufficient recovery window for\n\t// the internal branch.\n\tinHorizon, inWindow := scopeState.InternalBranch.ExtendHorizon()\n\tcount, childIndex = 0, inHorizon\n\tfor count < inWindow {\n\t\tkeyPath := internalKeyPath(childIndex)\n\t\taddr, err := scopedMgr.DeriveFromKeyPath(ns, keyPath)\n\t\tswitch {\n\t\tcase hdkeychain.ErrInvalidChild.Is(err):\n\t\t\t// Record the existence of an invalid child with the\n\t\t\t// internal branch's recovery state. This also\n\t\t\t// increments the branch's horizon so that it accounts\n\t\t\t// for this skipped child index.\n\t\t\tscopeState.InternalBranch.MarkInvalidChild(childIndex)\n\t\t\tchildIndex++\n\t\t\tcontinue\n\n\t\tcase err != nil:\n\t\t\treturn err\n\t\t}\n\n\t\t// Register the newly generated internal address and child index\n\t\t// with the internal branch recovery state.\n\t\tscopeState.InternalBranch.AddAddr(childIndex, addr.Address())\n\n\t\tchildIndex++\n\t\tcount++\n\t}\n\n\treturn nil\n}", "id": 23966, "concepts": ["error handling (idiomatic if-else)", "error handling (errors.Is)", "error handling (errors.As)", "error handling (errors.New)", "error handling (errors.Wrap)", "error handling (errors.Wrapf)", "error handling (errors.WithMessage)", "error handling (errors.WithMessagef)", "error handling (errors.WithStack)", "error handling (errors.Wrapf)", "error handling (errors.Wrap)", "error handling (errors.Wrapf)", "error handling (errors.WithStack)", "error handling (errors.Wrapf)", "error handling (errors.Wrap)", "error handling (errors.Wrapf)", "error handling (errors.WithStack)", "error handling (errors.Wrapf)", "error handling (errors.Wrap)", "error handling (errors.Wrapf)", "error handling (errors.WithStack)", "error handling (errors.Wrapf)", "error handling (errors.Wrap)", "error handling (errors.Wrapf)", "error handling (errors.WithStack)", "error handling (errors.Wrapf)", "error handling (errors.Wrap)", "error handling (errors.Wrapf)", "error handling (errors.WithStack)", "error handling (errors.Wrapf)", "error handling (errors.Wrap)", "error handling (errors.Wrapf)", "error handling (errors.With"], "_raw_llm_output": "error handling (idiomatic if-else), error handling (errors.Is), error handling (errors.As), error handling (errors.New), error handling (errors.Wrap), error handling (errors.Wrapf), error handling (errors.WithMessage), error handling (errors.WithMessagef), error handling (errors.WithStack), error handling (errors.Wrapf), error handling (errors.Wrap), error handling (errors.Wrapf), error handling (errors.WithStack), error handling (errors.Wrapf), error handling (errors.Wrap), error handling (errors.Wrapf), error handling (errors.WithStack), error handling (errors.Wrapf), error handling (errors.Wrap), error handling (errors.Wrapf), error handling (errors.WithStack), error handling (errors.Wrapf), error handling (errors.Wrap), error handling (errors.Wrapf), error handling (errors.WithStack), error handling (errors.Wrapf), error handling (errors.Wrap), error handling (errors.Wrapf), error handling (errors.WithStack), error handling (errors.Wrapf), error handling (errors.Wrap), error handling (errors.Wrapf), error handling (errors.With"}
{"seed": "// GenerateRandomKey is a convenience method which provides a pass-through to\n// the securecookie.GenerateRandomKey function.\nfunc GenerateRandomKey(length int) []byte {\n\tkey := securecookie.GenerateRandomKey(length)\n\treturn key\n}", "id": 23967, "concepts": ["securecookie package usage", "securecookie.GenerateRandomKey"], "_raw_llm_output": "securecookie package usage, securecookie.GenerateRandomKey"}
{"seed": "// MakeDeleter creates a Deleter for the given table.\n//\n// The returned Deleter contains a FetchCols field that defines the\n// expectation of which values are passed as values to DeleteRow. If\n// requestedCols is non-nil, then only the requested columns are included in\n// FetchCols; otherwise, all columns that are part of the key of any index\n// (either primary or secondary) are included in FetchCols.\nfunc MakeDeleter(\n\tcodec keys.SQLCodec, tableDesc catalog.TableDescriptor, requestedCols []descpb.ColumnDescriptor,\n) Deleter {\n\tindexes := tableDesc.DeletableNonPrimaryIndexes()\n\tindexDescs := make([]descpb.IndexDescriptor, len(indexes))\n\tfor i, index := range indexes {\n\t\tindexDescs[i] = *index.IndexDesc()\n\t}\n\n\tvar fetchCols []descpb.ColumnDescriptor\n\tvar fetchColIDtoRowIndex catalog.TableColMap\n\tif requestedCols != nil {\n\t\tfetchCols = requestedCols[:len(requestedCols):len(requestedCols)]\n\t\tfetchColIDtoRowIndex = ColIDtoRowIndexFromCols(fetchCols)\n\t} else {\n\t\tmaybeAddCol := func(colID descpb.ColumnID) error {\n\t\t\tif _, ok := fetchColIDtoRowIndex.Get(colID); !ok {\n\t\t\t\tcol, err := tableDesc.FindColumnWithID(colID)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tfetchColIDtoRowIndex.Set(col.GetID(), len(fetchCols))\n\t\t\t\tfetchCols = append(fetchCols, *col.ColumnDesc())\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t\tfor j := 0; j < tableDesc.GetPrimaryIndex().NumColumns(); j++ {\n\t\t\tcolID := tableDesc.GetPrimaryIndex().GetColumnID(j)\n\t\t\tif err := maybeAddCol(colID); err != nil {\n\t\t\t\treturn Deleter{}\n\t\t\t}\n\t\t}\n\t\tfor _, index := range indexes {\n\t\t\tfor j := 0; j < index.NumColumns(); j++ {\n\t\t\t\tcolID := index.GetColumnID(j)\n\t\t\t\tif err := maybeAddCol(colID); err != nil {\n\t\t\t\t\treturn Deleter{}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// The extra columns are needed to fix #14601.\n\t\t\tfor j := 0; j < index.NumExtraColumns(); j++ {\n\t\t\t\tcolID := index.GetExtraColumnID(j)\n\t\t\t\tif err := maybeAddCol(colID); err != nil {\n\t\t\t\t\treturn Deleter{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\trd := Deleter{\n\t\tHelper:               newRowHelper(codec, tableDesc, indexDescs),\n\t\tFetchCols:            fetchCols,\n\t\tFetchColIDtoRowIndex: fetchColIDtoRowIndex,\n\t}\n\n\treturn rd\n}", "id": 23968, "concepts": ["struct definition", "struct field access", "map iteration", "map key access", "map value access", "map value assignment", "map value deletion", "map value update", "map value retrieval", "map value assignment", "map value deletion", "map value update", "map value retrieval", "map value assignment", "map value deletion", "map value update", "map value retrieval", "map value assignment", "map value deletion", "map value update", "map value retrieval", "map value assignment", "map value deletion", "map value update", "map value retrieval", "map value assignment", "map value deletion", "map value update", "map value retrieval", "map value assignment", "map value deletion", "map value update", "map value retrieval", "map value assignment", "map value deletion", "map value update", "map value retrieval", "map value assignment", "map value deletion", "map value update", "map value retrieval", "map value assignment", "map value deletion", "map value update", "map value retrieval", "map value assignment", "map value deletion", "map value update", "map value retrieval", "map value assignment", "map value deletion", "map value update", "map value retrieval", "map value assignment", "map value deletion", "map value update", "map value retrieval", "map value assignment", "map value deletion", "map value update", "map value retrieval", "map value assignment", "map value deletion", "map value update", "map"], "_raw_llm_output": "struct definition, struct field access, map iteration, map key access, map value access, map value assignment, map value deletion, map value update, map value retrieval, map value assignment, map value deletion, map value update, map value retrieval, map value assignment, map value deletion, map value update, map value retrieval, map value assignment, map value deletion, map value update, map value retrieval, map value assignment, map value deletion, map value update, map value retrieval, map value assignment, map value deletion, map value update, map value retrieval, map value assignment, map value deletion, map value update, map value retrieval, map value assignment, map value deletion, map value update, map value retrieval, map value assignment, map value deletion, map value update, map value retrieval, map value assignment, map value deletion, map value update, map value retrieval, map value assignment, map value deletion, map value update, map value retrieval, map value assignment, map value deletion, map value update, map value retrieval, map value assignment, map value deletion, map value update, map value retrieval, map value assignment, map value deletion, map value update, map value retrieval, map value assignment, map value deletion, map value update, map"}
{"seed": "// SocialEmail applies equality check predicate on the \"social_email\" field. It's identical to SocialEmailEQ.\nfunc SocialEmail(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldSocialEmail), v))\n\t})\n}", "id": 23988, "concepts": ["sql.Selector", "sql.EQ", "sql.C", "sql.Where", "sql.Predicate", "sql.Field", "sql.Selector.Where", "sql.Selector.C", "sql.Selector.EQ", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector"], "_raw_llm_output": "sql.Selector, sql.EQ, sql.C, sql.Where, sql.Predicate, sql.Field, sql.Selector.Where, sql.Selector.C, sql.Selector.EQ, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector"}
{"seed": "// WithAttributes sets the attributes of the instance participating in the\n// election.\nfunc WithAttributes(attributes Attributes) ElectorConfigFunc {\n\treturn func(e *elector) { e.attributes = attributes }\n}", "id": 23995, "concepts": ["function composition", "function composition", "function composition", "function composition"], "_raw_llm_output": "function composition, function composition, function composition, function composition"}
{"seed": "// \u83b7\u53d6\u5f53\u524d\u7684\u65f6\u95f4 - \u6beb\u79d2\u7ea7\u65f6\u95f4\u6233\nfunc GetCurrentMilliUnix() int64 {\n\treturn time.Now().UnixNano() / 1000000\n}", "id": 23998, "concepts": ["time package usage", "time.Now()", "time.UnixNano()", "time.Unix()", "time.UnixMilli()", "time.UnixMicro()", "time.UnixNanosecond()"], "_raw_llm_output": "time package usage, time.Now(), time.UnixNano(), time.Unix(), time.UnixMilli(), time.UnixMicro(), time.UnixNanosecond()"}
{"seed": "// NewBookingClient returns a client for the Booking from the given config.\nfunc NewBookingClient(c config) *BookingClient {\n\treturn &BookingClient{config: c}\n}", "id": 23999, "concepts": ["struct definition", "method definition", "constructor pattern"], "_raw_llm_output": "struct definition, method definition, constructor pattern"}
{"seed": "// wmFreeformResize verifies that a window can be resized as defined in:\n// go/arc-wm-p \"Clamshell: freeform resize\" (slide #26)\nfunc wmFreeformResize(ctx context.Context, tconn *chrome.TestConn, a *arc.ARC, d *ui.Device) error {\n\tact, err := arc.NewActivity(a, wm.Pkg24, wm.ResizableUnspecifiedActivity)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer act.Close()\n\tif err := act.StartWithDefaultOptions(ctx, tconn); err != nil {\n\t\treturn err\n\t}\n\tdefer act.Stop(ctx, tconn)\n\tif err := wm.WaitUntilActivityIsReady(ctx, tconn, act, d); err != nil {\n\t\treturn err\n\t}\n\n\twindow, err := ash.GetARCAppWindowInfo(ctx, tconn, act.PackageName())\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Resizable apps are launched in maximized in P.\n\tif window.State != ash.WindowStateNormal {\n\t\tif ws, err := ash.SetARCAppWindowState(ctx, tconn, act.PackageName(), ash.WMEventNormal); err != nil {\n\t\t\treturn err\n\t\t} else if ws != ash.WindowStateNormal {\n\t\t\treturn errors.Errorf(\"failed to set window state: got %s, want %s\", ws, ash.WindowStateNormal)\n\t\t}\n\t\tif err := ash.WaitForARCAppWindowState(ctx, tconn, act.PackageName(), ash.WindowStateNormal); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := ash.WaitWindowFinishAnimating(ctx, tconn, window.ID); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tdispMode, err := ash.PrimaryDisplayMode(ctx, tconn)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdispInfo, err := display.GetPrimaryInfo(ctx, tconn)\n\tif err != nil {\n\t\treturn err\n\t}\n\tmaxBounds := coords.ConvertBoundsFromDPToPX(dispInfo.Bounds, dispMode.DeviceScaleFactor)\n\n\tif ws, err := ash.SetARCAppWindowState(ctx, tconn, act.PackageName(), ash.WMEventNormal); err != nil {\n\t\treturn err\n\t} else if ws != ash.WindowStateNormal {\n\t\treturn errors.Errorf(\"failed to set window state: got %s, want %s\", ws, ash.WindowStateNormal)\n\t}\n\n\t// Now we grab the bounds from the restored app, and we try to resize it to its previous right margin.\n\torigBounds, err := act.WindowBounds(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// The -1 is needed to prevent injecting a touch event outside bounds.\n\tright := maxBounds.Left + maxBounds.Width - 1\n\ttesting.ContextLog(ctx, \"Resizing app to right margin = \", right)\n\tto := coords.NewPoint(right, origBounds.Top+origBounds.Height/2)\n\tif err := act.ResizeWindow(ctx, tconn, arc.BorderRight, to, 500*time.Millisecond); err != nil {\n\t\treturn err\n\t}\n\n\tbounds, err := act.WindowBounds(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// ResizeWindow() does not guarantee pixel-perfect resizing.\n\t// For this particular test, we are good as long as the window has been resized at least one pixel.\n\tif bounds.Width <= origBounds.Width {\n\t\ttesting.ContextLogf(ctx, \"Original bounds: %+v; resized bounds: %+v\", origBounds, bounds)\n\t\treturn errors.Errorf(\"invalid window width: got %d; want %d > %d\", bounds.Width, bounds.Width, origBounds.Width)\n\t}\n\treturn nil\n}", "id": 24001, "concepts": ["context", "context cancellation", "context timeout", "context logging", "context error handling", "context wait", "context wait group", "context wait timeout", "context wait for", "context wait for timeout", "context wait for cancel", "context wait for cancel timeout", "context wait for cancel error handling", "context wait for cancel error handling timeout", "context wait for cancel error handling timeout", "context wait for cancel error handling timeout", "context wait for cancel error handling timeout", "context wait for cancel error handling timeout", "context wait for cancel error handling timeout", "context wait for cancel error handling timeout", "context wait for cancel error handling timeout", "context wait for cancel error handling timeout", "context wait for cancel error handling timeout", "context wait for cancel error handling timeout", "context wait for cancel error handling timeout", "context wait for cancel error handling timeout", "context wait for cancel error handling timeout", "context wait for cancel error handling timeout", "context wait for cancel error handling timeout", "context wait for cancel error handling timeout", "context wait for cancel error handling timeout", "context wait for cancel error handling timeout", "context wait for cancel error handling timeout", "context wait for cancel error handling timeout", "context wait for cancel error handling timeout", "context wait for cancel error handling timeout", "context wait for cancel error handling timeout", "context wait for cancel error handling timeout", "context wait"], "_raw_llm_output": "context, context cancellation, context timeout, context logging, context error handling, context wait, context wait group, context wait timeout, context wait for, context wait for timeout, context wait for cancel, context wait for cancel timeout, context wait for cancel error handling, context wait for cancel error handling timeout, context wait for cancel error handling timeout, context wait for cancel error handling timeout, context wait for cancel error handling timeout, context wait for cancel error handling timeout, context wait for cancel error handling timeout, context wait for cancel error handling timeout, context wait for cancel error handling timeout, context wait for cancel error handling timeout, context wait for cancel error handling timeout, context wait for cancel error handling timeout, context wait for cancel error handling timeout, context wait for cancel error handling timeout, context wait for cancel error handling timeout, context wait for cancel error handling timeout, context wait for cancel error handling timeout, context wait for cancel error handling timeout, context wait for cancel error handling timeout, context wait for cancel error handling timeout, context wait for cancel error handling timeout, context wait for cancel error handling timeout, context wait for cancel error handling timeout, context wait for cancel error handling timeout, context wait for cancel error handling timeout, context wait for cancel error handling timeout, context wait"}
{"seed": "// PossibleResourceStateValues returns an array of possible values for the ResourceState const type.\nfunc PossibleResourceStateValues() []ResourceState {\n\treturn []ResourceState{ResourceStateCreating, ResourceStateDeleting, ResourceStateDisabled, ResourceStateDisabling, ResourceStateEnabled, ResourceStateEnabling}\n}", "id": 24002, "concepts": ["constant definition", "array definition"], "_raw_llm_output": "constant definition, array definition"}
{"seed": "// DefaultExprNotIn applies the NotIn predicate on the \"default_expr\" field.\nfunc DefaultExprNotIn(vs ...string) predicate.User {\n\treturn predicate.User(sql.FieldNotIn(FieldDefaultExpr, vs...))\n}", "id": 24005, "concepts": ["sql.FieldNotIn", "sql.FieldIn", "sql.FieldEq", "sql.FieldNotEq", "sql.FieldGt", "sql.FieldGte", "sql.FieldLt", "sql.FieldLte", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldIs", "sql.FieldIsNot", "sql.FieldIsNull", "sql.FieldIsNotNull", "sql.FieldBetween", "sql.FieldNotBetween", "sql.FieldExists", "sql.FieldNotExists", "sql.FieldAnd", "sql.FieldOr", "sql.FieldNot", "sql.FieldXor", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldEq", "sql.FieldNotEq", "sql.FieldGt", "sql.FieldGte", "sql.FieldLt", "sql.FieldLte", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldIs", "sql.FieldIsNot", "sql.FieldIsNull", "sql.FieldIsNotNull", "sql.FieldBetween", "sql.FieldNotBetween", "sql.FieldExists", "sql.FieldNotExists", "sql.FieldAnd", "sql.FieldOr", "sql.FieldNot", "sql.FieldXor", "sql.Field"], "_raw_llm_output": "sql.FieldNotIn, sql.FieldIn, sql.FieldEq, sql.FieldNotEq, sql.FieldGt, sql.FieldGte, sql.FieldLt, sql.FieldLte, sql.FieldLike, sql.FieldNotLike, sql.FieldIn, sql.FieldNotIn, sql.FieldIs, sql.FieldIsNot, sql.FieldIsNull, sql.FieldIsNotNull, sql.FieldBetween, sql.FieldNotBetween, sql.FieldExists, sql.FieldNotExists, sql.FieldAnd, sql.FieldOr, sql.FieldNot, sql.FieldXor, sql.FieldIn, sql.FieldNotIn, sql.FieldEq, sql.FieldNotEq, sql.FieldGt, sql.FieldGte, sql.FieldLt, sql.FieldLte, sql.FieldLike, sql.FieldNotLike, sql.FieldIn, sql.FieldNotIn, sql.FieldIs, sql.FieldIsNot, sql.FieldIsNull, sql.FieldIsNotNull, sql.FieldBetween, sql.FieldNotBetween, sql.FieldExists, sql.FieldNotExists, sql.FieldAnd, sql.FieldOr, sql.FieldNot, sql.FieldXor, sql.Field"}
{"seed": "// ErrorProp creates a property that will always fail with an error.\n// Mostly used as a fallback when setup/initialization fails\nfunc ErrorProp(err error) gopter.Prop {\n\treturn func(genParams *gopter.GenParameters) *gopter.PropResult {\n\t\treturn &gopter.PropResult{\n\t\t\tStatus: gopter.PropError,\n\t\t\tError:  err,\n\t\t}\n\t}\n}", "id": 24007, "concepts": ["property-based testing", "gopter package usage"], "_raw_llm_output": "property-based testing, gopter package usage"}
{"seed": "// IsDirectMessage returns true if this message is in a direct message conversation\nfunc IsDirectMessage(rtm *slack.RTM, evt *slack.MessageEvent) bool {\n\treturn strings.HasPrefix(evt.Channel, \"D\")\n}", "id": 24013, "concepts": ["string manipulation", "string comparison", "string prefix check", "string prefix removal", "string prefix check", "string prefix removal", "string prefix check", "string prefix removal", "string prefix check", "string prefix removal", "string prefix check", "string prefix removal", "string prefix check", "string prefix removal", "string prefix check", "string prefix removal", "string prefix check", "string prefix removal", "string prefix check", "string prefix removal", "string prefix check", "string prefix removal", "string prefix check", "string prefix removal", "string prefix check", "string prefix removal", "string prefix check", "string prefix removal", "string prefix check", "string prefix removal", "string prefix check", "string prefix removal", "string prefix check", "string prefix removal", "string prefix check", "string prefix removal", "string prefix check", "string prefix removal", "string prefix check", "string prefix removal", "string prefix check", "string prefix removal", "string prefix check", "string prefix removal", "string prefix check", "string prefix removal", "string prefix check", "string prefix removal", "string prefix check", "string prefix removal", "string prefix check", "string prefix removal", "string prefix check", "string prefix removal", "string prefix check", "string prefix removal", "string prefix check", "string prefix removal", "string prefix check", "string prefix removal", "string prefix check", "string prefix removal", "string prefix check", "string prefix removal", "string"], "_raw_llm_output": "string manipulation, string comparison, string prefix check, string prefix removal, string prefix check, string prefix removal, string prefix check, string prefix removal, string prefix check, string prefix removal, string prefix check, string prefix removal, string prefix check, string prefix removal, string prefix check, string prefix removal, string prefix check, string prefix removal, string prefix check, string prefix removal, string prefix check, string prefix removal, string prefix check, string prefix removal, string prefix check, string prefix removal, string prefix check, string prefix removal, string prefix check, string prefix removal, string prefix check, string prefix removal, string prefix check, string prefix removal, string prefix check, string prefix removal, string prefix check, string prefix removal, string prefix check, string prefix removal, string prefix check, string prefix removal, string prefix check, string prefix removal, string prefix check, string prefix removal, string prefix check, string prefix removal, string prefix check, string prefix removal, string prefix check, string prefix removal, string prefix check, string prefix removal, string prefix check, string prefix removal, string prefix check, string prefix removal, string prefix check, string prefix removal, string prefix check, string prefix removal, string prefix check, string prefix removal, string"}
{"seed": "// Returns a new *goyaml.Node with the same values as the original node except for the Content field, which is initialized\n// to an empty array\nfunc shallowCopyNode(orig *goyaml.Node) *goyaml.Node {\n\treturn &goyaml.Node{\n\t\tKind:        orig.Kind,\n\t\tStyle:       orig.Style,\n\t\tTag:         orig.Tag,\n\t\tValue:       orig.Value,\n\t\tAnchor:      orig.Anchor,\n\t\tAlias:       orig.Alias,\n\t\tContent:     []*goyaml.Node{},\n\t\tHeadComment: orig.HeadComment,\n\t\tLineComment: orig.LineComment,\n\t\tFootComment: orig.FootComment,\n\t\tLine:        orig.Line,\n\t\tColumn:      orig.Column,\n\t}\n}", "id": 24025, "concepts": ["goyaml.Node", "shallow copy", "basic function definition"], "_raw_llm_output": "goyaml.Node, shallow copy, basic function definition"}
{"seed": "// Datalist represents the HTML element 'datalist'.\n// For more information visit https://www.w3schools.com/tags/tag_datalist.asp.\nfunc Datalist(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"datalist\", Attributes: attrs, Children: children}\n}", "id": 24030, "concepts": ["HTML generation", "HTML tree building", "HTML element definition", "HTML attribute definition", "HTML child definition"], "_raw_llm_output": "HTML generation, HTML tree building, HTML element definition, HTML attribute definition, HTML child definition"}
{"seed": "// BindingQueryPost POST \u8bf7\u6c42\u4f7f\u7528 ShouldBind \u53ef\u4ee5\u81ea\u52a8\u7ed1\u5b9a\u5c5e\u6027\u3002\n// \u6d4b\u8bd5 POST \u8bf7\u6c42\u7684\u7ed1\u5b9a\u3002\n// POST http://localhost:18080/bind/post\n// Content-Type: application/x-www-form-urlencoded\n// user=abc&password=123\n// ###\nfunc BindingQueryPost(ctx *gin.Context) {\n\ttype login struct {\n\t\tUser     string `form:\"user\" json:\"usr\" xml:\"user\"  binding:\"required\"`\n\t\tPassword string `form:\"password\" json:\"pwd\" xml:\"password\" binding:\"required\"`\n\t}\n\n\tvar usr login\n\tif err := ctx.ShouldBind(&usr); err != nil {\n\t\tctx.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()})\n\t\treturn\n\t}\n\n\tlog.Println(usr)\n\n\tctx.Status(http.StatusNoContent)\n}", "id": 24035, "concepts": ["gin.Context", "ShouldBind", "POST request", "binding", "JSON", "XML"], "_raw_llm_output": "gin.Context, ShouldBind, POST request, binding, JSON, XML"}
{"seed": "// Find takes a slice and looks for an element in it. If found it will\n// return it's key, otherwise it will return -1 and a bool of false.\nfunc find(slice []string, val string) (int, bool) {\n\tfor i, item := range slice {\n\t\tif item == val {\n\t\t\treturn i, true\n\t\t}\n\t}\n\treturn -1, false\n}", "id": 24039, "concepts": ["slice iteration (range loop)", "slice lookup", "basic function definition"], "_raw_llm_output": "slice iteration (range loop), slice lookup, basic function definition"}
{"seed": "// Img_ is a convenience wrapper for Img without the attrs argument.\nfunc Img_() HTML {\n  return Img(nil)\n}", "id": 24047, "concepts": ["function definition", "function composition", "function composition with nil argument"], "_raw_llm_output": "function definition, function composition, function composition with nil argument"}
{"seed": "// Textarea_ is a convenience wrapper for Textarea without the attrs argument.\nfunc Textarea_(children ...HTML) HTML {\n  return Textarea(nil, children...)\n}", "id": 24069, "concepts": ["HTML tag definition", "HTML tag attribute definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", "HTML tag attribute value definition", ""], "_raw_llm_output": "HTML tag definition, HTML tag attribute definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition, HTML tag attribute value definition,"}
{"seed": "// CreatedAtIsNil applies the IsNil predicate on the \"created_at\" field.\nfunc CreatedAtIsNil() predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.IsNull(s.C(FieldCreatedAt)))\n\t})\n}", "id": 24088, "concepts": ["sql package usage", "sql.Selector", "sql.IsNull", "predicate.User"], "_raw_llm_output": "sql package usage, sql.Selector, sql.IsNull, predicate.User"}
{"seed": "// NameGTE applies the GTE predicate on the \"name\" field.\nfunc NameGTE(v string) predicate.User {\n\treturn predicate.User(sql.FieldGTE(FieldName, v))\n}", "id": 24092, "concepts": ["predicate", "sql.FieldGTE", "sql.FieldLT"], "_raw_llm_output": "predicate, sql.FieldGTE, sql.FieldLT"}
{"seed": "// NewTestBucket creates test bkt client that before returning creates temporary bucket.\n// In a close function it empties and deletes the bucket.\nfunc NewTestBucket(t testing.TB) (objstore.Bucket, func(), error) {\n\tc := configFromEnv()\n\tif err := validateForTest(c); err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tif c.Bucket != \"\" {\n\t\tif os.Getenv(\"THANOS_ALLOW_EXISTING_BUCKET_USE\") == \"\" {\n\t\t\treturn nil, nil, errors.New(\"BOS_BUCKET is defined. Normally this tests will create temporary bucket \" +\n\t\t\t\t\"and delete it after test. Unset BOS_BUCKET env variable to use default logic. If you really want to run \" +\n\t\t\t\t\"tests against provided (NOT USED!) bucket, set THANOS_ALLOW_EXISTING_BUCKET_USE=true. WARNING: That bucket \" +\n\t\t\t\t\"needs to be manually cleared. This means that it is only useful to run one test in a time. This is due \" +\n\t\t\t\t\"to safety (accidentally pointing prod bucket for test) as well as BOS not being fully strong consistent.\")\n\t\t}\n\n\t\tbc, err := yaml.Marshal(c)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\n\t\tb, err := NewBucket(log.NewNopLogger(), bc, \"thanos-e2e-test\")\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\n\t\tif err := b.Iter(context.Background(), \"\", func(f string) error {\n\t\t\treturn errors.Errorf(\"bucket %s is not empty\", c.Bucket)\n\t\t}); err != nil {\n\t\t\treturn nil, nil, errors.Wrapf(err, \"checking bucket %s\", c.Bucket)\n\t\t}\n\n\t\tt.Log(\"WARNING. Reusing\", c.Bucket, \"BOS bucket for BOS tests. Manual cleanup afterwards is required\")\n\t\treturn b, func() {}, nil\n\t}\n\n\tsrc := rand.NewSource(time.Now().UnixNano())\n\ttmpBucketName := strings.Replace(fmt.Sprintf(\"test_%x\", src.Int63()), \"_\", \"-\", -1)\n\n\tif len(tmpBucketName) >= 31 {\n\t\ttmpBucketName = tmpBucketName[:31]\n\t}\n\n\tc.Bucket = tmpBucketName\n\tbc, err := yaml.Marshal(c)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tb, err := NewBucket(log.NewNopLogger(), bc, \"thanos-e2e-test\")\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tif _, err := b.client.PutBucket(b.name); err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tt.Log(\"created temporary BOS bucket for BOS tests with name\", tmpBucketName)\n\treturn b, func() {\n\t\tobjstore.EmptyBucket(t, context.Background(), b)\n\t\tif err := b.client.DeleteBucket(b.name); err != nil {\n\t\t\tt.Logf(\"deleting bucket %s failed: %s\", tmpBucketName, err)\n\t\t}\n\t}, nil\n}", "id": 24093, "concepts": ["string manipulation", "string formatting", "string length check", "string concatenation", "string replacement", "string slice", "string iteration", "string comparison", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string length check", "string"], "_raw_llm_output": "string manipulation, string formatting, string length check, string concatenation, string replacement, string slice, string iteration, string comparison, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string length check, string"}
{"seed": "// NewCreateExtensionsV1beta1NamespacedIngressCreated creates CreateExtensionsV1beta1NamespacedIngressCreated with default headers values\nfunc NewCreateExtensionsV1beta1NamespacedIngressCreated() *CreateExtensionsV1beta1NamespacedIngressCreated {\n\n\treturn &CreateExtensionsV1beta1NamespacedIngressCreated{}\n}", "id": 24104, "concepts": ["default headers", "function definition", "basic function definition"], "_raw_llm_output": "default headers, function definition, basic function definition"}
{"seed": "// decode unmarshals a counter. Nil buffers are decoded as 0.\nfunc decode(buf []byte) uint64 {\n\tif buf == nil {\n\t\treturn 0\n\t}\n\treturn binary.BigEndian.Uint64(buf)\n}", "id": 24110, "concepts": ["binary.BigEndian", "byte slice handling", "nil handling"], "_raw_llm_output": "binary.BigEndian, byte slice handling, nil handling"}
{"seed": "// MultiBulkValue returns a RESP array which contains one or more bulk strings.\n// For more information on RESP arrays and strings please see http://redis.io/topics/protocol.\nfunc MultiBulkValue(commandName string, args ...interface{}) Value {\n\tvals := make([]Value, len(args)+1)\n\tvals[0] = StringValue(commandName)\n\tfor i, arg := range args {\n\t\tif rval, ok := arg.(Value); ok && rval.Type() == BulkString {\n\t\t\tvals[i+1] = rval\n\t\t\tcontinue\n\t\t}\n\t\tswitch arg := arg.(type) {\n\t\tdefault:\n\t\t\tvals[i+1] = StringValue(fmt.Sprintf(\"%v\", arg))\n\t\tcase []byte:\n\t\t\tvals[i+1] = StringValue(string(arg))\n\t\tcase string:\n\t\t\tvals[i+1] = StringValue(arg)\n\t\tcase nil:\n\t\t\tvals[i+1] = NullValue()\n\t\t}\n\t}\n\treturn ArrayValue(vals)\n}", "id": 24118, "concepts": ["interface", "type assertion", "type switch", "type conversion", "type definition", "slice", "map", "struct", "function definition"], "_raw_llm_output": "interface, type assertion, type switch, type conversion, type definition, slice, map, struct, function definition"}
{"seed": "// AliasFields returns SearchAttributes struct where each search attribute name is replaced with alias.\n// If no replacement where made, it returns nil which means that original SearchAttributes struct should be used.\nfunc AliasFields(\n\tmapperProvider MapperProvider,\n\tsearchAttributes *commonpb.SearchAttributes,\n\tnamespaceName string,\n) (*commonpb.SearchAttributes, error) {\n\tmapper, err := mapperProvider.GetMapper(namespace.Name(namespaceName))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(searchAttributes.GetIndexedFields()) == 0 || mapper == nil {\n\t\treturn nil, nil\n\t}\n\n\tnewIndexedFields := make(map[string]*commonpb.Payload, len(searchAttributes.GetIndexedFields()))\n\tmapped := false\n\tfor saName, saPayload := range searchAttributes.GetIndexedFields() {\n\t\tif !IsMappable(saName) {\n\t\t\tnewIndexedFields[saName] = saPayload\n\t\t\tcontinue\n\t\t}\n\n\t\taliasName, err := mapper.GetAlias(saName, namespaceName)\n\t\tif err != nil {\n\t\t\tif _, isInvalidArgument := err.(*serviceerror.InvalidArgument); isInvalidArgument {\n\t\t\t\t// Silently ignore serviceerror.InvalidArgument because it indicates unmapped field (alias was deleted, for example).\n\t\t\t\t// IMPORTANT: AliasFields should never return serviceerror.InvalidArgument because it is used by Poll API and the error\n\t\t\t\t// goes through up to SDK, which shutdowns worker when it receives serviceerror.InvalidArgument as poll response.\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn nil, err\n\t\t}\n\t\tif aliasName != saName {\n\t\t\tmapped = true\n\t\t}\n\t\tnewIndexedFields[aliasName] = saPayload\n\t}\n\n\t// If no field name was mapped, return nil to save on clone operation on caller side.\n\tif !mapped {\n\t\treturn nil, nil\n\t}\n\treturn &commonpb.SearchAttributes{IndexedFields: newIndexedFields}, nil\n}", "id": 24121, "concepts": ["map iteration (range loop)", "map lookup", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", "map iteration (range loop)", ""], "_raw_llm_output": "map iteration (range loop), map lookup, map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop), map iteration (range loop),"}
{"seed": "// PossibleCustomRuleEnabledStateValues returns an array of possible values for the CustomRuleEnabledState const type.\nfunc PossibleCustomRuleEnabledStateValues() []CustomRuleEnabledState {\n\treturn []CustomRuleEnabledState{CustomRuleEnabledStateDisabled, CustomRuleEnabledStateEnabled}\n}", "id": 24125, "concepts": ["const type definition", "array definition", "array iteration"], "_raw_llm_output": "const type definition, array definition, array iteration"}
{"seed": "// NewMockDBStoreFrom creates a new mock of the MockDBStore interface. All\n// methods delegate to the given implementation, unless overwritten.\nfunc NewMockDBStoreFrom(i DBStore) *MockDBStore {\n\treturn &MockDBStore{\n\t\tCommitsVisibleToUploadFunc: &DBStoreCommitsVisibleToUploadFunc{\n\t\t\tdefaultHook: i.CommitsVisibleToUpload,\n\t\t},\n\t\tDirtyRepositoriesFunc: &DBStoreDirtyRepositoriesFunc{\n\t\t\tdefaultHook: i.DirtyRepositories,\n\t\t},\n\t\tDoneFunc: &DBStoreDoneFunc{\n\t\t\tdefaultHook: i.Done,\n\t\t},\n\t\tGetConfigurationPoliciesFunc: &DBStoreGetConfigurationPoliciesFunc{\n\t\t\tdefaultHook: i.GetConfigurationPolicies,\n\t\t},\n\t\tGetUploadsFunc: &DBStoreGetUploadsFunc{\n\t\t\tdefaultHook: i.GetUploads,\n\t\t},\n\t\tHandleFunc: &DBStoreHandleFunc{\n\t\t\tdefaultHook: i.Handle,\n\t\t},\n\t\tSelectRepositoriesForRetentionScanFunc: &DBStoreSelectRepositoriesForRetentionScanFunc{\n\t\t\tdefaultHook: i.SelectRepositoriesForRetentionScan,\n\t\t},\n\t\tTransactFunc: &DBStoreTransactFunc{\n\t\t\tdefaultHook: i.Transact,\n\t\t},\n\t\tUpdateUploadRetentionFunc: &DBStoreUpdateUploadRetentionFunc{\n\t\t\tdefaultHook: i.UpdateUploadRetention,\n\t\t},\n\t}\n}", "id": 24127, "concepts": ["interface implementation", "interface method definition", "interface method call", "interface method return value", "interface method return value type", "interface method return value type conversion", "interface method return value type conversion to interface", "interface method return value type conversion to interface", "interface method return value type conversion to interface", "interface method return value type conversion to interface", "interface method return value type conversion to interface", "interface method return value type conversion to interface", "interface method return value type conversion to interface", "interface method return value type conversion to interface", "interface method return value type conversion to interface", "interface method return value type conversion to interface", "interface method return value type conversion to interface", "interface method return value type conversion to interface", "interface method return value type conversion to interface", "interface method return value type conversion to interface", "interface method return value type conversion to interface", "interface method return value type conversion to interface", "interface method return value type conversion to interface", "interface method return value type conversion to interface", "interface method return value type conversion to interface", "interface method return value type conversion to interface", "interface method return value type conversion to interface", "interface method return value type conversion to interface", "interface method return value type conversion to interface", "interface method return value type conversion to interface", "interface method return value type conversion to interface", "interface"], "_raw_llm_output": "interface implementation, interface method definition, interface method call, interface method return value, interface method return value type, interface method return value type conversion, interface method return value type conversion to interface, interface method return value type conversion to interface, interface method return value type conversion to interface, interface method return value type conversion to interface, interface method return value type conversion to interface, interface method return value type conversion to interface, interface method return value type conversion to interface, interface method return value type conversion to interface, interface method return value type conversion to interface, interface method return value type conversion to interface, interface method return value type conversion to interface, interface method return value type conversion to interface, interface method return value type conversion to interface, interface method return value type conversion to interface, interface method return value type conversion to interface, interface method return value type conversion to interface, interface method return value type conversion to interface, interface method return value type conversion to interface, interface method return value type conversion to interface, interface method return value type conversion to interface, interface method return value type conversion to interface, interface method return value type conversion to interface, interface method return value type conversion to interface, interface method return value type conversion to interface, interface method return value type conversion to interface, interface"}
{"seed": "// MessageToBytes returns byte representation of the SimpleMessage\nfunc MessageToBytes(m *SimpleMessage) (b []byte, err error) {\n\tcontent, e := json.Marshal(m)\n\tif e != nil {\n\t\treturn nil, e\n\t}\n\treturn content, nil\n}", "id": 24141, "concepts": ["json.Marshal", "json.Unmarshal", "error handling"], "_raw_llm_output": "json.Marshal, json.Unmarshal, error handling"}
{"seed": "// NewTokenNotIn applies the NotIn predicate on the \"new_token\" field.\nfunc NewTokenNotIn(vs ...string) predicate.User {\n\treturn predicate.User(sql.FieldNotIn(FieldNewToken, vs...))\n}", "id": 24160, "concepts": ["predicate.User", "sql.FieldNotIn", "standard library usage"], "_raw_llm_output": "predicate.User, sql.FieldNotIn, standard library usage"}
{"seed": "// CreateMessagePipeForDirectory creates a message pipe for use with the\n// Directory interface with a Directory_Request on one end and a Directory_Pointer on the other.\nfunc CreateMessagePipeForDirectory() (Directory_Request, Directory_Pointer) {\n        r, p := bindings.CreateMessagePipeForMojoInterface()\n        return Directory_Request(r), Directory_Pointer(p)\n}", "id": 24164, "concepts": ["bindings package usage", "Mojo interface usage"], "_raw_llm_output": "bindings package usage, Mojo interface usage"}
{"seed": "// GetContentReader fetches url and returns io.ReadCloser.\n// Caller must close the reader.\nfunc GetContentReader(url string) (io.ReadCloser, error) {\n\t// http.Get() allows up to 10 redirects\n\tres, err := http.Get(url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif res.StatusCode/100 != 2 {\n\t\treturn nil, errors.New(url + \" returned non-successful status: \" + res.Status)\n\t}\n\treturn res.Body, nil\n}", "id": 24172, "concepts": ["http.Get", "io.ReadCloser", "error handling (errors.New)", "status code handling"], "_raw_llm_output": "http.Get, io.ReadCloser, error handling (errors.New), status code handling"}
{"seed": "// RequireFromString is similar to FromString except that instead of returning\n// an error on malformed input, it panics. It should only be used when the\n// input is statically verifiable.\nfunc RequireFromString(s string) ID {\n\tid, err := FromString(s)\n\tpanicOnErr(err)\n\treturn id\n}", "id": 24173, "concepts": ["panicOnErr", "panic", "error handling"], "_raw_llm_output": "panicOnErr, panic, error handling"}
{"seed": "// PossibleSubscriptionStateValues returns an array of possible values for the SubscriptionState const type.\nfunc PossibleSubscriptionStateValues() []SubscriptionState {\n\treturn []SubscriptionState{SubscriptionStateDeleted, SubscriptionStateRegistered, SubscriptionStateSuspended, SubscriptionStateUnregistered, SubscriptionStateWarned}\n}", "id": 24178, "concepts": ["const type", "array", "basic function definition"], "_raw_llm_output": "const type, array, basic function definition"}
{"seed": "// wmFollowRoot verifies that child activities follow the root activity state as defined in:\n// go/arc-wm-p \"Clamshell: new activities follow root activity\" (slides #15 - #17).\nfunc wmFollowRoot(ctx context.Context, tconn *chrome.TestConn, a *arc.ARC, d *ui.Device) error {\n\tfor _, test := range []struct {\n\t\tname    string\n\t\tpkgName string\n\t\tact     string\n\t}{\n\t\t// Root activities.\n\t\t{\"Unspecified (N)\", wm.Pkg24, wm.ResizableUnspecifiedActivity},\n\t\t{\"Portrait (N)\", wm.Pkg24, wm.ResizablePortraitActivity},\n\t\t{\"Landscape (N)\", wm.Pkg24, wm.ResizableLandscapeActivity},\n\n\t\t{\"Unspecified (Pre-N)\", wm.Pkg23, wm.UnspecifiedActivity},\n\t\t{\"Portrait (Pre-N)\", wm.Pkg23, wm.PortraitActivity},\n\t\t{\"Landscape (Pre-N)\", wm.Pkg23, wm.LandscapeActivity},\n\t} {\n\t\tfor _, orientation := range []struct {\n\t\t\tname string\n\t\t\tfn   uiClickFunc\n\t\t}{\n\t\t\t// Orientations for the child activity.\n\t\t\t{\"Unspecified\", wm.UIClickUnspecified},\n\t\t\t{\"Landscape\", wm.UIClickLandscape},\n\t\t\t{\"Portrait\", wm.UIClickPortrait},\n\t\t} {\n\t\t\tif err := func() error {\n\t\t\t\ttesting.ContextLogf(ctx, \"Running subtest: \\\"Root activity=%s -> child=%s\\\"\", test.name, orientation.name)\n\n\t\t\t\tif err := a.Command(ctx, \"am\", \"broadcast\", \"-a\", \"android.intent.action.arc.cleartaskstate\").Run(); err != nil {\n\t\t\t\t\treturn errors.Wrap(err, \"failed to clear WM state\")\n\t\t\t\t}\n\t\t\t\tact, err := arc.NewActivity(a, test.pkgName, test.act)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tdefer act.Close()\n\n\t\t\t\tif err := act.StartWithDefaultOptions(ctx, tconn); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\t// Stop activity at exit time so that the next WM test can launch a different activity from the same package.\n\t\t\t\tdefer act.Stop(ctx, tconn)\n\t\t\t\tif err := wm.WaitUntilActivityIsReady(ctx, tconn, act, d); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tif ws, err := ash.SetARCAppWindowState(ctx, tconn, act.PackageName(), ash.WMEventNormal); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t} else if ws != ash.WindowStateNormal {\n\t\t\t\t\treturn errors.Errorf(\"failed to set window state: got %s, want %s\", ws, ash.WMEventNormal)\n\t\t\t\t}\n\n\t\t\t\torigOrientation, err := wm.UIOrientation(ctx, act, d)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tif err := orientation.fn(ctx, act, d); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif err := wm.UIClickLaunchActivity(ctx, act, d); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\t// Window state and orientation should not change, and there should be two activities in the stack.\n\n\t\t\t\tif err := ash.WaitForARCAppWindowState(ctx, tconn, act.PackageName(), ash.WindowStateNormal); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tif newOrientation, err := wm.UIOrientation(ctx, act, d); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t} else if newOrientation != origOrientation {\n\t\t\t\t\treturn errors.Errorf(\"invalid orientation: got %q; want %q\", newOrientation, origOrientation)\n\t\t\t\t}\n\n\t\t\t\tif nrActivities, err := wm.UINumberActivities(ctx, act, d); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t} else if nrActivities != 2 {\n\t\t\t\t\treturn errors.Errorf(\"invalid number of activities: got %d; want 2\", nrActivities)\n\t\t\t\t}\n\n\t\t\t\treturn nil\n\t\t\t}(); err != nil {\n\t\t\t\treturn errors.Wrapf(err, \"\\\"Root activity=%s -> child=%s\\\" subtest failed\", test.name, orientation.name)\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}", "id": 24179, "concepts": ["concurrency", "sync.WaitGroup", "anonymous function", "wait for activity to be ready", "wait for window state", "wait for ARC app window state", "wait for UI element to be visible", "wait for UI element to be clickable", "wait for UI element to be enabled", "wait for UI element to be selected", "wait for UI element to be checked", "wait for UI element to be unchecked", "wait for UI element to be selected", "wait for UI element to be checked", "wait for UI element to be unchecked", "wait for UI element to be selected", "wait for UI element to be checked", "wait for UI element to be unchecked", "wait for UI element to be selected", "wait for UI element to be checked", "wait for UI element to be unchecked", "wait for UI element to be selected", "wait for UI element to be checked", "wait for UI element to be unchecked", "wait for UI element to be selected", "wait for UI element to be checked", "wait for UI element to be unchecked", "wait for UI element to be selected", "wait for UI element to be checked", "wait for UI element to be unchecked", "wait for UI element to be selected", "wait for UI element to be checked", "wait for UI element to be unchecked", "wait for UI element to be selected", "wait"], "_raw_llm_output": "concurrency, sync.WaitGroup, anonymous function, wait for activity to be ready, wait for window state, wait for ARC app window state, wait for UI element to be visible, wait for UI element to be clickable, wait for UI element to be enabled, wait for UI element to be selected, wait for UI element to be checked, wait for UI element to be unchecked, wait for UI element to be selected, wait for UI element to be checked, wait for UI element to be unchecked, wait for UI element to be selected, wait for UI element to be checked, wait for UI element to be unchecked, wait for UI element to be selected, wait for UI element to be checked, wait for UI element to be unchecked, wait for UI element to be selected, wait for UI element to be checked, wait for UI element to be unchecked, wait for UI element to be selected, wait for UI element to be checked, wait for UI element to be unchecked, wait for UI element to be selected, wait for UI element to be checked, wait for UI element to be unchecked, wait for UI element to be selected, wait for UI element to be checked, wait for UI element to be unchecked, wait for UI element to be selected, wait"}
{"seed": "// [ABC100C - *3 or /2](https://atcoder.jp/contests/abc100/tasks/abc100_c)\nfunc AnswerABC100C\u305d\u306e1(N int, A []int) int {\n\t// \u5fc5\u305a\u8ab0\u304b1\u4eba\u304c\u300c2\u3067\u5272\u308c\u308b\u300d\u3092\u8ca0\u62c5\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\n\t// \u3044\u304f\u30893\u500d\u3057\u3066\u3082\u3001\u300c2\u3067\u5272\u308c\u308b\u300d\u56de\u6570\u306f\u5897\u3048\u306a\u3044\n\t// \u2192 2\u3067\u5272\u308c\u308b\u56de\u6570\u3067\u6c7a\u307e\u308b\n\tvar ans int\n\n\tfor _, a := range A {\n\t\tcountDivide2 := 0 // 2\u3067\u5272\u308c\u308b\u56de\u6570\n\n\t\tfor a > 0 {\n\t\t\tif a%2 == 0 {\n\t\t\t\ta /= 2\n\t\t\t\tcountDivide2++\n\t\t\t} else {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tans += countDivide2\n\t}\n\n\treturn ans\n}", "id": 24181, "concepts": ["integer division", "integer summation"], "_raw_llm_output": "integer division, integer summation"}
{"seed": "// RequestHandler adds the request method and URL as a field to the context's logger\n// using fieldKey as field key.\nfunc RequestHandler(fieldKey string) func(next httpserver.Handler) httpserver.Handler {\n\treturn func(next httpserver.Handler) httpserver.Handler {\n\t\treturn httpserver.HandlerFunc(func(w http.ResponseWriter, r *http.Request) (int, error) {\n\t\t\tlog := zerolog.Ctx(r.Context())\n\t\t\tlog.UpdateContext(func(c zerolog.Context) zerolog.Context {\n\t\t\t\treturn c.Str(fieldKey, r.Method+\" \"+r.URL.String())\n\t\t\t})\n\t\t\treturn next.ServeHTTP(w, r)\n\t\t})\n\t}\n}", "id": 24187, "concepts": ["http.ResponseWriter", "http.Request", "http.HandlerFunc", "zerolog.Context", "zerolog.UpdateContext", "httpserver.Handler", "httpserver.HandlerFunc", "fieldKey"], "_raw_llm_output": "http.ResponseWriter, http.Request, http.HandlerFunc, zerolog.Context, zerolog.UpdateContext, httpserver.Handler, httpserver.HandlerFunc, fieldKey"}
{"seed": "// IsListOfStringInterfaceMaps returns true if the given list of interface{}\n// values is actually a list of map[string]interface{} values. Returns false if\n// the given list is empty.\nfunc IsListOfStringInterfaceMaps(list []interface{}) bool {\n\tif len(list) == 0 {\n\t\treturn false\n\t}\n\tfor _, e := range list {\n\t\t_, ok := e.(map[string]interface{})\n\t\tif !ok {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}", "id": 24199, "concepts": ["interface{} usage", "type assertion", "list iteration"], "_raw_llm_output": "interface{} usage, type assertion, list iteration"}
{"seed": "// GetPodSpecDefaulter extracts the PodSpecDefaulter from the context.\nfunc GetPodSpecDefaulter(ctx context.Context) PodSpecDefaulter {\n\tuntyped := ctx.Value(psdKey{})\n\tif untyped == nil {\n\t\treturn nil\n\t}\n\treturn untyped.(PodSpecDefaulter)\n}", "id": 24212, "concepts": ["context", "context.Context", "context.WithValue", "context.Value"], "_raw_llm_output": "context, context.Context, context.WithValue, context.Value"}
{"seed": "// AvailableLanguages lists all available languages\r\nfunc AvailableLanguages() []string {\r\n\tlanguages := []string{}\r\n\tfor _, trad := range translations {\r\n\t\tlanguages = append(languages, trad.Language)\r\n\t}\r\n\treturn languages\r\n}", "id": 24214, "concepts": ["slice iteration (range loop)", "slice manipulation", "basic function definition"], "_raw_llm_output": "slice iteration (range loop), slice manipulation, basic function definition"}
{"seed": "// SensitivityPConfidential returns a pointer to SensitivityVConfidential\nfunc SensitivityPConfidential() *Sensitivity {\n\tv := SensitivityVConfidential\n\treturn &v\n}", "id": 24215, "concepts": ["pointer", "pointer dereference"], "_raw_llm_output": "pointer, pointer dereference"}
{"seed": "// WithConfigFile tells Parse to read the provided filename as a config file.\n// Requires WithConfigFileParser, and overrides WithConfigFileFlag.\n// Because config files should generally be user-specifiable, this option\n// should be rarely used. Prefer WithConfigFileFlag.\nfunc WithConfigFile(filename string) Option {\n\treturn func(c *Context) {\n\t\tc.configFile = filename\n\t}\n}", "id": 24224, "concepts": ["function composition", "function composition with anonymous functions", "function composition with function literals", "function composition with function references", "function composition with function values", "function composition with named functions", "function composition with named functions as parameters", "function composition with named functions as return values", "function composition with named functions as return values", "function composition with named functions as return values", "function composition with named functions as return values", "function composition with named functions as return values", "function composition with named functions as return values", "function composition with named functions as return values", "function composition with named functions as return values", "function composition with named functions as return values", "function composition with named functions as return values", "function composition with named functions as return values", "function composition with named functions as return values", "function composition with named functions as return values", "function composition with named functions as return values", "function composition with named functions as return values", "function composition with named functions as return values", "function composition with named functions as return values", "function composition with named functions as return values", "function composition with named functions as return values", "function composition with named functions as return values", "function composition with named functions as return values", "function composition with named functions as return values", "function composition with named functions as return values", "function composition with named functions as return"], "_raw_llm_output": "function composition, function composition with anonymous functions, function composition with function literals, function composition with function references, function composition with function values, function composition with named functions, function composition with named functions as parameters, function composition with named functions as return values, function composition with named functions as return values, function composition with named functions as return values, function composition with named functions as return values, function composition with named functions as return values, function composition with named functions as return values, function composition with named functions as return values, function composition with named functions as return values, function composition with named functions as return values, function composition with named functions as return values, function composition with named functions as return values, function composition with named functions as return values, function composition with named functions as return values, function composition with named functions as return values, function composition with named functions as return values, function composition with named functions as return values, function composition with named functions as return values, function composition with named functions as return values, function composition with named functions as return values, function composition with named functions as return values, function composition with named functions as return values, function composition with named functions as return values, function composition with named functions as return values, function composition with named functions as return"}
{"seed": "// New creates a new backoff with the specified max duration and\n// interval. Zero values may be used to use the default values.\n//\n// Panics if either max or interval is negative.\nfunc New(max time.Duration, interval time.Duration) *Backoff {\n\tif max < 0 || interval < 0 {\n\t\tpanic(\"backoff: max or interval is negative\")\n\t}\n\n\tb := &Backoff{\n\t\tmaxDuration: max,\n\t\tinterval:    interval,\n\t}\n\tb.setup()\n\treturn b\n}", "id": 24228, "concepts": ["time package usage", "basic function definition", "error handling (panic)", "time.Duration"], "_raw_llm_output": "time package usage, basic function definition, error handling (panic), time.Duration"}
{"seed": "// NewQueryTokenswapParam creates a new QueryTokenswapParam\nfunc NewQueryTokenswapParam(txHash string) QueryTokenswapParam {\n\treturn QueryTokenswapParam{\n\t\tTxHash: txHash,\n\t}\n}", "id": 24238, "concepts": ["struct definition", "struct field definition", "struct initialization"], "_raw_llm_output": "struct definition, struct field definition, struct initialization"}
{"seed": "// unary = '+' expr | primary\nfunc parseUnary(lex *lexer) Expr {\n\tif lex.token == '+' || lex.token == '-' {\n\t\top := lex.token\n\t\tlex.next() // consume '+' or '-'\n\t\treturn unary{op, parseUnary(lex)}\n\t}\n\treturn parsePrimary(lex)\n}", "id": 24247, "concepts": ["recursive function definition", "operator precedence", "operator associativity", "operator precedence table"], "_raw_llm_output": "recursive function definition, operator precedence, operator associativity, operator precedence table"}
{"seed": "// AssetInfo loads and returns the asset info for the given name.\n// It returns an error if the asset could not be found or\n// could not be loaded.\nfunc AssetInfo(name string) (os.FileInfo, error) {\n\tcanonicalName := strings.Replace(name, \"\\\\\", \"/\", -1)\n\tif f, ok := _bindata[canonicalName]; ok {\n\t\ta, err := f()\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"AssetInfo %s can't read by error: %v\", name, err)\n\t\t}\n\t\treturn a.info, nil\n\t}\n\treturn nil, fmt.Errorf(\"AssetInfo %s not found\", name)\n}", "id": 24249, "concepts": ["bindata", "os.FileInfo", "error handling"], "_raw_llm_output": "bindata, os.FileInfo, error handling"}
{"seed": "// ReadDepositPart reads a full DepositPart structure from the database based on the supplied row object\nfunc ReadDepositPart(row *sql.Row, a *DepositPart) error {\n\terr := row.Scan(&a.DPID, &a.DID, &a.BID, &a.RCPTID, &a.CreateTS, &a.CreateBy, &a.LastModTime, &a.LastModBy)\n\tSkipSQLNoRowsError(&err)\n\treturn err\n}", "id": 24257, "concepts": ["sql.Row", "sql.Scan", "sql.ErrNoRows", "error handling (idiomatic `if err != nil`", "`errors.Is`", "`errors.As`)", "error handling (sql.ErrNoRows)", "error handling (SkipSQLNoRowsError)"], "_raw_llm_output": "sql.Row, sql.Scan, sql.ErrNoRows, error handling (idiomatic `if err != nil`, `errors.Is`, `errors.As`), error handling (sql.ErrNoRows), error handling (SkipSQLNoRowsError)"}
{"seed": "// WithIgnoreRequest holds the function to use for determining if the\n// incoming HTTP request should not be traced.\nfunc WithIgnoreRequest(f func(*http.Request) bool) MuxOption {\n\treturn func(cfg *config) {\n\t\tcfg.ignoreRequest = f\n\t}\n}", "id": 24259, "concepts": ["function definition", "function composition", "function options"], "_raw_llm_output": "function definition, function composition, function options"}
{"seed": "// Progress_ is a convenience wrapper for Progress without the attrs argument.\nfunc Progress_(children ...HTML) HTML {\n  return Progress(nil, children...)\n}", "id": 24261, "concepts": ["HTML", "anonymous function", "function definition", "function call"], "_raw_llm_output": "HTML, anonymous function, function definition, function call"}
{"seed": "// Hr_ is a convenience wrapper for Hr without the attrs argument.\nfunc Hr_() HTML {\n  return Hr(nil)\n}", "id": 24262, "concepts": ["HTML tag definition", "HTML tag usage", "HTML tag attribute definition", "HTML tag attribute usage"], "_raw_llm_output": "HTML tag definition, HTML tag usage, HTML tag attribute definition, HTML tag attribute usage"}
{"seed": "// InjectTrustedContext takes baseplate HTTP headers from the request,\n// verifies that it should trust the headers using the provided\n// HeaderTrustHandler, and attaches the trusted headers to the context.\n//\n// These headers can be retrieved using httpbp.GetHeader.\n//\n// This method does not implement the go-kit http.RequestFunc interface, if you\n// want to use this with go-kit, use PopulateRequestContext to return a function\n// that wraps InjectTrustedContext with the HeaderTrustHandler and does\n// implement the http.RequestFunc interface.\nfunc InjectTrustedContext(ctx context.Context, t HeaderTrustHandler, r *http.Request) context.Context {\n\tif t.TrustEdgeContext(r) {\n\t\tctx = SetHeader(ctx, EdgeContextContextKey, r.Header.Get(EdgeContextHeader))\n\t}\n\n\tif t.TrustSpan(r) {\n\t\tfor k, v := range map[HeaderContextKey]string{\n\t\t\tTraceIDContextKey:     r.Header.Get(TraceIDHeader),\n\t\t\tParentIDContextKey:    r.Header.Get(ParentIDHeader),\n\t\t\tSpanIDContextKey:      r.Header.Get(SpanIDHeader),\n\t\t\tSpanFlagsContextKey:   r.Header.Get(SpanFlagsHeader),\n\t\t\tSpanSampledContextKey: r.Header.Get(SpanSampledHeader),\n\t\t} {\n\t\t\tctx = SetHeader(ctx, k, v)\n\t\t}\n\t}\n\n\treturn ctx\n}", "id": 24266, "concepts": ["context", "context.Context", "http.Request", "http.Header", "httpbp.GetHeader", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context", "context.Context"], "_raw_llm_output": "context, context.Context, http.Request, http.Header, httpbp.GetHeader, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context, context.Context"}
{"seed": "// Strong_ is a convenience wrapper for Strong without the attrs argument.\nfunc Strong_(children ...HTML) HTML {\n  return Strong(nil, children...)\n}", "id": 24271, "concepts": ["function definition", "variadic function", "HTML rendering"], "_raw_llm_output": "function definition, variadic function, HTML rendering"}
{"seed": "// NewPointerField will return a new pointer field with stuffing as raw bytes.\n// The pointer field specifies where the TableHeader should start.\n// Everything in between the pointer field and table header should\n// be bytes with the value 0xFF.\nfunc NewPointerField(size int) []byte {\n\tdata := make([]byte, size+1)\n\tdata[0] = byte(size)\n\tfor i := 1; i < size+1; i++ {\n\t\tdata[i] = 0xFF\n\t}\n\treturn data\n}", "id": 24275, "concepts": ["slice creation", "byte handling", "pointer arithmetic"], "_raw_llm_output": "slice creation, byte handling, pointer arithmetic"}
{"seed": "// HasPetsWith applies the HasEdge predicate on the \"pets\" edge with a given conditions (other predicates).\nfunc HasPetsWith(preds ...predicate.Pet) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\tstep := sqlgraph.NewStep(\n\t\t\tsqlgraph.From(Table, FieldID),\n\t\t\tsqlgraph.To(PetsInverseTable, PetFieldID),\n\t\t\tsqlgraph.Edge(sqlgraph.O2O, false, PetsTable, PetsColumn),\n\t\t)\n\t\tsqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {\n\t\t\tfor _, p := range preds {\n\t\t\t\tp(s)\n\t\t\t}\n\t\t})\n\t})\n}", "id": 24283, "concepts": ["sqlgraph package usage", "sql.Selector usage", "sqlgraph.HasNeighborsWith usage"], "_raw_llm_output": "sqlgraph package usage, sql.Selector usage, sqlgraph.HasNeighborsWith usage"}
{"seed": "// NewDig instantiates a new Dig object\n// This constructor will assign default values to properties that have it defined,\n// and makes sure properties required by API are set, but the set of arguments\n// will change when the set of required properties is changed\nfunc NewDig(licenseID int32, posX int32, posY int32, depth int32) *Dig {\n\tthis := Dig{}\n\tthis.LicenseID = licenseID\n\tthis.PosX = posX\n\tthis.PosY = posY\n\tthis.Depth = depth\n\treturn &this\n}", "id": 24285, "concepts": ["struct definition", "struct initialization", "struct field assignment"], "_raw_llm_output": "struct definition, struct initialization, struct field assignment"}
{"seed": "// NewTokenGTE applies the GTE predicate on the \"new_token\" field.\nfunc NewTokenGTE(v string) predicate.User {\n\treturn predicate.User(sql.FieldGTE(FieldNewToken, v))\n}", "id": 24297, "concepts": ["sql package usage", "predicate definition", "predicate usage"], "_raw_llm_output": "sql package usage, predicate definition, predicate usage"}
{"seed": "// wmRT15 covers resizable/tablet: display size change.\n// Expected behavior is defined in: go/arc-wm-r RT15: resizable/tablet: display size change.\nfunc wmRT15(ctx context.Context, tconn *chrome.TestConn, a *arc.ARC, d *ui.Device) error {\n\tntActivities := []wm.TabletLaunchActivityInfo{\n\t\twm.TabletLaunchActivityInfo{\n\t\t\tActivityName: wm.ResizableLandscapeActivity,\n\t\t\tDesiredDO:    display.OrientationLandscapePrimary,\n\t\t},\n\t\twm.TabletLaunchActivityInfo{\n\t\t\tActivityName: wm.ResizableUnspecifiedActivity,\n\t\t\tDesiredDO:    display.OrientationLandscapePrimary,\n\t\t},\n\t\twm.TabletLaunchActivityInfo{\n\t\t\tActivityName: wm.ResizablePortraitActivity,\n\t\t\tDesiredDO:    display.OrientationPortraitPrimary,\n\t\t},\n\t\twm.TabletLaunchActivityInfo{\n\t\t\tActivityName: wm.ResizableUnspecifiedActivity,\n\t\t\tDesiredDO:    display.OrientationPortraitPrimary,\n\t\t},\n\t}\n\n\treturn wm.TabletDisplaySizeChangeHelper(ctx, tconn, a, d, ntActivities)\n}", "id": 24300, "concepts": ["context", "ui.Device", "arc.ARC", "display.Orientation", "display.OrientationLandscapePrimary", "display.OrientationPortraitPrimary", "wm.TabletLaunchActivityInfo", "wm.TabletDisplaySizeChangeHelper", "wm.ResizableLandscapeActivity", "wm.ResizableUnspecifiedActivity", "wm.ResizablePortraitActivity"], "_raw_llm_output": "context, ui.Device, arc.ARC, display.Orientation, display.OrientationLandscapePrimary, display.OrientationPortraitPrimary, wm.TabletLaunchActivityInfo, wm.TabletDisplaySizeChangeHelper, wm.ResizableLandscapeActivity, wm.ResizableUnspecifiedActivity, wm.ResizablePortraitActivity"}
{"seed": "// MapIntInt64Ptr takes two inputs -\n// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list\nfunc MapIntInt64Ptr(f func(*int) *int64, list []*int) []*int64 {\n\tif f == nil {\n\t\treturn []*int64{}\n\t}\n\tnewList := make([]*int64, len(list))\n\tfor i, v := range list {\n\t\tnewList[i] = f(v)\n\t}\n\treturn newList\n}", "id": 24306, "concepts": ["function definition", "function application", "function pointer", "function composition"], "_raw_llm_output": "function definition, function application, function pointer, function composition"}
{"seed": "// isManifestInvalidError returns true iff err from client.HandleErrorReponse is a \u201cmanifest invalid\u201d error.\nfunc isManifestInvalidError(err error) bool {\n\terrors, ok := err.(errcode.Errors)\n\tif !ok || len(errors) == 0 {\n\t\treturn false\n\t}\n\tec, ok := errors[0].(errcode.ErrorCoder)\n\tif !ok {\n\t\treturn false\n\t}\n\t// ErrorCodeManifestInvalid is returned by OpenShift with acceptschema2=false.\n\t// ErrorCodeTagInvalid is returned by docker/distribution (at least as of commit ec87e9b6971d831f0eff752ddb54fb64693e51cd)\n\t// when uploading to a tag (because it can\u2019t find a matching tag inside the manifest)\n\treturn ec.ErrorCode() == v2.ErrorCodeManifestInvalid || ec.ErrorCode() == v2.ErrorCodeTagInvalid\n}", "id": 24311, "concepts": ["error handling (errors.Is)", "error type assertion", "error type switch"], "_raw_llm_output": "error handling (errors.Is), error type assertion, error type switch"}
{"seed": "// HiCyanString is a convenient helper function to return a string with hi-intensity cyan\n// foreground.\nfunc HiCyanString(format string, a ...interface{}) (s string) {\n\ts = colorString(FgHiCyan, format, a...)\n\treturn\n}", "id": 24327, "concepts": ["color formatting", "string formatting", "fmt package usage"], "_raw_llm_output": "color formatting, string formatting, fmt package usage"}
{"seed": "// NewRepositoryTagServiceServer builds a TwirpServer that can be used as an http.Handler to handle\n// HTTP requests that are routed to the right method in the provided svc implementation.\n// The opts are twirp.ServerOption modifiers, for example twirp.WithServerHooks(hooks).\nfunc NewRepositoryTagServiceServer(svc RepositoryTagService, opts ...interface{}) TwirpServer {\n\tserverOpts := twirp.ServerOptions{}\n\tfor _, opt := range opts {\n\t\tswitch o := opt.(type) {\n\t\tcase twirp.ServerOption:\n\t\t\to(&serverOpts)\n\t\tcase *twirp.ServerHooks: // backwards compatibility, allow to specify hooks as an argument\n\t\t\ttwirp.WithServerHooks(o)(&serverOpts)\n\t\tcase nil: // backwards compatibility, allow nil value for the argument\n\t\t\tcontinue\n\t\tdefault:\n\t\t\tpanic(fmt.Sprintf(\"Invalid option type %T on NewRepositoryTagServiceServer\", o))\n\t\t}\n\t}\n\n\treturn &repositoryTagServiceServer{\n\t\tRepositoryTagService: svc,\n\t\tpathPrefix:           serverOpts.PathPrefix(),\n\t\tinterceptor:          twirp.ChainInterceptors(serverOpts.Interceptors...),\n\t\thooks:                serverOpts.Hooks,\n\t\tjsonSkipDefaults:     serverOpts.JSONSkipDefaults,\n\t}\n}", "id": 24329, "concepts": ["twirp", "http.Handler", "http.HandlerFunc", "twirp.ServerOption", "twirp.ServerHooks", "twirp.WithServerHooks", "twirp.ChainInterceptors", "twirp.ServerOptions", "twirp.JSONSkipDefaults"], "_raw_llm_output": "twirp, http.Handler, http.HandlerFunc, twirp.ServerOption, twirp.ServerHooks, twirp.WithServerHooks, twirp.ChainInterceptors, twirp.ServerOptions, twirp.JSONSkipDefaults"}
{"seed": "// SocialEmailHasPrefix applies the HasPrefix predicate on the \"social_email\" field.\nfunc SocialEmailHasPrefix(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.HasPrefix(s.C(FieldSocialEmail), v))\n\t})\n}", "id": 24344, "concepts": ["sql.Selector", "sql.C", "sql.HasPrefix", "sql.Where", "sql.And", "sql.Or", "sql.Not", "sql.IsNull", "sql.IsNotNull", "sql.Eq", "sql.Neq", "sql.Gt", "sql.Gte", "sql.Lt", "sql.Lte", "sql.Like", "sql.NotLike", "sql.In", "sql.NotIn", "sql.Between", "sql.NotBetween", "sql.Asc", "sql.Desc", "sql.NullsFirst", "sql.NullsLast", "sql.IsNull", "sql.IsNotNull", "sql.And", "sql.Or", "sql.Not", "sql.Xor", "sql.Xor", "sql.Xor", "sql.Xor", "sql.Xor", "sql.Xor", "sql.Xor", "sql.Xor", "sql.Xor", "sql.Xor", "sql.Xor", "sql.Xor", "sql.Xor", "sql.Xor", "sql.Xor", "sql.Xor", "sql.Xor", "sql.Xor", "sql.Xor", "sql.Xor", "sql.Xor", "sql.Xor", "sql.Xor", "sql.Xor", "sql.Xor", "sql.Xor", "sql.Xor", "sql.Xor", "sql.Xor", "sql.Xor", "sql.Xor", "sql."], "_raw_llm_output": "sql.Selector, sql.C, sql.HasPrefix, sql.Where, sql.And, sql.Or, sql.Not, sql.IsNull, sql.IsNotNull, sql.Eq, sql.Neq, sql.Gt, sql.Gte, sql.Lt, sql.Lte, sql.Like, sql.NotLike, sql.In, sql.NotIn, sql.Between, sql.NotBetween, sql.Asc, sql.Desc, sql.NullsFirst, sql.NullsLast, sql.IsNull, sql.IsNotNull, sql.And, sql.Or, sql.Not, sql.Xor, sql.Xor, sql.Xor, sql.Xor, sql.Xor, sql.Xor, sql.Xor, sql.Xor, sql.Xor, sql.Xor, sql.Xor, sql.Xor, sql.Xor, sql.Xor, sql.Xor, sql.Xor, sql.Xor, sql.Xor, sql.Xor, sql.Xor, sql.Xor, sql.Xor, sql.Xor, sql.Xor, sql.Xor, sql.Xor, sql.Xor, sql.Xor, sql.Xor, sql.Xor, sql.Xor, sql."}
{"seed": "// NewGetCountersParamsWithHTTPClient creates a new GetCountersParams object\n// with the ability to set a custom HTTPClient for a request.\nfunc NewGetCountersParamsWithHTTPClient(client *http.Client) *GetCountersParams {\n\treturn &GetCountersParams{\n\t\tHTTPClient: client,\n\t}\n}", "id": 24347, "concepts": ["http.Client usage", "function definition", "function composition"], "_raw_llm_output": "http.Client usage, function definition, function composition"}
{"seed": "// WhitespacePass XORs the cipher text with intercepted ciphers and reveals\n// letters thanks to the properties of ASCII whitespace XOR-ed with ASCII letters.\n// Hint: for any ASCII letter x, x XOR ' ' = X.\n// And for any ASCII letters (x,y), x XOR y cannot be an ASCII letter.\n// So if we XOR two messages together and interpret bytes as ASCII letters,\n// when we find a valid ASCII letter it means that one of the messages contains\n// a whitespace at that position and the other contains that letter.\n// Luckily for us the input intercepted ciphers are made to make decryption easy.\n// We easily see most of the words, and then there are only a few characters for which\n// we must do a bit of manual trial and error.\nfunc WhitespacePass() [][]byte {\n\tencrypted := cryptoutil.NewCipher(CipherToDecrypt)\n\tinterceptXor := make([]cryptoutil.Cipher, len(InterceptedCiphers))\n\tfor i, c := range InterceptedCiphers {\n\t\tcc, err := cryptoutil.NewCipher(c).XOR(encrypted)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"xor failed: %s\\n\", err.Error())\n\t\t}\n\n\t\tinterceptXor[i] = cc\n\t}\n\n\tres := make([][]byte, len(encrypted))\n\tfor i := 0; i < len(encrypted); i++ {\n\t\tvar candidates []byte\n\t\tfor j := 0; j < len(interceptXor); j++ {\n\t\t\tb := interceptXor[j][i]\n\t\t\t// Only keep letters\n\t\t\tif (65 <= b && b <= 90) || (97 <= b && b <= 122) {\n\t\t\t\tcandidates = append(candidates, b)\n\t\t\t}\n\t\t}\n\n\t\tres[i] = candidates\n\t}\n\n\treturn res\n}", "id": 24358, "concepts": ["XOR", "ASCII character handling", "string manipulation", "cryptoutil package usage"], "_raw_llm_output": "XOR, ASCII character handling, string manipulation, cryptoutil package usage"}
{"seed": "// Form_ is a convenience wrapper for Form without the attrs argument.\nfunc Form_(children ...HTML) HTML {\n  return Form(nil, children...)\n}", "id": 24369, "concepts": ["HTML tag definition", "HTML tag attribute definition", "HTML tag attribute value definition", "HTML tag attribute value interpolation", "HTML tag attribute value interpolation with string formatting", "HTML tag attribute value interpolation with string formatting and string concatenation"], "_raw_llm_output": "HTML tag definition, HTML tag attribute definition, HTML tag attribute value definition, HTML tag attribute value interpolation, HTML tag attribute value interpolation with string formatting, HTML tag attribute value interpolation with string formatting and string concatenation"}
{"seed": "// NewListTaskNexusParamsWithHTTPClient creates a new ListTaskNexusParams object\n// with the default values initialized, and the ability to set a custom HTTPClient for a request\nfunc NewListTaskNexusParamsWithHTTPClient(client *http.Client) *ListTaskNexusParams {\n\n\treturn &ListTaskNexusParams{\n\t\tHTTPClient: client,\n\t}\n}", "id": 24386, "concepts": ["struct initialization", "struct field initialization", "struct field assignment", "struct field access", "struct method definition", "struct method call", "struct method call with receiver", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method call with receiver and pointer", "struct method"], "_raw_llm_output": "struct initialization, struct field initialization, struct field assignment, struct field access, struct method definition, struct method call, struct method call with receiver, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method call with receiver and pointer, struct method"}
{"seed": "// NicknameNEQ applies the NEQ predicate on the \"nickname\" field.\nfunc NicknameNEQ(v string) predicate.User {\n\treturn predicate.User(sql.FieldNEQ(FieldNickname, v))\n}", "id": 24388, "concepts": ["sql.FieldNEQ", "sql.FieldEQ", "sql.FieldGT", "sql.FieldGTE", "sql.FieldLT", "sql.FieldLTE", "sql.FieldLike", "sql.FieldILike", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldBetween", "sql.FieldNotBetween", "sql.FieldExists", "sql.FieldNotExists", "sql.FieldIsNull", "sql.FieldIsNotNull", "sql.FieldIsDistinctFrom", "sql.FieldIsNotDistinctFrom", "sql.FieldIs", "sql.FieldIsNot", "sql.FieldIsOf", "sql.FieldIsNotOf", "sql.FieldIsUnknown", "sql.FieldIsNotUnknown", "sql.FieldIsTrue", "sql.FieldIsFalse", "sql.FieldIsUnknown", "sql.FieldIsNotUnknown", "sql.FieldIs", "sql.FieldIsNot", "sql.FieldIsOf", "sql.FieldIsNotOf", "sql.FieldIsUnknown", "sql.FieldIsNotUnknown", "sql.FieldIs", "sql.FieldIsNot", "sql.FieldIsOf", "sql.FieldIsNotOf", "sql.FieldIsUnknown", "sql.FieldIsNotUnknown", "sql.FieldIs", "sql.FieldIsNot", "sql.FieldIsOf", "sql.FieldIsNotOf", "sql.FieldIsUnknown", "sql.Field"], "_raw_llm_output": "sql.FieldNEQ, sql.FieldEQ, sql.FieldGT, sql.FieldGTE, sql.FieldLT, sql.FieldLTE, sql.FieldLike, sql.FieldILike, sql.FieldIn, sql.FieldNotIn, sql.FieldBetween, sql.FieldNotBetween, sql.FieldExists, sql.FieldNotExists, sql.FieldIsNull, sql.FieldIsNotNull, sql.FieldIsDistinctFrom, sql.FieldIsNotDistinctFrom, sql.FieldIs, sql.FieldIsNot, sql.FieldIsOf, sql.FieldIsNotOf, sql.FieldIsUnknown, sql.FieldIsNotUnknown, sql.FieldIsTrue, sql.FieldIsFalse, sql.FieldIsUnknown, sql.FieldIsNotUnknown, sql.FieldIs, sql.FieldIsNot, sql.FieldIsOf, sql.FieldIsNotOf, sql.FieldIsUnknown, sql.FieldIsNotUnknown, sql.FieldIs, sql.FieldIsNot, sql.FieldIsOf, sql.FieldIsNotOf, sql.FieldIsUnknown, sql.FieldIsNotUnknown, sql.FieldIs, sql.FieldIsNot, sql.FieldIsOf, sql.FieldIsNotOf, sql.FieldIsUnknown, sql.Field"}
{"seed": "// New creates a new matrix from the rows.\n// Note that if rows is empty (len(row) == 0) then the Matrix will be created with row and column length 0\n// To create a Matrix with zero rows and non-zero columns, use `NewZero(0, numColumns)`` instead\nfunc New(rows []Row) (Matrix, error) {\n\tnRows := len(rows)\n\n\tif nRows == 0 {\n\t\treturn Matrix{0, 0, rows}, nil\n\t}\n\n\trowsCopy := []Row{}\n\n\tnCols := len(rows[0])\n\tfor _, row := range rows {\n\t\tif len(row) != nCols {\n\t\t\treturn Matrix{}, errors.New(\"Matrix does not support jagged matrices. All rows must be of the same length\")\n\t\t}\n\n\t\trowsCopy = append(rowsCopy, row.Copy())\n\t}\n\n\treturn Matrix{nRows, nCols, rowsCopy}, nil\n}", "id": 24393, "concepts": ["error handling (idiomatic if err != nil)", "error handling (errors.New)", "error handling (errors.As)", "error handling (errors.Is)", "error handling (panic)", "error handling (recover)", "error handling (defer)", "error handling (panic)", "error handling (recover)", "error handling (defer)", "error handling (panic)", "error handling (recover)", "error handling (defer)", "error handling (panic)", "error handling (recover)", "error handling (defer)", "error handling (panic)", "error handling (recover)", "error handling (defer)", "error handling (panic)", "error handling (recover)", "error handling (defer)", "error handling (panic)", "error handling (recover)", "error handling (defer)", "error handling (panic)", "error handling (recover)", "error handling (defer)", "error handling (panic)", "error handling (recover)", "error handling (defer)", "error handling (panic)", "error handling (recover)", "error handling (defer)", "error handling (panic)", "error handling (recover)", "error handling (defer)", "error handling (panic)", "error handling (recover)", "error handling (defer)", "error handling (panic)", "error handling (recover)", "error handling (defer)", "error handling (panic)", "error handling (recover)", "error handling (defer)", "error handling (panic)", "error handling (recover)", "error handling ("], "_raw_llm_output": "error handling (idiomatic if err != nil), error handling (errors.New), error handling (errors.As), error handling (errors.Is), error handling (panic), error handling (recover), error handling (defer), error handling (panic), error handling (recover), error handling (defer), error handling (panic), error handling (recover), error handling (defer), error handling (panic), error handling (recover), error handling (defer), error handling (panic), error handling (recover), error handling (defer), error handling (panic), error handling (recover), error handling (defer), error handling (panic), error handling (recover), error handling (defer), error handling (panic), error handling (recover), error handling (defer), error handling (panic), error handling (recover), error handling (defer), error handling (panic), error handling (recover), error handling (defer), error handling (panic), error handling (recover), error handling (defer), error handling (panic), error handling (recover), error handling (defer), error handling (panic), error handling (recover), error handling (defer), error handling (panic), error handling (recover), error handling (defer), error handling (panic), error handling (recover), error handling ("}
{"seed": "// NewGetCountersParams creates a new GetCountersParams object,\n// with the default timeout for this client.\n//\n// Default values are not hydrated, since defaults are normally applied by the API server side.\n//\n// To enforce default values in parameter, use SetDefaults or WithDefaults.\nfunc NewGetCountersParams() *GetCountersParams {\n\treturn &GetCountersParams{\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 24399, "concepts": ["struct definition", "struct field definition", "struct field initialization", "struct field access", "struct field type", "struct field value", "struct field pointer", "struct field pointer access", "struct field pointer value", "struct field pointer value access", "struct field pointer value access", "struct field pointer value access", "struct field pointer value access", "struct field pointer value access", "struct field pointer value access", "struct field pointer value access", "struct field pointer value access", "struct field pointer value access", "struct field pointer value access", "struct field pointer value access", "struct field pointer value access", "struct field pointer value access", "struct field pointer value access", "struct field pointer value access", "struct field pointer value access", "struct field pointer value access", "struct field pointer value access", "struct field pointer value access", "struct field pointer value access", "struct field pointer value access", "struct field pointer value access", "struct field pointer value access", "struct field pointer value access", "struct field pointer value access", "struct field pointer value access", "struct field pointer value access", "struct field pointer value access", "struct field pointer value access", "struct field pointer value access", "struct field pointer value access", "struct field pointer value access", "struct field pointer value access", "struct field pointer value access", "struct field pointer value access", "struct field pointer value access", "struct field"], "_raw_llm_output": "struct definition, struct field definition, struct field initialization, struct field access, struct field type, struct field value, struct field pointer, struct field pointer access, struct field pointer value, struct field pointer value access, struct field pointer value access, struct field pointer value access, struct field pointer value access, struct field pointer value access, struct field pointer value access, struct field pointer value access, struct field pointer value access, struct field pointer value access, struct field pointer value access, struct field pointer value access, struct field pointer value access, struct field pointer value access, struct field pointer value access, struct field pointer value access, struct field pointer value access, struct field pointer value access, struct field pointer value access, struct field pointer value access, struct field pointer value access, struct field pointer value access, struct field pointer value access, struct field pointer value access, struct field pointer value access, struct field pointer value access, struct field pointer value access, struct field pointer value access, struct field pointer value access, struct field pointer value access, struct field pointer value access, struct field pointer value access, struct field pointer value access, struct field pointer value access, struct field pointer value access, struct field pointer value access, struct field pointer value access, struct field"}
{"seed": "// HandlerWithProtocPath returns a new HandlerOption that sets the path to the protoc binary.\n//\n// The default is to do exec.LookPath on \"protoc\".\nfunc HandlerWithProtocPath(protocPath string) HandlerOption {\n\treturn func(handlerOptions *handlerOptions) {\n\t\thandlerOptions.protocPath = protocPath\n\t}\n}", "id": 24401, "concepts": ["function definition", "function parameters", "function return values", "function options", "function composition"], "_raw_llm_output": "function definition, function parameters, function return values, function options, function composition"}
{"seed": "// Strong represents the HTML element 'strong'.\n// For more information visit https://www.w3schools.com/tags/tag_strong.asp.\nfunc Strong(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"strong\", Attributes: attrs, Children: children}\n}", "id": 24405, "concepts": ["HTML generation", "tree traversal", "HTML element definition"], "_raw_llm_output": "HTML generation, tree traversal, HTML element definition"}
{"seed": "// ConnectionDirectionPOutbound returns a pointer to ConnectionDirectionVOutbound\nfunc ConnectionDirectionPOutbound() *ConnectionDirection {\n\tv := ConnectionDirectionVOutbound\n\treturn &v\n}", "id": 24407, "concepts": ["pointer", "pointer dereference", "pointer assignment"], "_raw_llm_output": "pointer, pointer dereference, pointer assignment"}
{"seed": "// ExtractUUID takes in a token string and extracts the UUID from the body.\n// Returns the uuid or an empty string due to an error.\nfunc ExtractUUID(tokenString string) string {\n\ttokenSignature := strings.Split(tokenString, \".\")\n\tif len(tokenSignature) != 3 {\n\t\treturn \"\"\n\t}\n\tdecodedBody, err := base64Decode(tokenSignature[1])\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\tbody := &Body{}\n\tif err := json.Unmarshal([]byte(decodedBody), body); err != nil {\n\t\treturn \"\"\n\t}\n\tif body == nil {\n\t\treturn \"\"\n\t}\n\tif err := validation.ValidateUserUUID(body.UUID); err != nil {\n\t\treturn \"\"\n\t}\n\treturn body.UUID\n}", "id": 24409, "concepts": ["base64 decoding", "JSON decoding", "interface usage", "validation"], "_raw_llm_output": "base64 decoding, JSON decoding, interface usage, validation"}
{"seed": "// PutUint64 encodes an integer into buf and returns the serial size.\n// If the buffer is smaller than 9 bytes, PutUint64 may panic.\nfunc PutUint64(buf []byte, v uint64) (n int) {\n\tif v >= uint64(1)<<56 {\n\t\tbuf[0] = 0\n\t\tbinary.LittleEndian.PutUint64(buf[1:], v)\n\t\treturn 9\n\t}\n\n\tbitCount := bits.Len64(v)\n\te := (bitCount + (bitCount >> 3)) >> 3\n\n\tv = v<<1 | 1\n\tv <<= uint(e)\n\tbinary.LittleEndian.PutUint64(buf, v)\n\n\treturn e + 1\n}", "id": 24410, "concepts": ["bit manipulation", "binary encoding", "bit shifting", "integer encoding"], "_raw_llm_output": "bit manipulation, binary encoding, bit shifting, integer encoding"}
{"seed": "// SocialEmailEqualFold applies the EqualFold predicate on the \"social_email\" field.\nfunc SocialEmailEqualFold(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.EqualFold(s.C(FieldSocialEmail), v))\n\t})\n}", "id": 24413, "concepts": ["sql.Selector", "sql.EqualFold", "predicate.User", "sql.C", "sql.Where"], "_raw_llm_output": "sql.Selector, sql.EqualFold, predicate.User, sql.C, sql.Where"}
{"seed": "// Distance will compute hamming distance of two given DNA strand, a and b.\n// If the length of a and b is dissimilar, Distance will return error.\nfunc Distance(a, b string) (int, error) {\n\t// If a and b has dissimilar then raise error.\n\tif len(a) != len(b) {\n\t\treturn 0, errors.New(\"a and b must have same length\")\n\t}\n\n\t// Initiate the hamming distance\n\tdistance := 0\n\n\t// Convert to rune to cover utf-8 string\n\tstrandA := []rune(a)\n\tstrandB := []rune(b)\n\n\t// Iterate two DNA strands and compare it by characters at the same index.\n\tfor index := range strandA {\n\t\tif strandA[index] != strandB[index] {\n\t\t\tdistance++\n\t\t}\n\t}\n\n\treturn distance, nil\n}", "id": 24417, "concepts": ["string manipulation", "rune handling", "character comparison", "error handling", "basic function definition"], "_raw_llm_output": "string manipulation, rune handling, character comparison, error handling, basic function definition"}
{"seed": "// NewCommand returns a new instance of Command with default setting applied.\nfunc NewCommand() *Command {\n\treturn &Command{\n\t\tStderr:        os.Stderr,\n\t\tStdout:        os.Stdout,\n\t\tshardPaths:    map[uint64]string{},\n\t\tshardIdxs:     map[uint64]*tsi1.Index{},\n\t\tcardinalities: map[uint64]map[string]*cardinality{},\n\t\ttopN:          0,\n\t\tbyMeasurement: true,\n\t\tbyTagKey:      false,\n\t\tconcurrency:   runtime.GOMAXPROCS(0),\n\t}\n}", "id": 24418, "concepts": ["map iteration", "map key iteration", "map value iteration", "map key/value iteration", "map creation", "concurrency", "runtime.GOMAXPROCS", "basic function definition"], "_raw_llm_output": "map iteration, map key iteration, map value iteration, map key/value iteration, map creation, concurrency, runtime.GOMAXPROCS, basic function definition"}
{"seed": "//\n// AssetInfo loads and returns the asset info for the given name.\n// It returns an error if the asset could not be found or could not be loaded.\n//\nfunc AssetInfo(name string) (os.FileInfo, error) {\n\tcannonicalName := strings.Replace(name, \"\\\\\", \"/\", -1)\n\tif f, ok := _bindata[cannonicalName]; ok {\n\t\ta, err := f()\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"AssetInfo %s can't read by error: %v\", name, err)\n\t\t}\n\t\treturn a.info, nil\n\t}\n\treturn nil, &os.PathError{Op: \"open\", Path: name, Err: os.ErrNotExist}\n}", "id": 24439, "concepts": ["os.FileInfo", "bindata usage"], "_raw_llm_output": "os.FileInfo, bindata usage"}
{"seed": "// ToTextPatternInfo converts a an atomic query to internal values that drive\n// text search. An atomic query is a Basic query where the Pattern is either\n// nil, or comprises only one Pattern node (hence, an atom, and not an\n// expression). See TextPatternInfo for the values it computes and populates.\nfunc ToTextPatternInfo(q query.Basic, p Protocol, transform query.BasicPass) *TextPatternInfo {\n\tq = transform(q)\n\t// Handle file: and -file: filters.\n\tfilesInclude, filesExclude := IncludeExcludeValues(q, query.FieldFile)\n\t// Handle lang: and -lang: filters.\n\tlangInclude, langExclude := IncludeExcludeValues(q, query.FieldLang)\n\tfilesInclude = append(filesInclude, mapSlice(langInclude, langToFileRegexp)...)\n\tfilesExclude = append(filesExclude, mapSlice(langExclude, langToFileRegexp)...)\n\tfilesReposMustInclude, filesReposMustExclude := IncludeExcludeValues(q, query.FieldRepoHasFile)\n\tselector, _ := filter.SelectPathFromString(q.FindValue(query.FieldSelect)) // Invariant: select is validated\n\tcount := count(q, p)\n\n\t// Ugly assumption: for a literal search, the IsRegexp member of\n\t// TextPatternInfo must be set true. The logic assumes that a literal\n\t// pattern is an escaped regular expression.\n\tisRegexp := q.IsLiteral() || q.IsRegexp()\n\n\tvar pattern string\n\tif p, ok := q.Pattern.(query.Pattern); ok {\n\t\tif q.IsLiteral() {\n\t\t\t// Escape regexp meta characters if this pattern should be treated literally.\n\t\t\tpattern = regexp.QuoteMeta(p.Value)\n\t\t} else {\n\t\t\tpattern = p.Value\n\t\t}\n\t}\n\n\tif q.Pattern == nil {\n\t\t// For compatibility: A nil pattern implies isRegexp is set to\n\t\t// true. This has no effect on search logic.\n\t\tisRegexp = true\n\t}\n\n\tnegated := false\n\tif p, ok := q.Pattern.(query.Pattern); ok {\n\t\tnegated = p.Negated\n\t}\n\n\treturn &TextPatternInfo{\n\t\t// Values dependent on pattern atom.\n\t\tIsRegExp:        isRegexp,\n\t\tIsStructuralPat: q.IsStructural(),\n\t\tIsCaseSensitive: q.IsCaseSensitive(),\n\t\tFileMatchLimit:  int32(count),\n\t\tPattern:         pattern,\n\t\tIsNegated:       negated,\n\n\t\t// Values dependent on parameters.\n\t\tIncludePatterns:              filesInclude,\n\t\tExcludePattern:               unionRegexp(filesExclude),\n\t\tFilePatternsReposMustInclude: filesReposMustInclude,\n\t\tFilePatternsReposMustExclude: filesReposMustExclude,\n\t\tLanguages:                    langInclude,\n\t\tPathPatternsAreCaseSensitive: q.IsCaseSensitive(),\n\t\tCombyRule:                    q.FindValue(query.FieldCombyRule),\n\t\tIndex:                        q.Index(),\n\t\tSelect:                       selector,\n\t}\n}", "id": 24440, "concepts": ["string manipulation", "regexp", "regular expression", "string comparison", "string concatenation", "string escaping", "string formatting", "string matching", "string replacement", "string splitting", "string trimming", "string validation", "string wildcard", "string concatenation", "string escaping", "string formatting", "string matching", "string replacement", "string splitting", "string trimming", "string validation", "string wildcard", "string concatenation", "string escaping", "string formatting", "string matching", "string replacement", "string splitting", "string trimming", "string validation", "string wildcard", "string concatenation", "string escaping", "string formatting", "string matching", "string replacement", "string splitting", "string trimming", "string validation", "string wildcard", "string concatenation", "string escaping", "string formatting", "string matching", "string replacement", "string splitting", "string trimming", "string validation", "string wildcard", "string concatenation", "string escaping", "string formatting", "string matching", "string replacement", "string splitting", "string trimming", "string validation", "string wildcard", "string concatenation", "string escaping", "string formatting", "string matching", "string replacement", "string splitting", "string trimming", "string validation", "string wildcard", "string concatenation", "string escaping", "string formatting", "string matching", "string replacement", "string splitting", "string trimming", "string validation"], "_raw_llm_output": "string manipulation, regexp, regular expression, string comparison, string concatenation, string escaping, string formatting, string matching, string replacement, string splitting, string trimming, string validation, string wildcard, string concatenation, string escaping, string formatting, string matching, string replacement, string splitting, string trimming, string validation, string wildcard, string concatenation, string escaping, string formatting, string matching, string replacement, string splitting, string trimming, string validation, string wildcard, string concatenation, string escaping, string formatting, string matching, string replacement, string splitting, string trimming, string validation, string wildcard, string concatenation, string escaping, string formatting, string matching, string replacement, string splitting, string trimming, string validation, string wildcard, string concatenation, string escaping, string formatting, string matching, string replacement, string splitting, string trimming, string validation, string wildcard, string concatenation, string escaping, string formatting, string matching, string replacement, string splitting, string trimming, string validation, string wildcard, string concatenation, string escaping, string formatting, string matching, string replacement, string splitting, string trimming, string validation"}
{"seed": "// NewHyperflexVmSnapshotInfoAllOf instantiates a new HyperflexVmSnapshotInfoAllOf object\n// This constructor will assign default values to properties that have it defined,\n// and makes sure properties required by API are set, but the set of arguments\n// will change when the set of required properties is changed\nfunc NewHyperflexVmSnapshotInfoAllOf(classId string, objectType string) *HyperflexVmSnapshotInfoAllOf {\n\tthis := HyperflexVmSnapshotInfoAllOf{}\n\tthis.ClassId = classId\n\tthis.ObjectType = objectType\n\treturn &this\n}", "id": 24452, "concepts": ["struct definition", "struct initialization", "struct field definition", "struct field initialization", "struct field assignment", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct field access", "struct"], "_raw_llm_output": "struct definition, struct initialization, struct field definition, struct field initialization, struct field assignment, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct field access, struct"}
{"seed": "// WithUninstallAnnotations is an Option that configures Uninstall annotations\n// to enable custom action.Uninstall fields to be set based on the value of\n// annotations found in the custom resource watched by this reconciler.\n// Duplicate annotation names will result in an error.\nfunc WithUninstallAnnotations(as ...annotation.Uninstall) Option {\n\treturn func(r *Reconciler) error {\n\t\tr.annotSetupOnce.Do(r.setupAnnotationMaps)\n\n\t\tfor _, a := range as {\n\t\t\tname := a.Name()\n\t\t\tif _, ok := r.annotations[name]; ok {\n\t\t\t\treturn fmt.Errorf(\"annotation %q already exists\", name)\n\t\t\t}\n\n\t\t\tr.annotations[name] = struct{}{}\n\t\t\tr.uninstallAnnotations[name] = a\n\t\t}\n\t\treturn nil\n\t}\n}", "id": 24453, "concepts": ["struct definition", "struct field access", "map iteration", "map key access", "map value access", "map key access", "map value access", "map key access", "map value access", "map key access", "map value access", "map key access", "map value access", "map key access", "map value access", "map key access", "map value access", "map key access", "map value access", "map key access", "map value access", "map key access", "map value access", "map key access", "map value access", "map key access", "map value access", "map key access", "map value access", "map key access", "map value access", "map key access", "map value access", "map key access", "map value access", "map key access", "map value access", "map key access", "map value access", "map key access", "map value access", "map key access", "map value access", "map key access", "map value access", "map key access", "map value access", "map key access", "map value access", "map key access", "map value access", "map key access", "map value access", "map key access", "map value access", "map key access", "map value access", "map key access", "map value access", "map key access", "map value access", "map key access", "map value access", "map key access", "map"], "_raw_llm_output": "struct definition, struct field access, map iteration, map key access, map value access, map key access, map value access, map key access, map value access, map key access, map value access, map key access, map value access, map key access, map value access, map key access, map value access, map key access, map value access, map key access, map value access, map key access, map value access, map key access, map value access, map key access, map value access, map key access, map value access, map key access, map value access, map key access, map value access, map key access, map value access, map key access, map value access, map key access, map value access, map key access, map value access, map key access, map value access, map key access, map value access, map key access, map value access, map key access, map value access, map key access, map value access, map key access, map value access, map key access, map value access, map key access, map value access, map key access, map value access, map key access, map value access, map key access, map value access, map key access, map"}
{"seed": "// Verses returns an excerpt of the lyrics of 99 bottles of beer\n// between verse start and stop. The verse numbers count backwards, so the\n// first verse sung will be verse 99, and the last will be verse 0\nfunc Verses(start, stop int) (string, error) {\n\tswitch {\n\tcase 0 > start || start > 99:\n\t\treturn \"\", fmt.Errorf(\"start value[%d] is not a valid verse\", start)\n\tcase 0 > stop || stop > 99:\n\t\treturn \"\", fmt.Errorf(\"stop value[%d] is not a valid verse\", stop)\n\tcase start < stop:\n\t\treturn \"\", fmt.Errorf(\"start value[%d] is less than stop value[%d]\", start, stop)\n\t}\n\n\tvar buff bytes.Buffer\n\tfor i := start; i >= stop; i-- {\n\t\tv, _ := Verse(i)\n\t\tbuff.WriteString(v)\n\t\tbuff.WriteString(\"\\n\")\n\t}\n\treturn buff.String(), nil\n}", "id": 24457, "concepts": ["error handling (idiomatic if err != nil)", "switch statement", "basic function definition", "string concatenation", "string manipulation"], "_raw_llm_output": "error handling (idiomatic if err != nil), switch statement, basic function definition, string concatenation, string manipulation"}
{"seed": "// Subtype sets the subtype of the mount. The main type is always\n// `fuse`. The type in a list of mounted file systems will look like\n// `fuse.foo`.\n//\n// FreeBSD ignores this option.\nfunc Subtype(fstype string) MountOption {\n\treturn func(conf *mountConfig) error {\n\t\tconf.options[\"subtype\"] = fstype\n\t\treturn nil\n\t}\n}", "id": 24462, "concepts": ["struct field access", "function composition", "option pattern", "option function"], "_raw_llm_output": "struct field access, function composition, option pattern, option function"}
{"seed": "// NewTokenContains applies the Contains predicate on the \"new_token\" field.\nfunc NewTokenContains(v string) predicate.User {\n\treturn predicate.User(sql.FieldContains(FieldNewToken, v))\n}", "id": 24466, "concepts": ["sql.FieldContains", "predicate.User", "sql package usage"], "_raw_llm_output": "sql.FieldContains, predicate.User, sql package usage"}
{"seed": "// NewEncoder instantiates an CayenneLPP encoder.\nfunc NewEncoder() Encoder {\n\treturn &encoder{\n\t\tbuf: new(bytes.Buffer),\n\t}\n}", "id": 24467, "concepts": ["struct definition", "basic function definition", "pointer usage", "bytes.Buffer usage"], "_raw_llm_output": "struct definition, basic function definition, pointer usage, bytes.Buffer usage"}
{"seed": "// NewMemoryKeyValueStore creates a new in-memory key-value store\nfunc NewMemoryKeyValueStore() *MemoryKeyValueStore {\n\treturn &MemoryKeyValueStore{\n\t\tm: make(map[string][]byte),\n\t}\n}", "id": 24469, "concepts": ["map", "struct", "basic function definition"], "_raw_llm_output": "map, struct, basic function definition"}
{"seed": "// NewListEngineTypeParamsWithHTTPClient creates a new ListEngineTypeParams object\n// with the default values initialized, and the ability to set a custom HTTPClient for a request\nfunc NewListEngineTypeParamsWithHTTPClient(client *http.Client) *ListEngineTypeParams {\n\tvar ()\n\treturn &ListEngineTypeParams{\n\t\tHTTPClient: client,\n\t}\n}", "id": 24476, "concepts": ["custom HTTPClient usage", "function definition", "function parameter", "function return value"], "_raw_llm_output": "custom HTTPClient usage, function definition, function parameter, function return value"}
{"seed": "// MergePrefixes64 merges two pairs of uint64s, returning a new prefix, new length\nfunc MergePrefixes64(leftLeft uint64, leftRight uint64, leftLength uint, rightLeft uint64, rightRight uint64, rightLength uint) (uint64, uint64, uint) {\n\t// mask the left 128 bits\n\tif leftLength <= 64 {\n\t\tleftLeft &= _leftMasks64[leftLength]\n\t\tleftRight = 0\n\t} else {\n\t\tleftRight &= _leftMasks64[leftLength-64]\n\t}\n\n\t// mask the right 128 bits\n\tif rightLength <= 64 {\n\t\trightLeft &= _leftMasks64[rightLength]\n\t\trightRight = 0\n\t} else {\n\t\trightRight &= _leftMasks64[rightLength-64]\n\t}\n\n\t// shift the right 128 bits to the right\n\trightLeft, rightRight = ShiftRightIPv6(rightLeft, rightRight, leftLength)\n\n\t// now merge the two\n\treturn leftLeft | rightLeft, leftRight | rightRight, leftLength + rightLength\n}", "id": 24489, "concepts": ["bitwise operations", "bit shifting", "IPv6 address handling"], "_raw_llm_output": "bitwise operations, bit shifting, IPv6 address handling"}
{"seed": "/* 739. Daily Temperatures\n\nRelated Topic\nStack, Hash Table\n\nGiven a list of daily temperatures T, return a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead.\n\nFor example, given the list of temperatures T = [73, 74, 75, 71, 69, 72, 76, 73], your output should be [1, 1, 4, 2, 1, 1, 0, 0].\n\nNote: The length of temperatures will be in the range [1, 30000]. Each temperature will be an integer in the range [30, 100].\n*/\n\nfunc dailyTemperatures(T []int) []int {\n \n    type Pair struct {\n\t\tidx int\n\t\tval int\n\t}\n\n\tres := make([]int, len(T))\n\tstack := []Pair{Pair{0, T[0]}}\n\n\tfor i := 1; i < len(T); i++ {\n\t\tfor len(stack) > 0 && stack[len(stack)-1].val < T[i] {\n\t\t\tstackIdx := stack[len(stack)-1].idx\n\t\t\tres[stackIdx] = i - stackIdx\n\t\t\tstack = stack[:len(stack)-1]\n\t\t}\n\t\tstack = append(stack, Pair{i, T[i]})\n\t}\n\n\treturn res\n    \n}", "id": 24498, "concepts": ["stack", "hash table", "array iteration", "mathematical series"], "_raw_llm_output": "stack, hash table, array iteration, mathematical series"}
{"seed": "// SumSha256Ripemd160 is a convience function that returns the\n// ripemd160 hash of the sha256 hash of the data.\n// SumSha256Ripemd160 panics if the crypto.RIPEMD160 hash is not linked into the binary.\nfunc SumSha256Ripemd160(data []byte) (sum160 [ripemd160Size]byte) {\n\t// As of go1.2 the ripemd160 package does not provide a Sum160()\n\t// function so we need to use it's hash.Hash implementation.\n\t// This also avoids us having to import golang.org/x/crypto/ripemd160\n\tripemd160 := crypto.RIPEMD160.New()\n\th := sha256.Sum256(data)\n\tripemd160.Write(h[:])\n\tsum := ripemd160.Sum(nil)\n\tcopy(sum160[:], sum[:ripemd160Size])\n\treturn\n}", "id": 24504, "concepts": ["crypto package usage", "crypto/sha256 package usage", "crypto/ripemd160 package usage", "crypto/sha256/ripemd160 package usage", "crypto/sha256/ripemd160/crypto/ripemd160 package usage", "crypto/sha256/ripemd160/crypto/ripemd160/crypto/sha256 package usage", "crypto/sha256/ripemd160/crypto/ripemd160/crypto/sha256/crypto/ripemd160 package usage", "crypto/sha256/ripemd160/crypto/ripemd160/crypto/sha256/crypto/ripemd160/crypto/sha256 package usage", "crypto/sha256/ripemd160/crypto/ripemd160/crypto/sha256/crypto/ripemd160/crypto/sha256/crypto/sha256 package usage", "crypto/sha256/ripemd160/"], "_raw_llm_output": "crypto package usage, crypto/sha256 package usage, crypto/ripemd160 package usage, crypto/sha256/ripemd160 package usage, crypto/sha256/ripemd160/crypto/ripemd160 package usage, crypto/sha256/ripemd160/crypto/ripemd160/crypto/sha256 package usage, crypto/sha256/ripemd160/crypto/ripemd160/crypto/sha256/crypto/ripemd160 package usage, crypto/sha256/ripemd160/crypto/ripemd160/crypto/sha256/crypto/ripemd160/crypto/sha256 package usage, crypto/sha256/ripemd160/crypto/ripemd160/crypto/sha256/crypto/ripemd160/crypto/sha256/crypto/sha256 package usage, crypto/sha256/ripemd160/"}
{"seed": "// projectRefPipelineForPeriodicBuilds is an aggregation pipeline to find projects that are\n// 1) explicitly enabled, or that default to the repo which is enabled, and\n// 2) they have periodic builds defined, or they default to the repo which has periodic builds defined.\nfunc projectRefPipelineForPeriodicBuilds() []bson.M {\n\tnonEmptySize := bson.M{\"$gt\": bson.M{\"$size\": 0}}\n\treturn []bson.M{\n\t\tlookupRepoStep,\n\t\t{\"$match\": bson.M{\n\t\t\t\"$and\": []bson.M{\n\t\t\t\t{\"$or\": []bson.M{\n\t\t\t\t\t{ProjectRefEnabledKey: true},\n\t\t\t\t\t{ProjectRefEnabledKey: nil, bsonutil.GetDottedKeyName(\"repo_ref\", RepoRefEnabledKey): true},\n\t\t\t\t}},\n\t\t\t\t{\"$or\": []bson.M{\n\t\t\t\t\t{\n\t\t\t\t\t\tprojectRefPeriodicBuildsKey: nonEmptySize,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tprojectRefPeriodicBuildsKey:                                     nil,\n\t\t\t\t\t\tbsonutil.GetDottedKeyName(\"repo_ref\", RepoRefPeriodicBuildsKey): nonEmptySize,\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n}", "id": 24508, "concepts": ["aggregation pipeline", "bson package usage", "bson.M usage", "bson.M construction", "bson.M matching", "bson.M aggregation", "bson.M lookup", "bson.M aggregation pipeline", "bson.M aggregation pipeline matching", "bson.M aggregation pipeline lookup", "bson.M aggregation pipeline lookup matching", "bson.M aggregation pipeline lookup matching aggregation", "bson.M aggregation pipeline lookup matching aggregation pipeline", "bson.M aggregation pipeline lookup matching aggregation pipeline matching", "bson.M aggregation pipeline lookup matching aggregation pipeline matching projectRefEnabledKey", "bson.M aggregation pipeline lookup matching aggregation pipeline matching projectRefEnabledKey", "bson.M aggregation pipeline lookup matching aggregation pipeline matching projectRefEnabledKey", "bson.M aggregation pipeline lookup matching aggregation pipeline matching projectRefEnabledKey", "bson.M aggregation pipeline lookup matching aggregation pipeline matching projectRefEnabledKey", "bson.M aggregation pipeline lookup matching aggregation pipeline matching projectRefEnabledKey", "bson.M aggregation pipeline lookup matching aggregation pipeline matching projectRefEnabledKey", "bson.M aggregation pipeline lookup matching aggregation pipeline matching projectRefEnabledKey", "bson.M aggregation pipeline lookup matching aggregation pipeline matching projectRefEnabledKey", "bson.M aggregation pipeline lookup matching aggregation pipeline matching projectRefEnabledKey", "bson.M aggregation pipeline lookup matching aggregation pipeline matching projectRefEnabledKey", ""], "_raw_llm_output": "aggregation pipeline, bson package usage, bson.M usage, bson.M construction, bson.M matching, bson.M aggregation, bson.M lookup, bson.M aggregation pipeline, bson.M aggregation pipeline matching, bson.M aggregation pipeline lookup, bson.M aggregation pipeline lookup matching, bson.M aggregation pipeline lookup matching aggregation, bson.M aggregation pipeline lookup matching aggregation pipeline, bson.M aggregation pipeline lookup matching aggregation pipeline matching, bson.M aggregation pipeline lookup matching aggregation pipeline matching projectRefEnabledKey, bson.M aggregation pipeline lookup matching aggregation pipeline matching projectRefEnabledKey, bson.M aggregation pipeline lookup matching aggregation pipeline matching projectRefEnabledKey, bson.M aggregation pipeline lookup matching aggregation pipeline matching projectRefEnabledKey, bson.M aggregation pipeline lookup matching aggregation pipeline matching projectRefEnabledKey, bson.M aggregation pipeline lookup matching aggregation pipeline matching projectRefEnabledKey, bson.M aggregation pipeline lookup matching aggregation pipeline matching projectRefEnabledKey, bson.M aggregation pipeline lookup matching aggregation pipeline matching projectRefEnabledKey, bson.M aggregation pipeline lookup matching aggregation pipeline matching projectRefEnabledKey, bson.M aggregation pipeline lookup matching aggregation pipeline matching projectRefEnabledKey, bson.M aggregation pipeline lookup matching aggregation pipeline matching projectRefEnabledKey,"}
{"seed": "// NewListInstancesParamsWithContext creates a new ListInstancesParams object\n// with the default values initialized, and the ability to set a context for a request\nfunc NewListInstancesParamsWithContext(ctx context.Context) *ListInstancesParams {\n\tvar ()\n\treturn &ListInstancesParams{\n\n\t\tContext: ctx,\n\t}\n}", "id": 24514, "concepts": ["context package usage", "method definition"], "_raw_llm_output": "context package usage, method definition"}
{"seed": "// SensitivityPPersonal returns a pointer to SensitivityVPersonal\nfunc SensitivityPPersonal() *Sensitivity {\n\tv := SensitivityVPersonal\n\treturn &v\n}", "id": 24522, "concepts": ["pointer", "pointer dereference"], "_raw_llm_output": "pointer, pointer dereference"}
{"seed": "// SocialPayloadHasSuffix applies the HasSuffix predicate on the \"social_payload\" field.\nfunc SocialPayloadHasSuffix(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.HasSuffix(s.C(FieldSocialPayload), v))\n\t})\n}", "id": 24533, "concepts": ["sql package usage", "sql.Selector", "sql.C", "sql.HasSuffix", "predicate.User", "function composition"], "_raw_llm_output": "sql package usage, sql.Selector, sql.C, sql.HasSuffix, predicate.User, function composition"}
{"seed": "// SocialTypeHasPrefix applies the HasPrefix predicate on the \"social_type\" field.\nfunc SocialTypeHasPrefix(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.HasPrefix(s.C(FieldSocialType), v))\n\t})\n}", "id": 24570, "concepts": ["sql.Selector", "sql.C", "sql.HasPrefix", "sql.Where", "sql.And", "sql.Or", "sql.Not", "sql.IsNull", "sql.IsNotNull", "sql.Eq", "sql.Gt", "sql.Lt", "sql.Gte", "sql.Lte", "sql.Like", "sql.NotLike", "sql.In", "sql.NotIn", "sql.Contains", "sql.NotContains", "sql.HasPrefix", "sql.HasSuffix", "sql.NotHasPrefix", "sql.NotHasSuffix", "sql.And", "sql.Or", "sql.Not", "sql.IsNull", "sql.IsNotNull", "sql.Eq", "sql.Gt", "sql.Lt", "sql.Gte", "sql.Lte", "sql.Like", "sql.NotLike", "sql.In", "sql.NotIn", "sql.Contains", "sql.NotContains", "sql.HasPrefix", "sql.HasSuffix", "sql.NotHasPrefix", "sql.NotHasSuffix", "sql.And", "sql.Or", "sql.Not", "sql.IsNull", "sql.IsNotNull", "sql.Eq", "sql.Gt", "sql.Lt", "sql.Gte", "sql.Lte", "sql.Like", "sql.NotLike", "sql.In", "sql.NotIn", "sql."], "_raw_llm_output": "sql.Selector, sql.C, sql.HasPrefix, sql.Where, sql.And, sql.Or, sql.Not, sql.IsNull, sql.IsNotNull, sql.Eq, sql.Gt, sql.Lt, sql.Gte, sql.Lte, sql.Like, sql.NotLike, sql.In, sql.NotIn, sql.Contains, sql.NotContains, sql.HasPrefix, sql.HasSuffix, sql.NotHasPrefix, sql.NotHasSuffix, sql.And, sql.Or, sql.Not, sql.IsNull, sql.IsNotNull, sql.Eq, sql.Gt, sql.Lt, sql.Gte, sql.Lte, sql.Like, sql.NotLike, sql.In, sql.NotIn, sql.Contains, sql.NotContains, sql.HasPrefix, sql.HasSuffix, sql.NotHasPrefix, sql.NotHasSuffix, sql.And, sql.Or, sql.Not, sql.IsNull, sql.IsNotNull, sql.Eq, sql.Gt, sql.Lt, sql.Gte, sql.Lte, sql.Like, sql.NotLike, sql.In, sql.NotIn, sql."}
{"seed": "// ParseGetLoadBalancerServiceResponse parses an HTTP response from a GetLoadBalancerServiceWithResponse call\nfunc ParseGetLoadBalancerServiceResponse(rsp *http.Response) (*GetLoadBalancerServiceResponse, error) {\n\tbodyBytes, err := ioutil.ReadAll(rsp.Body)\n\tdefer rsp.Body.Close()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse := &GetLoadBalancerServiceResponse{\n\t\tBody:         bodyBytes,\n\t\tHTTPResponse: rsp,\n\t}\n\n\tswitch {\n\tcase strings.Contains(rsp.Header.Get(\"Content-Type\"), \"json\") && rsp.StatusCode == 200:\n\t\tvar dest LoadBalancerService\n\t\tif err := json.Unmarshal(bodyBytes, &dest); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresponse.JSON200 = &dest\n\n\t}\n\n\treturn response, nil\n}", "id": 24600, "concepts": ["HTTP response parsing", "JSON parsing", "error handling", "HTTP status code handling"], "_raw_llm_output": "HTTP response parsing, JSON parsing, error handling, HTTP status code handling"}
{"seed": "// TableValue returns a Value holding the given arg.\nfunc TableValue(t *Table) Value {\n\treturn Value{iface: t}\n}", "id": 24614, "concepts": ["struct definition", "struct field access", "interface definition", "interface implementation"], "_raw_llm_output": "struct definition, struct field access, interface definition, interface implementation"}
{"seed": "// LockingPOSIX enables flock-based (BSD) locking. This is mostly\n// useful for distributed filesystems with global locking. Without\n// this, kernel manages local locking automatically.\n//\n// Beware POSIX locks are a broken API with unintuitive behavior for\n// callers.\nfunc LockingPOSIX() MountOption {\n\treturn func(conf *mountConfig) error {\n\t\tconf.initFlags |= InitPOSIXLocks\n\t\treturn nil\n\t}\n}", "id": 24620, "concepts": ["mount option", "mount configuration", "mount initialization"], "_raw_llm_output": "mount option, mount configuration, mount initialization"}
{"seed": "// isAllowedFileType determines if the file is among types defined\n// in map of allowed file types\nfunc isAllowedFileType(mimeType string) bool {\n\t_, exists := validFileTypes[mimeType]\n\n\treturn exists\n}", "id": 24624, "concepts": ["map", "map lookup", "map iteration", "map key lookup"], "_raw_llm_output": "map, map lookup, map iteration, map key lookup"}
{"seed": "// NewNetworkPruneParams creates a new NetworkPruneParams object\n// with the default values initialized.\nfunc NewNetworkPruneParams() *NetworkPruneParams {\n\tvar ()\n\treturn &NetworkPruneParams{\n\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 24626, "concepts": ["struct initialization", "pointer usage", "default values"], "_raw_llm_output": "struct initialization, pointer usage, default values"}
{"seed": "// removeReference removes ref from object obj with property prop.\n// It returns ok (removal took place) and an error message\nfunc removeReference(obj *models.Object, prop string, ref *models.SingleRef) (ok bool, errmsg string) {\n\tproperties := obj.Properties.(map[string]interface{})\n\tif properties == nil || properties[prop] == nil {\n\t\treturn false, \"\"\n\t}\n\n\trefs, ok := properties[prop].(models.MultipleRef)\n\tif !ok {\n\t\treturn false, \"source list is not well formed\"\n\t}\n\n\tnewrefs := make(models.MultipleRef, 0, len(refs))\n\tfor _, r := range refs {\n\t\tif r.Beacon != ref.Beacon {\n\t\t\tnewrefs = append(newrefs, r)\n\t\t}\n\t}\n\tproperties[prop] = newrefs\n\treturn len(refs) != len(newrefs), \"\"\n}", "id": 24632, "concepts": ["map iteration (range loop)", "map manipulation", "interface conversion"], "_raw_llm_output": "map iteration (range loop), map manipulation, interface conversion"}
{"seed": "// Figure_ is a convenience wrapper for Figure without the attrs argument.\nfunc Figure_(children ...HTML) HTML {\n  return Figure(nil, children...)\n}", "id": 24634, "concepts": ["function definition", "variadic function definition", "function call", "function return"], "_raw_llm_output": "function definition, variadic function definition, function call, function return"}
{"seed": "// CorrectionContains applies the Contains predicate on the \"correction\" field.\nfunc CorrectionContains(v string) predicate.TradeCorrection {\n\treturn predicate.TradeCorrection(sql.FieldContains(FieldCorrection, v))\n}", "id": 24635, "concepts": ["sql.FieldContains", "predicate.TradeCorrection", "predicate.FieldContains"], "_raw_llm_output": "sql.FieldContains, predicate.TradeCorrection, predicate.FieldContains"}
{"seed": "// New returns an SimpleHandler ready to serve using the specified directory.\n// The dev flag indicates if development functionality is enabled.\n// Settings on SimpleHandler may be tuned more specifically after creation, this function just\n// returns sensible defaults for development or production according to if dev is true or false.\nfunc New(dir string, dev bool) *SimpleHandler {\n\n\tif !filepath.IsAbs(dir) {\n\t\tpanic(fmt.Errorf(\"dir %q is not an absolute path\", dir))\n\t}\n\n\tret := &SimpleHandler{\n\t\tDir: dir,\n\t}\n\n\tret.IsPage = DefaultIsPageFunc\n\tret.PageHandler = &PageHandler{\n\t\tTemplate:         template.Must(template.New(\"_page_\").Parse(DefaultPageTemplateSource)),\n\t\tTemplateDataFunc: DefaultTemplateDataFunc,\n\t}\n\n\tret.StaticHandler = FilteredFileServer(\n\t\tregexp.MustCompile(`[.](css|js|html|map|jpg|jpeg|png|gif|svg|eot|ttf|otf|woff|woff2|wasm)$`),\n\t\thttp.Dir(dir))\n\n\tif dev {\n\t\tret.EnableBuildAndServe = true\n\t\tret.ParserGoPkgOpts = &gen.ParserGoPkgOpts{}\n\t\tret.MainWasmPath = \"/main.wasm\"\n\t\tret.WasmExecJsPath = \"/wasm_exec.js\"\n\t}\n\n\treturn ret\n}", "id": 24640, "concepts": ["string manipulation", "regexp", "http.Dir", "http.FileServer", "http.HandlerFunc", "http.ServeMux", "http.Handler", "http.File", "http.ResponseWriter", "http.Request", "http.ServeFile", "http.Redirect", "http.NotFound", "http.Error", "http.StripPrefix", "http.HandlerFunc", "http.ListenAndServe", "http.ListenAndServeTLS", "http.FileServer", "http.File", "http.ServeContent", "http.ServeMux", "http.Handler", "http.HandlerFunc", "http.ServeFile", "http.StripPrefix", "http.File", "http.FileServer", "http.File", "http.File", "http.File", "http.File", "http.File", "http.File", "http.File", "http.File", "http.File", "http.File", "http.File", "http.File", "http.File", "http.File", "http.File", "http.File", "http.File", "http.File", "http.File", "http.File", "http.File", "http.File", "http.File", "http.File", "http.File", "http.File", "http.File", "http.File", "http.File", "http.File", "http.File", "http.File", "http.File"], "_raw_llm_output": "string manipulation, regexp, http.Dir, http.FileServer, http.HandlerFunc, http.ServeMux, http.Handler, http.File, http.ResponseWriter, http.Request, http.ServeFile, http.Redirect, http.NotFound, http.Error, http.StripPrefix, http.HandlerFunc, http.ListenAndServe, http.ListenAndServeTLS, http.FileServer, http.File, http.ServeContent, http.ServeMux, http.Handler, http.HandlerFunc, http.ServeFile, http.StripPrefix, http.File, http.FileServer, http.File, http.File, http.File, http.File, http.File, http.File, http.File, http.File, http.File, http.File, http.File, http.File, http.File, http.File, http.File, http.File, http.File, http.File, http.File, http.File, http.File, http.File, http.File, http.File, http.File, http.File, http.File, http.File, http.File, http.File, http.File, http.File, http.File"}
{"seed": "// Pre represents the HTML element 'pre'.\n// For more information visit https://www.w3schools.com/tags/tag_pre.asp.\nfunc Pre(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"pre\", Attributes: attrs, Children: children}\n}", "id": 24658, "concepts": ["HTML generation", "HTML tree representation", "HTML element definition", "HTML attribute definition", "HTML element usage"], "_raw_llm_output": "HTML generation, HTML tree representation, HTML element definition, HTML attribute definition, HTML element usage"}
{"seed": "// Title represents the HTML element 'title'.\n// For more information visit https://www.w3schools.com/tags/tag_title.asp.\nfunc Title(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"title\", Attributes: attrs, Children: children}\n}", "id": 24660, "concepts": ["HTML generation", "HTML tree representation", "HTML element definition"], "_raw_llm_output": "HTML generation, HTML tree representation, HTML element definition"}
{"seed": "// Address represents the HTML element 'address'.\n// For more information visit https://www.w3schools.com/tags/tag_address.asp.\nfunc Address(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"address\", Attributes: attrs, Children: children}\n}", "id": 24685, "concepts": ["HTML generation", "HTML tree traversal", "HTML element definition"], "_raw_llm_output": "HTML generation, HTML tree traversal, HTML element definition"}
{"seed": "// filterOutCondition returns a new slice of caffe2job conditions without conditions with the provided type.\nfunc filterOutCondition(conditions []api.Caffe2JobCondition, condType api.Caffe2JobConditionType) []api.Caffe2JobCondition {\n\tvar newConditions []api.Caffe2JobCondition\n\tfor _, c := range conditions {\n\t\tif c.Type == condType {\n\t\t\tcontinue\n\t\t}\n\t\tnewConditions = append(newConditions, c)\n\t}\n\treturn newConditions\n}", "id": 24688, "concepts": ["slice iteration (range loop)", "slice manipulation", "basic function definition"], "_raw_llm_output": "slice iteration (range loop), slice manipulation, basic function definition"}
{"seed": "// PossibleExtensionCategoryValues returns the possible values for the ExtensionCategory const type.\nfunc PossibleExtensionCategoryValues() []ExtensionCategory {\n\treturn []ExtensionCategory{\n\t\tExtensionCategoryNotSpecified,\n\t\tExtensionCategoryResourceCreationBegin,\n\t\tExtensionCategoryResourceCreationCompleted,\n\t\tExtensionCategoryResourceCreationValidate,\n\t\tExtensionCategoryResourceDeletionBegin,\n\t\tExtensionCategoryResourceDeletionCompleted,\n\t\tExtensionCategoryResourceDeletionValidate,\n\t\tExtensionCategoryResourceMoveBegin,\n\t\tExtensionCategoryResourceMoveCompleted,\n\t\tExtensionCategoryResourcePatchBegin,\n\t\tExtensionCategoryResourcePatchCompleted,\n\t\tExtensionCategoryResourcePatchValidate,\n\t\tExtensionCategoryResourcePostAction,\n\t\tExtensionCategoryResourceReadBegin,\n\t\tExtensionCategoryResourceReadValidate,\n\t\tExtensionCategorySubscriptionLifecycleNotification,\n\t}\n}", "id": 24692, "concepts": ["const type", "type casting"], "_raw_llm_output": "const type, type casting"}
{"seed": "// BulkCreditSamedayGT applies the GT predicate on the \"bulkCreditSameday\" field.\nfunc BulkCreditSamedayGT(v float64) predicate.Bulk {\n\treturn predicate.Bulk(func(s *sql.Selector) {\n\t\ts.Where(sql.GT(s.C(FieldBulkCreditSameday), v))\n\t})\n}", "id": 24693, "concepts": ["sql package usage", "sql.Selector", "sql.Where", "sql.GT", "sql.C", "sql.Field", "sql.Predicate", "sql.Predicate.Bulk"], "_raw_llm_output": "sql package usage, sql.Selector, sql.Where, sql.GT, sql.C, sql.Field, sql.Predicate, sql.Predicate.Bulk"}
{"seed": "// FailoverGroupReadOnlyEndpointGenerator returns a generator of FailoverGroupReadOnlyEndpoint instances for property testing.\nfunc FailoverGroupReadOnlyEndpointGenerator() gopter.Gen {\n\tif failoverGroupReadOnlyEndpointGenerator != nil {\n\t\treturn failoverGroupReadOnlyEndpointGenerator\n\t}\n\n\tgenerators := make(map[string]gopter.Gen)\n\tAddIndependentPropertyGeneratorsForFailoverGroupReadOnlyEndpoint(generators)\n\tfailoverGroupReadOnlyEndpointGenerator = gen.Struct(reflect.TypeOf(FailoverGroupReadOnlyEndpoint{}), generators)\n\n\treturn failoverGroupReadOnlyEndpointGenerator\n}", "id": 24708, "concepts": ["struct", "map", "reflect", "property testing", "gopter"], "_raw_llm_output": "struct, map, reflect, property testing, gopter"}
{"seed": "// SocialAvatarURLHasSuffix applies the HasSuffix predicate on the \"social_avatar_url\" field.\nfunc SocialAvatarURLHasSuffix(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.HasSuffix(s.C(FieldSocialAvatarURL), v))\n\t})\n}", "id": 24713, "concepts": ["sql package usage", "sql.Selector", "sql.C", "sql.HasSuffix"], "_raw_llm_output": "sql package usage, sql.Selector, sql.C, sql.HasSuffix"}
{"seed": "// Prompt prints the given string and blocks until the user inputs one of the\n// alphanumeric characters shown in parentheses. For example, a prompt\n// containing \"(y/n)\" would accept either 'y' or 'n' as input. Multiple\n// parentheticals can be included.\nfunc Prompt(s string) rune {\n\tacceptedRunes := \"\"\n\n\t// show parentheticals in bold\n\tline := make([]segment, 0)\n\tpos := 0\n\tfor pos < len(s) {\n\t\topen := strings.IndexRune(s[pos:], '(')\n\t\tif open == -1 {\n\t\t\tline = append(line, segment{text: s[pos:]})\n\t\t\tbreak\n\t\t} else {\n\t\t\tclose := strings.IndexRune(s[pos+open:], ')')\n\t\t\tif close == -1 {\n\t\t\t\tline = append(line, segment{text: s[pos:]})\n\t\t\t\tbreak\n\t\t\t} else {\n\t\t\t\tline = append(line, segment{text: s[pos : pos+open]})\n\t\t\t\tline = append(line, segment{\n\t\t\t\t\ttext: s[pos+open : pos+open+close+1],\n\t\t\t\t\tfg:   colorDefault | bold,\n\t\t\t\t})\n\t\t\t\tacceptedRunes += s[pos+open+1 : pos+open+close]\n\t\t\t\tpos += open + close + 1\n\t\t\t}\n\t\t}\n\t}\n\n\t// add space before cursor\n\tline = append(line, segment{text: \" \"})\n\n\t// wait for and return a valid rune\n\twrite <- line\n\tchange <- modePrompt\n\tfor {\n\t\tch := <-prompt\n\t\tif strings.ContainsRune(acceptedRunes, ch) {\n\t\t\trewrite <- append(line, segment{text: string(ch)})\n\t\t\tchange <- modeWorking\n\t\t\treturn ch\n\t\t}\n\t}\n}", "id": 24728, "concepts": ["string manipulation", "rune handling", "character comparison", "string formatting", "standard library usage"], "_raw_llm_output": "string manipulation, rune handling, character comparison, string formatting, standard library usage"}
{"seed": "// NewCatalogProductRepositoryV1SavePutParamsWithTimeout creates a new CatalogProductRepositoryV1SavePutParams object\n// with the default values initialized, and the ability to set a timeout on a request\nfunc NewCatalogProductRepositoryV1SavePutParamsWithTimeout(timeout time.Duration) *CatalogProductRepositoryV1SavePutParams {\n\tvar ()\n\treturn &CatalogProductRepositoryV1SavePutParams{\n\n\t\ttimeout: timeout,\n\t}\n}", "id": 24732, "concepts": ["struct initialization", "timeout handling"], "_raw_llm_output": "struct initialization, timeout handling"}
{"seed": "// ResultFailureTemplate returns a Result with a template string and data which\n// can be used to format a failure message. The template may access data from .Data,\n// the comparison args with the callArg function, and the formatNode function may\n// be used to format the call args.\nfunc ResultFailureTemplate(template string, data map[string]interface{}) Result {\n\treturn templatedResult{template: template, data: data}\n}", "id": 24751, "concepts": ["template string formatting", "map iteration", "function definition", "function call", "function return"], "_raw_llm_output": "template string formatting, map iteration, function definition, function call, function return"}
{"seed": "// HasFriendsWith applies the HasEdge predicate on the \"friends\" edge with a given conditions (other predicates).\nfunc HasFriendsWith(preds ...predicate.User) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\tstep := sqlgraph.NewStep(\n\t\t\tsqlgraph.From(Table, FieldID),\n\t\t\tsqlgraph.To(Table, FieldID),\n\t\t\tsqlgraph.Edge(sqlgraph.M2M, false, FriendsTable, FriendsPrimaryKey...),\n\t\t)\n\t\tsqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {\n\t\t\tfor _, p := range preds {\n\t\t\t\tp(s)\n\t\t\t}\n\t\t})\n\t})\n}", "id": 24757, "concepts": ["sqlgraph package usage", "sql package usage", "predicate.User", "sqlgraph.HasNeighborsWith", "sqlgraph.M2M", "sqlgraph.Edge"], "_raw_llm_output": "sqlgraph package usage, sql package usage, predicate.User, sqlgraph.HasNeighborsWith, sqlgraph.M2M, sqlgraph.Edge"}
{"seed": "// serverCSR generates a certificate signing request for a server certificate and returns it.\n// Takes in the list of hosts/ip addresses this certificate applies to.\nfunc serverCSR(hosts []string) *x509.CertificateRequest {\n\tcsr := &x509.CertificateRequest{\n\t\tSubject: pkix.Name{\n\t\t\tOrganization: []string{\"Cockroach\"},\n\t\t\tCommonName:   \"node\",\n\t\t},\n\t}\n\n\t// Determine if addresses are IP addresses or DNS names and store them in the correct field.\n\tif hosts != nil {\n\t\tfor _, h := range hosts {\n\t\t\tif ip := net.ParseIP(h); ip != nil {\n\t\t\t\tcsr.IPAddresses = append(csr.IPAddresses, ip)\n\t\t\t} else {\n\t\t\t\tcsr.DNSNames = append(csr.DNSNames, h)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn csr\n}", "id": 24760, "concepts": ["x509 package usage", "certificate signing request generation", "certificate request definition"], "_raw_llm_output": "x509 package usage, certificate signing request generation, certificate request definition"}
{"seed": "// StringToNTBytes safely convert a string to byte array with an extra null terminator\n// This is to ensure a correct CGO conversion to char*\nfunc StringToNTBytes(s string) []byte {\n\tb := make([]byte, len(s)+1)\n\tcopy(b[:], s)\n\treturn b\n}", "id": 24768, "concepts": ["CGO", "string to byte array conversion", "null terminator"], "_raw_llm_output": "CGO, string to byte array conversion, null terminator"}
{"seed": "// Aside_ is a convenience wrapper for Aside without the attrs argument.\nfunc Aside_(children ...HTML) HTML {\n  return Aside(nil, children...)\n}", "id": 24772, "concepts": ["function definition", "function argument handling", "variadic function argument handling", "function return value handling"], "_raw_llm_output": "function definition, function argument handling, variadic function argument handling, function return value handling"}
{"seed": "// NewTestIndexer returns a do-nothing test indexer with specified elements.\n// \t- id\t\t-- GetID return\n//\t- version\t-- GetVersion return\n//\t- subs\t\t-- GetSubscriptions return\n//\t- prepare\t-- write PrepareReindex args to chan when called\n//\t- complete\t-- write CompleteReindex args to chan when called\n//\t- index\t\t-- write Index args to chan when called\nfunc NewTestIndexer(id string, version indexer.Version, subs []indexer.Subscription, prepare, complete, index chan mock.Arguments) indexer.Indexer {\n\tidx := &Indexer{}\n\n\tidx.On(\"GetID\").Return(id)\n\tidx.On(\"GetVersion\").Return(version)\n\tidx.On(\"GetSubscriptions\").Return(subs)\n\tidx.On(\"PrepareReindex\", mock.Anything, mock.Anything, mock.Anything).Run(func(args mock.Arguments) {\n\t\tif prepare != nil {\n\t\t\tprepare <- args\n\t\t}\n\t}).Return(nil)\n\tidx.On(\"CompleteReindex\", mock.Anything, mock.Anything).Run(func(args mock.Arguments) {\n\t\tif complete != nil {\n\t\t\tcomplete <- args\n\t\t}\n\t}).Return(nil)\n\tidx.On(\"Index\", mock.Anything, mock.Anything).Run(func(args mock.Arguments) {\n\t\tif index != nil {\n\t\t\tindex <- args\n\t\t}\n\t}).Return(nil, nil)\n\n\treturn idx\n}", "id": 24778, "concepts": ["mocking", "interface implementation", "mocking package usage"], "_raw_llm_output": "mocking, interface implementation, mocking package usage"}
{"seed": "// GetUptime parses output from OS X's `sysctl -n kern.boottime` and returns\n// the number of seconds since the machine booted.\nfunc GetUptime() float64 {\n\tout, err := exec.Command(\"sysctl\", \"-n\", \"kern.boottime\").Output()\n\t// { sec = 1413585004, usec = 0 } Fri Oct 17 15:30:04 2014\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tpieces := strings.Fields(string(out))\n\n\treturn ConvertSeconds(strings.TrimRight(pieces[3], \",\"))\n}", "id": 24779, "concepts": ["exec package", "string manipulation", "string conversion", "string parsing", "string trimming", "string fields", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation", "string fields manipulation"], "_raw_llm_output": "exec package, string manipulation, string conversion, string parsing, string trimming, string fields, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation, string fields manipulation"}
{"seed": "/*\nDecrypt decrypts a literal of the form <b64URLmetadata>.<b64URLciphertext>.<b64URLnonce> given an AEAD cipher and\nproduces a metadata and data string.\n*/\nfunc Decrypt(aeadCipher cipher.AEAD, literal string) (string, string, error) {\n\tvar (\n\t\tliteralSubStrings []string\n\t\tmetadata          []byte\n\t\tciphertext        []byte\n\t\tnonce             []byte\n\t\tdata              []byte\n\t\terr               error\n\t)\n\n\t//Split the literal into its base64 encoded metadata, ciphertext and nonce components\n\tliteralSubStrings = strings.Split(literal, \".\")\n\tif len(literalSubStrings) != 3 {\n\t\treturn \"\", \"\", fmt.Errorf(\"Bad AEAD Literal: %v\\n\", literal)\n\t}\n\n\t//Decode the metadata, ciphertext and nonce\n\tmetadata, err = base64.URLEncoding.DecodeString(literalSubStrings[0])\n\tif err != nil {\n\t\treturn \"\", \"\", fmt.Errorf(\"Decode metadata failed: %v\\n\", literal)\n\t}\n\tciphertext, err = base64.URLEncoding.DecodeString(literalSubStrings[1])\n\tif err != nil {\n\t\treturn \"\", \"\", fmt.Errorf(\"Decode ciphertext failed: %v\\n\", literal)\n\t}\n\tnonce, err = base64.URLEncoding.DecodeString(literalSubStrings[2])\n\tif err != nil {\n\t\treturn \"\", \"\", fmt.Errorf(\"Decode nonce failed: %v\\n\", literal)\n\t}\n\n\t//Open validates the integrity of the metadata using the authentication code in the ciphertext\n\t//and, if valid, decrypts the ciphertext\n\tdata, err = aeadCipher.Open(data, nonce, ciphertext, metadata)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\treturn string(metadata), string(data), nil\n}", "id": 24804, "concepts": ["string manipulation", "base64 encoding", "string formatting", "string comparison", "string to byte conversion", "byte to string conversion", "string to byte conversion", "byte to string conversion", "string to byte conversion", "byte to string conversion", "string to byte conversion", "byte to string conversion", "string to byte conversion", "byte to string conversion", "string to byte conversion", "byte to string conversion", "string to byte conversion", "byte to string conversion", "string to byte conversion", "byte to string conversion", "string to byte conversion", "byte to string conversion", "string to byte conversion", "byte to string conversion", "string to byte conversion", "byte to string conversion", "string to byte conversion", "byte to string conversion", "string to byte conversion", "byte to string conversion", "string to byte conversion", "byte to string conversion", "string to byte conversion", "byte to string conversion", "string to byte conversion", "byte to string conversion", "string to byte conversion", "byte to string conversion", "string to byte conversion", "byte to string conversion", "string to byte conversion", "byte to string conversion", "string to byte conversion", "byte to string conversion", "string to byte conversion", "byte to string conversion", "string to byte conversion", "byte to string conversion", "string to byte conversion", "byte to string conversion", "string to byte conversion", "byte to string conversion", "string"], "_raw_llm_output": "string manipulation, base64 encoding, string formatting, string comparison, string to byte conversion, byte to string conversion, string to byte conversion, byte to string conversion, string to byte conversion, byte to string conversion, string to byte conversion, byte to string conversion, string to byte conversion, byte to string conversion, string to byte conversion, byte to string conversion, string to byte conversion, byte to string conversion, string to byte conversion, byte to string conversion, string to byte conversion, byte to string conversion, string to byte conversion, byte to string conversion, string to byte conversion, byte to string conversion, string to byte conversion, byte to string conversion, string to byte conversion, byte to string conversion, string to byte conversion, byte to string conversion, string to byte conversion, byte to string conversion, string to byte conversion, byte to string conversion, string to byte conversion, byte to string conversion, string to byte conversion, byte to string conversion, string to byte conversion, byte to string conversion, string to byte conversion, byte to string conversion, string to byte conversion, byte to string conversion, string to byte conversion, byte to string conversion, string to byte conversion, byte to string conversion, string to byte conversion, byte to string conversion, string"}
{"seed": "// Some returns true if at least 1 element of a subset is contained into a collection.\nfunc Some[T comparable](collection []T, subset []T) bool {\n\tfor _, elem := range subset {\n\t\tif Contains(collection, elem) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}", "id": 24823, "concepts": ["generic programming", "type constraints", "type parameters", "type arguments", "slice iteration", "slice comparison"], "_raw_llm_output": "generic programming, type constraints, type parameters, type arguments, slice iteration, slice comparison"}
{"seed": "// Sub represents the HTML element 'sub'.\n// For more information visit https://www.w3schools.com/tags/tag_sub.asp.\nfunc Sub(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"sub\", Attributes: attrs, Children: children}\n}", "id": 24831, "concepts": ["HTML generation", "HTML tree", "HTML element definition", "HTML attribute definition"], "_raw_llm_output": "HTML generation, HTML tree, HTML element definition, HTML attribute definition"}
{"seed": "// GetSearchSoftwareSourceModulesDetailsSortByEnumValues Enumerates the set of values for SearchSoftwareSourceModulesDetailsSortByEnum\nfunc GetSearchSoftwareSourceModulesDetailsSortByEnumValues() []SearchSoftwareSourceModulesDetailsSortByEnum {\n\tvalues := make([]SearchSoftwareSourceModulesDetailsSortByEnum, 0)\n\tfor _, v := range mappingSearchSoftwareSourceModulesDetailsSortByEnum {\n\t\tvalues = append(values, v)\n\t}\n\treturn values\n}", "id": 24838, "concepts": ["enumerations", "mapping", "basic function definition"], "_raw_llm_output": "enumerations, mapping, basic function definition"}
{"seed": "// Parents sets the commits used as the parents.\nfunc Parents(parents ...*Commit) CommitOption {\n\treturn func(c *commitConfig) {\n\t\tc.parents = parents\n\t}\n}", "id": 24844, "concepts": ["function composition", "function options", "function arguments"], "_raw_llm_output": "function composition, function options, function arguments"}
{"seed": "// Runs the given program and returns the resulting program memory.\n// What the program does is defined by the opcode. The first opcode is at position 0 and the arguments for the command\n// defined by that opcode are behind the opcode. The amount of arguments is defined by the opcode.\n// Once the command is run, the instruction pointer moves behind the instruction and checks for the next opcode.\n// Once the opcode 99 is detected, the result is returned. If no such opcode is found, an error is returned.\n//\n// Possible opcodes:\n// 1 - Adds the values at the position of the first and second arguments and saves the result in the third argument.\n// 2 - Multiplies the values at the position of the first and second arguments and saves the result in the third argument.\n// 99 - Terminates the program.\nfunc runProgram(program []int) (result []int, err error) {\n\tif len(program) <= 0 {\n\t\treturn nil, errors.New(\"program is empty\")\n\t}\n\n\tresult = program\n\tinstructionPointer := 0\n\n\tfor instructionPointer < len(result) {\n\t\topcode := result[instructionPointer]\n\n\t\tif opcode == 99 {\n\t\t\treturn result, nil\n\t\t} else {\n\t\t\t// We have read the opcode. Advance the instruction pointer by one.\n\t\t\tinstructionPointer += 1\n\n\t\t\tif opcode == 1 {\n\t\t\t\t// Adds the values at the positions given by the first and second arg\n\t\t\t\t//and writes the result to the position given by the third arg.\n\t\t\t\targuments, err := readArguments(program, instructionPointer, 3)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\n\t\t\t\tresult[arguments[2]] = result[arguments[0]] + result[arguments[1]]\n\t\t\t\tinstructionPointer += 3\n\t\t\t} else if opcode == 2 {\n\t\t\t\t// Multiplies the values at the positions given by the first and second arg\n\t\t\t\t//and writes the result to the position given by the third arg.\n\t\t\t\targuments, err := readArguments(program, instructionPointer, 3)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\n\t\t\t\tresult[arguments[2]] = result[arguments[0]] * result[arguments[1]]\n\t\t\t\tinstructionPointer += 3\n\t\t\t} else {\n\t\t\t\treturn nil, errors.New(fmt.Sprintf(\"unknown opcode detected: %d\", opcode))\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil, errors.New(\"no terminating opcode (99) found in program\")\n}", "id": 24845, "concepts": ["array iteration (range loop)", "integer multiplication", "integer addition", "error handling (errors.New)", "standard library usage"], "_raw_llm_output": "array iteration (range loop), integer multiplication, integer addition, error handling (errors.New), standard library usage"}
{"seed": "// AllOf creates a new AndMatcher with m.\nfunc AllOf(m ...Matcher) AndMatcher {\n\treturn AndMatcher(m)\n}", "id": 24850, "concepts": ["interface", "type assertion", "type conversion", "type definition", "type embedding"], "_raw_llm_output": "interface, type assertion, type conversion, type definition, type embedding"}
{"seed": "// Version returns the version of the web server.\nfunc Version() string {\n\treturn version\n}", "id": 24860, "concepts": ["constant definition", "string formatting"], "_raw_llm_output": "constant definition, string formatting"}
{"seed": "// RecentTasksActivityCreatedByASC function sorts data by CreatedBy field in ascending order\n// sorting layers: CreateBy > LRStatus(ASC) > LRTime(DESC) > Name(ASC)\n// function chain according to sorting layers: RecentTasksActivityCreatedByASC > RecentTasksActivityLRStatusASC > subsortingByLRTimeDESC > subsortingByNameASC\nfunc RecentTasksActivityCreatedByASC(p1, p2 interface{}) bool {\n\tp1CreatedBy := p1.(RecentTasksActivity).Task.CreatedBy\n\tp2CreatedBy := p2.(RecentTasksActivity).Task.CreatedBy\n\n\tif p1CreatedBy == p2CreatedBy {\n\t\treturn RecentTasksActivityLRStatusASC(p1, p2)\n\t}\n\n\treturn Relay.StringLessOp(p1CreatedBy, p2CreatedBy)\n}", "id": 24870, "concepts": ["interface", "sorting", "sorting by multiple fields", "sorting by multiple fields with different sorting orders"], "_raw_llm_output": "interface, sorting, sorting by multiple fields, sorting by multiple fields with different sorting orders"}
{"seed": "// AgeNEQ applies the NEQ predicate on the \"age\" field.\nfunc AgeNEQ(v int) predicate.User {\n\treturn predicate.User(sql.FieldNEQ(FieldAge, v))\n}", "id": 24873, "concepts": ["predicate.User", "sql.FieldNEQ", "sql.FieldEQ"], "_raw_llm_output": "predicate.User, sql.FieldNEQ, sql.FieldEQ"}
{"seed": "// FormatPkgName formats a package name by keeping only the letters.\nfunc FormatPkgName(name string) string {\n\tformatted := bytes.NewBuffer(nil)\n\n\tfor _, c := range []byte(name) {\n\t\tif bytes.Contains(letters, []byte{c}) {\n\t\t\tformatted.WriteByte(c)\n\t\t}\n\t}\n\n\treturn formatted.String()\n}", "id": 24883, "concepts": ["string manipulation", "byte manipulation", "byte comparison"], "_raw_llm_output": "string manipulation, byte manipulation, byte comparison"}
{"seed": "// Given a slice of lines, where each line is a slice of token strings that should\n// appear on that line and a function that maps line number -> desired width,\n// add spaces to each line to make it reach the desired width if possible.\n// If centered is set to true, also center the output.\n// Join the justified lines together and return a string.\nfunc JustifyByWidth(lines [][]string, widthFromLineNo func(int) int, centered bool) string {\n\tmaxW := maxWidth(len(lines), widthFromLineNo)\n\tjustifiedLines := make([]string, 0, len(lines))\n\tfor i, line := range lines {\n\t\twidth := int(math.Max(float64(widthFromLineNo(i)), 1))\n\t\tfor TotalLength(line) < width {\n\t\t\tidx := rand.Intn(len(line))\n\t\t\tline[idx] += \" \"\n\t\t}\n\t\tspacing := \"\"\n\t\t// center by prepending spaces such that the center is at maxW/2\n\t\tif centered {\n\t\t\tspacing = fmt.Sprintf(\"%*s\", (maxW-width)/2+2, \" \")\n\t\t}\n\t\tjustifiedLines = append(justifiedLines, spacing+strings.Join(line, \"\"))\n\t}\n\treturn strings.Join(justifiedLines, \"\\n\")\n}", "id": 24887, "concepts": ["slice iteration (range loop)", "string manipulation", "string concatenation", "random number generation"], "_raw_llm_output": "slice iteration (range loop), string manipulation, string concatenation, random number generation"}
{"seed": "// CreateKeyValueFromDiscriminatorValue creates a new instance of the appropriate class based on discriminator value\nfunc CreateKeyValueFromDiscriminatorValue(parseNode i878a80d2330e89d26896388a3f487eef27b0a0e6c010c493bf80be1452208f91.ParseNode)(i878a80d2330e89d26896388a3f487eef27b0a0e6c010c493bf80be1452208f91.Parsable, error) {\n    return NewKeyValue(), nil\n}", "id": 24899, "concepts": ["interface implementation", "interface definition", "interface usage", "struct definition", "struct usage"], "_raw_llm_output": "interface implementation, interface definition, interface usage, struct definition, struct usage"}
{"seed": "// NewGetDeploymentTargetOperatingSystemNamesListAllParamsWithTimeout creates a new GetDeploymentTargetOperatingSystemNamesListAllParams object\n// with the default values initialized, and the ability to set a timeout on a request\nfunc NewGetDeploymentTargetOperatingSystemNamesListAllParamsWithTimeout(timeout time.Duration) *GetDeploymentTargetOperatingSystemNamesListAllParams {\n\n\treturn &GetDeploymentTargetOperatingSystemNamesListAllParams{\n\n\t\ttimeout: timeout,\n\t}\n}", "id": 24911, "concepts": ["timeout handling", "function definition", "function parameter handling"], "_raw_llm_output": "timeout handling, function definition, function parameter handling"}
{"seed": "// ParseListDomainsResponse parses an HTTP response from a ListDomainsWithResponse call\nfunc ParseListDomainsResponse(rsp *http.Response) (*ListDomainsResponse, error) {\n\tbodyBytes, err := ioutil.ReadAll(rsp.Body)\n\tdefer rsp.Body.Close()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse := &ListDomainsResponse{\n\t\tBody:         bodyBytes,\n\t\tHTTPResponse: rsp,\n\t}\n\n\tswitch {\n\tcase strings.Contains(rsp.Header.Get(\"Content-Type\"), \"json\") && rsp.StatusCode == 200:\n\t\tvar dest ScalewayDomainV2alpha2ListDomainsResponse\n\t\tif err := json.Unmarshal(bodyBytes, &dest); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresponse.JSON200 = &dest\n\n\t}\n\n\treturn response, nil\n}", "id": 24912, "concepts": ["http.Response", "json.Unmarshal", "io.ReadAll", "strings.Contains", "switch statement", "basic function definition"], "_raw_llm_output": "http.Response, json.Unmarshal, io.ReadAll, strings.Contains, switch statement, basic function definition"}
{"seed": "// CopyGRPCHeadersHTTPClientInterceptorFxOption copies filtered Headers found in the Incoming GRPC metadata.MD to the Outgoing HTTP Request Headers.\n//\n// This is useful if you want to propagate them to the next service when using `http.Client`\n//\n// For Example: \"authorization\" header containing user token\nfunc CopyGRPCHeadersHTTPClientInterceptorFxOption() fx.Option {\n\treturn fx.Provide(\n\t\tfx.Annotated{\n\t\t\tGroup:  groups.RESTClientInterceptors,\n\t\t\tTarget: client.CopyGRPCHeadersHTTPClientInterceptor,\n\t\t})\n}", "id": 24914, "concepts": ["fx.Option", "fx.Annotated", "fx.Provide", "function definition", "struct definition", "struct field definition", "struct field initialization", "struct field initialization (map literal)", "struct field initialization (slice literal)", "struct field initialization (slice literal)", "struct field initialization (slice literal)", "struct field initialization (slice literal)", "struct field initialization (slice literal)", "struct field initialization (slice literal)", "struct field initialization (slice literal)", "struct field initialization (slice literal)", "struct field initialization (slice literal)", "struct field initialization (slice literal)", "struct field initialization (slice literal)", "struct field initialization (slice literal)", "struct field initialization (slice literal)", "struct field initialization (slice literal)", "struct field initialization (slice literal)", "struct field initialization (slice literal)", "struct field initialization (slice literal)", "struct field initialization (slice literal)", "struct field initialization (slice literal)", "struct field initialization (slice literal)", "struct field initialization (slice literal)", "struct field initialization (slice literal)", "struct field initialization (slice literal)", "struct field initialization (slice literal)", "struct field initialization (slice literal)", "struct field initialization (slice literal)", "struct field initialization (slice literal)", "struct field initialization (slice literal)", "struct field initialization (slice literal)", "struct field initialization (slice literal)", "struct field initialization (slice literal)", "struct field initialization (slice"], "_raw_llm_output": "fx.Option, fx.Annotated, fx.Provide, function definition, struct definition, struct field definition, struct field initialization, struct field initialization (map literal), struct field initialization (slice literal), struct field initialization (slice literal), struct field initialization (slice literal), struct field initialization (slice literal), struct field initialization (slice literal), struct field initialization (slice literal), struct field initialization (slice literal), struct field initialization (slice literal), struct field initialization (slice literal), struct field initialization (slice literal), struct field initialization (slice literal), struct field initialization (slice literal), struct field initialization (slice literal), struct field initialization (slice literal), struct field initialization (slice literal), struct field initialization (slice literal), struct field initialization (slice literal), struct field initialization (slice literal), struct field initialization (slice literal), struct field initialization (slice literal), struct field initialization (slice literal), struct field initialization (slice literal), struct field initialization (slice literal), struct field initialization (slice literal), struct field initialization (slice literal), struct field initialization (slice literal), struct field initialization (slice literal), struct field initialization (slice literal), struct field initialization (slice literal), struct field initialization (slice literal), struct field initialization (slice literal), struct field initialization (slice"}
{"seed": "// PossibleReasonValues returns an array of possible values for the Reason const type.\nfunc PossibleReasonValues() []Reason {\n\treturn []Reason{AlreadyExists, Invalid}\n}", "id": 24921, "concepts": ["const", "type definition", "array definition", "array iteration"], "_raw_llm_output": "const, type definition, array definition, array iteration"}
{"seed": "// CheckNick tests whether the given user can change to the given nick.\n// Note that this does not prevent collisions; these can only be checked for by\n// checking SetNick's return value.\nfunc CheckNick(pkg string, u *core.User, nick string) (bool, os.Error) {\n\tperm, err := CheckNickPerm(pkg, u, nick)\n\treturn perm > 0, err\n}", "id": 24923, "concepts": ["user", "permission", "error handling"], "_raw_llm_output": "user, permission, error handling"}
{"seed": "// Section represents the HTML element 'section'.\n// For more information visit https://www.w3schools.com/tags/tag_section.asp.\nfunc Section(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"section\", Attributes: attrs, Children: children}\n}", "id": 24936, "concepts": ["HTML", "HTML element definition", "HTML attribute definition", "HTML element creation"], "_raw_llm_output": "HTML, HTML element definition, HTML attribute definition, HTML element creation"}
{"seed": "// MapUint64Float32Ptr takes two inputs -\n// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list\nfunc MapUint64Float32Ptr(f func(*uint64) *float32, list []*uint64) []*float32 {\n\tif f == nil {\n\t\treturn []*float32{}\n\t}\n\tnewList := make([]*float32, len(list))\n\tfor i, v := range list {\n\t\tnewList[i] = f(v)\n\t}\n\treturn newList\n}", "id": 24943, "concepts": ["function", "function pointer", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function"], "_raw_llm_output": "function, function pointer, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function"}
{"seed": "// NewTmpl creates new Tmpl and loads templates. The dir argument is\n// directory to load templates from. The ext argument is extension of\n// templates. The devel (if true) turns the Tmpl to reload templates\n// every Render if there is a change in the dir.\nfunc NewTmpl(dir, ext string, devel bool) (tmpl *Tmpl, err error) {\n\t// get absolute path\n\tif dir, err = filepath.Abs(dir); err != nil {\n\t\treturn\n\t}\n\n\ttmpl = new(Tmpl)\n\ttmpl.dir = dir\n\ttmpl.ext = ext\n\ttmpl.devel = devel\n\n\tif err = tmpl.Load(); err != nil {\n\t\ttmpl = nil // drop for GC\n\t}\n\n\treturn\n}", "id": 24947, "concepts": ["file system", "filepath.Abs", "filepath.Walk", "filepath.Join", "filepath.Dir", "filepath.Ext", "filepath.IsAbs", "filepath.Clean", "filepath.ToSlash", "filepath.Split", "filepath.SplitList", "filepath.Match", "filepath.Rel", "filepath.SkipDir", "filepath.SkipDir", "filepath.WalkDir", "filepath.WalkFunc", "filepath.WalkDirFunc", "filepath.WalkDirFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc", "filepath.WalkFunc"], "_raw_llm_output": "file system, filepath.Abs, filepath.Walk, filepath.Join, filepath.Dir, filepath.Ext, filepath.IsAbs, filepath.Clean, filepath.ToSlash, filepath.Split, filepath.SplitList, filepath.Match, filepath.Rel, filepath.SkipDir, filepath.SkipDir, filepath.WalkDir, filepath.WalkFunc, filepath.WalkDirFunc, filepath.WalkDirFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc, filepath.WalkFunc"}
{"seed": "// WithOverrideValues is an Option that configures a Reconciler's override\n// values.\n//\n// Override values can be used to enforce that certain values provided by the\n// chart's default values.yaml or by a CR spec are always overridden when\n// rendering the chart. If a value in overrides is set by a CR, it is\n// overridden by the override value. The override value can be static but can\n// also refer to an environment variable.\n//\n// If an environment variable reference is listed in override values but is not\n// present in the environment when this function runs, it will resolve to an\n// empty string and override all other values. Therefore, when using\n// environment variable expansion, ensure that the environment variable is set.\nfunc WithOverrideValues(overrides map[string]string) Option {\n\treturn func(r *Reconciler) error {\n\t\t// Validate that overrides can be parsed and applied\n\t\t// so that we fail fast during operator setup rather\n\t\t// than during the first reconciliation.\n\t\tm := internalvalues.New(map[string]interface{}{})\n\t\tif err := m.ApplyOverrides(overrides); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tr.overrideValues = overrides\n\t\treturn nil\n\t}\n}", "id": 24949, "concepts": ["map iteration (range loop)", "map key lookup", "map value lookup", "map value modification", "map value deletion", "map value assignment", "map iteration (for loop)", "map iteration (for range loop)", "map iteration (while loop)", "map iteration (while range loop)", "map key iteration (for loop)", "map key iteration (for range loop)", "map key iteration (while loop)", "map key iteration (while range loop)", "map value iteration (for loop)", "map value iteration (for range loop)", "map value iteration (while loop)", "map value iteration (while range loop)", "map key/value iteration (for loop)", "map key/value iteration (for range loop)", "map key/value iteration (while loop)", "map key/value iteration (while range loop)", "map key/value iteration (for range loop)", "map key/value iteration (while range loop)", "map key/value iteration (for range loop)", "map key/value iteration (while range loop)", "map key/value iteration (for range loop)", "map key/value iteration (while range loop)", "map key/value iteration (for range loop)", "map key/value iteration (while range loop)", "map key/value iteration (for range loop)", "map key/value iteration (while range loop)", "map key/value iteration"], "_raw_llm_output": "map iteration (range loop), map key lookup, map value lookup, map value modification, map value deletion, map value assignment, map iteration (for loop), map iteration (for range loop), map iteration (while loop), map iteration (while range loop), map key iteration (for loop), map key iteration (for range loop), map key iteration (while loop), map key iteration (while range loop), map value iteration (for loop), map value iteration (for range loop), map value iteration (while loop), map value iteration (while range loop), map key/value iteration (for loop), map key/value iteration (for range loop), map key/value iteration (while loop), map key/value iteration (while range loop), map key/value iteration (for range loop), map key/value iteration (while range loop), map key/value iteration (for range loop), map key/value iteration (while range loop), map key/value iteration (for range loop), map key/value iteration (while range loop), map key/value iteration (for range loop), map key/value iteration (while range loop), map key/value iteration (for range loop), map key/value iteration (while range loop), map key/value iteration"}
{"seed": "// quantile calculates the given quantile of a vector of samples.\n//\n// The Vector will be sorted.\n// If 'values' has zero elements, NaN is returned.\n// If q<0, -Inf is returned.\n// If q>1, +Inf is returned.\nfunc quantile(q float64, values vector.HeapByMaxValue) float64 {\n\tif len(values) == 0 {\n\t\treturn math.NaN()\n\t}\n\tif q < 0 {\n\t\treturn math.Inf(-1)\n\t}\n\tif q > 1 {\n\t\treturn math.Inf(+1)\n\t}\n\tsort.Sort(values)\n\n\tn := float64(len(values))\n\t// When the quantile lies between two samples,\n\t// we use a weighted average of the two samples.\n\trank := q * (n - 1)\n\n\tlowerIndex := math.Max(0, math.Floor(rank))\n\tupperIndex := math.Min(n-1, lowerIndex+1)\n\n\tweight := rank - math.Floor(rank)\n\treturn values[int(lowerIndex)].V*(1-weight) + values[int(upperIndex)].V*weight\n}", "id": 24951, "concepts": ["sorting", "heap", "math package usage"], "_raw_llm_output": "sorting, heap, math package usage"}
{"seed": "// getHeight prompts the user to enter an integer, and reprompts on invalid input.\n// It returns a positive integer between 1-23.\nfunc getHeight() int {\n\tfor {\n\t\theight := go50.GetInt(\"Height: \")\n\t\tif height > 0 && height < 24 {\n\t\t\treturn height\n\t\t}\n\t}\n}", "id": 24963, "concepts": ["integer input", "error handling (idiomatic if err != nil)", "basic function definition"], "_raw_llm_output": "integer input, error handling (idiomatic if err != nil), basic function definition"}
{"seed": "// NewNetInfoCell builds a NetInfoCell with the given receiver and sender\n// addresses.\nfunc NewNetInfoCell(r net.IP, s []net.IP) *NetInfoCell {\n\treturn &NetInfoCell{\n\t\tTimestamp:       time.Now(),\n\t\tReceiverAddress: r,\n\t\tSenderAddresses: s,\n\t}\n}", "id": 24972, "concepts": ["struct definition", "struct field access", "pointer receivers", "struct composition"], "_raw_llm_output": "struct definition, struct field access, pointer receivers, struct composition"}
{"seed": "// License returns package license\nfunc License() string {\n\treturn \"Licensed under the Apache License 2.0\"\n}", "id": 24997, "concepts": ["package definition", "license definition"], "_raw_llm_output": "package definition, license definition"}
{"seed": "// DriverErr returns the original error as returned by the database driver\n// if the error comes from the driver, with the second value set to true.\n// Otherwise, it returns err itself with false as second value.\nfunc DriverErr(err error) (error, bool) {\n\tif dbe, ok := err.(*dbErr); ok {\n\t\treturn dbe.err, true\n\t}\n\treturn err, false\n}", "id": 24999, "concepts": ["error handling (errors.As)", "error wrapping", "error type"], "_raw_llm_output": "error handling (errors.As), error wrapping, error type"}
{"seed": "// RuleType_Values returns all elements of the RuleType enum\nfunc RuleType_Values() []string {\n\treturn []string{\n\t\tRuleTypeAtleast,\n\t\tRuleTypeAnd,\n\t\tRuleTypeOr,\n\t}\n}", "id": 25027, "concepts": ["enum", "string formatting", "slice definition"], "_raw_llm_output": "enum, string formatting, slice definition"}
{"seed": "// NewJobExecutionsClient creates a new instance of JobExecutionsClient with the specified values.\n//   - subscriptionID - The subscription ID that identifies an Azure subscription.\n//   - credential - used to authorize requests. Usually a credential from azidentity.\n//   - options - pass nil to accept the default values.\nfunc NewJobExecutionsClient(subscriptionID string, credential azcore.TokenCredential, options *arm.ClientOptions) (*JobExecutionsClient, error) {\n\tcl, err := arm.NewClient(moduleName+\".JobExecutionsClient\", moduleVersion, credential, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tclient := &JobExecutionsClient{\n\t\tsubscriptionID: subscriptionID,\n\t\tinternal:       cl,\n\t}\n\treturn client, nil\n}", "id": 25035, "concepts": ["azure SDK usage", "azure SDK client creation", "azure SDK client initialization", "azure SDK client usage"], "_raw_llm_output": "azure SDK usage, azure SDK client creation, azure SDK client initialization, azure SDK client usage"}
{"seed": "// explodeStages creates one or multiple stages by processing byName.\n//\n// It searches if there's any driver than has dependency on another driver and\n// create stages from this DAG.\n//\n// It also verifies that there is not cycle in the DAG.\n//\n// When this function starts, allDriver and byName are guaranteed to be\n// immutable. state must not be touched by this function.\nfunc explodeStages() ([]*stage, error) {\n\t// First, create the DAG.\n\tdag := map[string]map[string]struct{}{}\n\tfor name, d := range byName {\n\t\tm := map[string]struct{}{}\n\t\tfor _, p := range d.Prerequisites() {\n\t\t\tif _, ok := byName[p]; !ok {\n\t\t\t\treturn nil, errors.New(\"periph: unsatisfied dependency \" + strconv.Quote(name) + \"->\" + strconv.Quote(p) + \"; it is missing; skipping\")\n\t\t\t}\n\t\t\tm[p] = struct{}{}\n\t\t}\n\t\tfor _, p := range d.After() {\n\t\t\t// Skip undefined drivers silently, unlike Prerequisites().\n\t\t\tif _, ok := byName[p]; ok {\n\t\t\t\tm[p] = struct{}{}\n\t\t\t}\n\t\t}\n\t\tdag[name] = m\n\t}\n\n\t// Create stages.\n\tvar stages []*stage\n\tfor len(dag) != 0 {\n\t\ts := &stage{drvs: map[string]Driver{}}\n\t\tfor name, deps := range dag {\n\t\t\t// This driver has no dependency, add it to the current stage.\n\t\t\tif len(deps) == 0 {\n\t\t\t\ts.drvs[name] = byName[name]\n\t\t\t\tdelete(dag, name)\n\t\t\t}\n\t\t}\n\t\tif len(s.drvs) == 0 {\n\t\t\t// Print out the remaining DAG so users can diagnose.\n\t\t\t// It'd probably be nicer if it were done in Register()?\n\t\t\ts := make([]string, 0, len(dag))\n\t\t\tfor name, deps := range dag {\n\t\t\t\tx := make([]string, 0, len(deps))\n\t\t\t\tfor d := range deps {\n\t\t\t\t\tx = insertString(x, d)\n\t\t\t\t}\n\t\t\t\ts = insertString(s, name+\": \"+strings.Join(x, \", \"))\n\t\t\t}\n\t\t\treturn nil, errors.New(\"periph: found cycle(s) in drivers dependencies:\\n\" + strings.Join(s, \"\\n\"))\n\t\t}\n\t\tstages = append(stages, s)\n\n\t\t// Trim the dependencies for the items remaining in the dag.\n\t\tfor passed := range s.drvs {\n\t\t\tfor name := range dag {\n\t\t\t\tdelete(dag[name], passed)\n\t\t\t}\n\t\t}\n\t}\n\treturn stages, nil\n}", "id": 25041, "concepts": ["map iteration (range loop)", "map deletion", "map insertion", "map key iteration", "map value iteration", "map value deletion", "map value insertion", "map value iteration", "map value deletion", "map value insertion", "map value iteration", "map value deletion", "map value insertion", "map value iteration", "map value deletion", "map value insertion", "map value iteration", "map value deletion", "map value insertion", "map value iteration", "map value deletion", "map value insertion", "map value iteration", "map value deletion", "map value insertion", "map value iteration", "map value deletion", "map value insertion", "map value iteration", "map value deletion", "map value insertion", "map value iteration", "map value deletion", "map value insertion", "map value iteration", "map value deletion", "map value insertion", "map value iteration", "map value deletion", "map value insertion", "map value iteration", "map value deletion", "map value insertion", "map value iteration", "map value deletion", "map value insertion", "map value iteration", "map value deletion", "map value insertion", "map value iteration", "map value deletion", "map value insertion", "map value iteration", "map value deletion", "map value insertion", "map value iteration", "map value deletion", "map value insertion", "map value iteration", "map value deletion", "map value insertion", "map value iteration", "map value deletion", "map value insertion"], "_raw_llm_output": "map iteration (range loop), map deletion, map insertion, map key iteration, map value iteration, map value deletion, map value insertion, map value iteration, map value deletion, map value insertion, map value iteration, map value deletion, map value insertion, map value iteration, map value deletion, map value insertion, map value iteration, map value deletion, map value insertion, map value iteration, map value deletion, map value insertion, map value iteration, map value deletion, map value insertion, map value iteration, map value deletion, map value insertion, map value iteration, map value deletion, map value insertion, map value iteration, map value deletion, map value insertion, map value iteration, map value deletion, map value insertion, map value iteration, map value deletion, map value insertion, map value iteration, map value deletion, map value insertion, map value iteration, map value deletion, map value insertion, map value iteration, map value deletion, map value insertion, map value iteration, map value deletion, map value insertion, map value iteration, map value deletion, map value insertion, map value iteration, map value deletion, map value insertion, map value iteration, map value deletion, map value insertion, map value iteration, map value deletion, map value insertion"}
{"seed": "// EnsembleTwoOne creates and starts an Ensemble with two full nodes and one miner.\n// It does not interconnect nodes nor does it begin mining.\n//\n// This function supports passing both ensemble and node functional options.\n// Functional options are applied to all nodes.\nfunc EnsembleTwoOne(t *testing.T, opts ...interface{}) (*TestFullNode, *TestFullNode, *TestMiner, *Ensemble) {\n\topts = append(opts, WithAllSubsystems())\n\n\teopts, nopts := siftOptions(t, opts)\n\n\tvar (\n\t\tone, two TestFullNode\n\t\tminer    TestMiner\n\t)\n\tens := NewEnsemble(t, eopts...).FullNode(&one, nopts...).FullNode(&two, nopts...).Miner(&miner, &one, nopts...).Start()\n\treturn &one, &two, &miner, ens\n}", "id": 25061, "concepts": ["testing", "testing.T", "testing.B", "testing.Skip", "testing.Fail", "testing.FailNow", "testing.Parallel", "testing.Run", "testing.SkipNow", "testing.Skipf", "testing.Errorf", "testing.Fatalf", "testing.Helper", "testing.TB", "testing.T.Parallel", "testing.T.Run", "testing.T.Skip", "testing.T.SkipNow", "testing.T.Skipf", "testing.T.Errorf", "testing.T.Fatalf", "testing.T.Helper", "testing.T.Log", "testing.T.Logf", "testing.T.Fail", "testing.T.FailNow", "testing.T.Failf", "testing.T.Fatal", "testing.T.FatalIf", "testing.T.FatalIfError", "testing.T.FatalIfEmpty", "testing.T.FatalIfEqual", "testing.T.FatalIfGreater", "testing.T.FatalIfGreaterOrEqual", "testing.T.FatalIfLess", "testing.T.FatalIfLessOrEqual", "testing.T.FatalIfNil", "testing.T.FatalIfNotNil", "testing.T.FatalIfZero", "testing.T.FatalIfError", "testing.T.FatalIfEmpty", "testing.T.Fatal"], "_raw_llm_output": "testing, testing.T, testing.B, testing.Skip, testing.Fail, testing.FailNow, testing.Parallel, testing.Run, testing.SkipNow, testing.Skipf, testing.Errorf, testing.Fatalf, testing.Helper, testing.TB, testing.T.Parallel, testing.T.Run, testing.T.Skip, testing.T.SkipNow, testing.T.Skipf, testing.T.Errorf, testing.T.Fatalf, testing.T.Helper, testing.T.Log, testing.T.Logf, testing.T.Fail, testing.T.FailNow, testing.T.Failf, testing.T.Fatal, testing.T.FatalIf, testing.T.FatalIfError, testing.T.FatalIfEmpty, testing.T.FatalIfEqual, testing.T.FatalIfGreater, testing.T.FatalIfGreaterOrEqual, testing.T.FatalIfLess, testing.T.FatalIfLessOrEqual, testing.T.FatalIfNil, testing.T.FatalIfNotNil, testing.T.FatalIfZero, testing.T.FatalIfError, testing.T.FatalIfEmpty, testing.T.Fatal"}
{"seed": "// imageNamesMapping provides mapping between image name in the examples yaml files and desired image name for specific arch.\n// by default empty map is returned.\nfunc imageNamesMapping() map[string]string {\n\n\tswitch getTestArch() {\n\tcase \"s390x\":\n\t\treturn map[string]string{\n\t\t\t\"registry\":                              getTestImage(registryImage),\n\t\t\t\"node\":                                  \"node:alpine3.11\",\n\t\t\t\"gcr.io/cloud-builders/git\":             \"alpine/git:latest\",\n\t\t\t\"docker:dind\":                           \"ibmcom/docker-s390x:dind\",\n\t\t\t\"docker\":                                \"docker:18.06.3\",\n\t\t\t\"mikefarah/yq:3\":                        \"danielxlee/yq:2.4.0\",\n\t\t\t\"stedolan/jq\":                           \"ibmcom/jq-s390x:latest\",\n\t\t\t\"gcr.io/kaniko-project/executor:v1.3.0\": getTestImage(kanikoImage),\n\t\t}\n\tcase \"ppc64le\":\n\t\treturn map[string]string{\n\t\t\t\"registry\":                              getTestImage(registryImage),\n\t\t\t\"node\":                                  \"node:alpine3.11\",\n\t\t\t\"gcr.io/cloud-builders/git\":             \"alpine/git:latest\",\n\t\t\t\"docker:dind\":                           \"ibmcom/docker-ppc64le:19.03-dind\",\n\t\t\t\"docker\":                                \"docker:18.06.3\",\n\t\t\t\"mikefarah/yq:3\":                        \"danielxlee/yq:2.4.0\",\n\t\t\t\"stedolan/jq\":                           \"ibmcom/jq-ppc64le:latest\",\n\t\t\t\"gcr.io/kaniko-project/executor:v1.3.0\": getTestImage(kanikoImage),\n\t\t}\n\n\t}\n\n\treturn make(map[string]string)\n}", "id": 25087, "concepts": ["switch statement", "map", "string manipulation", "string comparison"], "_raw_llm_output": "switch statement, map, string manipulation, string comparison"}
{"seed": "// BlockRegex will block responses that contain match any of the given regexes.\n//\n// This function is a streaming function, and will not introduce significant\n// TTFB latency. It will use about 4MB of RAM, give or take, for the scanning\n// window. The scanning process ends up scanning all bytes twice, in order to\n// detect matches that might span a stream chunk.\n//\n// For example:\n// window = [A B]\n// window scans OK\n// send A\n// window = [B C]\n// window scans OK\n// send B\n// and so on.\n//\n// Partial responses may be sent, but any chunk with a regex match will not be\n// sent, and the first one detected cancels the rest of the copy.\n//\n// Patterns which may match more than 4MB of data are not supported; they will\n// not error, but they simply will not be detected.\nfunc BlockRegex(ctx context.Context, handle MediaFilterHandle, regexes []*regexp.Regexp) error {\n\tdefer handle.input.Close()\n\tdefer handle.output.Close()\n\t// make the buffer\n\tconst chunkSize = int64(1024 * 1024 * 2)\n\tbuffer := bytes.NewBuffer(make([]byte, 0, chunkSize*2))\n\t// seed the buffer with two chunks\n\tio.CopyN(buffer, handle.input, chunkSize*2)\n\tfor {\n\t\t// scan the buffer\n\t\tfor _, re := range regexes {\n\t\t\tmatch := re.Match(buffer.Bytes())\n\t\t\tif match {\n\t\t\t\t// BLOCK -- not an error, but we stop the response right now\n\t\t\t\thttp.Error(handle.response, \"PROHIBITED REGEX PATTERN MATCHED\", http.StatusGone)\n\t\t\t\tlog.Warn().Msgf(\"blockregex: matched %v\", re.String())\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\t// send one chunk\n\t\tif _, err := io.CopyN(handle.output, buffer, chunkSize); err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\t// done\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn FilterError(handle, http.StatusInternalServerError, \"block regex: %v\", err)\n\t\t}\n\t\t// refill the buffer\n\t\tif _, err := io.CopyN(buffer, handle.input, chunkSize); err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\t// continue, to flush buffer\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn FilterError(handle, http.StatusInternalServerError, \"block regex: %v\", err)\n\t\t}\n\t}\n\treturn nil\n}", "id": 25101, "concepts": ["io.CopyN", "io.EOF", "io.Copy", "context.Context", "http.Error", "http.StatusGone", "io.Writer", "io.Reader", "bytes.NewBuffer", "io.Copy", "io.EOF", "io.ReaderFrom", "io.WriterTo", "io.Writer", "io.Reader", "bytes.Buffer", "io.ReaderFrom", "io.WriterTo", "io.Writer", "io.Reader", "bytes.Buffer", "io.ReaderFrom", "io.WriterTo", "io.Writer", "io.Reader", "bytes.Buffer", "io.ReaderFrom", "io.WriterTo", "io.Writer", "io.Reader", "bytes.Buffer", "io.ReaderFrom", "io.WriterTo", "io.Writer", "io.Reader", "bytes.Buffer", "io.ReaderFrom", "io.WriterTo", "io.Writer", "io.Reader", "bytes.Buffer", "io.ReaderFrom", "io.WriterTo", "io.Writer", "io.Reader", "bytes.Buffer", "io.ReaderFrom", "io.WriterTo", "io.Writer", "io.Reader", "bytes.Buffer", "io.ReaderFrom", "io.WriterTo", "io.Writer", "io.Reader", "bytes.Buffer", "io.ReaderFrom", "io.WriterTo"], "_raw_llm_output": "io.CopyN, io.EOF, io.Copy, context.Context, http.Error, http.StatusGone, io.Writer, io.Reader, bytes.NewBuffer, io.Copy, io.EOF, io.ReaderFrom, io.WriterTo, io.Writer, io.Reader, bytes.Buffer, io.ReaderFrom, io.WriterTo, io.Writer, io.Reader, bytes.Buffer, io.ReaderFrom, io.WriterTo, io.Writer, io.Reader, bytes.Buffer, io.ReaderFrom, io.WriterTo, io.Writer, io.Reader, bytes.Buffer, io.ReaderFrom, io.WriterTo, io.Writer, io.Reader, bytes.Buffer, io.ReaderFrom, io.WriterTo, io.Writer, io.Reader, bytes.Buffer, io.ReaderFrom, io.WriterTo, io.Writer, io.Reader, bytes.Buffer, io.ReaderFrom, io.WriterTo, io.Writer, io.Reader, bytes.Buffer, io.ReaderFrom, io.WriterTo, io.Writer, io.Reader, bytes.Buffer, io.ReaderFrom, io.WriterTo"}
{"seed": "// QuarksToKin converts an int64 amount of quarks to the\n// string representation of kin.\nfunc QuarksToKin(amount int64) string {\n\tquarks := big.NewFloat(0)\n\tquarks.SetInt64(amount)\n\n\treturn new(big.Float).Quo(quarks, quarkCoeff).Text('f', 5)\n}", "id": 25105, "concepts": ["big.Float package usage", "big.Int package usage", "floating point arithmetic"], "_raw_llm_output": "big.Float package usage, big.Int package usage, floating point arithmetic"}
{"seed": "// ParseGetPrivateNetworkResponse parses an HTTP response from a GetPrivateNetworkWithResponse call\nfunc ParseGetPrivateNetworkResponse(rsp *http.Response) (*GetPrivateNetworkResponse, error) {\n\tbodyBytes, err := ioutil.ReadAll(rsp.Body)\n\tdefer rsp.Body.Close()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse := &GetPrivateNetworkResponse{\n\t\tBody:         bodyBytes,\n\t\tHTTPResponse: rsp,\n\t}\n\n\tswitch {\n\tcase strings.Contains(rsp.Header.Get(\"Content-Type\"), \"json\") && rsp.StatusCode == 200:\n\t\tvar dest PrivateNetwork\n\t\tif err := json.Unmarshal(bodyBytes, &dest); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresponse.JSON200 = &dest\n\n\t}\n\n\treturn response, nil\n}", "id": 25106, "concepts": ["http.Response", "json.Unmarshal", "error handling (errors.Is)", "switch statement"], "_raw_llm_output": "http.Response, json.Unmarshal, error handling (errors.Is), switch statement"}
{"seed": "// NewInterpreter returns an initialized Interpreter instance.\nfunc NewInterpreter() Interpreter {\n\treturn _interpreter{\n\t\tdirInterpreter:    dir.NewInterpreter(),\n\t\tstringInterpreter: stringPkg.NewInterpreter(),\n\t}\n}", "id": 25116, "concepts": ["struct definition", "struct composition", "anonymous struct"], "_raw_llm_output": "struct definition, struct composition, anonymous struct"}
{"seed": "// newFollowersPage converts projected type FollowersPage to service type\n// FollowersPage.\nfunc newFollowersPage(vres *followingviews.FollowersPageView) *FollowersPage {\n\tres := &FollowersPage{}\n\tif vres.Total != nil {\n\t\tres.Total = *vres.Total\n\t}\n\tif vres.Page != nil {\n\t\tres.Page = *vres.Page\n\t}\n\tif vres.Followers != nil {\n\t\tres.Followers = newFollowerCollection(vres.Followers)\n\t}\n\treturn res\n}", "id": 25117, "concepts": ["type conversion", "type aliasing", "pointer dereferencing", "nil handling"], "_raw_llm_output": "type conversion, type aliasing, pointer dereferencing, nil handling"}
{"seed": "// RTWithServiceName sets the given service name for the RoundTripper.\nfunc RTWithServiceName(name string) RoundTripperOption {\n\treturn func(cfg *roundTripperConfig) {\n\t\tcfg.serviceName = name\n\t}\n}", "id": 25135, "concepts": ["function composition", "function options", "function composition", "function options", "function composition"], "_raw_llm_output": "function composition, function options, function composition, function options, function composition"}
{"seed": "// IsNoneSpanExporter returns true for the exporter returned by [NewSpanExporter]\n// when OTEL_TRACES_EXPORTER environment variable is set to \"none\".\nfunc IsNoneSpanExporter(e trace.SpanExporter) bool {\n\t_, ok := e.(noop)\n\treturn ok\n}", "id": 25139, "concepts": ["interface", "type assertion", "environment variable", "nil interface"], "_raw_llm_output": "interface, type assertion, environment variable, nil interface"}
{"seed": "// PossibleRoutingTypeValues returns the possible values for the RoutingType const type.\nfunc PossibleRoutingTypeValues() []RoutingType {\n\treturn []RoutingType{\n\t\tRoutingTypeCascadeExtension,\n\t\tRoutingTypeDefault,\n\t\tRoutingTypeExtension,\n\t\tRoutingTypeFailover,\n\t\tRoutingTypeFanout,\n\t\tRoutingTypeHostBased,\n\t\tRoutingTypeLocationBased,\n\t\tRoutingTypeProxyOnly,\n\t\tRoutingTypeTenant,\n\t}\n}", "id": 25142, "concepts": ["constant definition", "type definition", "array definition", "array iteration", "array value assignment"], "_raw_llm_output": "constant definition, type definition, array definition, array iteration, array value assignment"}
{"seed": "// New creates a new TagsBuilder with the specified build parameters\n// and with optional configuration.\nfunc New(params *infrav1.BuildParams, opts ...BuilderOption) *Builder {\n\tbuilder := &Builder{\n\t\tparams: params,\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(builder)\n\t}\n\n\treturn builder\n}", "id": 25147, "concepts": ["struct definition", "function definition", "function parameters", "function return values", "function options", "struct composition", "function composition"], "_raw_llm_output": "struct definition, function definition, function parameters, function return values, function options, struct composition, function composition"}
{"seed": "// DateTimeLTE applies the LTE predicate on the \"dateTime\" field.\nfunc DateTimeLTE(v time.Time) predicate.Bulk {\n\treturn predicate.Bulk(func(s *sql.Selector) {\n\t\ts.Where(sql.LTE(s.C(FieldDateTime), v))\n\t})\n}", "id": 25150, "concepts": ["sql.Selector", "sql.C", "sql.LTE", "sql.Bulk", "predicate.Bulk"], "_raw_llm_output": "sql.Selector, sql.C, sql.LTE, sql.Bulk, predicate.Bulk"}
{"seed": "// NewListAlertableEventTypeParamsWithContext creates a new ListAlertableEventTypeParams object\n// with the default values initialized, and the ability to set a context for a request\nfunc NewListAlertableEventTypeParamsWithContext(ctx context.Context) *ListAlertableEventTypeParams {\n\tvar ()\n\treturn &ListAlertableEventTypeParams{\n\n\t\tContext: ctx,\n\t}\n}", "id": 25160, "concepts": ["context package usage", "function definition", "function parameters"], "_raw_llm_output": "context package usage, function definition, function parameters"}
{"seed": "/*\n  This utility takes an already-trained HMM, specified as the \"Model\" parameter,\n  and generates a random observation sequence and hidden state sequence based on\n  its parameters. The observation sequence may be saved with the \"Output\" output\n  parameter, and the internal state  sequence may be saved with the \"State\"\n  output parameter.\n  \n  The state to start the sequence in may be specified with the \"StartState\"\n  parameter.\n\n  For example, to generate a sequence of length 150 from the HMM hmm and save\n  the observation sequence to observations and the hidden state sequence to\n  states, the following command may be used: \n  \n  // Initialize optional parameters for HmmGenerate().\n  param := mlpack.HmmGenerateOptions()\n  \n  observations, states := mlpack.HmmGenerate(&hmm, 150, param)\n\n  Input parameters:\n\n   - length (int): Length of sequence to generate.\n   - model (hmmModel): Trained HMM to generate sequences with.\n   - Seed (int): Random seed.  If 0, 'std::time(NULL)' is used.  Default\n        value 0.\n   - StartState (int): Starting state of sequence.  Default value 0.\n   - Verbose (bool): Display informational messages and the full list of\n        parameters and timers at the end of execution.\n\n  Output parameters:\n\n   - output (mat.Dense): Matrix to save observation sequence to.\n   - state (mat.Dense): Matrix to save hidden state sequence to.\n\n */\nfunc HmmGenerate(length int, model *hmmModel, param *HmmGenerateOptionalParam) (*mat.Dense, *mat.Dense) {\n  params := getParams(\"hmm_generate\")\n  timers := getTimers()\n\n  disableBacktrace()\n  disableVerbose()\n  // Detect if the parameter was passed; set if so.\n  setParamInt(params, \"length\", length)\n  setPassed(params, \"length\")\n\n  // Detect if the parameter was passed; set if so.\n  setHMMModel(params, \"model\", model)\n  setPassed(params, \"model\")\n\n  // Detect if the parameter was passed; set if so.\n  if param.Seed != 0 {\n    setParamInt(params, \"seed\", param.Seed)\n    setPassed(params, \"seed\")\n  }\n\n  // Detect if the parameter was passed; set if so.\n  if param.StartState != 0 {\n    setParamInt(params, \"start_state\", param.StartState)\n    setPassed(params, \"start_state\")\n  }\n\n  // Detect if the parameter was passed; set if so.\n  if param.Verbose != false {\n    setParamBool(params, \"verbose\", param.Verbose)\n    setPassed(params, \"verbose\")\n    enableVerbose()\n  }\n\n  // Mark all output options as passed.\n  setPassed(params, \"output\")\n  setPassed(params, \"state\")\n\n  // Call the mlpack program.\n  C.mlpackHmmGenerate(params.mem, timers.mem)\n\n  // Initialize result variable and get output.\n  var outputPtr mlpackArma\n  output := outputPtr.armaToGonumMat(params, \"output\")\n  var statePtr mlpackArma\n  state := statePtr.armaToGonumUmat(params, \"state\")\n  // Clean memory.\n  cleanParams(params)\n  cleanTimers(timers)\n  // Return output(s).\n  return output, state\n}", "id": 25162, "concepts": ["mat.Dense", "mat.Dense.New", "mat.Dense.Set", "mat.Dense.Row", "mat.Dense.Col", "mat.Dense.At", "mat.Dense.T", "mat.Dense.String", "mat.Dense.Size", "mat.Dense.Dims", "mat.Dense.Slice", "mat.Dense.SliceRow", "mat.Dense.SliceCol", "mat.Dense.SliceRowVec", "mat.Dense.SliceColVec", "mat.Dense.SliceRowVec", "mat.Dense.SliceColVec", "mat.Dense.SliceRowVec", "mat.Dense.SliceColVec", "mat.Dense.SliceRowVec", "mat.Dense.SliceColVec", "mat.Dense.SliceRowVec", "mat.Dense.SliceColVec", "mat.Dense.SliceRowVec", "mat.Dense.SliceColVec", "mat.Dense.SliceRowVec", "mat.Dense.SliceColVec", "mat.Dense.SliceRowVec", "mat.Dense.SliceColVec", "mat.Dense.SliceRowVec", "mat.Dense.SliceColVec", "mat.Dense.SliceRowVec", "mat.Dense.SliceColVec", "mat.Dense.SliceRowVec", "mat.Dense.SliceColVec", "mat"], "_raw_llm_output": "mat.Dense, mat.Dense.New, mat.Dense.Set, mat.Dense.Row, mat.Dense.Col, mat.Dense.At, mat.Dense.T, mat.Dense.String, mat.Dense.Size, mat.Dense.Dims, mat.Dense.Slice, mat.Dense.SliceRow, mat.Dense.SliceCol, mat.Dense.SliceRowVec, mat.Dense.SliceColVec, mat.Dense.SliceRowVec, mat.Dense.SliceColVec, mat.Dense.SliceRowVec, mat.Dense.SliceColVec, mat.Dense.SliceRowVec, mat.Dense.SliceColVec, mat.Dense.SliceRowVec, mat.Dense.SliceColVec, mat.Dense.SliceRowVec, mat.Dense.SliceColVec, mat.Dense.SliceRowVec, mat.Dense.SliceColVec, mat.Dense.SliceRowVec, mat.Dense.SliceColVec, mat.Dense.SliceRowVec, mat.Dense.SliceColVec, mat.Dense.SliceRowVec, mat.Dense.SliceColVec, mat.Dense.SliceRowVec, mat.Dense.SliceColVec, mat"}
{"seed": "// IsNonBlockingTxn returns true if transaction context is configured for\n// non-blocking Commit.\nfunc IsNonBlockingTxn(ctx context.Context) bool {\n\t_, nonBlocking := ctx.Value(nonBlockingTxnCtxKey).(*nonBlockingTxnOpt)\n\treturn nonBlocking\n}", "id": 25183, "concepts": ["context", "context.Context", "context.WithValue", "context.Value", "context.Background", "context.TODO", "context.Deadline", "context.WithDeadline", "context.WithTimeout", "context.WithCancel", "context.WithDeadline", "context.WithCancel", "context.WithDeadline", "context.WithCancel", "context.WithDeadline", "context.WithCancel", "context.WithDeadline", "context.WithCancel", "context.WithDeadline", "context.WithCancel", "context.WithDeadline", "context.WithCancel", "context.WithDeadline", "context.WithCancel", "context.WithDeadline", "context.WithCancel", "context.WithDeadline", "context.WithCancel", "context.WithDeadline", "context.WithCancel", "context.WithDeadline", "context.WithCancel", "context.WithDeadline", "context.WithCancel", "context.WithDeadline", "context.WithCancel", "context.WithDeadline", "context.WithCancel", "context.WithDeadline", "context.WithCancel", "context.WithDeadline", "context.WithCancel", "context.WithDeadline", "context.WithCancel", "context.WithDeadline", "context.WithCancel", "context.WithDeadline", "context.WithCancel", "context.WithDeadline", "context.WithCancel", "context.WithDeadline", "context.WithCancel", "context.WithDeadline", ""], "_raw_llm_output": "context, context.Context, context.WithValue, context.Value, context.Background, context.TODO, context.Deadline, context.WithDeadline, context.WithTimeout, context.WithCancel, context.WithDeadline, context.WithCancel, context.WithDeadline, context.WithCancel, context.WithDeadline, context.WithCancel, context.WithDeadline, context.WithCancel, context.WithDeadline, context.WithCancel, context.WithDeadline, context.WithCancel, context.WithDeadline, context.WithCancel, context.WithDeadline, context.WithCancel, context.WithDeadline, context.WithCancel, context.WithDeadline, context.WithCancel, context.WithDeadline, context.WithCancel, context.WithDeadline, context.WithCancel, context.WithDeadline, context.WithCancel, context.WithDeadline, context.WithCancel, context.WithDeadline, context.WithCancel, context.WithDeadline, context.WithCancel, context.WithDeadline, context.WithCancel, context.WithDeadline, context.WithCancel, context.WithDeadline, context.WithCancel, context.WithDeadline, context.WithCancel, context.WithDeadline, context.WithCancel, context.WithDeadline,"}
{"seed": "// InAscOrder returns true if numbers are in ascending order and false\n// otherwise.\nfunc InAscOrder(numbers []int) bool {\n\n\tif len(numbers) < 1 {\n\t\treturn false\n\t}\n\n\tcurr := numbers[0]\n\n\tfor _, elem := range numbers {\n\t\tif elem < curr {\n\t\t\treturn false\n\t\t}\n\t\tcurr = elem\n\t}\n\n\treturn true\n}", "id": 25185, "concepts": ["slice iteration (range loop)", "integer comparison", "basic function definition"], "_raw_llm_output": "slice iteration (range loop), integer comparison, basic function definition"}
{"seed": "// WithTTL defines the duration to keep the task in the broker.\nfunc WithTTL(ttl time.Duration) Option {\n\treturn func(opts *Options) {\n\t\topts.TTL = ttl\n\t}\n}", "id": 25192, "concepts": ["struct definition", "function definition", "function options"], "_raw_llm_output": "struct definition, function definition, function options"}
{"seed": "// NewReplaceSpoeMessageOK creates ReplaceSpoeMessageOK with default headers values\nfunc NewReplaceSpoeMessageOK() *ReplaceSpoeMessageOK {\n\n\treturn &ReplaceSpoeMessageOK{}\n}", "id": 25212, "concepts": ["struct definition", "struct initialization", "struct field access", "struct field initialization", "basic function definition"], "_raw_llm_output": "struct definition, struct initialization, struct field access, struct field initialization, basic function definition"}
{"seed": "// NewAPIServiceMissedBlocksParamsWithTimeout creates a new APIServiceMissedBlocksParams object\n// with the default values initialized, and the ability to set a timeout on a request\nfunc NewAPIServiceMissedBlocksParamsWithTimeout(timeout time.Duration) *APIServiceMissedBlocksParams {\n\tvar ()\n\treturn &APIServiceMissedBlocksParams{\n\n\t\ttimeout: timeout,\n\t}\n}", "id": 25225, "concepts": ["function definition", "timeout handling", "standard library usage"], "_raw_llm_output": "function definition, timeout handling, standard library usage"}
{"seed": "// CreatedAtEQ applies the EQ predicate on the \"created_at\" field.\nfunc CreatedAtEQ(v time.Time) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldCreatedAt), v))\n\t})\n}", "id": 25241, "concepts": ["sql.Selector", "sql.EQ", "sql.Where", "sql.C", "sql.Predicate"], "_raw_llm_output": "sql.Selector, sql.EQ, sql.Where, sql.C, sql.Predicate"}
{"seed": "// DnsZones_CAA_SpecGenerator returns a generator of DnsZones_CAA_Spec instances for property testing.\n// We first initialize dnsZones_CAA_SpecGenerator with a simplified generator based on the\n// fields with primitive types then replacing it with a more complex one that also handles complex fields\n// to ensure any cycles in the object graph properly terminate.\nfunc DnsZones_CAA_SpecGenerator() gopter.Gen {\n\tif dnsZones_CAA_SpecGenerator != nil {\n\t\treturn dnsZones_CAA_SpecGenerator\n\t}\n\n\tgenerators := make(map[string]gopter.Gen)\n\tAddIndependentPropertyGeneratorsForDnsZones_CAA_Spec(generators)\n\tdnsZones_CAA_SpecGenerator = gen.Struct(reflect.TypeOf(DnsZones_CAA_Spec{}), generators)\n\n\t// The above call to gen.Struct() captures the map, so create a new one\n\tgenerators = make(map[string]gopter.Gen)\n\tAddIndependentPropertyGeneratorsForDnsZones_CAA_Spec(generators)\n\tAddRelatedPropertyGeneratorsForDnsZones_CAA_Spec(generators)\n\tdnsZones_CAA_SpecGenerator = gen.Struct(reflect.TypeOf(DnsZones_CAA_Spec{}), generators)\n\n\treturn dnsZones_CAA_SpecGenerator\n}", "id": 25251, "concepts": ["property-based testing", "generator", "property-based testing", "generator", "property-based testing", "generator", "property-based testing", "generator", "property-based testing", "generator", "property-based testing", "generator", "property-based testing", "generator", "property-based testing", "generator", "property-based testing", "generator", "property-based testing", "generator", "property-based testing", "generator", "property-based testing", "generator", "property-based testing", "generator", "property-based testing", "generator", "property-based testing", "generator", "property-based testing", "generator", "property-based testing", "generator", "property-based testing", "generator", "property-based testing", "generator", "property-based testing", "generator", "property-based testing", "generator", "property-based testing", "generator", "property-based testing", "generator", "property-based testing", "generator", "property-based testing", "generator", "property-based testing", "generator", "property-based testing", "generator", "property-based testing", "generator", "property-based testing", "generator", "property-based testing", "generator", "property-based testing", "generator", "property-based testing", "generator", "property-based testing", "generator", "property-based testing", "generator", "property-based testing", "generator", "property-based testing", "generator", "property-based"], "_raw_llm_output": "property-based testing, generator, property-based testing, generator, property-based testing, generator, property-based testing, generator, property-based testing, generator, property-based testing, generator, property-based testing, generator, property-based testing, generator, property-based testing, generator, property-based testing, generator, property-based testing, generator, property-based testing, generator, property-based testing, generator, property-based testing, generator, property-based testing, generator, property-based testing, generator, property-based testing, generator, property-based testing, generator, property-based testing, generator, property-based testing, generator, property-based testing, generator, property-based testing, generator, property-based testing, generator, property-based testing, generator, property-based testing, generator, property-based testing, generator, property-based testing, generator, property-based testing, generator, property-based testing, generator, property-based testing, generator, property-based testing, generator, property-based testing, generator, property-based testing, generator, property-based testing, generator, property-based testing, generator, property-based testing, generator, property-based"}
{"seed": "// RequireTrustDomainFromURI is similar to TrustDomainFromURI except that\n// instead of returning an error on malformed input, it panics. It should only\n// be used when the input is statically verifiable.\nfunc RequireTrustDomainFromURI(uri *url.URL) TrustDomain {\n\ttd, err := TrustDomainFromURI(uri)\n\tpanicOnErr(err)\n\treturn td\n}", "id": 25273, "concepts": ["panicOnErr", "panic", "error handling", "panicOnErr function definition"], "_raw_llm_output": "panicOnErr, panic, error handling, panicOnErr function definition"}
{"seed": "// castGoRSIDVARColsToC convert GO RSIDVARCols to C.rsidvar_cols_t.\nfunc castGoRSIDVARColsToC(rc RSIDVARCols) C.rsidvar_cols_t {\n\tvar rvc C.rsidvar_cols_t\n\trvc.vk = (*C.uint64_t)(rc.Vk)\n\trvc.rs = (*C.uint32_t)(rc.Rs)\n\trvc.nrows = C.uint64_t(rc.NRows)\n\treturn rvc\n}", "id": 25281, "concepts": ["casting", "pointer handling", "integer conversion"], "_raw_llm_output": "casting, pointer handling, integer conversion"}
{"seed": "// marshalPostsPostOutputToPostOutputResponseBody builds a value of type\n// *PostOutputResponseBody from a value of type *posts.PostOutput.\nfunc marshalPostsPostOutputToPostOutputResponseBody(v *posts.PostOutput) *PostOutputResponseBody {\n\tres := &PostOutputResponseBody{\n\t\tID:             v.ID,\n\t\tTitle:          v.Title,\n\t\tDescription:    v.Description,\n\t\tScreenImageURL: v.ScreenImageURL,\n\t}\n\n\treturn res\n}", "id": 25285, "concepts": ["type conversion", "pointer handling", "struct field access"], "_raw_llm_output": "type conversion, pointer handling, struct field access"}
{"seed": "// PossibleManagedRuleSetActionTypeValues returns an array of possible values for the ManagedRuleSetActionType const type.\nfunc PossibleManagedRuleSetActionTypeValues() []ManagedRuleSetActionType {\n\treturn []ManagedRuleSetActionType{ManagedRuleSetActionTypeBlock, ManagedRuleSetActionTypeLog, ManagedRuleSetActionTypeRedirect}\n}", "id": 25287, "concepts": ["const type", "array type", "array iteration"], "_raw_llm_output": "const type, array type, array iteration"}
{"seed": "// ServersFailoverGroupGenerator returns a generator of ServersFailoverGroup instances for property testing.\nfunc ServersFailoverGroupGenerator() gopter.Gen {\n\tif serversFailoverGroupGenerator != nil {\n\t\treturn serversFailoverGroupGenerator\n\t}\n\n\tgenerators := make(map[string]gopter.Gen)\n\tAddRelatedPropertyGeneratorsForServersFailoverGroup(generators)\n\tserversFailoverGroupGenerator = gen.Struct(reflect.TypeOf(ServersFailoverGroup{}), generators)\n\n\treturn serversFailoverGroupGenerator\n}", "id": 25293, "concepts": ["struct", "map", "reflection", "property testing"], "_raw_llm_output": "struct, map, reflection, property testing"}
{"seed": "// New returns a new OS specific resource collector.\nfunc New() Collector {\n\treturn &collector{\n\t\tinner: sigar.ConcreteSigar{},\n\t}\n}", "id": 25295, "concepts": ["struct definition", "interface definition", "method definition", "pointer usage", "type conversion"], "_raw_llm_output": "struct definition, interface definition, method definition, pointer usage, type conversion"}
{"seed": "// BufferIsNil applies the IsNil predicate on the \"buffer\" field.\nfunc BufferIsNil() predicate.User {\n\treturn predicate.User(sql.FieldIsNull(FieldBuffer))\n}", "id": 25307, "concepts": ["predicate.User", "sql.FieldIsNull", "sql.Field"], "_raw_llm_output": "predicate.User, sql.FieldIsNull, sql.Field"}
{"seed": "// isValidTagName returns true if the ident is a valid tag name.\n// Uses rules according to Biber which means a tag key is a Bibtex name with the\n// extra condition that it must begin with a letter:\n// https://metacpan.org/pod/release/AMBS/Text-BibTeX-0.66/btparse/doc/bt_language.pod\nfunc isValidTagName(key *ast.Ident) bool {\n\tch := key.Name[0]\n\treturn ('a' <= ch && ch <= 'z') || ('A' <= ch && ch <= 'Z')\n}", "id": 25310, "concepts": ["ast package usage", "string manipulation", "character comparison", "regular expressions"], "_raw_llm_output": "ast package usage, string manipulation, character comparison, regular expressions"}
{"seed": "// Agglo performs agglomerative clustering on the indexes 0 to n-1. d should\n// return the distance between the i'th and j'th element, such that\n// d(i,j)=d(j,i) and d(i,i)=0.\n//\n// clusterDist should be one of AggloMin or AggloMax.\n//\n// Works in O(n^2) time and makes O(n^2) calls to d.\nfunc Agglo(n int, clusterDist int, d func(int, int) float64) *AggloResult {\n\tif n <= 0 {\n\t\tpanic(fmt.Sprintf(\"Bad n: %d, must be positive\", n))\n\t}\n\n\tswitch clusterDist {\n\tcase AggloMin:\n\t\treturn slink(n, d)\n\tcase AggloMax:\n\t\treturn clink(n, d)\n\tcase AggloAverage:\n\t\treturn upgma(n, d)\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"Unsupported cluster distance: %v, \"+\n\t\t\t\"want AggloMin or AggloMax\", clusterDist))\n\t}\n}", "id": 25327, "concepts": ["function definition", "function calls", "function parameters", "function return values", "function closures", "function composition", "function recursion", "function pointers", "function interfaces", "function signatures", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading", "function overloading"], "_raw_llm_output": "function definition, function calls, function parameters, function return values, function closures, function composition, function recursion, function pointers, function interfaces, function signatures, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading, function overloading"}
{"seed": "// NewGetServerStatusParamsWithHTTPClient creates a new GetServerStatusParams object\n// with the default values initialized, and the ability to set a custom HTTPClient for a request\nfunc NewGetServerStatusParamsWithHTTPClient(client *http.Client) *GetServerStatusParams {\n\n\treturn &GetServerStatusParams{\n\t\tHTTPClient: client,\n\t}\n}", "id": 25346, "concepts": ["http.Client", "*http.Client", "function definition", "parameter passing"], "_raw_llm_output": "http.Client, *http.Client, function definition, parameter passing"}
{"seed": "// NewModelsBackupSchedule instantiates a new ModelsBackupSchedule object\n// This constructor will assign default values to properties that have it defined,\n// and makes sure properties required by API are set, but the set of arguments\n// will change when the set of required properties is changed\nfunc NewModelsBackupSchedule() *ModelsBackupSchedule {\n\tthis := ModelsBackupSchedule{}\n\treturn &this\n}", "id": 25348, "concepts": ["struct definition", "struct instantiation", "struct property definition"], "_raw_llm_output": "struct definition, struct instantiation, struct property definition"}
{"seed": "// WithClient is an Option that configures a Reconciler's client.\n//\n// By default, manager.GetClient() is used if this option is not configured.\nfunc WithClient(cl client.Client) Option {\n\treturn func(r *Reconciler) error {\n\t\tr.client = cl\n\t\treturn nil\n\t}\n}", "id": 25349, "concepts": ["struct definition", "struct field definition", "struct field initialization", "struct field access", "function definition", "function call", "function return", "function argument", "function return value", "function return value assignment", "function return value type", "function return value type assertion", "function return value type assertion value", "function return value type assertion value type", "function return value type assertion value type assertion", "function return value type assertion value type assertion value", "function return value type assertion value type assertion value type", "function return value type assertion value type assertion value type assertion", "function return value type assertion value type assertion value type assertion value", "function return value type assertion value type assertion value type assertion value type", "function return value type assertion value type assertion value type assertion value type assertion", "function return value type assertion value type assertion value type assertion value type assertion value", "function return value type assertion value type assertion value type assertion value type assertion value type", "function return value type assertion value type assertion value type assertion value type assertion value type assertion", "function return value type assertion value type assertion value type assertion value type assertion value type assertion value", "function return value type assertion value type assertion value type assertion value type assertion value type assertion value type", "function return value type assertion value type assertion value type assertion value type assertion value type assertion value type"], "_raw_llm_output": "struct definition, struct field definition, struct field initialization, struct field access, function definition, function call, function return, function argument, function return value, function return value assignment, function return value type, function return value type assertion, function return value type assertion value, function return value type assertion value type, function return value type assertion value type assertion, function return value type assertion value type assertion value, function return value type assertion value type assertion value type, function return value type assertion value type assertion value type assertion, function return value type assertion value type assertion value type assertion value, function return value type assertion value type assertion value type assertion value type, function return value type assertion value type assertion value type assertion value type assertion, function return value type assertion value type assertion value type assertion value type assertion value, function return value type assertion value type assertion value type assertion value type assertion value type, function return value type assertion value type assertion value type assertion value type assertion value type assertion, function return value type assertion value type assertion value type assertion value type assertion value type assertion value, function return value type assertion value type assertion value type assertion value type assertion value type assertion value type, function return value type assertion value type assertion value type assertion value type assertion value type assertion value type"}
{"seed": "// StrToSlice returns the slice of strings with all tags parsed from the input\n// string.\n// It will trim leading and trailing whitespace, and reduce middle whitespaces to 1 space.\n// It will also remove 'empty' tags (ie. whitespaces enclosed with commas, ',   ,')\n// The input string contains tags separated with commas.\n// E.g. input string: \" tag1, tag2,  tag3 ,   , \"\n// E.g. output: [\"tag1\", \"tag2\", \"tag3\"]\nfunc StrToSlice(tagsStr string) ([]string) {\n  if tagsStr == \"\" {\n    return nil\n  }\n  noSpaces := strings.TrimSpace(tagsStr)\n  noSpaces = strings.TrimPrefix(noSpaces, \",\")\n  noSpaces = strings.TrimSuffix(noSpaces, \",\")\n  // regexp to remove duplicate spaces\n  reInsideWhtsp := regexp.MustCompile(`[\\s\\p{Zs}]{2,}`)\n  result := make([]string, 0)\n  for _, t := range strings.Split(noSpaces, \",\") {\n    t = strings.TrimSpace(t)\n    if len(t) > 0 {\n      result = append(result, reInsideWhtsp.ReplaceAllString(t, \" \"))\n    }\n  }\n  return result\n}", "id": 25352, "concepts": ["string manipulation", "regexp usage", "string iteration (range loop)", "string trimming", "string concatenation", "string splitting", "string length", "string comparison", "string concatenation", "string manipulation", "string trimming", "string concatenation", "string manipulation", "string trimming", "string concatenation", "string manipulation", "string trimming", "string concatenation", "string manipulation", "string trimming", "string concatenation", "string manipulation", "string trimming", "string concatenation", "string manipulation", "string trimming", "string concatenation", "string manipulation", "string trimming", "string concatenation", "string manipulation", "string trimming", "string concatenation", "string manipulation", "string trimming", "string concatenation", "string manipulation", "string trimming", "string concatenation", "string manipulation", "string trimming", "string concatenation", "string manipulation", "string trimming", "string concatenation", "string manipulation", "string trimming", "string concatenation", "string manipulation", "string trimming", "string concatenation", "string manipulation", "string trimming", "string concatenation", "string manipulation", "string trimming", "string concatenation", "string manipulation", "string trimming", "string concatenation", "string manipulation", "string trimming", "string concatenation", "string manipulation", "string tri"], "_raw_llm_output": "string manipulation, regexp usage, string iteration (range loop), string trimming, string concatenation, string splitting, string length, string comparison, string concatenation, string manipulation, string trimming, string concatenation, string manipulation, string trimming, string concatenation, string manipulation, string trimming, string concatenation, string manipulation, string trimming, string concatenation, string manipulation, string trimming, string concatenation, string manipulation, string trimming, string concatenation, string manipulation, string trimming, string concatenation, string manipulation, string trimming, string concatenation, string manipulation, string trimming, string concatenation, string manipulation, string trimming, string concatenation, string manipulation, string trimming, string concatenation, string manipulation, string trimming, string concatenation, string manipulation, string trimming, string concatenation, string manipulation, string trimming, string concatenation, string manipulation, string trimming, string concatenation, string manipulation, string trimming, string concatenation, string manipulation, string trimming, string concatenation, string manipulation, string trimming, string concatenation, string manipulation, string tri"}
{"seed": "// WithServiceID sets the service ID of the instance participating in the\n// election. If one is not set, then one is randomly generated.\nfunc WithServiceID(serviceID string) ElectorConfigFunc {\n\treturn func(e *elector) { e.serviceID = serviceID }\n}", "id": 25353, "concepts": ["function composition", "function composition", "function composition", "function composition"], "_raw_llm_output": "function composition, function composition, function composition, function composition"}
{"seed": "// NewStore creates a new Store.\nfunc NewStore() *Store {\n\treturn &Store{\n\t\topaStore: inmem.New(),\n\t}\n}", "id": 25354, "concepts": ["struct definition", "struct field initialization", "struct pointer usage"], "_raw_llm_output": "struct definition, struct field initialization, struct pointer usage"}
{"seed": "// NewPacketCapture creates a new (zeroed) PacketCapture struct with the TypeMetadata initialised to the current\n// version.\nfunc NewPacketCapture() *PacketCapture {\n\treturn &PacketCapture{\n\t\tTypeMeta: metav1.TypeMeta{\n\t\t\tKind:       KindPacketCapture,\n\t\t\tAPIVersion: GroupVersionCurrent,\n\t\t},\n\t}\n}", "id": 25358, "concepts": ["struct definition", "struct field initialisation", "metav1.TypeMeta usage"], "_raw_llm_output": "struct definition, struct field initialisation, metav1.TypeMeta usage"}
{"seed": "// filterValuesByMatchers applies matchers to inputed labelName and\n// labelValues. A map of matched values is returned and also all label matchers\n// not matching the labelName.\n// In case a label matcher is set on a label conflicting with tenantLabelName,\n// we need to rename this labelMatcher's name to its original name. This is\n// used to as part of Select in the mergeQueryable, to ensure only relevant\n// queries are considered and the forwarded matchers do not contain matchers on\n// the tenantLabelName.\nfunc filterValuesByMatchers(labelName string, labelValues []string, matchers ...*labels.Matcher) (matchedValues map[string]struct{}, unrelatedMatchers []*labels.Matcher) {\n\t// this contains the matchers which are not related to labelName\n\tunrelatedMatchers = make([]*labels.Matcher, 0, len(matchers))\n\n\t// build map of values to consider for the matchers\n\tmatchedValues = make(map[string]struct{}, len(labelValues))\n\tfor _, value := range labelValues {\n\t\tmatchedValues[value] = struct{}{}\n\t}\n\n\tfor _, m := range matchers {\n\t\tif m.Name != labelName {\n\t\t\t// check if has the retained label name\n\t\t\tif m.Name == originalDefaultTenantLabel {\n\t\t\t\t// rewrite label to the original name, by copying matcher and\n\t\t\t\t// replacing the label name\n\t\t\t\trewrittenM := *m\n\t\t\t\trewrittenM.Name = labelName\n\t\t\t\tunrelatedMatchers = append(unrelatedMatchers, &rewrittenM)\n\t\t\t} else {\n\t\t\t\tunrelatedMatchers = append(unrelatedMatchers, m)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tfor value := range matchedValues {\n\t\t\tif !m.Matches(value) {\n\t\t\t\tdelete(matchedValues, value)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn matchedValues, unrelatedMatchers\n}", "id": 25364, "concepts": ["map iteration (range loop)", "map iteration (for-range loop)", "map deletion", "map iteration (for-range loop)", "map iteration (for-range loop)", "map iteration (for-range loop)", "map iteration (for-range loop)", "map iteration (for-range loop)", "map iteration (for-range loop)", "map iteration (for-range loop)", "map iteration (for-range loop)", "map iteration (for-range loop)", "map iteration (for-range loop)", "map iteration (for-range loop)", "map iteration (for-range loop)", "map iteration (for-range loop)", "map iteration (for-range loop)", "map iteration (for-range loop)", "map iteration (for-range loop)", "map iteration (for-range loop)", "map iteration (for-range loop)", "map iteration (for-range loop)", "map iteration (for-range loop)", "map iteration (for-range loop)", "map iteration (for-range loop)", "map iteration (for-range loop)", "map iteration (for-range loop)", "map iteration (for-range loop)", "map iteration (for-range loop)", "map iteration (for-range loop)", "map iteration (for-range loop)", "map iteration (for-range loop)", "map iteration (for-range"], "_raw_llm_output": "map iteration (range loop), map iteration (for-range loop), map deletion, map iteration (for-range loop), map iteration (for-range loop), map iteration (for-range loop), map iteration (for-range loop), map iteration (for-range loop), map iteration (for-range loop), map iteration (for-range loop), map iteration (for-range loop), map iteration (for-range loop), map iteration (for-range loop), map iteration (for-range loop), map iteration (for-range loop), map iteration (for-range loop), map iteration (for-range loop), map iteration (for-range loop), map iteration (for-range loop), map iteration (for-range loop), map iteration (for-range loop), map iteration (for-range loop), map iteration (for-range loop), map iteration (for-range loop), map iteration (for-range loop), map iteration (for-range loop), map iteration (for-range loop), map iteration (for-range loop), map iteration (for-range loop), map iteration (for-range loop), map iteration (for-range loop), map iteration (for-range loop), map iteration (for-range"}
{"seed": "// PhoneNotIn applies the NotIn predicate on the \"phone\" field.\nfunc PhoneNotIn(vs ...string) predicate.User {\n\treturn predicate.User(sql.FieldNotIn(FieldPhone, vs...))\n}", "id": 25370, "concepts": ["sql.FieldNotIn", "sql.FieldIn", "sql.FieldEq", "sql.FieldNotEq", "sql.FieldGt", "sql.FieldLt", "sql.FieldGte", "sql.FieldLte", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldNull", "sql.FieldNotNull", "sql.FieldAnd", "sql.FieldOr", "sql.FieldNot", "sql.FieldEq", "sql.FieldNotEq", "sql.FieldGt", "sql.FieldLt", "sql.FieldGte", "sql.FieldLte", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldNull", "sql.FieldNotNull", "sql.FieldAnd", "sql.FieldOr", "sql.FieldNot", "sql.FieldEq", "sql.FieldNotEq", "sql.FieldGt", "sql.FieldLt", "sql.FieldGte", "sql.FieldLte", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldNull", "sql.FieldNotNull", "sql.FieldAnd", "sql.FieldOr", "sql.FieldNot", "sql.FieldEq", "sql.Field"], "_raw_llm_output": "sql.FieldNotIn, sql.FieldIn, sql.FieldEq, sql.FieldNotEq, sql.FieldGt, sql.FieldLt, sql.FieldGte, sql.FieldLte, sql.FieldLike, sql.FieldNotLike, sql.FieldIn, sql.FieldNotIn, sql.FieldNull, sql.FieldNotNull, sql.FieldAnd, sql.FieldOr, sql.FieldNot, sql.FieldEq, sql.FieldNotEq, sql.FieldGt, sql.FieldLt, sql.FieldGte, sql.FieldLte, sql.FieldLike, sql.FieldNotLike, sql.FieldIn, sql.FieldNotIn, sql.FieldNull, sql.FieldNotNull, sql.FieldAnd, sql.FieldOr, sql.FieldNot, sql.FieldEq, sql.FieldNotEq, sql.FieldGt, sql.FieldLt, sql.FieldGte, sql.FieldLte, sql.FieldLike, sql.FieldNotLike, sql.FieldIn, sql.FieldNotIn, sql.FieldNull, sql.FieldNotNull, sql.FieldAnd, sql.FieldOr, sql.FieldNot, sql.FieldEq, sql.Field"}
{"seed": "// SocialUserIDLTE applies the LTE predicate on the \"social_user_id\" field.\nfunc SocialUserIDLTE(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.LTE(s.C(FieldSocialUserID), v))\n\t})\n}", "id": 25377, "concepts": ["sql.Selector", "sql.C", "sql.LTE", "predicate.User", "function definition"], "_raw_llm_output": "sql.Selector, sql.C, sql.LTE, predicate.User, function definition"}
{"seed": "// labelsWithPrefix is a helper for fetching all labels on a PR that start with\n// a given string. This pattern is used often in the k/k repo and we can take\n// advantage of this to contextualize release note generation with the kind, sig,\n// area, etc labels.\nfunc labelsWithPrefix(pr *gogithub.PullRequest, prefix string) []string {\n\tlabels := []string{}\n\tfor _, label := range pr.Labels {\n\t\tif strings.HasPrefix(*label.Name, prefix) {\n\t\t\tlabels = append(labels, strings.TrimPrefix(*label.Name, prefix+\"/\"))\n\t\t}\n\t}\n\treturn labels\n}", "id": 25379, "concepts": ["string manipulation", "string prefix handling", "string trimming", "slice iteration", "slice append", "slice creation"], "_raw_llm_output": "string manipulation, string prefix handling, string trimming, slice iteration, slice append, slice creation"}
{"seed": "// PossibleTimeseriesTypeValues returns an array of possible values for the TimeseriesType const type.\nfunc PossibleTimeseriesTypeValues() []TimeseriesType {\n\treturn []TimeseriesType{TimeseriesTypeLatencyP50, TimeseriesTypeLatencyP75, TimeseriesTypeLatencyP95, TimeseriesTypeMeasurementCounts}\n}", "id": 25380, "concepts": ["const", "array", "type conversion"], "_raw_llm_output": "const, array, type conversion"}
{"seed": "// NewCreateMigrationInvoiceParams creates a new CreateMigrationInvoiceParams object,\n// with the default timeout for this client.\n//\n// Default values are not hydrated, since defaults are normally applied by the API server side.\n//\n// To enforce default values in parameter, use SetDefaults or WithDefaults.\nfunc NewCreateMigrationInvoiceParams() *CreateMigrationInvoiceParams {\n\treturn &CreateMigrationInvoiceParams{\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 25387, "concepts": ["default values", "timeout handling", "method chaining"], "_raw_llm_output": "default values, timeout handling, method chaining"}
{"seed": "// CreateUpdateServiceAutoScalerResponse creates a response to parse from UpdateServiceAutoScaler response\nfunc CreateUpdateServiceAutoScalerResponse() (response *UpdateServiceAutoScalerResponse) {\n\tresponse = &UpdateServiceAutoScalerResponse{\n\t\tBaseResponse: &responses.BaseResponse{},\n\t}\n\treturn\n}", "id": 25396, "concepts": ["struct definition", "pointer usage", "method definition", "response struct definition"], "_raw_llm_output": "struct definition, pointer usage, method definition, response struct definition"}
{"seed": "// GenerateRoomPath takes a request form and returns a path\n// so that the user can be routed to a room\n// if user does not provide a room # then a new one is created\nfunc GenerateRoomPath(form url.Values) string {\n\n\tvar route string\n\tvar roomID string\n\n\txr := form[\"room\"]\n\tif len(xr) > 0 {\n\t\troomID = xr[0]\n\t}\n\n\tif len(roomID) > 0 {\n\n\t\troute = fmt.Sprintf(\"/room/%v\", roomID)\n\n\t} else {\n\n\t\tnewRoom := CreateRoom()\n\t\troute = fmt.Sprintf(\"/room/%v\", newRoom.ID)\n\t}\n\n\treturn route\n}", "id": 25402, "concepts": ["url parsing", "url.Values", "string formatting", "basic function definition"], "_raw_llm_output": "url parsing, url.Values, string formatting, basic function definition"}
{"seed": "// isRegistered checks to see if the required checker has already been\n// registered in order to avoid a panic caused by double registration.\nfunc isRegistered(c *checkers.Checker, name string) bool {\n\tif c == nil {\n\t\treturn false\n\t}\n\n\tfor _, info := range c.Info() {\n\t\tif info.Name == name && info.Prefix == \"std\" {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}", "id": 25422, "concepts": ["interface", "method set", "method receiver", "nil pointer check"], "_raw_llm_output": "interface, method set, method receiver, nil pointer check"}
{"seed": "// DecodeNameSlice converts tsdb internal serialization back to organization and bucket IDs.\nfunc DecodeNameSlice(name []byte) (org, bucket platform.ID) {\n\treturn platform.ID(binary.BigEndian.Uint64(name[0:8])), platform.ID(binary.BigEndian.Uint64(name[8:16]))\n}", "id": 25434, "concepts": ["binary encoding", "byte array manipulation", "binary decoding", "standard library usage"], "_raw_llm_output": "binary encoding, byte array manipulation, binary decoding, standard library usage"}
{"seed": "// FetchEntriesFromFiles fetches all available log entries on disk\n// that are between the 'startTimestamp' and 'endTimestamp'. It will\n// stop reading new files if the number of entries exceeds\n// 'maxEntries'. Log entries are further filtered by the regexp\n// 'pattern' if provided. The logs entries are returned in reverse\n// chronological order.\nfunc FetchEntriesFromFiles(\n\tstartTimestamp, endTimestamp int64, maxEntries int, pattern *regexp.Regexp,\n) ([]Entry, error) {\n\tlogFiles, err := ListLogFiles()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tselectedFiles := selectFiles(logFiles, endTimestamp)\n\n\tentries := []Entry{}\n\tfor _, file := range selectedFiles {\n\t\tnewEntries, entryBeforeStart, err := readAllEntriesFromFile(\n\t\t\tfile,\n\t\t\tstartTimestamp,\n\t\t\tendTimestamp,\n\t\t\tmaxEntries-len(entries),\n\t\t\tpattern)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tentries = append(entries, newEntries...)\n\t\tif len(entries) >= maxEntries {\n\t\t\tbreak\n\t\t}\n\t\tif entryBeforeStart {\n\t\t\t// Stop processing files that won't have any timestamps after\n\t\t\t// startTime.\n\t\t\tbreak\n\t\t}\n\t}\n\treturn entries, nil\n}", "id": 25435, "concepts": ["regexp usage", "error handling (idiomatic if err != nil)", "standard library usage (like fmt", "os", "sync)", "concurrency patterns (goroutines", "channels", "mutexes)", "error handling (idiomatic if err != nil)", "types (structs", "interfaces", "slices", "maps)", "common Go idioms (like defer)", "pointers", "and control flow."], "_raw_llm_output": "regexp usage, error handling (idiomatic if err != nil), standard library usage (like fmt, os, sync), concurrency patterns (goroutines, channels, mutexes), error handling (idiomatic if err != nil), types (structs, interfaces, slices, maps), common Go idioms (like defer), pointers, and control flow."}
{"seed": "// getHandshakeInfo returns a pointer to the HandshakeInfo stored in attr.\nfunc getHandshakeInfo(attr *attributes.Attributes) *HandshakeInfo {\n\tv := attr.Value(handshakeAttrKey{})\n\thi, _ := v.(*HandshakeInfo)\n\treturn hi\n}", "id": 25443, "concepts": ["pointer handling", "attributes.Attributes usage"], "_raw_llm_output": "pointer handling, attributes.Attributes usage"}
{"seed": "// PossibleCompressionValues returns an array of possible values for the Compression const type.\nfunc PossibleCompressionValues() []Compression {\n\treturn []Compression{CompressionGZip, CompressionNone}\n}", "id": 25444, "concepts": ["type definition", "type alias", "array definition"], "_raw_llm_output": "type definition, type alias, array definition"}
{"seed": "// GetTimeSinceGPSEpoch returns the time since GPS epoch if it is available\n// in the uplink payload.\nfunc GetTimeSinceGPSEpoch(rxInfo []*gw.UplinkRXInfo) *time.Duration {\n\tfor i := range rxInfo {\n\t\tif rxInfo[i].TimeSinceGpsEpoch != nil {\n\t\t\td, err := ptypes.Duration(rxInfo[i].TimeSinceGpsEpoch)\n\t\t\tif err == nil {\n\t\t\t\treturn &d\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}", "id": 25446, "concepts": ["time package usage", "duration package usage", "type conversion", "pointer handling", "pointer dereference"], "_raw_llm_output": "time package usage, duration package usage, type conversion, pointer handling, pointer dereference"}
{"seed": "// translatePath takes in a S3 root prefix, a home directory, and either an absolute or relative path to append, and returns a cleaned and validated path.\n// It will resolve things like '..' while disallowing the prefix to be escaped.\n// It also preserves a single trailing slash if one is present, so it can be used on both directories and files.\nfunc TranslatePath(prefix, home, path string) (string, error) {\n\tif path == \"\" {\n\t\treturn filepath.Clean(\"/\" + prefix + \"/\" + home), nil\n\t}\n\n\tvar cleanPath string\n\tif strings.HasPrefix(path, \"/\") {\n\t\tcleanPath = filepath.Clean(prefix + path)\n\t\tif !strings.HasPrefix(cleanPath, prefix) {\n\t\t\tcleanPath = prefix\n\t\t}\n\t} else {\n\t\tcleanPath = filepath.Clean(\"/\" + prefix + \"/\" + home + filepath.Clean(\"/\"+path))\n\t}\n\n\t// For some reason, filepath.Clean drops trailing /'s, so if there was one we have to put it back\n\tif strings.HasSuffix(path, \"/\") {\n\t\tcleanPath += \"/\"\n\t}\n\treturn strings.TrimLeft(cleanPath, \"/\"), nil\n}", "id": 25450, "concepts": ["filepath package usage", "filepath.Clean", "filepath.HasPrefix", "filepath.IsAbs", "filepath.Join", "filepath.Split", "filepath.ToSlash", "filepath.Clean", "filepath.Dir", "filepath.Base", "filepath.Ext", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath.Clean", "filepath"], "_raw_llm_output": "filepath package usage, filepath.Clean, filepath.HasPrefix, filepath.IsAbs, filepath.Join, filepath.Split, filepath.ToSlash, filepath.Clean, filepath.Dir, filepath.Base, filepath.Ext, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath.Clean, filepath"}
{"seed": "// NewMsgBlockTxns returns a new bitcoin blocktxn message that conforms to the\n// Message interface using the passed parameters and defaults for the remaining\n// fields.\nfunc NewMsgBlockTxns(blockHash chainhash.Hash, txs []*MsgTx) *MsgBlockTxns {\n\treturn &MsgBlockTxns{BlockHash: blockHash, Txs: txs}\n}", "id": 25455, "concepts": ["struct definition", "pointer usage", "function definition", "default parameter values"], "_raw_llm_output": "struct definition, pointer usage, function definition, default parameter values"}
{"seed": "// B represents the HTML element 'b'.\n// For more information visit https://www.w3schools.com/tags/tag_b.asp.\nfunc B(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"b\", Attributes: attrs, Children: children}\n}", "id": 25461, "concepts": ["HTML generation", "HTML tree representation", "HTML element definition", "HTML attribute definition", "HTML element usage"], "_raw_llm_output": "HTML generation, HTML tree representation, HTML element definition, HTML attribute definition, HTML element usage"}
{"seed": "// AddressFromBalancesStore returns an account address from a balances prefix\n// store. The key must not contain the perfix BalancesPrefix as the prefix store\n// iterator discards the actual prefix.\nfunc AddressFromBalancesStore(key []byte) sdk.AccAddress {\n\tkv.AssertKeyAtLeastLength(key, 1+v1auth.AddrLen)\n\taddr := key[:v1auth.AddrLen]\n\tkv.AssertKeyLength(addr, v1auth.AddrLen)\n\treturn sdk.AccAddress(addr)\n}", "id": 25467, "concepts": ["sdk.AccAddress", "sdk.KVStore", "sdk.KVStoreIterator", "sdk.KVStorePrefixIterator", "sdk.KVStoreDelete", "sdk.KVStoreHas", "sdk.KVStoreGet", "sdk.KVStoreSet", "sdk.KVStorePrefixIteratorNext", "sdk.KVStorePrefixIteratorClose", "sdk.KVStoreIteratorNext", "sdk.KVStoreIteratorClose", "sdk.KVStorePrefixIteratorSeek", "sdk.KVStorePrefixIteratorSeekEnd", "sdk.KVStorePrefixIteratorSeekStart", "sdk.KVStorePrefixIteratorSeekPrefix", "sdk.KVStorePrefixIteratorSeekSuffix", "sdk.KVStorePrefixIteratorSeekGe", "sdk.KVStorePrefixIteratorSeekGt", "sdk.KVStorePrefixIteratorSeekLe", "sdk.KVStorePrefixIteratorSeekLt", "sdk.KVStorePrefixIteratorSeekPrefix", "sdk.KVStorePrefixIteratorSeekSuffix", "sdk.KVStorePrefixIteratorSeekGe", "sdk.KVStorePrefixIteratorSeekGt", "sdk.KVStorePrefixIteratorSeekLe", "sdk.KVStorePrefixIteratorSeekLt", "sdk.KVStorePrefixIteratorSeekPrefix", "sdk.KVStorePrefixIteratorSeekSuffix", "sdk.KVStorePrefixIteratorSeekGe", "sdk.KVStorePrefixIteratorSeekGt", "sdk.KVStorePrefixIteratorSeekLe"], "_raw_llm_output": "sdk.AccAddress, sdk.KVStore, sdk.KVStoreIterator, sdk.KVStorePrefixIterator, sdk.KVStoreDelete, sdk.KVStoreHas, sdk.KVStoreGet, sdk.KVStoreSet, sdk.KVStorePrefixIteratorNext, sdk.KVStorePrefixIteratorClose, sdk.KVStoreIteratorNext, sdk.KVStoreIteratorClose, sdk.KVStorePrefixIteratorSeek, sdk.KVStorePrefixIteratorSeekEnd, sdk.KVStorePrefixIteratorSeekStart, sdk.KVStorePrefixIteratorSeekPrefix, sdk.KVStorePrefixIteratorSeekSuffix, sdk.KVStorePrefixIteratorSeekGe, sdk.KVStorePrefixIteratorSeekGt, sdk.KVStorePrefixIteratorSeekLe, sdk.KVStorePrefixIteratorSeekLt, sdk.KVStorePrefixIteratorSeekPrefix, sdk.KVStorePrefixIteratorSeekSuffix, sdk.KVStorePrefixIteratorSeekGe, sdk.KVStorePrefixIteratorSeekGt, sdk.KVStorePrefixIteratorSeekLe, sdk.KVStorePrefixIteratorSeekLt, sdk.KVStorePrefixIteratorSeekPrefix, sdk.KVStorePrefixIteratorSeekSuffix, sdk.KVStorePrefixIteratorSeekGe, sdk.KVStorePrefixIteratorSeekGt, sdk.KVStorePrefixIteratorSeekLe"}
{"seed": "// \u65e0\u9700\u6574\u5f62\u6570\u7ec4\u4e2d\uff0c\u627e\u5230\u672a\u51fa\u73b0\u7684\u6700\u5c0f\u6b63\u6574\u6570\n\n// \u7406\u60f3\u60c5\u51b5\u4e0b\uff0c\u6570\u7ec4\u4e2d\u5e94\u8be5\u662f[1, N]\u8fd9N\u4e2a\u6570\n// [1, l]\u5df2\u7ecf\u786e\u5b9a\u7684\u6b63\u6574\u6570\uff0c[r, N-1]\u65e0\u6548\u5143\u7d20;l=0, r=N\n// arr[l] == l+1, \u5bf9\u5e94\u7684\u5143\u7d20\u5728\u5bf9\u5e94\u7684\u4f4d\u7f6e\u4e0a\uff0c\u76f4\u63a5\u6269\u5c55\u5de6\u8fb9\u533a\u95f4\uff0c[1, l+1]\u4e3a\u5305\u542b\u7684\u6b63\u6574\u6570\n// arr[l] <= l\uff0c\u5df2\u7ecf\u5305\u542b\u6b63\u6574\u6570\u4e3a[1,l]\uff0c\u90a3\u4e48[l+1,r]\u5185\u6570\u5b57\u5c31\u5c11\u4e00\u4e2a\uff0c\u53f3\u8fb9\u533a\u95f4\u53d8\u4e3a[l, r-1]\uff0c\u5e76\u5c06\u6709\u6548\u6570\u7ec4\u7684\u6700\u540earr[r-1]\u653e\u5230\u5f53\u524d\u4f4d\u7f6e\n// arr[l] > r, \u540c\u4e0a\n// arr[l] \\in [l+1, r], \u6b64\u65f6arr[l]\u5e94\u8be5\u653e\u5230arr[l]-1\u8fd9\u4e2a\u4f4d\u7f6e\u4e0a\uff0c\u4ea4\u6362\uff08\u6709\u4e2a\u7279\u6b8a\u60c5\u51b5\uff0c\u4ea4\u6362\u540e\u5143\u7d20\u4e0d\u53d8\uff0c\u4e5f\u5c31\u662f\u8bf4\uff0c\u51fa\u73b0\u90a3\u4e2a\u4f4d\u7f6e\u4e0a\u7684\u5143\u7d20\u548carr[l]\u91cd\u590d\uff0c\u8fd9\u4e2a\u60c5\u51b5\u9700\u8981\u989d\u5916\u5904\u7406\u4e0b\uff09\n\n// \u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(N)\nfunc missNum(arr []int) int {\n\tl, r := 0, len(arr)\n\n\tfor l < r {\n\t\tif arr[l] == l+1 {\n\t\t\tl++\n\t\t} else if arr[l] <= l || arr[l] > r {\n\t\t\tr--\n\t\t\tarr[l] = arr[r]\n\t\t} else {\n\t\t\tif arr[arr[l]-1] == arr[l] { //\u4e24\u8005\u4fdd\u7559\u4e00\u4e2a\u5373\u53ef\uff0c\u4fdd\u7559\u4f4d\u7f6e\u6b63\u786e\u7684\u90a3\u4e2a\n\t\t\t\tr--\n\t\t\t\tarr[l] = arr[r]\n\t\t\t} else {\n\t\t\t\tarr[l], arr[arr[l]-1] = arr[arr[l]-1], arr[l]\n\t\t\t}\n\t\t}\n\t}\n\treturn l + 1\n}", "id": 25474, "concepts": ["array", "slice", "pointer", "slice manipulation", "array manipulation"], "_raw_llm_output": "array, slice, pointer, slice manipulation, array manipulation"}
{"seed": "// NewBalancedURIScoringMiddleware returns URI scoring middleware that tracks in-flight requests and recent failures\n// for each URI configured on an HTTP client. URIs are scored based on fewest in-flight requests and recent errors,\n// where client errors are weighted the same as 1/10 of an in-flight request, server errors are weighted as 10\n// in-flight requests, and errors are decayed using exponential decay with a half-life of 30 seconds.\n//\n// This implementation is based on Dialogue's BalancedScoreTracker:\n// https://github.com/palantir/dialogue/blob/develop/dialogue-core/src/main/java/com/palantir/dialogue/core/BalancedScoreTracker.java\nfunc NewBalancedURIScoringMiddleware(uris []string, nanoClock func() int64) URIScoringMiddleware {\n\turiInfos := make(map[string]uriInfo, len(uris))\n\tfor _, uri := range uris {\n\t\turiInfos[uri] = uriInfo{\n\t\t\trecentFailures: NewCourseExponentialDecayReservoir(nanoClock, failureMemory),\n\t\t}\n\t}\n\treturn &balancedScorer{uriInfos}\n}", "id": 25481, "concepts": ["map", "struct", "exponential decay", "reservoir sampling", "concurrency", "standard library usage"], "_raw_llm_output": "map, struct, exponential decay, reservoir sampling, concurrency, standard library usage"}
{"seed": "// GenerateSecretKey generates a base64 URL-safe string\n// built from securely generated random bytes.\n// Number of bytes is determined by tokenSize.\n// Return error if system's secure random number generator fails.\nfunc GenerateSecretKey(tokenSize int) (string, error) {\n\tif tokenSize <= 0 {\n\t\treturn \"\", consts.ErrInvalidTokenSize\n\t}\n\n\tkeyGenLocker.Lock()\n\tdefer keyGenLocker.Unlock()\n\n\trandomBytes := make([]byte, tokenSize)\n\t_, err := cryptorand.Read(randomBytes)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn base64.URLEncoding.EncodeToString(randomBytes), nil\n}", "id": 25486, "concepts": ["crypto/rand", "sync.Mutex", "sync.Locker", "crypto/rand package usage", "base64 encoding"], "_raw_llm_output": "crypto/rand, sync.Mutex, sync.Locker, crypto/rand package usage, base64 encoding"}
{"seed": "// TitleEQ applies the EQ predicate on the \"title\" field.\nfunc TitleEQ(v string) predicate.User {\n\treturn predicate.User(sql.FieldEQ(FieldTitle, v))\n}", "id": 25491, "concepts": ["sql.FieldEQ", "predicate.User", "sql package usage"], "_raw_llm_output": "sql.FieldEQ, predicate.User, sql package usage"}
{"seed": "// WithSelectors specifies what debug selectors are enabled. If no selectors are\n// specified then they are all enabled.\nfunc WithSelectors(selectors ...string) Option {\n\treturn func(cfg *Config) {\n\t\tcfg.Selectors = append(cfg.Selectors, selectors...)\n\t}\n}", "id": 25495, "concepts": ["function definition", "function composition", "function options", "function arguments", "function return value"], "_raw_llm_output": "function definition, function composition, function options, function arguments, function return value"}
{"seed": "// WithCapabilities overrides the default GetCapabilities function for a processor.\n// The default GetCapabilities function returns mutable capabilities.\nfunc WithCapabilities(capabilities consumer.Capabilities) Option {\n\treturn func(o *baseConsumer) {\n\t\to.capabilities = capabilities\n\t}\n}", "id": 25503, "concepts": ["function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", ""], "_raw_llm_output": "function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition,"}
{"seed": "// S represents the HTML element 's'.\n// For more information visit https://www.w3schools.com/tags/tag_s.asp.\nfunc S(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"s\", Attributes: attrs, Children: children}\n}", "id": 25527, "concepts": ["HTML generation", "HTML generation using the htmlgo package"], "_raw_llm_output": "HTML generation, HTML generation using the htmlgo package"}
{"seed": "// NewClientFromFlags returns a Client with credentials obtained from flags.\n// Assumes that SetupFlags() and flag.Parse() have been called.\nfunc NewClientFromFlags() (*Client, error) {\n\treturn NewClient(*host, *user, *password, *database)\n}", "id": 25535, "concepts": ["flag package usage", "function definition", "function call"], "_raw_llm_output": "flag package usage, function definition, function call"}
{"seed": "// NoDebugStack prevents stack traces from being attached to spans finishing\n// with an error. This is useful in situations where errors are frequent and\n// performance is critical.\nfunc NoDebugStack() Option {\n\treturn func(cfg *config) {\n\t\tcfg.finishOpts = append(cfg.finishOpts, tracer.NoDebugStack())\n\t}\n}", "id": 25550, "concepts": ["function definition", "function composition", "option pattern", "error handling"], "_raw_llm_output": "function definition, function composition, option pattern, error handling"}
{"seed": "// NewNodeFromString creates a remote identity from a string in the following format: 126.0.0.1:3572/r9gJRWVB9JVPap2HKnduoFySvHtVTfJdQ4WG8DriUD82 .\nfunc NewNodeFromString(data string) (Node, error) {\n\titems := strings.Split(data, \"/\")\n\tif len(items) != 2 {\n\t\treturn EmptyNode, fmt.Errorf(\"could'nt create node from string, wrong format\")\n\t}\n\tpubk, err := p2pcrypto.NewPublicKeyFromBase58(items[1])\n\tif err != nil {\n\t\treturn EmptyNode, err\n\t}\n\treturn Node{pubk, items[0]}, nil\n}", "id": 25556, "concepts": ["string manipulation", "string splitting", "string parsing", "base58 encoding", "public key handling", "struct definition", "error handling"], "_raw_llm_output": "string manipulation, string splitting, string parsing, base58 encoding, public key handling, struct definition, error handling"}
{"seed": "// IsClientStatusUpdateError checks whether the given error is of type ClientStatusUpdateError or\n// in case this is a list of errors, that it contains at least one error of type ClientStatusUpdateError\nfunc IsClientStatusUpdateError(err error) bool {\n\tswitch terr := err.(type) {\n\tcase *ClientStatusUpdateError, ClientStatusUpdateError:\n\t\treturn true\n\n\tcase Errors:\n\t\tfor _, e := range terr.errors {\n\t\t\tif IsClientStatusUpdateError(e) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false\n}", "id": 25567, "concepts": ["type assertion", "interface assertion", "type assertion", "type switch", "error handling (errors.Is)", "error handling (errors.As)"], "_raw_llm_output": "type assertion, interface assertion, type assertion, type switch, error handling (errors.Is), error handling (errors.As)"}
{"seed": "// NewCreateSksClusterRequest calls the generic CreateSksCluster builder with application/json body\nfunc NewCreateSksClusterRequest(server string, body CreateSksClusterJSONRequestBody) (*http.Request, error) {\n\tvar bodyReader io.Reader\n\tbuf, err := json.Marshal(body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tbodyReader = bytes.NewReader(buf)\n\treturn NewCreateSksClusterRequestWithBody(server, \"application/json\", bodyReader)\n}", "id": 25576, "concepts": ["http.Request", "io.Reader", "json.Marshal", "bytes.NewReader", "http.NewRequest"], "_raw_llm_output": "http.Request, io.Reader, json.Marshal, bytes.NewReader, http.NewRequest"}
{"seed": "// NewSimpleTrainer constructs a trainable feed-forward neural net with the specified sizes and\n// tanh neuron activators in the hidden layer. Common choices for the final layer activator\n// are activator.Linear for regression and activator.Tanh for classification.\n// nLayers is the number of hidden layers. For now, must be at least one.\nfunc NewSimpleTrainer(inputDim, outputDim, nHiddenLayers, nNeuronsPerLayer int, finalLayerActivator Activator) (*Trainer, error) {\n\tif inputDim <= 0 {\n\t\treturn nil, errors.New(\"non-positive input dimension\")\n\t}\n\tif outputDim <= 0 {\n\t\treturn nil, errors.New(\"non-positive output dimension\")\n\t}\n\tif inputDim <= 0 {\n\t\treturn nil, errors.New(\"non-positive number of neurons per layer\")\n\t}\n\n\t// Create the neurons\n\t// the hidden layers have the same number of neurons as hidden layers\n\t// final layer has a number of neurons equal to the number of outputs\n\n\tneurons := make([][]Neuron, nHiddenLayers+1)\n\tfor i := 0; i < nHiddenLayers; i++ {\n\t\tneurons[i] = make([]Neuron, nNeuronsPerLayer)\n\t\tfor j := 0; j < nNeuronsPerLayer; j++ {\n\t\t\tneurons[i][j] = TanhNeuron\n\t\t}\n\t}\n\n\tneurons[nHiddenLayers] = make([]Neuron, outputDim)\n\tfor i := 0; i < outputDim; i++ {\n\t\tneurons[nHiddenLayers][i] = SumNeuron{Activator: finalLayerActivator}\n\t}\n\treturn NewTrainer(inputDim, outputDim, neurons)\n}", "id": 25581, "concepts": ["struct definition", "slice definition", "slice iteration", "slice indexing", "slice length", "slice capacity", "slice append", "slice copy", "slice sorting", "slice sorting by function", "slice sorting by function", "slice sorting by function", "slice sorting by function", "slice sorting by function", "slice sorting by function", "slice sorting by function", "slice sorting by function", "slice sorting by function", "slice sorting by function", "slice sorting by function", "slice sorting by function", "slice sorting by function", "slice sorting by function", "slice sorting by function", "slice sorting by function", "slice sorting by function", "slice sorting by function", "slice sorting by function", "slice sorting by function", "slice sorting by function", "slice sorting by function", "slice sorting by function", "slice sorting by function", "slice sorting by function", "slice sorting by function", "slice sorting by function", "slice sorting by function", "slice sorting by function", "slice sorting by function", "slice sorting by function", "slice sorting by function", "slice sorting by function", "slice sorting by function", "slice sorting by function", "slice sorting by function", "slice sorting by function", "slice sorting by function", "slice sorting by function", "slice sorting by function", "slice sorting by function", "slice sorting by function", "slice sorting by function", "slice sorting by function", "slice sorting by function", "slice sorting by"], "_raw_llm_output": "struct definition, slice definition, slice iteration, slice indexing, slice length, slice capacity, slice append, slice copy, slice sorting, slice sorting by function, slice sorting by function, slice sorting by function, slice sorting by function, slice sorting by function, slice sorting by function, slice sorting by function, slice sorting by function, slice sorting by function, slice sorting by function, slice sorting by function, slice sorting by function, slice sorting by function, slice sorting by function, slice sorting by function, slice sorting by function, slice sorting by function, slice sorting by function, slice sorting by function, slice sorting by function, slice sorting by function, slice sorting by function, slice sorting by function, slice sorting by function, slice sorting by function, slice sorting by function, slice sorting by function, slice sorting by function, slice sorting by function, slice sorting by function, slice sorting by function, slice sorting by function, slice sorting by function, slice sorting by function, slice sorting by function, slice sorting by function, slice sorting by function, slice sorting by function, slice sorting by function, slice sorting by function, slice sorting by function, slice sorting by function, slice sorting by function, slice sorting by function, slice sorting by function, slice sorting by"}
{"seed": "// Version returns version string\nfunc Version() string {\n\treturn C.GoString(C.khaiii_version())\n}", "id": 25584, "concepts": ["C.GoString", "C.khaiii_version", "string manipulation"], "_raw_llm_output": "C.GoString, C.khaiii_version, string manipulation"}
{"seed": "// str_is_in_slice returns true if str is in the given slice of strings\nfunc str_is_in_slice(slice []string, str string) bool {\n\tfor _, s := range slice {\n\t\tif s == str {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}", "id": 25586, "concepts": ["slice iteration (range loop)", "string comparison", "basic function definition"], "_raw_llm_output": "slice iteration (range loop), string comparison, basic function definition"}
{"seed": "// IsWindows detects if we are running on the microsoft windows platform\nfunc IsWindows() bool {\n\treturn runtime.GOOS == \"windows\"\n}", "id": 25593, "concepts": ["runtime.GOOS", "basic function definition", "boolean return"], "_raw_llm_output": "runtime.GOOS, basic function definition, boolean return"}
{"seed": "// NewMultiSignatureCondition creates a new multisig unlock condition,\n// using the given unlockhashes as a representation of the identities\n// who can unlock the output\nfunc NewMultiSignatureCondition(uhs UnlockHashSlice, minsigs uint64) *MultiSignatureCondition {\n\tif minsigs == 0 {\n\t\tbuild.Severe(\"MultiSig outputs must require at least a single signature to unlock\")\n\t}\n\tif len(uhs) == 0 {\n\t\tbuild.Severe(\"MultiSig outputs must specify at least a single address which can sign it as an input\")\n\t}\n\tif uint64(len(uhs)) < minsigs {\n\t\tbuild.Severe(\"You can't create a multisig which requires more signatures to spent then there are addresses which can sign\")\n\t}\n\tif build.DEBUG {\n\t\tfor _, uh := range uhs {\n\t\t\tif uh.Type != UnlockTypePubKey {\n\t\t\t\tbuild.Critical(\"Unlock hashes used in multisig condition must have the UnlockTypePubKey type\")\n\t\t\t}\n\t\t}\n\n\t}\n\treturn &MultiSignatureCondition{UnlockHashes: uhs, MinimumSignatureCount: minsigs}\n}", "id": 25599, "concepts": ["slice iteration (range loop)", "basic function definition", "basic type definition", "pointer usage", "error handling"], "_raw_llm_output": "slice iteration (range loop), basic function definition, basic type definition, pointer usage, error handling"}
{"seed": "// IndexGetHandler is called for the `/` (index) route and directs the user either to the first\n// page, or to the last page the user viewed.\nfunc IndexGetHandler(w http.ResponseWriter, req *http.Request) {\n\tu := users.FromContext(req.Context())\n\tif u == nil {\n\t\thttp.Error(w, \"Could not read user data from request context\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tif len(u.LastViewed) == 0 {\n\t\t// There's no value or we can't read from it, so we'll just sent the user to the first page.\n\t\thttp.Redirect(w, req, \"/page/1\", http.StatusSeeOther)\n\t\treturn\n\t}\n\n\tn, err := posts.GetOffset(u.LastViewed)\n\tif err != nil {\n\t\t// There's no value or we can't read from it, so we'll just sent the user to the first page.\n\t\thttp.Redirect(w, req, \"/page/1\", http.StatusSeeOther)\n\t\treturn\n\t}\n\n\tpn := utility.ComputePage(n, u.PPP)\n\turi := fmt.Sprintf(\"/page/%d#%s\", pn, u.LastViewed)\n\n\thttp.Redirect(w, req, uri, http.StatusSeeOther)\n}", "id": 25603, "concepts": ["http.ResponseWriter", "http.Request", "http.Redirect", "http.Error", "http.StatusSeeOther", "fmt.Sprintf", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http.Redirect", "http"], "_raw_llm_output": "http.ResponseWriter, http.Request, http.Redirect, http.Error, http.StatusSeeOther, fmt.Sprintf, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http.Redirect, http"}
{"seed": "// SocialNameGTE applies the GTE predicate on the \"social_name\" field.\nfunc SocialNameGTE(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.GTE(s.C(FieldSocialName), v))\n\t})\n}", "id": 25607, "concepts": ["SQL query building", "predicate.User", "sql.Selector", "sql.C", "sql.GTE"], "_raw_llm_output": "SQL query building, predicate.User, sql.Selector, sql.C, sql.GTE"}
{"seed": "// RTWithSpanNamer specifies a function which will be used to\n// obtain the span operation name for a given request.\nfunc RTWithSpanNamer(namer func(req *http.Request) string) RoundTripperOption {\n\treturn func(cfg *roundTripperConfig) {\n\t\tcfg.spanNamer = namer\n\t}\n}", "id": 25616, "concepts": ["http.Request", "http.RoundTripper", "http.Transport", "function composition"], "_raw_llm_output": "http.Request, http.RoundTripper, http.Transport, function composition"}
{"seed": "// NewDeleteFreeIpaByEnvironmentV1ParamsWithTimeout creates a new DeleteFreeIpaByEnvironmentV1Params object\n// with the default values initialized, and the ability to set a timeout on a request\nfunc NewDeleteFreeIpaByEnvironmentV1ParamsWithTimeout(timeout time.Duration) *DeleteFreeIpaByEnvironmentV1Params {\n\tvar (\n\t\tforcedDefault = bool(false)\n\t)\n\treturn &DeleteFreeIpaByEnvironmentV1Params{\n\t\tForced: &forcedDefault,\n\n\t\ttimeout: timeout,\n\t}\n}", "id": 25625, "concepts": ["struct initialization", "function definition", "pointer usage", "timeout handling"], "_raw_llm_output": "struct initialization, function definition, pointer usage, timeout handling"}
{"seed": "// Description applies equality check predicate on the \"description\" field. It's identical to DescriptionEQ.\nfunc Description(v string) predicate.User {\n\treturn predicate.User(sql.FieldEQ(FieldDescription, v))\n}", "id": 25626, "concepts": ["struct field access", "sql.FieldEQ"], "_raw_llm_output": "struct field access, sql.FieldEQ"}
{"seed": "// Tt_ is a convenience wrapper for Tt without the attrs argument.\nfunc Tt_(children ...HTML) HTML {\n  return Tt(nil, children...)\n}", "id": 25627, "concepts": ["basic function definition", "function argument handling", "function return value handling", "HTML tag handling"], "_raw_llm_output": "basic function definition, function argument handling, function return value handling, HTML tag handling"}
{"seed": "//TransformAccount converts an account from the history archive ingestion system into a form suitable for BigQuery\nfunc TransformAccount(ledgerChange ingestio.Change) (AccountOutput, error) {\n\tledgerEntry, outputDeleted, err := utils.ExtractEntryFromChange(ledgerChange)\n\tif err != nil {\n\t\treturn AccountOutput{}, err\n\t}\n\n\taccountEntry, accountFound := ledgerEntry.Data.GetAccount()\n\tif !accountFound {\n\t\treturn AccountOutput{}, fmt.Errorf(\"Could not extract account data from ledger entry; actual type is %s\", ledgerEntry.Data.Type)\n\t}\n\n\toutputID, err := accountEntry.AccountId.GetAddress()\n\tif err != nil {\n\t\treturn AccountOutput{}, err\n\t}\n\n\toutputBalance := int64(accountEntry.Balance)\n\tif outputBalance < 0 {\n\t\treturn AccountOutput{}, fmt.Errorf(\"Balance is negative (%d) for account: %s\", outputBalance, outputID)\n\t}\n\n\t//The V1 struct is the first version of the extender from accountEntry. It contains information on liabilities, and in the future\n\t//more extensions may contain extra information\n\taccountExtensionInfo, V1Found := accountEntry.Ext.GetV1()\n\tvar outputBuyingLiabilities, outputSellingLiabilities int64\n\tif V1Found {\n\t\tliabilities := accountExtensionInfo.Liabilities\n\t\toutputBuyingLiabilities, outputSellingLiabilities = int64(liabilities.Buying), int64(liabilities.Selling)\n\t\tif outputBuyingLiabilities < 0 {\n\t\t\treturn AccountOutput{}, fmt.Errorf(\"The buying liabilities count is negative (%d) for account: %s\", outputBuyingLiabilities, outputID)\n\t\t}\n\n\t\tif outputSellingLiabilities < 0 {\n\t\t\treturn AccountOutput{}, fmt.Errorf(\"The selling liabilities count is negative (%d) for account: %s\", outputSellingLiabilities, outputID)\n\t\t}\n\t}\n\n\toutputSequenceNumber := int64(accountEntry.SeqNum)\n\tif outputSequenceNumber < 0 {\n\t\treturn AccountOutput{}, fmt.Errorf(\"Account sequence number is negative (%d) for account: %s\", outputSequenceNumber, outputID)\n\t}\n\n\toutputNumSubentries := uint32(accountEntry.NumSubEntries)\n\n\tinflationDestAccountID := accountEntry.InflationDest\n\tvar outputInflationDest string\n\tif inflationDestAccountID != nil {\n\t\toutputInflationDest, err = inflationDestAccountID.GetAddress()\n\t\tif err != nil {\n\t\t\treturn AccountOutput{}, err\n\t\t}\n\t}\n\n\toutputFlags := uint32(accountEntry.Flags)\n\n\toutputHomeDomain := string(accountEntry.HomeDomain)\n\n\toutputMasterWeight := int32(accountEntry.MasterKeyWeight())\n\toutputThreshLow := int32(accountEntry.ThresholdLow())\n\toutputThreshMed := int32(accountEntry.ThresholdMedium())\n\toutputThreshHigh := int32(accountEntry.ThresholdHigh())\n\n\toutputLastModifiedLedger := uint32(ledgerEntry.LastModifiedLedgerSeq)\n\n\ttransformedAccount := AccountOutput{\n\t\tAccountID:            outputID,\n\t\tBalance:              outputBalance,\n\t\tBuyingLiabilities:    outputBuyingLiabilities,\n\t\tSellingLiabilities:   outputSellingLiabilities,\n\t\tSequenceNumber:       outputSequenceNumber,\n\t\tNumSubentries:        outputNumSubentries,\n\t\tInflationDestination: outputInflationDest,\n\t\tFlags:                outputFlags,\n\t\tHomeDomain:           outputHomeDomain,\n\t\tMasterWeight:         outputMasterWeight,\n\t\tThresholdLow:         outputThreshLow,\n\t\tThresholdMedium:      outputThreshMed,\n\t\tThresholdHigh:        outputThreshHigh,\n\t\tLastModifiedLedger:   outputLastModifiedLedger,\n\t\tDeleted:              outputDeleted,\n\t}\n\treturn transformedAccount, nil\n}", "id": 25628, "concepts": ["struct definition", "interface definition", "struct field access", "function definition", "function return values", "function parameter passing", "function parameter definition", "function parameter type", "function parameter type inference", "function parameter default value", "function parameter named return value", "function parameter named return value type", "function parameter named return value type inference", "function parameter named return value default value", "function parameter named return value type default value", "function parameter named return value type inference default value", "function parameter named return value type inference default value", "function parameter named return value type inference default value", "function parameter named return value type inference default value", "function parameter named return value type inference default value", "function parameter named return value type inference default value", "function parameter named return value type inference default value", "function parameter named return value type inference default value", "function parameter named return value type inference default value", "function parameter named return value type inference default value", "function parameter named return value type inference default value", "function parameter named return value type inference default value", "function parameter named return value type inference default value", "function parameter named return value type inference default value", "function parameter named return value type inference default value", "function parameter named return value type inference default value", "function parameter named return value type inference default value", "function parameter named return value type inference default"], "_raw_llm_output": "struct definition, interface definition, struct field access, function definition, function return values, function parameter passing, function parameter definition, function parameter type, function parameter type inference, function parameter default value, function parameter named return value, function parameter named return value type, function parameter named return value type inference, function parameter named return value default value, function parameter named return value type default value, function parameter named return value type inference default value, function parameter named return value type inference default value, function parameter named return value type inference default value, function parameter named return value type inference default value, function parameter named return value type inference default value, function parameter named return value type inference default value, function parameter named return value type inference default value, function parameter named return value type inference default value, function parameter named return value type inference default value, function parameter named return value type inference default value, function parameter named return value type inference default value, function parameter named return value type inference default value, function parameter named return value type inference default value, function parameter named return value type inference default value, function parameter named return value type inference default value, function parameter named return value type inference default value, function parameter named return value type inference default value, function parameter named return value type inference default"}
{"seed": "// StatusNEQ applies the NEQ predicate on the \"status\" field.\nfunc StatusNEQ(v Status) predicate.User {\n\treturn predicate.User(sql.FieldNEQ(FieldStatus, v))\n}", "id": 25630, "concepts": ["predicate.User", "sql.FieldNEQ", "sql.FieldEQ"], "_raw_llm_output": "predicate.User, sql.FieldNEQ, sql.FieldEQ"}
{"seed": "// strictSignatureCheck is used as part of the IsStandardFulfillment\n// check of any Fulfillment which has a signature as part of its body.\n// It ensures that the given public key and signature are a valid pair.\nfunc strictSignatureCheck(pk PublicKey, signature ByteSlice) error {\n\tswitch pk.Algorithm {\n\tcase SignatureAlgoEd25519:\n\t\tif len(pk.Key) != crypto.PublicKeySize {\n\t\t\treturn errors.New(\"invalid public key size in transaction\")\n\t\t}\n\t\tif len(signature) != crypto.SignatureSize {\n\t\t\treturn errors.New(\"invalid signature size in transaction\")\n\t\t}\n\t\treturn nil\n\tdefault:\n\t\treturn errors.New(\"unrecognized public key type in transaction\")\n\t}\n}", "id": 25638, "concepts": ["crypto.PublicKeySize", "crypto.SignatureSize", "switch statement", "error handling"], "_raw_llm_output": "crypto.PublicKeySize, crypto.SignatureSize, switch statement, error handling"}
{"seed": "// NotJSONAPIError returns a non-blank string if the JSON appears to be a\n// JSONAPI error response\nfunc NotJSONAPIError(actual interface{}, expected ...interface{}) (fail string) {\n\tusage := \"BeJSONAPIArray expects a single string argument and passes if that argument parses as a JSONAPI multi-object array.\"\n\tif actual == nil {\n\t\treturn usage\n\t}\n\tjson, err := ParseJSON(actual)\n\tif err != nil {\n\t\treturn err.Error()\n\t}\n\tif json.PathExists(\"error\") {\n\t\treturn FormatFailure(\n\t\t\t\"You got what looks like a malformed jsonapi error. (It should only have .errors, an array, instead of .error, a singleton.)\",\n\t\t\tjson.GetPath(\"error\").String(),\n\t\t\t\"\",\n\t\t\t\"\",\n\t\t)\n\t}\n\tif json.PathExists(\"errors\") {\n\t\treturn FormatFailure(\n\t\t\t\"You expected a jsonapi return, but you got what looks like a jsonapi error.\",\n\t\t\tjson.GetPath(\"errors\").String(),\n\t\t\t\"\",\n\t\t\t\"\",\n\t\t)\n\t}\n\treturn\n}", "id": 25663, "concepts": ["JSON parsing", "JSONAPI parsing", "error handling", "JSONAPI error handling"], "_raw_llm_output": "JSON parsing, JSONAPI parsing, error handling, JSONAPI error handling"}
{"seed": "// ParsePropertiesFormat parses the properties format configuration into map[string]string\nfunc ParsePropertiesFormat(properties string) map[string]string {\n\tconfig := map[string]string{}\n\n\tsplitProps := strings.Split(properties, \"\\n\")\n\n\tfor _, line := range splitProps {\n\t\tif equal := strings.Index(line, \"=\"); equal >= 0 {\n\t\t\tif key := strings.TrimSpace(line[:equal]); len(key) > 0 {\n\t\t\t\tvalue := \"\"\n\t\t\t\tif len(line) > equal {\n\t\t\t\t\tvalue = strings.TrimSpace(line[equal+1:])\n\t\t\t\t}\n\t\t\t\tconfig[key] = value\n\t\t\t}\n\t\t}\n\t}\n\n\treturn config\n}", "id": 25670, "concepts": ["string manipulation", "string splitting", "map iteration", "string trimming", "string indexing"], "_raw_llm_output": "string manipulation, string splitting, map iteration, string trimming, string indexing"}
{"seed": "// NewGetConfigsClusterParams creates a new GetConfigsClusterParams object\n// with the default values initialized.\nfunc NewGetConfigsClusterParams() *GetConfigsClusterParams {\n\tvar ()\n\treturn &GetConfigsClusterParams{\n\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 25676, "concepts": ["struct initialization", "default values", "function definition"], "_raw_llm_output": "struct initialization, default values, function definition"}
{"seed": "// ParseLinesOfInts runs ParseInts on every string in the passed slice, passing\n// back a slice of slices of ints.\nfunc ParseLinesOfInts(commaStrings []string, separator string) ([][]int, error) {\n\tresult := make([][]int, 0, len(commaStrings))\n\tfor _, commaString := range commaStrings {\n\t\tints, err := ParseInts(commaString, separator)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresult = append(result, ints)\n\t}\n\treturn result, nil\n}", "id": 25677, "concepts": ["slice iteration (range loop)", "slice append", "error handling (idiomatic if err != nil)", "error handling (errors.As)", "error handling (errors.Is)", "concurrency", "standard library usage"], "_raw_llm_output": "slice iteration (range loop), slice append, error handling (idiomatic if err != nil), error handling (errors.As), error handling (errors.Is), concurrency, standard library usage"}
{"seed": "// PossibleSaaSOfferStatusValues returns the possible values for the SaaSOfferStatus const type.\nfunc PossibleSaaSOfferStatusValues() []SaaSOfferStatus {\n\treturn []SaaSOfferStatus{\n\t\tSaaSOfferStatusFailed,\n\t\tSaaSOfferStatusInProgress,\n\t\tSaaSOfferStatusPendingFulfillmentStart,\n\t\tSaaSOfferStatusReinstated,\n\t\tSaaSOfferStatusStarted,\n\t\tSaaSOfferStatusSubscribed,\n\t\tSaaSOfferStatusSucceeded,\n\t\tSaaSOfferStatusSuspended,\n\t\tSaaSOfferStatusUnsubscribed,\n\t\tSaaSOfferStatusUpdating,\n\t}\n}", "id": 25726, "concepts": ["constants", "type definition", "type conversion"], "_raw_llm_output": "constants, type definition, type conversion"}
{"seed": "// Exists returns true/false depending if the file indicated in path, exists or not\nfunc Exists(path string) bool {\n\tif _, err := os.Stat(path); err == nil {\n\t\treturn true\n\t}\n\treturn false\n}", "id": 25745, "concepts": ["os package usage", "file existence check"], "_raw_llm_output": "os package usage, file existence check"}
{"seed": "// NewCumulativeGainsIndicator returns a derivative indicator which returns all gains made in a base indicator for a given\n// window.\nfunc NewCumulativeGainsIndicator(indicator Indicator, window int) Indicator {\n\treturn cumulativeIndicator{\n\t\tIndicator: indicator,\n\t\twindow:    window,\n\t\tmult:      big.ONE,\n\t}\n}", "id": 25756, "concepts": ["struct definition", "interface definition", "function definition", "anonymous function definition", "function composition"], "_raw_llm_output": "struct definition, interface definition, function definition, anonymous function definition, function composition"}
{"seed": "// PathBits specifies a graph.Bits value for nodes of the path to the\n// currently visited node.\n//\n// A use for PathBits is identifying back arcs in a search.\n//\n// Unlike Visited, PathBits are zeroed at the start of a search.\nfunc PathBits(b *graph.Bits) func(*config) {\n\treturn func(c *config) { c.pathBits = b }\n}", "id": 25760, "concepts": ["function composition", "function definition", "function composition"], "_raw_llm_output": "function composition, function definition, function composition"}
{"seed": "/* NewNode creates a pointer to a Node object. The value and parent can be set,\nwhile the other values are set to default values.*/\nfunc NewNode(v float64, parent *Node) *Node {\n\tn := new(Node)\n\tn.Value = v\n\tn.Children = NewNodeList()\n\tn.Parent = parent\n\tn.Marked = false\n\tn.Next = nil\n\tn.prev = nil\n\treturn n\n}", "id": 25766, "concepts": ["struct definition", "pointer usage", "struct initialization"], "_raw_llm_output": "struct definition, pointer usage, struct initialization"}
{"seed": "// newFollowersPageView projects result type FollowersPage to projected type\n// FollowersPageView using the \"default\" view.\nfunc newFollowersPageView(res *FollowersPage) *followingviews.FollowersPageView {\n\tvres := &followingviews.FollowersPageView{\n\t\tTotal: &res.Total,\n\t\tPage:  &res.Page,\n\t}\n\tif res.Followers != nil {\n\t\tvres.Followers = newFollowerCollectionView(res.Followers)\n\t}\n\treturn vres\n}", "id": 25767, "concepts": ["type aliasing", "type conversion", "type assertion", "type projection"], "_raw_llm_output": "type aliasing, type conversion, type assertion, type projection"}
{"seed": "// findTargetIDAndMethod finds ID of the target service and method from the following three places:\n// 1. HTTP header 'dapr-app-id' (path is method)\n// 2. Basic auth header: `http://dapr-app-id:<service-id>@localhost:3500/<method>`\n// 3. URL parameter: `http://localhost:3500/v1.0/invoke/<app-id>/method/<method>`\nfunc findTargetIDAndMethod(reqPath string, headers http.Header) (targetID string, method string) {\n\tif appID := headers.Get(daprAppID); appID != \"\" {\n\t\treturn appID, strings.TrimPrefix(path.Clean(reqPath), \"/\")\n\t}\n\n\tif auth := headers.Get(\"Authorization\"); strings.HasPrefix(auth, \"Basic \") {\n\t\tif s, err := base64.StdEncoding.DecodeString(strings.TrimPrefix(auth, \"Basic \")); err == nil {\n\t\t\tpair := strings.Split(string(s), \":\")\n\t\t\tif len(pair) == 2 && pair[0] == daprAppID {\n\t\t\t\treturn pair[1], strings.TrimPrefix(path.Clean(reqPath), \"/\")\n\t\t\t}\n\t\t}\n\t}\n\n\t// If we're here, the handler was probably invoked with /v1.0/invoke/ (or the invocation is invalid, missing the app id provided as header or Basic auth)\n\t// However, we are not relying on wildcardParam because the URL may have been sanitized to remove `//``, so `http://` would have been turned into `http:/`\n\t// First, check to make sure that the path has the prefix\n\tif idx := pathHasPrefix(reqPath, apiVersionV1, \"invoke\"); idx > 0 {\n\t\treqPath = reqPath[idx:]\n\n\t\t// Scan to find app ID and method\n\t\t// Matches `<appid>/method/<method>`.\n\t\t// Examples:\n\t\t// - `appid/method/mymethod`\n\t\t// - `http://example.com/method/mymethod`\n\t\t// - `https://example.com/method/mymethod`\n\t\t// - `http%3A%2F%2Fexample.com/method/mymethod`\n\t\tif idx = strings.Index(reqPath, \"/method/\"); idx > 0 {\n\t\t\ttargetID := reqPath[:idx]\n\t\t\tmethod := reqPath[(idx + len(\"/method/\")):]\n\t\t\tif t, _ := url.QueryUnescape(targetID); t != \"\" {\n\t\t\t\ttargetID = t\n\t\t\t}\n\t\t\treturn targetID, method\n\t\t}\n\t}\n\n\treturn \"\", \"\"\n}", "id": 25771, "concepts": ["string manipulation", "path manipulation", "URL parsing", "string formatting", "string comparison", "string prefix check", "string index check", "string slice", "string slice manipulation", "string slice iteration (range loop)", "string slice concatenation", "string slice removal", "string slice removal (range loop)", "string slice removal (range loop)", "string slice removal (range loop)", "string slice removal (range loop)", "string slice removal (range loop)", "string slice removal (range loop)", "string slice removal (range loop)", "string slice removal (range loop)", "string slice removal (range loop)", "string slice removal (range loop)", "string slice removal (range loop)", "string slice removal (range loop)", "string slice removal (range loop)", "string slice removal (range loop)", "string slice removal (range loop)", "string slice removal (range loop)", "string slice removal (range loop)", "string slice removal (range loop)", "string slice removal (range loop)", "string slice removal (range loop)", "string slice removal (range loop)", "string slice removal (range loop)", "string slice removal (range loop)", "string slice removal (range loop)", "string slice removal (range loop)", "string slice removal (range loop)", "string slice removal (range loop)", "string slice removal (range loop)", "string slice removal (range loop)", "string slice removal (range loop"], "_raw_llm_output": "string manipulation, path manipulation, URL parsing, string formatting, string comparison, string prefix check, string index check, string slice, string slice manipulation, string slice iteration (range loop), string slice concatenation, string slice removal, string slice removal (range loop), string slice removal (range loop), string slice removal (range loop), string slice removal (range loop), string slice removal (range loop), string slice removal (range loop), string slice removal (range loop), string slice removal (range loop), string slice removal (range loop), string slice removal (range loop), string slice removal (range loop), string slice removal (range loop), string slice removal (range loop), string slice removal (range loop), string slice removal (range loop), string slice removal (range loop), string slice removal (range loop), string slice removal (range loop), string slice removal (range loop), string slice removal (range loop), string slice removal (range loop), string slice removal (range loop), string slice removal (range loop), string slice removal (range loop), string slice removal (range loop), string slice removal (range loop), string slice removal (range loop), string slice removal (range loop), string slice removal (range loop), string slice removal (range loop"}
{"seed": "// Nav_ is a convenience wrapper for Nav without the attrs argument.\nfunc Nav_(children ...HTML) HTML {\n  return Nav(nil, children...)\n}", "id": 25777, "concepts": ["basic function definition", "variadic function definition", "function argument handling", "HTML rendering"], "_raw_llm_output": "basic function definition, variadic function definition, function argument handling, HTML rendering"}
{"seed": "// \u5982\u679c\u4e24\u4e2a\u6570\u51fa\u73b0\u4e86\u5947\u6570\u6b21\uff0c\u5176\u4ed6\u6570\u90fd\u51fa\u73b0\u5076\u6570\u6b21\n// \u90a3\u4e48\u4ea6\u6216\u4e4b\u540e\uff0c\u80af\u5b9a\u4f1a\u662fa^b != 0\n// a^b\u4e2d\u81f3\u5c11\u67091\u4f4d\u662f1\uff0c\u8be5\u4f4d\u4e0aab\u5f02\u53f7\n// \u636e\u6b64\uff0c\u518d\u6b21\u904d\u5386\u6570\u7ec4\uff0c\u5373\u53ef\u533a\u5206\u51faa\uff0cb\n\nfunc printOddTimesNum2(a []int) (int, int) {\n\tret := 0\n\tret2 := 0\n\tfor _, num := range a {\n\t\tret ^= num\n\t}\n\t// ret == a^b\n\tlowbit := ret & (^ret + 1) // lowbit\u5f80\u53f3\u90fd\u4e00\u6837\uff0c\u5f80\u5de6\u4ecd\u7136\u76f8\u53cd\n\tfor _, num := range a {\n\t\tif (num & lowbit) != 0 {\n\t\t\tret2 ^= num\n\t\t}\n\t}\n\t// ret2 == a || ret2  == b\n\treturn ret2, ret ^ ret2\n\n}", "id": 25784, "concepts": ["\u4ea6\u6216\uff0c\u4f4d\u8fd0\u7b97\uff0c\u5f02\u6216\uff0c\u4f4d\u8fd0\u7b97\uff0c\u4f4d\u8fd0\u7b97\uff0c\u4f4d\u8fd0\u7b97\uff0c\u4f4d\u8fd0\u7b97"], "_raw_llm_output": "\u4ea6\u6216\uff0c\u4f4d\u8fd0\u7b97\uff0c\u5f02\u6216\uff0c\u4f4d\u8fd0\u7b97\uff0c\u4f4d\u8fd0\u7b97\uff0c\u4f4d\u8fd0\u7b97\uff0c\u4f4d\u8fd0\u7b97"}
{"seed": "// DescriptionLTE applies the LTE predicate on the \"description\" field.\nfunc DescriptionLTE(v string) predicate.User {\n\treturn predicate.User(sql.FieldLTE(FieldDescription, v))\n}", "id": 25786, "concepts": ["SQL query building", "SQL query building (field-based)", "SQL query building (field-based)", "SQL query building (field-based)"], "_raw_llm_output": "SQL query building, SQL query building (field-based), SQL query building (field-based), SQL query building (field-based)"}
{"seed": "// Cook up a unique-ish UNIX-domain socket name\n// in /var/tmp, for the coordinator.\n// Can't use the current directory since\n// Athena AFS doesn't support UNIX-domain sockets.\nfunc coordinatorSock() string {\n\ts := \"/var/tmp/824-mr-\"\n\ts += strconv.Itoa(os.Getuid())\n\treturn s\n}", "id": 25798, "concepts": ["string manipulation", "string formatting", "string concatenation", "integer conversion", "os package usage"], "_raw_llm_output": "string manipulation, string formatting, string concatenation, integer conversion, os package usage"}
{"seed": "// Successful returns an error if the status code is not 2xx.\nfunc Successful(resp *http.Response) error {\n\tif resp == nil {\n\t\treturn errors.New(\"nil response\")\n\t}\n\tif resp.StatusCode/100 != 2 {\n\t\tb, _ := readAtMost(resp.Body, HTTPStatusErrorBodyMaxLength)\n\t\treturn &HTTPStatusError{\n\t\t\tStatusCode: resp.StatusCode,\n\t\t\tBody:       string(b),\n\t\t}\n\t}\n\treturn nil\n}", "id": 25799, "concepts": ["http.Response", "error handling", "error wrapping", "readAtMost"], "_raw_llm_output": "http.Response, error handling, error wrapping, readAtMost"}
{"seed": "// ParseImportProviderDNSZoneResponse parses an HTTP response from a ImportProviderDNSZoneWithResponse call\nfunc ParseImportProviderDNSZoneResponse(rsp *http.Response) (*ImportProviderDNSZoneResponse, error) {\n\tbodyBytes, err := ioutil.ReadAll(rsp.Body)\n\tdefer rsp.Body.Close()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse := &ImportProviderDNSZoneResponse{\n\t\tBody:         bodyBytes,\n\t\tHTTPResponse: rsp,\n\t}\n\n\tswitch {\n\tcase strings.Contains(rsp.Header.Get(\"Content-Type\"), \"json\") && rsp.StatusCode == 200:\n\t\tvar dest ScalewayDomainV2alpha2ImportProviderDNSZoneResponse\n\t\tif err := json.Unmarshal(bodyBytes, &dest); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresponse.JSON200 = &dest\n\n\t}\n\n\treturn response, nil\n}", "id": 25808, "concepts": ["HTTP response parsing", "JSON parsing", "error handling"], "_raw_llm_output": "HTTP response parsing, JSON parsing, error handling"}
{"seed": "// NewContentWithDefaults instantiates a new Content object\n// This constructor will only assign default values to properties that have it defined,\n// but it doesn't guarantee that properties required by API are set\nfunc NewContentWithDefaults() *Content {\n\tthis := Content{}\n\tvar accessType string = \"acl\"\n\tthis.AccessType = &accessType\n\tvar runAsCurrentUser bool = false\n\tthis.RunAsCurrentUser = &runAsCurrentUser\n\treturn &this\n}", "id": 25814, "concepts": ["struct", "pointer", "default values", "nil pointer"], "_raw_llm_output": "struct, pointer, default values, nil pointer"}
{"seed": "// CheckAndCreateSparseFile will reuse the existing sparse file if it already exists,\n// for handling cases where NDM is upgraded or restarted. If the file doesn't exist\n// a new file will be created.\nfunc CheckAndCreateSparseFile(sparseFile string, sparseFileSize int64) error {\n\tsparseFileInfo, err := util.SparseFileInfo(sparseFile)\n\tif err != nil {\n\t\tklog.Info(\"Check for existing file returned error: \", err)\n\t\tklog.Info(\"Creating a new Sparse file: \", sparseFile)\n\t\terr = util.SparseFileCreate(sparseFile, sparseFileSize)\n\t} else {\n\t\tklog.Info(\"Sparse file already exists: \", sparseFileInfo.Name())\n\t}\n\treturn err\n}", "id": 25825, "concepts": ["sparse file handling", "sparse file creation", "sparse file existence check"], "_raw_llm_output": "sparse file handling, sparse file creation, sparse file existence check"}
{"seed": "// NewTHSRAPIDailyTrainInfo21233NotModified creates a THSRAPIDailyTrainInfo21233NotModified with default headers values\nfunc NewTHSRAPIDailyTrainInfo21233NotModified() *THSRAPIDailyTrainInfo21233NotModified {\n\treturn &THSRAPIDailyTrainInfo21233NotModified{}\n}", "id": 25826, "concepts": ["struct", "pointer", "method", "function definition", "struct initialization"], "_raw_llm_output": "struct, pointer, method, function definition, struct initialization"}
{"seed": "// NewNiatelemetryNveVniWithDefaults instantiates a new NiatelemetryNveVni object\n// This constructor will only assign default values to properties that have it defined,\n// but it doesn't guarantee that properties required by API are set\nfunc NewNiatelemetryNveVniWithDefaults() *NiatelemetryNveVni {\n\tthis := NiatelemetryNveVni{}\n\tvar classId string = \"niatelemetry.NveVni\"\n\tthis.ClassId = classId\n\tvar objectType string = \"niatelemetry.NveVni\"\n\tthis.ObjectType = objectType\n\treturn &this\n}", "id": 25831, "concepts": ["constructor", "object initialization", "object type definition", "class ID definition"], "_raw_llm_output": "constructor, object initialization, object type definition, class ID definition"}
{"seed": "// If skip is true, just append to the queue and return\n// nothing. Otherwise, if there is something in the queue, return\n// it. Otherwise, just pass it right through.\nfunc checkSetAside(dp *IncomingDP, queue *dpQueue, skip bool) *IncomingDP {\n\n\tif skip {\n\t\tqueue.push(dp)\n\t\treturn nil\n\t}\n\n\tif queue.size() > 0 {\n\t\treturn queue.pop()\n\t}\n\n\treturn dp\n}", "id": 25835, "concepts": ["queue", "concurrency", "mutex", "standard library usage"], "_raw_llm_output": "queue, concurrency, mutex, standard library usage"}
{"seed": "// DefaultParams returns parameters with reasonable default values that are safe to use.\n// Be aware that default parameters may change from release to release to reflect\n// updates and changes in security requirements.\nfunc DefaultParams() *Params {\n\tp := Params{\n\t\tKeyLength:          512,\n\t\tInternalSaltLength: 256,\n\t\tExternalSaltLength: 256,\n\t\tArgon2Memory:       64 * 1024,\n\t\tArgon2Iterations:   3,\n\t\tArgon2Parallelism:  4}\n\treturn &p\n}", "id": 25837, "concepts": ["struct", "pointer", "method definition", "default parameter values"], "_raw_llm_output": "struct, pointer, method definition, default parameter values"}
{"seed": "// compressMotionNotify takes a MotionNotify event, and inspects the event\n// queue for any future MotionNotify events that can be received without\n// blocking. The most recent MotionNotify event is then returned.\n// Note that we need to make sure that the Event, Child, Detail, State, Root\n// and SameScreen fields are the same to ensure the same window/action is\n// generating events. That is, we are only compressing the RootX, RootY,\n// EventX and EventY fields.\n// This function is not thread safe, since Peek returns a *copy* of the\n// event queue---which could be out of date by the time we dequeue events.\nfunc compressMotionNotify(X *xgbutil.XUtil,\n\tev xevent.MotionNotifyEvent) xevent.MotionNotifyEvent {\n\n\t// We force a round trip request so that we make sure to read all\n\t// available events.\n\tX.Sync()\n\txevent.Read(X, false)\n\n\t// The most recent MotionNotify event that we'll end up returning.\n\tlaste := ev\n\n\t// Look through each event in the queue. If it's an event and it matches\n\t// all the fields in 'ev' that are detailed above, then set it to 'laste'.\n\t// In which case, we'll also dequeue the event, otherwise it will be\n\t// processed twice!\n\t// N.B. If our only goal was to find the most recent relevant MotionNotify\n\t// event, we could traverse the event queue backwards and simply use\n\t// the first MotionNotify we see. However, this could potentially leave\n\t// other MotionNotify events in the queue, which we *don't* want to be\n\t// processed. So we stride along and just pick off MotionNotify events\n\t// until we don't see any more.\n\tfor i, ee := range xevent.Peek(X) {\n\t\tif ee.Err != nil { // This is an error, skip it.\n\t\t\tcontinue\n\t\t}\n\n\t\t// Use type assertion to make sure this is a MotionNotify event.\n\t\tif mn, ok := ee.Event.(xproto.MotionNotifyEvent); ok {\n\t\t\t// Now make sure all appropriate fields are equivalent.\n\t\t\tif ev.Event == mn.Event && ev.Child == mn.Child &&\n\t\t\t\tev.Detail == mn.Detail && ev.State == mn.State &&\n\t\t\t\tev.Root == mn.Root && ev.SameScreen == mn.SameScreen {\n\n\t\t\t\t// Set the most recent/valid motion notify event.\n\t\t\t\tlaste = xevent.MotionNotifyEvent{&mn}\n\n\t\t\t\t// We cheat and use the stack semantics of defer to dequeue\n\t\t\t\t// most recent motion notify events first, so that the indices\n\t\t\t\t// don't become invalid. (If we dequeued oldest first, we'd\n\t\t\t\t// have to account for all future events shifting to the left\n\t\t\t\t// by one.)\n\t\t\t\tdefer func(i int) { xevent.DequeueAt(X, i) }(i)\n\t\t\t}\n\t\t}\n\t}\n\n\t// This isn't strictly necessary, but is correct. We should update\n\t// xgbutil's sense of time with the most recent event processed.\n\t// This is typically done in the main event loop, but since we are\n\t// subverting the main event loop, we should take care of it.\n\tX.TimeSet(laste.Time)\n\n\treturn laste\n}", "id": 25847, "concepts": ["event queue", "event queue iteration", "event queue dequeue", "event queue peek", "event queue synchronization", "event queue dequeue at index", "event queue dequeue oldest first", "event queue dequeue newest first", "event queue dequeue oldest first", "event queue dequeue newest first", "event queue dequeue oldest first", "event queue dequeue newest first", "event queue dequeue oldest first", "event queue dequeue newest first", "event queue dequeue oldest first", "event queue dequeue newest first", "event queue dequeue oldest first", "event queue dequeue newest first", "event queue dequeue oldest first", "event queue dequeue newest first", "event queue dequeue oldest first", "event queue dequeue newest first", "event queue dequeue oldest first", "event queue dequeue newest first", "event queue dequeue oldest first", "event queue dequeue newest first", "event queue dequeue oldest first", "event queue dequeue newest first", "event queue dequeue oldest first", "event queue dequeue newest first", "event queue dequeue oldest first", "event queue dequeue newest first", "event queue dequeue oldest first", "event queue dequeue newest first", "event queue dequeue oldest first", "event queue dequeue newest first", "event queue dequeue oldest first", "event queue dequeue newest first", "event queue dequeue"], "_raw_llm_output": "event queue, event queue iteration, event queue dequeue, event queue peek, event queue synchronization, event queue dequeue at index, event queue dequeue oldest first, event queue dequeue newest first, event queue dequeue oldest first, event queue dequeue newest first, event queue dequeue oldest first, event queue dequeue newest first, event queue dequeue oldest first, event queue dequeue newest first, event queue dequeue oldest first, event queue dequeue newest first, event queue dequeue oldest first, event queue dequeue newest first, event queue dequeue oldest first, event queue dequeue newest first, event queue dequeue oldest first, event queue dequeue newest first, event queue dequeue oldest first, event queue dequeue newest first, event queue dequeue oldest first, event queue dequeue newest first, event queue dequeue oldest first, event queue dequeue newest first, event queue dequeue oldest first, event queue dequeue newest first, event queue dequeue oldest first, event queue dequeue newest first, event queue dequeue oldest first, event queue dequeue newest first, event queue dequeue oldest first, event queue dequeue newest first, event queue dequeue oldest first, event queue dequeue newest first, event queue dequeue"}
{"seed": "// DropOptionalIn applies the In predicate on the \"drop_optional\" field.\nfunc DropOptionalIn(vs ...string) predicate.User {\n\treturn predicate.User(sql.FieldIn(FieldDropOptional, vs...))\n}", "id": 25850, "concepts": ["sql.FieldIn", "sql.FieldNotIn", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldBetween", "sql.FieldNotBetween", "sql.FieldIsNull", "sql.FieldIsNotNull", "sql.FieldIs", "sql.FieldIsNot", "sql.FieldContains", "sql.FieldNotContains", "sql.FieldStartsWith", "sql.FieldNotStartsWith", "sql.FieldEndsWith", "sql.FieldNotEndsWith", "sql.FieldRegex", "sql.FieldNotRegex", "sql.FieldIn", "sql.FieldNotIn", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldBetween", "sql.FieldNotBetween", "sql.FieldIsNull", "sql.FieldIsNotNull", "sql.FieldIs", "sql.FieldIsNot", "sql.FieldContains", "sql.FieldNotContains", "sql.FieldStartsWith", "sql.FieldNotStartsWith", "sql.FieldEndsWith", "sql.FieldNotEndsWith", "sql.FieldRegex", "sql.FieldNotRegex"], "_raw_llm_output": "sql.FieldIn, sql.FieldNotIn, sql.FieldLike, sql.FieldNotLike, sql.FieldBetween, sql.FieldNotBetween, sql.FieldIsNull, sql.FieldIsNotNull, sql.FieldIs, sql.FieldIsNot, sql.FieldContains, sql.FieldNotContains, sql.FieldStartsWith, sql.FieldNotStartsWith, sql.FieldEndsWith, sql.FieldNotEndsWith, sql.FieldRegex, sql.FieldNotRegex, sql.FieldIn, sql.FieldNotIn, sql.FieldLike, sql.FieldNotLike, sql.FieldBetween, sql.FieldNotBetween, sql.FieldIsNull, sql.FieldIsNotNull, sql.FieldIs, sql.FieldIsNot, sql.FieldContains, sql.FieldNotContains, sql.FieldStartsWith, sql.FieldNotStartsWith, sql.FieldEndsWith, sql.FieldNotEndsWith, sql.FieldRegex, sql.FieldNotRegex"}
{"seed": "// proxyConn proxies between an existing net.Conn and a destination address. If\n// the destAddr starts with \"unix://\" it is treated as a path to a unix socket.\n// Otherwise it is treated as a host for a TCP connection.\n//\n// When the context is cancelled proxyConn blocks until all goroutines shutdown\n// to prevent leaks.\nfunc proxyConn(ctx context.Context, logger hclog.Logger, destAddr string, conn net.Conn) {\n\t// Close the connection when we're done with it.\n\tdefer conn.Close()\n\n\tctx, cancel := context.WithCancel(ctx)\n\tdefer cancel()\n\n\t// Detect unix sockets\n\tnetwork := \"tcp\"\n\tconst unixPrefix = \"unix://\"\n\tif strings.HasPrefix(destAddr, unixPrefix) {\n\t\tnetwork = \"unix\"\n\t\tdestAddr = destAddr[len(unixPrefix):]\n\t}\n\n\tdialer := &net.Dialer{}\n\tdest, err := dialer.DialContext(ctx, network, destAddr)\n\tif err == context.Canceled || err == context.DeadlineExceeded {\n\t\tlogger.Trace(\"proxy exiting gracefully\", \"error\", err, \"dest\", destAddr,\n\t\t\t\"src_local\", conn.LocalAddr(), \"src_remote\", conn.RemoteAddr())\n\t\treturn\n\t}\n\tif err != nil {\n\t\tlogger.Error(\"error connecting to grpc\", \"error\", err, \"dest\", destAddr)\n\t\treturn\n\t}\n\n\t// Wait for goroutines to exit before exiting to prevent leaking.\n\twg := sync.WaitGroup{}\n\tdefer wg.Wait()\n\n\t// socket -> consul\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tdefer cancel()\n\t\tn, err := io.Copy(dest, conn)\n\t\tif ctx.Err() == nil && err != nil {\n\t\t\t// expect disconnects when proxying http\n\t\t\tlogger.Trace(\"error message received proxying to Consul\",\n\t\t\t\t\"msg\", err, \"dest\", destAddr, \"src_local\", conn.LocalAddr(),\n\t\t\t\t\"src_remote\", conn.RemoteAddr(), \"bytes\", n)\n\t\t\treturn\n\t\t}\n\t\tlogger.Trace(\"proxy to Consul complete\",\n\t\t\t\"src_local\", conn.LocalAddr(), \"src_remote\", conn.RemoteAddr(),\n\t\t\t\"bytes\", n,\n\t\t)\n\t}()\n\n\t// consul -> socket\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tdefer cancel()\n\t\tn, err := io.Copy(conn, dest)\n\t\tif ctx.Err() == nil && err != nil {\n\t\t\tlogger.Trace(\"error message received proxying from Consul\",\n\t\t\t\t\"msg\", err, \"dest\", destAddr, \"src_local\", conn.LocalAddr(),\n\t\t\t\t\"src_remote\", conn.RemoteAddr(), \"bytes\", n)\n\t\t\treturn\n\t\t}\n\t\tlogger.Trace(\"proxy from Consul complete\",\n\t\t\t\"src_local\", conn.LocalAddr(), \"src_remote\", conn.RemoteAddr(),\n\t\t\t\"bytes\", n,\n\t\t)\n\t}()\n\n\t// When cancelled close connections to break out of copies goroutines.\n\t<-ctx.Done()\n\t_ = conn.Close()\n\t_ = dest.Close()\n}", "id": 25852, "concepts": ["net.DialContext", "net.Conn.Close", "context.WithCancel", "context.WithDeadline", "context.DeadlineExceeded", "context.Canceled", "io.Copy", "sync.WaitGroup", "anonymous function", "concurrency", "standard library usage"], "_raw_llm_output": "net.DialContext, net.Conn.Close, context.WithCancel, context.WithDeadline, context.DeadlineExceeded, context.Canceled, io.Copy, sync.WaitGroup, anonymous function, concurrency, standard library usage"}
{"seed": "// NewForConfigOrDie creates a new LekvaV1Client for the given config and\n// panics if there is an error in the config.\nfunc NewForConfigOrDie(c *rest.Config) *LekvaV1Client {\n\tclient, err := NewForConfig(c)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn client\n}", "id": 25864, "concepts": ["panic", "error handling (idiomatic if err != nil)", "standard library usage"], "_raw_llm_output": "panic, error handling (idiomatic if err != nil), standard library usage"}
{"seed": "// ServiceUnitName returns a systemd service unit name for the given app name.\nfunc ServiceUnitName(appName types.ACName) string {\n\treturn appName.String() + \".service\"\n}", "id": 25865, "concepts": ["type conversion", "string formatting", "string concatenation"], "_raw_llm_output": "type conversion, string formatting, string concatenation"}
{"seed": "// testFrontMatterKeywords tests if keywords are present and correctly\n// formatted in given markdown file bytes\nfunc testFrontMatterKeywords(mdBytes []byte) error {\n\tfm, _, err := frontparser.ParseFrontmatterAndContent(mdBytes)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tkeywords, exists := fm[\"keywords\"]\n\n\t// it's ok to have a page without keywords\n\tif exists == false {\n\t\treturn nil\n\t}\n\n\tif _, ok := keywords.(string); !ok {\n\t\treturn errors.New(\"keywords should be a comma separated string\")\n\t}\n\n\treturn nil\n}", "id": 25880, "concepts": ["frontmatter parsing", "frontmatter usage", "string manipulation", "errors.New", "type assertion"], "_raw_llm_output": "frontmatter parsing, frontmatter usage, string manipulation, errors.New, type assertion"}
{"seed": "// PossibleActionTypeValues returns an array of possible values for the ActionType const type.\nfunc PossibleActionTypeValues() []ActionType {\n\treturn []ActionType{ActionTypeAllow, ActionTypeBlock, ActionTypeLog, ActionTypeRedirect}\n}", "id": 25882, "concepts": ["const type", "array definition", "array iteration"], "_raw_llm_output": "const type, array definition, array iteration"}
{"seed": "// NameEqualFold applies the EqualFold predicate on the \"name\" field.\nfunc NameEqualFold(v string) predicate.User {\n\treturn predicate.User(sql.FieldEqualFold(FieldName, v))\n}", "id": 25896, "concepts": ["predicate.User", "sql.FieldEqualFold", "predicate.FieldEqualFold"], "_raw_llm_output": "predicate.User, sql.FieldEqualFold, predicate.FieldEqualFold"}
{"seed": "// PlaybackMode_Values returns all elements of the PlaybackMode enum\nfunc PlaybackMode_Values() []string {\n\treturn []string{\n\t\tPlaybackModeLoop,\n\t\tPlaybackModeLinear,\n\t}\n}", "id": 25905, "concepts": ["enum usage", "string formatting", "standard library usage"], "_raw_llm_output": "enum usage, string formatting, standard library usage"}
{"seed": "// CreateDeviceManagementComplexSettingDefinitionFromDiscriminatorValue creates a new instance of the appropriate class based on discriminator value\nfunc CreateDeviceManagementComplexSettingDefinitionFromDiscriminatorValue(parseNode i878a80d2330e89d26896388a3f487eef27b0a0e6c010c493bf80be1452208f91.ParseNode)(i878a80d2330e89d26896388a3f487eef27b0a0e6c010c493bf80be1452208f91.Parsable, error) {\n    return NewDeviceManagementComplexSettingDefinition(), nil\n}", "id": 25917, "concepts": ["interface implementation", "struct definition", "anonymous function", "function definition", "basic function definition"], "_raw_llm_output": "interface implementation, struct definition, anonymous function, function definition, basic function definition"}
{"seed": "// Bdi represents the HTML element 'bdi'.\n// For more information visit https://www.w3schools.com/tags/tag_bdi.asp.\nfunc Bdi(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"bdi\", Attributes: attrs, Children: children}\n}", "id": 25920, "concepts": ["HTML generation", "HTML manipulation", "HTML tree traversal", "HTML element definition", "HTML attribute definition"], "_raw_llm_output": "HTML generation, HTML manipulation, HTML tree traversal, HTML element definition, HTML attribute definition"}
{"seed": "// doCut performs cutting Column t by Cut c.\n// It returns new columns created with this cut and boolean flag if there was some cut or not.\n// If there was cut new columns can be also empty which means that whole column was destroyed by this cut.\nfunc doCut(t *Column, c Cut) ([]*Column, bool) {\n\t// get dimensions\n\tx, y := t.Position()\n\t_, h := t.Size()\n\n\t// is cut line out of column ?\n\tif c.MaxY < y || c.MinY > y+h-1 {\n\t\treturn nil, false\n\t}\n\n\t// init cut\n\tcuttingParts := []*Column{}\n\n\t// local y coordinates of cut hole\n\ttopy := gmath.Max(0, c.MinY-y)\n\tbottomy := gmath.Min(h-1, c.MaxY-y)\n\n\t// create two new columns around cut hole\n\tcanvas := *t.canvas\n\ttopCol := NewColumn(t.terrain, x, y, &tl.Canvas{canvas[0][:topy]})\n\tbottomCol := NewColumn(t.terrain, x, y+bottomy+1, &tl.Canvas{canvas[0][bottomy+1:]})\n\n\t// add top column if it has non zero height\n\t_, h1 := topCol.Size()\n\tif h1 > 0 {\n\t\tcuttingParts = append(cuttingParts, topCol)\n\t}\n\n\t// add bottom column if it has non zero height\n\t_, h2 := bottomCol.Size()\n\tif h2 > 0 {\n\t\tcuttingParts = append(cuttingParts, bottomCol)\n\t}\n\n\treturn cuttingParts, true\n}", "id": 25927, "concepts": ["slice manipulation", "slice creation", "slice iteration (range loop)", "slice concatenation", "slice slicing", "slice length", "slice capacity", "slice length", "slice capacity", "slice length", "slice capacity", "slice length", "slice capacity", "slice length", "slice capacity", "slice length", "slice capacity", "slice length", "slice capacity", "slice length", "slice capacity", "slice length", "slice capacity", "slice length", "slice capacity", "slice length", "slice capacity", "slice length", "slice capacity", "slice length", "slice capacity", "slice length", "slice capacity", "slice length", "slice capacity", "slice length", "slice capacity", "slice length", "slice capacity", "slice length", "slice capacity", "slice length", "slice capacity", "slice length", "slice capacity", "slice length", "slice capacity", "slice length", "slice capacity", "slice length", "slice capacity", "slice length", "slice capacity", "slice length", "slice capacity", "slice length", "slice capacity", "slice length", "slice capacity", "slice length", "slice capacity", "slice length", "slice capacity", "slice length", "slice capacity", "slice length", "slice capacity", "slice length", "slice capacity", "slice length", "slice capacity", "slice length", "slice capacity", "slice length", "slice capacity", "slice length", "slice capacity", "slice length", "slice capacity", "slice length", "slice capacity", "slice length", "slice capacity", "slice"], "_raw_llm_output": "slice manipulation, slice creation, slice iteration (range loop), slice concatenation, slice slicing, slice length, slice capacity, slice length, slice capacity, slice length, slice capacity, slice length, slice capacity, slice length, slice capacity, slice length, slice capacity, slice length, slice capacity, slice length, slice capacity, slice length, slice capacity, slice length, slice capacity, slice length, slice capacity, slice length, slice capacity, slice length, slice capacity, slice length, slice capacity, slice length, slice capacity, slice length, slice capacity, slice length, slice capacity, slice length, slice capacity, slice length, slice capacity, slice length, slice capacity, slice length, slice capacity, slice length, slice capacity, slice length, slice capacity, slice length, slice capacity, slice length, slice capacity, slice length, slice capacity, slice length, slice capacity, slice length, slice capacity, slice length, slice capacity, slice length, slice capacity, slice length, slice capacity, slice length, slice capacity, slice length, slice capacity, slice length, slice capacity, slice length, slice capacity, slice length, slice capacity, slice length, slice capacity, slice length, slice capacity, slice length, slice capacity, slice"}
{"seed": "// WithEnvVarNoPrefix tells Parse to try to set flags from environment variables\n// without any specific prefix. Flag names are matched to environment variables\n// by capitalizing the flag name, and replacing separator characters like\n// periods or hyphens with underscores. By default, flags are not set from\n// environment variables at all.\nfunc WithEnvVarNoPrefix() Option {\n\treturn func(c *Context) {\n\t\tc.envVarNoPrefix = true\n\t}\n}", "id": 25928, "concepts": ["environment variable handling", "function composition", "function option pattern"], "_raw_llm_output": "environment variable handling, function composition, function option pattern"}
{"seed": "// NewListEngineTypeParamsWithContext creates a new ListEngineTypeParams object\n// with the default values initialized, and the ability to set a context for a request\nfunc NewListEngineTypeParamsWithContext(ctx context.Context) *ListEngineTypeParams {\n\tvar ()\n\treturn &ListEngineTypeParams{\n\n\t\tContext: ctx,\n\t}\n}", "id": 25929, "concepts": ["context package usage", "function definition", "struct definition"], "_raw_llm_output": "context package usage, function definition, struct definition"}
{"seed": "// FirewallFailOpenStatus_Values returns all elements of the FirewallFailOpenStatus enum\nfunc FirewallFailOpenStatus_Values() []string {\n\treturn []string{\n\t\tFirewallFailOpenStatusEnabled,\n\t\tFirewallFailOpenStatusDisabled,\n\t\tFirewallFailOpenStatusUseLocalResourceSetting,\n\t}\n}", "id": 25930, "concepts": ["enum", "string formatting", "standard library usage"], "_raw_llm_output": "enum, string formatting, standard library usage"}
{"seed": "// sumOfPowersMod calculates the sum of powers modulo mod.\n// Reference: https://stackoverflow.com/a/31221590\nfunc sumOfPowersMod(base int64, power int64, mod int64) int64 {\n\tif power&1 == 1 {\n\t\t// (base * sumOfPowersMod(base, power-1, mod) + 1) % mod\n\n\t\tsum := sumOfPowersMod(base, power-1, mod) // partial_sum (see below)\n\n\t\tresult := big.NewInt(sum)\n\t\tresult.Mul(result, big.NewInt(base))     //  base * partial_sum\n\t\tresult.Add(result, big.NewInt(int64(1))) //  base * partial_sum + 1\n\t\tresult.Mod(result, big.NewInt(mod))      // (base * partial_sum + 1) % mod\n\n\t\tif !result.IsInt64() {\n\t\t\tpanic(\"result should be int64!\")\n\t\t}\n\n\t\treturn result.Int64()\n\n\t} else if power > 0 {\n\t\t// ((base + 1) * sumOfPowersMod(base * base % mod, power // 2, mod)) % mod\n\t\tpb := big.NewInt(mod)\n\n\t\tresult := big.NewInt(base)\n\t\tresult.Mul(result, big.NewInt(base)) // base * base\n\t\tresult.Mod(result, pb)               // base * base % mod\n\n\t\tif !result.IsInt64() {\n\t\t\tpanic(\"result should be int64!\")\n\t\t}\n\n\t\thalfN := power / 2\n\t\tsum := sumOfPowersMod(result.Int64(), halfN, mod)\n\n\t\tresult.SetInt64(sum)                   // partial_sum (see below)\n\t\tresult.Mul(result, big.NewInt(base+1)) // (base + 1) * partial_sum\n\t\tresult.Mod(result, pb)                 // ((base + 1) * partial_sum) % mod\n\n\t\tif !result.IsInt64() {\n\t\t\tpanic(\"result should be int64!\")\n\t\t}\n\n\t\treturn result.Int64()\n\t}\n\n\treturn 0\n}", "id": 25948, "concepts": ["big.Int package usage", "integer multiplication", "integer division", "integer modulo", "integer addition"], "_raw_llm_output": "big.Int package usage, integer multiplication, integer division, integer modulo, integer addition"}
{"seed": "// SpinWords takes in a string of one or more words,\n// and returns the same string, but with all five\n// or more letter words reversed.\nfunc SpinWords(sentence string) string {\n\twords := strings.Split(sentence, \" \")\n\n\tfor i := 0; i < len(words); i++ {\n\t\tif len(words[i]) >= 5 {\n\t\t\twords[i] = reverse(words[i])\n\t\t}\n\t}\n\n\treturn strings.Join(words, \" \")\n}", "id": 25952, "concepts": ["string manipulation", "string splitting", "string joining", "string reversal"], "_raw_llm_output": "string manipulation, string splitting, string joining, string reversal"}
{"seed": "// messageString transforms the given browser.Message to a string so we can\n// compare strings in a test output.\nfunc messageString(t *testing.T, m *browser.Message) string {\n\tt.Helper()\n\n\tvar s []string\n\tif m != nil && len(m.Measurements) > 0 {\n\t\ts = append(s, strings.Join(m.Measurements, \"-\"))\n\t}\n\tif m != nil && len(m.Stations) > 0 {\n\t\ts = append(s, strings.Join(m.Stations, \"-\"))\n\t}\n\tif m != nil && len(m.Landuse) > 0 {\n\t\ts = append(s, strings.Join(m.Landuse, \"-\"))\n\t}\n\n\treturn strings.Join(s, \"_\")\n}", "id": 25962, "concepts": ["string manipulation", "string joining", "testing", "helper functions"], "_raw_llm_output": "string manipulation, string joining, testing, helper functions"}
{"seed": "// mustGetServerMetrics returns a singleton instance of the server metrics\n// that are shared across all gRPC servers that this process creates.\n//\n// This function panics if the metrics cannot be registered with the default\n// Prometheus registry.\nfunc mustGetServerMetrics() *grpc_prometheus.ServerMetrics {\n\tserverMetricsOnce.Do(func() {\n\t\tserverMetrics = grpc_prometheus.NewRegisteredServerMetrics(prometheus.DefaultRegisterer,\n\t\t\tgrpc_prometheus.WithServerCounterOptions(setCounterNamespace),\n\t\t\tgrpc_prometheus.WithServerHandlingTimeHistogram(setHistogramNamespace), // record the overall response latency for a gRPC request)\n\t\t)\n\t})\n\n\treturn serverMetrics\n}", "id": 25963, "concepts": ["singleton pattern", "error handling (panic)", "Prometheus metrics"], "_raw_llm_output": "singleton pattern, error handling (panic), Prometheus metrics"}
{"seed": "// Map_ is a convenience wrapper for Map without the attrs argument.\nfunc Map_(children ...HTML) HTML {\n  return Map(nil, children...)\n}", "id": 25965, "concepts": ["HTML struct", "HTML.Map function", "HTML.Attrs function", "HTML.Children function", "HTML.Class function", "HTML.Style function", "HTML.Body function", "HTML.Head function", "HTML.Title function", "HTML.Div function", "HTML.P function", "HTML.Span function", "HTML.A function", "HTML.Br function", "HTML.H1 function", "HTML.H2 function", "HTML.H3 function", "HTML.H4 function", "HTML.H5 function", "HTML.H6 function", "HTML.Img function", "HTML.Input function", "HTML.Form function", "HTML.Select function", "HTML.Option function", "HTML.Text function", "HTML.Raw function", "HTML.Comment function", "HTML.Script function", "HTML.Style function", "HTML.Link function", "HTML.I function", "HTML.B function", "HTML.U function", "HTML.S function", "HTML.Del function", "HTML.Ins function", "HTML.Strong function", "HTML.Em function", "HTML.Sub function", "HTML.Sup function", "HTML.Code function", "HTML.Pre function", "HTML.Blockquote function", "HTML.Ol function", "HTML.Ul function", "HTML.Li function", "HTML.Hr function", "HTML.Table function", "HTML.Tr function", ""], "_raw_llm_output": "HTML struct, HTML.Map function, HTML.Attrs function, HTML.Children function, HTML.Class function, HTML.Style function, HTML.Body function, HTML.Head function, HTML.Title function, HTML.Div function, HTML.P function, HTML.Span function, HTML.A function, HTML.Br function, HTML.H1 function, HTML.H2 function, HTML.H3 function, HTML.H4 function, HTML.H5 function, HTML.H6 function, HTML.Img function, HTML.Input function, HTML.Form function, HTML.Select function, HTML.Option function, HTML.Text function, HTML.Raw function, HTML.Comment function, HTML.Script function, HTML.Style function, HTML.Link function, HTML.I function, HTML.B function, HTML.U function, HTML.S function, HTML.Del function, HTML.Ins function, HTML.Strong function, HTML.Em function, HTML.Sub function, HTML.Sup function, HTML.Code function, HTML.Pre function, HTML.Blockquote function, HTML.Ol function, HTML.Ul function, HTML.Li function, HTML.Hr function, HTML.Table function, HTML.Tr function,"}
{"seed": "// PossibleEventGridDataFormatValues returns an array of possible values for the EventGridDataFormat const type.\nfunc PossibleEventGridDataFormatValues() []EventGridDataFormat {\n\treturn []EventGridDataFormat{APACHEAVRO, AVRO, CSV, JSON, MULTIJSON, ORC, PARQUET, PSV, RAW, SCSV, SINGLEJSON, SOHSV, TSV, TSVE, TXT, W3CLOGFILE}\n}", "id": 25968, "concepts": ["enumerations", "constant definition", "array definition"], "_raw_llm_output": "enumerations, constant definition, array definition"}
{"seed": "// ErrAssumptionFailed is an assert of when our assumptions fails, in debug mode it will return and error. In\n// non debug mode it will panic\nfunc ErrAssumptionFailed() error {\n\tstr := fmt.Sprintf(\"Assumption failed at: %v \", debugger.FFL(0))\n\tif debug {\n\t\treturn errors.New(str)\n\t}\n\tpanic(str)\n}", "id": 25975, "concepts": ["error handling (errors.New)", "panic", "debugging", "FFL", "fmt package usage"], "_raw_llm_output": "error handling (errors.New), panic, debugging, FFL, fmt package usage"}
{"seed": "// +lifted:source=https://github.com/kubernetes/kubernetes/blob/release-1.26/pkg/controller/deployment/util/deployment_util.go#L563C1-L595\n// +lifted:changed\n\n// ListPodsByRS returns a list of pods the given deployment targets.\n// This needs a list of ReplicaSets for the Deployment,\n// which can be found with ListReplicaSets().\n// Note that this does NOT attempt to reconcile ControllerRef (adopt/orphan),\n// because only the controller itself should do that.\n// However, it does filter out anything whose ControllerRef doesn't match.\nfunc ListPodsByRS(deployment *appsv1.Deployment, rsList []*appsv1.ReplicaSet, f PodListFunc) ([]*corev1.Pod, error) {\n\tnamespace := deployment.Namespace\n\tselector, err := metav1.LabelSelectorAsSelector(deployment.Spec.Selector)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tall, err := f(namespace, selector)\n\tif err != nil {\n\t\treturn all, err\n\t}\n\t// Only include those whose ControllerRef points to a ReplicaSet that is in\n\t// turn owned by this Deployment.\n\trsMap := make(map[types.UID]bool, len(rsList))\n\tfor _, rs := range rsList {\n\t\tif rs != nil {\n\t\t\trsMap[rs.UID] = true\n\t\t}\n\t}\n\towned := make([]*corev1.Pod, 0, len(all))\n\tfor i := range all {\n\t\tpod := all[i]\n\t\tcontrollerRef := metav1.GetControllerOf(pod)\n\t\tif controllerRef != nil && rsMap[controllerRef.UID] {\n\t\t\towned = append(owned, pod)\n\t\t}\n\t}\n\treturn owned, nil\n}", "id": 25978, "concepts": ["PodListFunc", "metav1.LabelSelectorAsSelector", "metav1.GetControllerOf", "types.UID", "map", "slice iteration"], "_raw_llm_output": "PodListFunc, metav1.LabelSelectorAsSelector, metav1.GetControllerOf, types.UID, map, slice iteration"}
{"seed": "// Del_ is a convenience wrapper for Del without the attrs argument.\nfunc Del_(children ...HTML) HTML {\n  return Del(nil, children...)\n}", "id": 25988, "concepts": ["HTML struct definition", "HTML struct field definition", "HTML struct field initialization", "HTML struct field access", "HTML struct method definition", "HTML struct method call", "HTML struct method call with receiver", "HTML struct method call with receiver and arguments", "HTML struct method call with receiver and arguments and return value", "HTML struct method call with receiver and arguments and return value and error handling", "HTML struct method call with receiver and arguments and return value and error handling with error handling", "HTML struct method call with receiver and arguments and return value and error handling with error handling and return value", "HTML struct method call with receiver and arguments and return value and error handling with error handling and return value and error handling", "HTML struct method call with receiver and arguments and return value and error handling with error handling and return value and error handling with error handling", "HTML struct method call with receiver and arguments and return value and error handling with error handling and return value and error handling with error handling and return value and error handling with error handling", "HTML struct method call with receiver and arguments and return value and error handling with error handling and return value and error handling with error handling and return value and error handling with error handling", "HTML struct method call with receiver and arguments and return value and error handling with error handling and return value and"], "_raw_llm_output": "HTML struct definition, HTML struct field definition, HTML struct field initialization, HTML struct field access, HTML struct method definition, HTML struct method call, HTML struct method call with receiver, HTML struct method call with receiver and arguments, HTML struct method call with receiver and arguments and return value, HTML struct method call with receiver and arguments and return value and error handling, HTML struct method call with receiver and arguments and return value and error handling with error handling, HTML struct method call with receiver and arguments and return value and error handling with error handling and return value, HTML struct method call with receiver and arguments and return value and error handling with error handling and return value and error handling, HTML struct method call with receiver and arguments and return value and error handling with error handling and return value and error handling with error handling, HTML struct method call with receiver and arguments and return value and error handling with error handling and return value and error handling with error handling and return value and error handling with error handling, HTML struct method call with receiver and arguments and return value and error handling with error handling and return value and error handling with error handling and return value and error handling with error handling, HTML struct method call with receiver and arguments and return value and error handling with error handling and return value and"}
{"seed": "// Calculate the Eccent Earth Orbit based on the formula: 0.016708634 - julianCentury * (0.000042037 + 0.0000001267 * julianCentury)\n// julianCentury - Julian century calculated by the calcJulianCentury function\n// Return The Eccent Earth Orbit slice\nfunc calcEccentEarthOrbit(julianCentury []float64) (eccentEarthOrbit []float64) {\n\tfor index := 0; index < len(julianCentury); index++ {\n\t\ttemp := 0.016708634 - julianCentury[index]*(0.000042037+0.0000001267*julianCentury[index])\n\t\teccentEarthOrbit = append(eccentEarthOrbit, temp)\n\t}\n\treturn\n}", "id": 25994, "concepts": ["slice iteration (range loop)", "slice append", "basic function definition", "mathematical series"], "_raw_llm_output": "slice iteration (range loop), slice append, basic function definition, mathematical series"}
{"seed": "// K\u6b21\u53d6\u53cd\u540e\u6700\u5927\u5316\u7684\u6570\u7ec4\u548c\n// 1. \u8981\u5148\u6392\u5e8f,\u60f3\u529e\u6cd5\u628a\u5927\u7684\u8d1f\u6570\u7ffb\u8f6c\u8fc7\u6765  2.\u6ca1\u5fc5\u8981\u53d6\u7ea0\u7ed3k\u548c\u8d1f\u6570\u7684\u5173\u7cfb,\u76f4\u63a5\u5148\u7ffb\u8f6c\u5927\u7684\u8d1f\u6570\u5373\u53ef\n// 3. \u5bf9\u4e8eindex\u5b9a\u4f4d,\u521d\u59cb\u503c\u5e94\u8be5\u8003\u91cf\u7684\u662f\u4e0d\u8d70else\u7684\u60c5\u51b5\nfunc largestSumAfterKNegations(nums []int, k int) int {\n\tsort.Ints(nums)\n\n\tindex := len(nums) - 1\n\tfor i := 0; i < len(nums); i++ {\n\t\tif k > 0 && nums[i] < 0 {\n\t\t\tnums[i] = -nums[i]\n\t\t\tk--\n\t\t} else {\n\t\t\tindex = i\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif k > 0 {\n\t\tif k % 2 == 1 {\n\t\t\tm := index\n\t\t\tif index > 0 && nums[index - 1] < nums[index] {\n\t\t\t\tm = index - 1\n\t\t\t}\n\t\t\tnums[m] = -nums[m]\n\t\t}\n\t}\n\n\tres := 0\n\tfor i := 0; i < len(nums); i++ {\n\t\tres += nums[i]\n\t}\n\n\treturn res\n}", "id": 26002, "concepts": ["integer summation", "slice iteration (range loop)", "slice manipulation", "sorting", "pointer handling"], "_raw_llm_output": "integer summation, slice iteration (range loop), slice manipulation, sorting, pointer handling"}
{"seed": "// stateEndTop is the state after finishing the top-level value,\n// such as after reading `A<1,?>` or `{1,2,3}`.\n// Only space characters should be seen now.\nfunc stateEndTop(s *scanner, c byte) int {\n\tif c != ' ' && c != '\\t' && c != '\\r' && c != '\\n' {\n\t\t// Complain about non-space byte on next call.\n\t\ts.error(c, \"after top-level value\")\n\t}\n\treturn scanEnd\n}", "id": 26018, "concepts": ["state machine", "state transition", "error handling"], "_raw_llm_output": "state machine, state transition, error handling"}
{"seed": "// BlobHash returns the sha512 hash hex encoded string of the blob byte slice.\nfunc BlobHash(blob []byte) string {\n\thashBytes := sha512.Sum384(blob)\n\treturn hex.EncodeToString(hashBytes[:])\n}", "id": 26033, "concepts": ["sha512 hash calculation", "string encoding", "byte slice handling", "hex encoding"], "_raw_llm_output": "sha512 hash calculation, string encoding, byte slice handling, hex encoding"}
{"seed": "// parseGithubRemote parses string remoteURL against known patterns matching\n// GitHub remotes and returns the owner and repo, along with a boolean ok\n// indicating whether a match was found.\n//\n// Possible GitHub remote formats (HTTPS/SSH):\n// \t https://github.com/mroth/bump.git\n//   git@github.com:mroth/bump.git\nfunc parseGithubRemote(remoteURL string) (owner, repo string, ok bool) {\n\tre := regexp.MustCompile(`^(?:https://|git@)github.com[:/](.*)/(.*?)(?:\\.git$|$)`)\n\tmatches := re.FindStringSubmatch(remoteURL)\n\tif matches == nil || len(matches) < 3 {\n\t\treturn\n\t}\n\treturn matches[1], matches[2], true\n}", "id": 26039, "concepts": ["regular expression matching", "string manipulation", "string comparison", "string concatenation", "string formatting", "regular expression usage", "string matching", "string replacement", "string splitting", "string trimming", "string concatenation", "string comparison", "string concatenation", "string formatting", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concat"], "_raw_llm_output": "regular expression matching, string manipulation, string comparison, string concatenation, string formatting, regular expression usage, string matching, string replacement, string splitting, string trimming, string concatenation, string comparison, string concatenation, string formatting, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concat"}
{"seed": "// NewRolesTransactor creates a new write-only instance of Roles, bound to a specific deployed contract.\nfunc NewRolesTransactor(address common.Address, transactor bind.ContractTransactor) (*RolesTransactor, error) {\n\tcontract, err := bindRoles(address, nil, transactor, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &RolesTransactor{contract: contract}, nil\n}", "id": 26044, "concepts": ["bind.ContractTransactor", "bind.ContractBackend", "common.Address", "bind.Contract", "bind.ContractBackend", "bind.ContractBackend", "bind.Contract", "bind.ContractBackend", "bind.ContractBackend", "bind.Contract", "bind.ContractBackend", "bind.ContractBackend", "bind.Contract", "bind.ContractBackend", "bind.ContractBackend", "bind.Contract", "bind.ContractBackend", "bind.ContractBackend", "bind.Contract", "bind.ContractBackend", "bind.ContractBackend", "bind.Contract", "bind.ContractBackend", "bind.ContractBackend", "bind.Contract", "bind.ContractBackend", "bind.ContractBackend", "bind.Contract", "bind.ContractBackend", "bind.ContractBackend", "bind.Contract", "bind.ContractBackend", "bind.ContractBackend", "bind.Contract", "bind.ContractBackend", "bind.ContractBackend", "bind.Contract", "bind.ContractBackend", "bind.ContractBackend", "bind.Contract", "bind.ContractBackend", "bind.ContractBackend", "bind.Contract", "bind.ContractBackend", "bind.ContractBackend", "bind.Contract", "bind.ContractBackend", "bind.ContractBackend", "bind.Contract", "bind.ContractBackend", "bind.ContractBackend", "bind.Contract", "bind.ContractBackend", "bind.ContractBackend", "bind."], "_raw_llm_output": "bind.ContractTransactor, bind.ContractBackend, common.Address, bind.Contract, bind.ContractBackend, bind.ContractBackend, bind.Contract, bind.ContractBackend, bind.ContractBackend, bind.Contract, bind.ContractBackend, bind.ContractBackend, bind.Contract, bind.ContractBackend, bind.ContractBackend, bind.Contract, bind.ContractBackend, bind.ContractBackend, bind.Contract, bind.ContractBackend, bind.ContractBackend, bind.Contract, bind.ContractBackend, bind.ContractBackend, bind.Contract, bind.ContractBackend, bind.ContractBackend, bind.Contract, bind.ContractBackend, bind.ContractBackend, bind.Contract, bind.ContractBackend, bind.ContractBackend, bind.Contract, bind.ContractBackend, bind.ContractBackend, bind.Contract, bind.ContractBackend, bind.ContractBackend, bind.Contract, bind.ContractBackend, bind.ContractBackend, bind.Contract, bind.ContractBackend, bind.ContractBackend, bind.Contract, bind.ContractBackend, bind.ContractBackend, bind.Contract, bind.ContractBackend, bind.ContractBackend, bind.Contract, bind.ContractBackend, bind.ContractBackend, bind."}
{"seed": "// PossibleSubscriptionReregistrationResultValues returns the possible values for the SubscriptionReregistrationResult const type.\nfunc PossibleSubscriptionReregistrationResultValues() []SubscriptionReregistrationResult {\n\treturn []SubscriptionReregistrationResult{\n\t\tSubscriptionReregistrationResultConditionalUpdate,\n\t\tSubscriptionReregistrationResultFailed,\n\t\tSubscriptionReregistrationResultForcedUpdate,\n\t\tSubscriptionReregistrationResultNotApplicable,\n\t}\n}", "id": 26049, "concepts": ["constant definition", "array definition", "array iteration (range loop)"], "_raw_llm_output": "constant definition, array definition, array iteration (range loop)"}
{"seed": "// env is a simple helper function to read an environment variable or return a default value\nfunc env(key string, defaultValue string) string {\n\tif value, exists := os.LookupEnv(key); exists {\n\t\treturn value\n\t}\n\treturn defaultValue\n}", "id": 26060, "concepts": ["environment variable handling", "os package usage"], "_raw_llm_output": "environment variable handling, os package usage"}
{"seed": "// MakeEndpoints returns an Endpoints struct where each endpoint invokes\n// the corresponding method on the provided service.\nfunc MakeEndpoints(service project.Service, middleware ...endpoint.Middleware) Endpoints {\n\tmw := kitxendpoint.Chain(middleware...)\n\n\treturn Endpoints{ListProjects: mw(MakeListProjectsEndpoint(service))}\n}", "id": 26075, "concepts": ["function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", "function composition", ""], "_raw_llm_output": "function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition, function composition,"}
{"seed": "// TitleHasPrefix applies the HasPrefix predicate on the \"title\" field.\nfunc TitleHasPrefix(v string) predicate.User {\n\treturn predicate.User(sql.FieldHasPrefix(FieldTitle, v))\n}", "id": 26080, "concepts": ["predicate.User", "sql.FieldHasPrefix"], "_raw_llm_output": "predicate.User, sql.FieldHasPrefix"}
{"seed": "// HasRecord applies the HasEdge predicate on the \"record\" edge.\nfunc HasRecord() predicate.TradeCorrection {\n\treturn predicate.TradeCorrection(func(s *sql.Selector) {\n\t\tstep := sqlgraph.NewStep(\n\t\t\tsqlgraph.From(Table, FieldID),\n\t\t\tsqlgraph.Edge(sqlgraph.M2M, true, RecordTable, RecordPrimaryKey...),\n\t\t)\n\t\tsqlgraph.HasNeighbors(s, step)\n\t})\n}", "id": 26082, "concepts": ["sqlgraph package usage", "edge traversal", "predicate definition"], "_raw_llm_output": "sqlgraph package usage, edge traversal, predicate definition"}
{"seed": "// importMessage imports an email message.  Returns nil if msg does\n// not appear to be a lyft ride summary.  Returns an error if it does\n// appear to be a lyft ride summary, but we have trouble parsing it.\n// An example valid email would be:\n//\n//   Hi Gina, thanks for riding with Jane D!\n//\n//   Receipt #999999999999999999\n//   Ride completed on October 20 at 10:38 PM\n//   Your Driver was Jane\n//   Pickup: 450 California St, San Francisco, CA 94104\n//   Dropoff: 700 4th St, San Francisco, CA 94107\n//\n//   Lyft fare (3.74mi, 20m 2s): $10.95\n//   Prime Time  + 50%*: $5.48\n//   Service fee: $1.75\n//   Tip: $2.00\n//\n//   Total charged to Visa ***1234: $20.18\n//\n//   *50% Prime Time was included in your total.\n//   Prime Time encourages more people to drive when Lyft gets really busy.\n//   Learn More at http://email.lyftmail.com/someurl\n//   --\n//   Lose something, go to http://email.lyftmail.com/someotherurl\n//   To learn more about our Zero Tolerance Policies, go to http://email.lyftmai=\n//   l.com/somethirdurl\nfunc importMessage(msg ledgertools.Message) (*importer.Parsed, error) {\n\tif !strings.Contains(msg.From, fromMatcher) {\n\t\treturn nil, nil\n\t}\n\tif !strings.HasPrefix(msg.Subject, subjectPrefix) {\n\t\treturn nil, nil\n\t}\n\n\tdate, err := time.Parse(time.RFC1123Z, msg.Date)\n\tif err != nil {\n\t\treturn nil, errors.Wrapf(err, \"Parsing date in %v\", msg)\n\t}\n\tdate = date.In(mailimp.PacificTz)\n\n\t// build all these up by looking at the message text\n\tvar checkNumber string\n\tvar comments = make([]string, 0, len(commentMatchers))\n\tvar amount string\n\tvar instrument string\n\n\tsplitter := mailimp.NewLineSplitter(msg.TextPlain)\n\tfor {\n\t\tline, ok := splitter.Next()\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tfor _, m := range commentMatchers {\n\t\t\tif m.Match(line) != nil {\n\t\t\t\tcomments = append(comments, line)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tif match := receiptMatcher.Match(line); match != nil {\n\t\t\tcheckNumber = match()\n\t\t\tcontinue\n\t\t}\n\n\t\tif match := chargeMatcher.Match(line); match != nil {\n\t\t\t// rest should like like 'Visa ***1234: $20.18'\n\t\t\ttokens := strings.SplitN(match(), \":\", 2)\n\t\t\tif len(tokens) == 2 {\n\t\t\t\tinstrument = tokens[0]\n\t\t\t\tamount = strings.TrimSpace(tokens[1])\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t}\n\n\t// Verify that we found everything we were expecting\n\tif checkNumber == \"\" {\n\t\treturn nil, errors.Errorf(\"Missing valid receipt line in %q\", msg.TextPlain)\n\t}\n\tif len(comments) != len(commentMatchers) {\n\t\treturn nil, errors.Errorf(\"Missing comments.  Found %q in %q.  Expected to find lines starting with %q\", comments, msg.TextPlain, commentMatchers)\n\t}\n\tif amount == \"\" || instrument == \"\" {\n\t\treturn nil, errors.Errorf(\"charge line in %q\", msg.TextPlain)\n\t}\n\n\treturn importer.NewParsed(\n\t\tdate,\n\t\tcheckNumber,\n\t\tpayee,\n\t\tcomments,\n\t\tamount,\n\t\tinstrument), nil\n}", "id": 26086, "concepts": ["string manipulation", "regexp", "string formatting", "string parsing", "string matching", "string splitting", "string concatenation", "string iteration", "string comparison", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", "string concatenation", ""], "_raw_llm_output": "string manipulation, regexp, string formatting, string parsing, string matching, string splitting, string concatenation, string iteration, string comparison, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation, string concatenation,"}
{"seed": "// NewAndDisplayTime creates a new JE struct and configures it to display the timestamp.\n// Domain is optional but can be at most 1 string.\nfunc NewAndDisplayTime(code int, error string, message string, domain ...string) JE {\n\tj := JE{Code: code, error: error, message: message, time: time.Now().UTC(), DisplayTime: true}\n\tif len(domain) != 0 {\n\t\tj.Domain = domain[0]\n\t}\n\treturn j\n}", "id": 26098, "concepts": ["struct definition", "struct field initialization", "struct field access", "struct field assignment", "struct field type conversion", "struct field pointer access", "struct field pointer assignment", "struct field pointer type conversion", "struct field pointer pointer access", "struct field pointer pointer assignment", "struct field pointer pointer type conversion", "struct field pointer pointer pointer access", "struct field pointer pointer pointer assignment", "struct field pointer pointer pointer type conversion", "struct field pointer pointer pointer pointer access", "struct field pointer pointer pointer pointer assignment", "struct field pointer pointer pointer pointer type conversion", "struct field pointer pointer pointer pointer pointer access", "struct field pointer pointer pointer pointer pointer assignment", "struct field pointer pointer pointer pointer pointer type conversion", "struct field pointer pointer pointer pointer pointer pointer access", "struct field pointer pointer pointer pointer pointer pointer assignment", "struct field pointer pointer pointer pointer pointer pointer type conversion", "struct field pointer pointer pointer pointer pointer pointer pointer access", "struct field pointer pointer pointer pointer pointer pointer pointer assignment", "struct field pointer pointer pointer pointer pointer pointer pointer type conversion", "struct field pointer pointer pointer pointer pointer pointer pointer pointer access", "struct field pointer pointer pointer pointer pointer pointer pointer pointer assignment", "struct field pointer pointer pointer pointer pointer pointer pointer pointer type conversion", "struct field pointer pointer pointer pointer pointer pointer pointer pointer pointer access", "struct field pointer pointer pointer pointer pointer pointer pointer pointer"], "_raw_llm_output": "struct definition, struct field initialization, struct field access, struct field assignment, struct field type conversion, struct field pointer access, struct field pointer assignment, struct field pointer type conversion, struct field pointer pointer access, struct field pointer pointer assignment, struct field pointer pointer type conversion, struct field pointer pointer pointer access, struct field pointer pointer pointer assignment, struct field pointer pointer pointer type conversion, struct field pointer pointer pointer pointer access, struct field pointer pointer pointer pointer assignment, struct field pointer pointer pointer pointer type conversion, struct field pointer pointer pointer pointer pointer access, struct field pointer pointer pointer pointer pointer assignment, struct field pointer pointer pointer pointer pointer type conversion, struct field pointer pointer pointer pointer pointer pointer access, struct field pointer pointer pointer pointer pointer pointer assignment, struct field pointer pointer pointer pointer pointer pointer type conversion, struct field pointer pointer pointer pointer pointer pointer pointer access, struct field pointer pointer pointer pointer pointer pointer pointer assignment, struct field pointer pointer pointer pointer pointer pointer pointer type conversion, struct field pointer pointer pointer pointer pointer pointer pointer pointer access, struct field pointer pointer pointer pointer pointer pointer pointer pointer assignment, struct field pointer pointer pointer pointer pointer pointer pointer pointer type conversion, struct field pointer pointer pointer pointer pointer pointer pointer pointer pointer access, struct field pointer pointer pointer pointer pointer pointer pointer pointer"}
{"seed": "// MaxCallSendMsgSize is the client-side request send limit in bytes.\n// If 0, it defaults to 2.0 MiB (2 * 1024 * 1024).\n// Make sure that \"MaxCallSendMsgSize\" < server-side default send/recv limit.\n// (\"--max-request-bytes\" flag to etcd or \"embed.Config.MaxRequestBytes\").\nfunc MaxCallSendMsgSize(v int) Configer {\n\treturn func(c *clientv3.Config) {\n\t\tc.MaxCallSendMsgSize = v\n\t}\n}", "id": 26105, "concepts": ["configuration", "clientv3.Config", "configuration function"], "_raw_llm_output": "configuration, clientv3.Config, configuration function"}
{"seed": "// Meter represents the HTML element 'meter'.\n// For more information visit https://www.w3schools.com/tags/tag_meter.asp.\nfunc Meter(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"meter\", Attributes: attrs, Children: children}\n}", "id": 26110, "concepts": ["HTML generation", "HTML element definition", "HTML attribute definition", "HTML element children definition"], "_raw_llm_output": "HTML generation, HTML element definition, HTML attribute definition, HTML element children definition"}
{"seed": "// DialOptions is a list of dial options for the grpc client (e.g., for interceptors).\nfunc DialOptions(v []grpc.DialOption) Configer {\n\treturn func(c *clientv3.Config) {\n\t\tc.DialOptions = v\n\t}\n}", "id": 26113, "concepts": ["grpc.DialOption", "function composition", "function definition", "function return"], "_raw_llm_output": "grpc.DialOption, function composition, function definition, function return"}
{"seed": "// hasExec reports whether the current system can start new processes\n// using os.StartProcess or (more commonly) exec.Command.\n// Copied from internal/testenv.HasExec\nfunc hasExec() bool {\n\tswitch runtime.GOOS {\n\tcase \"wasip1\", \"js\", \"ios\":\n\t\treturn false\n\t}\n\treturn true\n}", "id": 26114, "concepts": ["runtime.GOOS", "runtime.GOARCH", "runtime.GOOS/runtime.GOARCH handling"], "_raw_llm_output": "runtime.GOOS, runtime.GOARCH, runtime.GOOS/runtime.GOARCH handling"}
{"seed": "// Area_ is a convenience wrapper for Area without the attrs argument.\nfunc Area_() HTML {\n  return Area(nil)\n}", "id": 26118, "concepts": ["function definition", "function call", "function return", "function argument", "function attribute"], "_raw_llm_output": "function definition, function call, function return, function argument, function attribute"}
{"seed": "// Embed_ is a convenience wrapper for Embed without the attrs argument.\nfunc Embed_() HTML {\n  return Embed(nil)\n}", "id": 26126, "concepts": ["HTML embedding", "function definition", "function call"], "_raw_llm_output": "HTML embedding, function definition, function call"}
{"seed": "// EncodeTimeout encodes a gRPC/pRPC timeout into a timeout header\n// time.Duration.\n//\n// This rounds the time.Duration to the smallest time unit that can represent\n// it.\nfunc EncodeTimeout(t time.Duration) string {\n\tif d := div(t, time.Nanosecond); d <= maxTimeoutValue {\n\t\treturn strconv.FormatInt(d, 10) + \"n\"\n\t}\n\tif d := div(t, time.Microsecond); d <= maxTimeoutValue {\n\t\treturn strconv.FormatInt(d, 10) + \"u\"\n\t}\n\tif d := div(t, time.Millisecond); d <= maxTimeoutValue {\n\t\treturn strconv.FormatInt(d, 10) + \"m\"\n\t}\n\tif d := div(t, time.Second); d <= maxTimeoutValue {\n\t\treturn strconv.FormatInt(d, 10) + \"S\"\n\t}\n\tif d := div(t, time.Minute); d <= maxTimeoutValue {\n\t\treturn strconv.FormatInt(d, 10) + \"M\"\n\t}\n\t// Note that maxTimeoutValue * time.Hour > MaxInt64.\n\treturn strconv.FormatInt(div(t, time.Hour), 10) + \"H\"\n}", "id": 26127, "concepts": ["time package usage", "integer division", "string formatting"], "_raw_llm_output": "time package usage, integer division, string formatting"}
{"seed": "// SocialPayloadLTE applies the LTE predicate on the \"social_payload\" field.\nfunc SocialPayloadLTE(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.LTE(s.C(FieldSocialPayload), v))\n\t})\n}", "id": 26129, "concepts": ["SQL query building", "SQL query building with predicate.User", "SQL query building with SQL query building", "SQL query building with SQL query building with predicate.User", "SQL query building with SQL query building with SQL query building", "SQL query building with SQL query building with SQL query building with predicate.User", "SQL query building with SQL query building with SQL query building with SQL query building", "SQL query building with SQL query building with SQL query building with SQL query building with predicate.User", "SQL query building with SQL query building with SQL query building with SQL query building with SQL query building", "SQL query building with SQL query building with SQL query building with SQL query building with SQL query building with predicate.User", "SQL query building with SQL query building with SQL query building with SQL query building with SQL query building with SQL query building", "SQL query building with SQL query building with SQL query building with SQL query building with SQL query building with SQL query building with predicate.User", "SQL query building with SQL query building with SQL query building with SQL query building with SQL query building with SQL query building with SQL query building", "SQL query building with SQL query building with SQL query building with SQL query building with SQL query building with SQL query building with SQL query building with predicate.User", "SQL query building"], "_raw_llm_output": "SQL query building, SQL query building with predicate.User, SQL query building with SQL query building, SQL query building with SQL query building with predicate.User, SQL query building with SQL query building with SQL query building, SQL query building with SQL query building with SQL query building with predicate.User, SQL query building with SQL query building with SQL query building with SQL query building, SQL query building with SQL query building with SQL query building with SQL query building with predicate.User, SQL query building with SQL query building with SQL query building with SQL query building with SQL query building, SQL query building with SQL query building with SQL query building with SQL query building with SQL query building with predicate.User, SQL query building with SQL query building with SQL query building with SQL query building with SQL query building with SQL query building, SQL query building with SQL query building with SQL query building with SQL query building with SQL query building with SQL query building with predicate.User, SQL query building with SQL query building with SQL query building with SQL query building with SQL query building with SQL query building with SQL query building, SQL query building with SQL query building with SQL query building with SQL query building with SQL query building with SQL query building with SQL query building with predicate.User, SQL query building"}
{"seed": "// RunContainer launches a detached docker container on the host machine. It\n// takes an image name, a list of \"docker run\" arguments, and a list of\n// arguments that get passed to the container runtime\nfunc RunContainer(image string, dockerArgs, runtimeArgs []string) (func() error, error) {\n\t// build a list of args to pass to cmd.Exec\n\texecDocker := append([]string{\"docker\", \"run\", \"-d\"}, dockerArgs...)\n\texecRuntime := append([]string{image}, runtimeArgs...)\n\texecDocker = append(execDocker, execRuntime...)\n\t// launch the container\n\tout, err := exec.Command(execDocker[0], execDocker[1:]...).CombinedOutput()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"%s: %s\", err.Error(), string(out))\n\t}\n\t// get the uuid from the container after it starts. this gets used to kill\n\t// the container\n\tsplit := strings.Split(string(out), \"\\n\")\n\tif len(split) == 0 {\n\t\treturn nil, errors.New(\"unable to get container uuid\")\n\t}\n\tuuid := split[0]\n\treturn func() error {\n\t\treturn exec.Command(\"docker\", \"kill\", uuid).Run()\n\t}, nil\n}", "id": 26131, "concepts": ["docker usage", "exec.Command", "error handling", "string manipulation", "error wrapping", "anonymous function", "function definition", "function return", "function composition"], "_raw_llm_output": "docker usage, exec.Command, error handling, string manipulation, error wrapping, anonymous function, function definition, function return, function composition"}
{"seed": "// NewGasEstimator creates a new instance of GasEstimator. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.\nfunc NewGasEstimator(t mockConstructorTestingTNewGasEstimator) *GasEstimator {\n\tmock := &GasEstimator{}\n\tmock.Mock.Test(t)\n\n\tt.Cleanup(func() { mock.AssertExpectations(t) })\n\n\treturn mock\n}", "id": 26135, "concepts": ["testing interface", "mocking", "cleanup function"], "_raw_llm_output": "testing interface, mocking, cleanup function"}
{"seed": "// New creates a new hyperloglog counter with the specified precision. p must be in the range [4,18]\nfunc New(p uint8) Counter {\n\tif p < 4 || p > 18 {\n\t\tpanic(\"hll: precision p must be in range [4,18]\")\n\t}\n\tm := int(1 << uint(p))\n\tc := Counter{\n\t\tp:    p,\n\t\tbits: bitbucket.New(m, 6),\n\t}\n\tc.initParams()\n\n\treturn c\n}", "id": 26144, "concepts": ["bit manipulation", "bitbucket package usage"], "_raw_llm_output": "bit manipulation, bitbucket package usage"}
{"seed": "// FieldByName is a helper for fetching a named field from a struct. It is\n// useful in conjunction with Map, to retrieve many values at once.\nfunc FieldByName(name string) func(interface{}) interface{} {\n\treturn func(record interface{}) interface{} {\n\t\treturn reflect.ValueOf(record).FieldByName(name).Interface()\n\t}\n}", "id": 26145, "concepts": ["reflection", "struct field access", "anonymous function"], "_raw_llm_output": "reflection, struct field access, anonymous function"}
{"seed": "// NewColumnFamilyMetricsTotalDiskSpaceUsedByNameGetParamsWithTimeout creates a new ColumnFamilyMetricsTotalDiskSpaceUsedByNameGetParams object\n// with the ability to set a timeout on a request.\nfunc NewColumnFamilyMetricsTotalDiskSpaceUsedByNameGetParamsWithTimeout(timeout time.Duration) *ColumnFamilyMetricsTotalDiskSpaceUsedByNameGetParams {\n\treturn &ColumnFamilyMetricsTotalDiskSpaceUsedByNameGetParams{\n\t\ttimeout: timeout,\n\t}\n}", "id": 26180, "concepts": ["timeout handling", "function definition", "function composition"], "_raw_llm_output": "timeout handling, function definition, function composition"}
{"seed": "// NewListHetznerSizesParamsWithTimeout creates a new ListHetznerSizesParams object\n// with the ability to set a timeout on a request.\nfunc NewListHetznerSizesParamsWithTimeout(timeout time.Duration) *ListHetznerSizesParams {\n\treturn &ListHetznerSizesParams{\n\t\ttimeout: timeout,\n\t}\n}", "id": 26192, "concepts": ["timeout handling", "time package usage"], "_raw_llm_output": "timeout handling, time package usage"}
{"seed": "// NewMock returns a new Mock with current time set to now.\n//\n// Use Realtime to get the real-time Clock.\nfunc NewMock(now time.Time) *Mock {\n\treturn &Mock{\n\t\tnow:        now,\n\t\tmockTimers: &timerHeap{},\n\t}\n}", "id": 26214, "concepts": ["mocking", "time package usage", "heap data structure"], "_raw_llm_output": "mocking, time package usage, heap data structure"}
{"seed": "// WithRotationTime creates a new Option that sets the\n// time between rotation.\nfunc WithRotationTime(d time.Duration) Option {\n\treturn OptionFn(func(rl *RotateLogs) error {\n\t\trl.rotationTime = d\n\t\treturn nil\n\t})\n}", "id": 26227, "concepts": ["Option pattern", "OptionFn", "time.Duration"], "_raw_llm_output": "Option pattern, OptionFn, time.Duration"}
{"seed": "// Resource writes a JSON API compliant resource response\n// More here: https://jsonapi.org/format/#document-resource-objects\nfunc Resource(w http.ResponseWriter, status int, resource interface{}) error {\n\tw.Header().Set(\"Content-Type\", jsonapi.MediaType)\n\tw.WriteHeader(status)\n\n\treturn jsonapi.MarshalPayload(w, resource)\n}", "id": 26232, "concepts": ["http.ResponseWriter", "jsonapi.MarshalPayload", "jsonapi.MediaType"], "_raw_llm_output": "http.ResponseWriter, jsonapi.MarshalPayload, jsonapi.MediaType"}
{"seed": "// Applet represents the HTML element 'applet'.\n// For more information visit https://www.w3schools.com/tags/tag_applet.asp.\nfunc Applet(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"applet\", Attributes: attrs, Children: children}\n}", "id": 26233, "concepts": ["HTML generation", "HTML tree representation", "HTML element definition"], "_raw_llm_output": "HTML generation, HTML tree representation, HTML element definition"}
{"seed": "// WithIndent creates a new Option to control the indentation\n// for the encoded definition\nfunc WithIndent(s string) Option {\n\treturn option.New(optkeyIndent, s)\n}", "id": 26245, "concepts": ["struct definition", "struct field definition", "struct field access", "struct field initialization", "struct field assignment", "struct field type conversion", "struct field pointer access", "struct field pointer assignment", "struct field pointer type conversion", "struct field pointer initialization", "struct field pointer assignment", "struct field pointer type conversion", "struct field pointer initialization", "struct field pointer assignment", "struct field pointer type conversion", "struct field pointer initialization", "struct field pointer assignment", "struct field pointer type conversion", "struct field pointer initialization", "struct field pointer assignment", "struct field pointer type conversion", "struct field pointer initialization", "struct field pointer assignment", "struct field pointer type conversion", "struct field pointer initialization", "struct field pointer assignment", "struct field pointer type conversion", "struct field pointer initialization", "struct field pointer assignment", "struct field pointer type conversion", "struct field pointer initialization", "struct field pointer assignment", "struct field pointer type conversion", "struct field pointer initialization", "struct field pointer assignment", "struct field pointer type conversion", "struct field pointer initialization", "struct field pointer assignment", "struct field pointer type conversion", "struct field pointer initialization", "struct field pointer assignment", "struct field pointer type conversion", "struct field pointer initialization", "struct field pointer assignment", "struct field pointer type conversion", "struct field pointer initialization", "struct field pointer assignment", "struct field pointer type conversion", "struct field pointer initialization", "struct field"], "_raw_llm_output": "struct definition, struct field definition, struct field access, struct field initialization, struct field assignment, struct field type conversion, struct field pointer access, struct field pointer assignment, struct field pointer type conversion, struct field pointer initialization, struct field pointer assignment, struct field pointer type conversion, struct field pointer initialization, struct field pointer assignment, struct field pointer type conversion, struct field pointer initialization, struct field pointer assignment, struct field pointer type conversion, struct field pointer initialization, struct field pointer assignment, struct field pointer type conversion, struct field pointer initialization, struct field pointer assignment, struct field pointer type conversion, struct field pointer initialization, struct field pointer assignment, struct field pointer type conversion, struct field pointer initialization, struct field pointer assignment, struct field pointer type conversion, struct field pointer initialization, struct field pointer assignment, struct field pointer type conversion, struct field pointer initialization, struct field pointer assignment, struct field pointer type conversion, struct field pointer initialization, struct field pointer assignment, struct field pointer type conversion, struct field pointer initialization, struct field pointer assignment, struct field pointer type conversion, struct field pointer initialization, struct field pointer assignment, struct field pointer type conversion, struct field pointer initialization, struct field pointer assignment, struct field pointer type conversion, struct field pointer initialization, struct field"}
{"seed": "// PossibleManifestResourceDeletionPolicyValues returns the possible values for the ManifestResourceDeletionPolicy const type.\nfunc PossibleManifestResourceDeletionPolicyValues() []ManifestResourceDeletionPolicy {\n\treturn []ManifestResourceDeletionPolicy{\n\t\tManifestResourceDeletionPolicyCascade,\n\t\tManifestResourceDeletionPolicyForce,\n\t\tManifestResourceDeletionPolicyNotSpecified,\n\t}\n}", "id": 26250, "concepts": ["enumerations", "consts", "type definition", "type conversion"], "_raw_llm_output": "enumerations, consts, type definition, type conversion"}
{"seed": "// Small_ is a convenience wrapper for Small without the attrs argument.\nfunc Small_(children ...HTML) HTML {\n  return Small(nil, children...)\n}", "id": 26309, "concepts": ["function definition", "variadic function argument", "function return value"], "_raw_llm_output": "function definition, variadic function argument, function return value"}
{"seed": "// \u68c0\u67e5field\u662f\u5426\u6709\u503c\n// \u7ea6\u5b9a\u7a7a\u5b57\u7b26\u4e32(\"\")\u30010\u548cfalse\u4e3a\u672a\u8bbe\u7f6e\u521d\u59cb\u503c\nfunc isSet(field *reflect.Value) bool {\n\tswitch field.Kind() {\n\tcase reflect.String:\n\t\treturn len(field.Interface().(string)) > 0\n\tcase reflect.Int, reflect.Int8, reflect.Int32, reflect.Int64:\n\t\treturn field.Int() > 0\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint32, reflect.Uint64:\n\t\treturn field.Uint() > 0\n\tcase reflect.Bool:\n\t\treturn field.Interface().(bool)\n\t}\n\n\treturn true\n}", "id": 26328, "concepts": ["reflect package usage", "reflection", "type checking", "type switch"], "_raw_llm_output": "reflect package usage, reflection, type checking, type switch"}
{"seed": "// NewCommandExecutor returns a new instance of CommandExecutor.\nfunc NewCommandExecutor() CommandExecutor {\n\treturn &commandExecutor{}\n}", "id": 26335, "concepts": ["interface implementation", "basic function definition"], "_raw_llm_output": "interface implementation, basic function definition"}
{"seed": "// XORBytes sets dst[i] = x[i] ^ y[i] for all i < n = min(len(x), len(y)),\n// returning n, the number of bytes written to dst.\n// If dst does not have length at least n,\n// XORBytes panics without writing anything to dst.\nfunc XORBytes(dst, x, y []byte) int {\n\tn := len(x)\n\tif len(y) < n {\n\t\tn = len(y)\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n > len(dst) {\n\t\tpanic(\"subtle.XORBytes: dst too short\")\n\t}\n\txorBytes(&dst[0], &x[0], &y[0], n) // arch-specific\n\treturn n\n}", "id": 26356, "concepts": ["byte manipulation", "XOR operation", "pointer arithmetic", "standard library usage"], "_raw_llm_output": "byte manipulation, XOR operation, pointer arithmetic, standard library usage"}
{"seed": "// BulkCreditSamedayFeeIsNil applies the IsNil predicate on the \"bulkCreditSamedayFee\" field.\nfunc BulkCreditSamedayFeeIsNil() predicate.Bulk {\n\treturn predicate.Bulk(func(s *sql.Selector) {\n\t\ts.Where(sql.IsNull(s.C(FieldBulkCreditSamedayFee)))\n\t})\n}", "id": 26388, "concepts": ["sql.Selector", "sql.IsNull", "sql.IsNull predicate", "sql.IsNull predicate usage"], "_raw_llm_output": "sql.Selector, sql.IsNull, sql.IsNull predicate, sql.IsNull predicate usage"}
{"seed": "// NewIssues creates a client that implements issues.Service remotely over HTTP.\n// If a nil httpClient is provided, http.DefaultClient will be used.\n// scheme and host can be empty strings to target local service.\n// A trailing \"/\" is added to path if there isn't one.\nfunc NewIssues(httpClient *http.Client, scheme, host, path string) issues.Service {\n\tif !strings.HasSuffix(path, \"/\") {\n\t\tpath += \"/\"\n\t}\n\treturn &issueClient{\n\t\tclient: httpClient,\n\t\tbaseURL: &url.URL{\n\t\t\tScheme: scheme,\n\t\t\tHost:   host,\n\t\t\tPath:   path,\n\t\t},\n\t}\n}", "id": 26391, "concepts": ["http.Client usage", "url.URL usage", "string manipulation", "error handling (idiomatic `if err != nil`", "`errors.Is`", "`errors.As`)", "standard library usage"], "_raw_llm_output": "http.Client usage, url.URL usage, string manipulation, error handling (idiomatic `if err != nil`, `errors.Is`, `errors.As`), standard library usage"}
{"seed": "// PossibleEndpointTypeValues returns an array of possible values for the EndpointType const type.\nfunc PossibleEndpointTypeValues() []EndpointType {\n\treturn []EndpointType{EndpointTypeAFD, EndpointTypeATM, EndpointTypeAzureRegion, EndpointTypeCDN}\n}", "id": 26427, "concepts": ["const type", "array", "type conversion"], "_raw_llm_output": "const type, array, type conversion"}
{"seed": "// NewPcloudSapGetParamsWithTimeout creates a new PcloudSapGetParams object\n// with the ability to set a timeout on a request.\nfunc NewPcloudSapGetParamsWithTimeout(timeout time.Duration) *PcloudSapGetParams {\n\treturn &PcloudSapGetParams{\n\t\ttimeout: timeout,\n\t}\n}", "id": 26431, "concepts": ["timeout handling", "time package usage"], "_raw_llm_output": "timeout handling, time package usage"}
{"seed": "// NewJsonReceiver initializes an empty `JsonReceiver` and returns a pointer to it.\n//\n// It expects a response channel to be passed in for parsed `Alert` data structures\n// to be placed onto.\nfunc NewJsonReceiver(alertReceived chan<- models.Alert) *JsonReceiver {\n\treturn &JsonReceiver{alertReceived: alertReceived}\n}", "id": 26433, "concepts": ["pointer usage", "struct definition", "channel usage"], "_raw_llm_output": "pointer usage, struct definition, channel usage"}
{"seed": "// hasValidCountQuery checks whether the count query passed by user is valid. It\n// validates especially if the query len is less than 10.\nfunc hasValidCountQuery(query interface{}) error {\n\tswitch query.(type) {\n\tcase []interface{}:\n\t\tquerySize := len(query.([]interface{}))\n\t\tif querySize > 10 {\n\t\t\treturn errors.New(\"Count Query Validator: the query count entity has a limit of 10 queries by request.\")\n\t\t}\n\t}\n\n\treturn nil\n}", "id": 26437, "concepts": ["type assertion", "type switch", "interface", "error handling"], "_raw_llm_output": "type assertion, type switch, interface, error handling"}
{"seed": "// NewConsoleHandler creates and returns a Handler which prints every log\n// message that it has access to (according to its level(s)) to the console\nfunc NewConsoleHandler(levels ...LogLevel) Handler {\n\treturn &consoleHandler{leveled{levels}}\n}", "id": 26449, "concepts": ["struct composition", "interface composition", "type embedding", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", "method composition", ""], "_raw_llm_output": "struct composition, interface composition, type embedding, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition, method composition,"}
{"seed": "// WithDisableOutput defines if the output (logo, queues information)\n// should be disabled.\nfunc WithDisableOutput(disableOutput bool) Option {\n\treturn func(opts *Options) {\n\t\topts.DisableOutput = disableOutput\n\t}\n}", "id": 26450, "concepts": ["function composition", "function options", "function composition", "function options"], "_raw_llm_output": "function composition, function options, function composition, function options"}
{"seed": "// ByteCountSI converts input string like \"982814103\" (size in bytes, number represented as a string)\n// to a more human-readable string like \"969.9 MB\"\nfunc ByteCountSI(input string) string {\n\n\tb, err := strconv.Atoi(input)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\treturn ByteCountSIInt(b)\n}", "id": 26479, "concepts": ["string to int conversion", "string formatting", "integer division", "integer multiplication", "integer summation", "integer subtraction", "integer division", "integer multiplication", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer division", "integer"], "_raw_llm_output": "string to int conversion, string formatting, integer division, integer multiplication, integer summation, integer subtraction, integer division, integer multiplication, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer division, integer"}
{"seed": "// NewUploadRecord returns a TransferRecord filled out with a UUID,\n// StartTime, Status of \"requested\", and a Kind of \"upload\".\nfunc NewUploadRecord() *TransferRecord {\n\treturn &TransferRecord{\n\t\tUUID:      uuid.New(),\n\t\tStartTime: time.Now(),\n\t\tStatus:    RequestedStatus,\n\t\tKind:      DownloadKind,\n\t}\n}", "id": 26483, "concepts": ["UUID generation", "time handling", "struct definition", "struct initialization"], "_raw_llm_output": "UUID generation, time handling, struct definition, struct initialization"}
{"seed": "// Returns a string that gives the given number of bytes with reasonable\n// units. If 'fixedWidth' is true, the returned string will always be the same\n// length, which makes it easier to line things up in columns.\nfunc fmtbytes(n int64, fixedWidth bool) string {\n\tif fixedWidth {\n\t\tif n >= 1024*1024*1024*1024 {\n\t\t\treturn fmt.Sprintf(\"%6.2f TiB\", float64(n)/(1024.*1024.*\n\t\t\t\t1024.*1024.))\n\t\t} else if n >= 1024*1024*1024 {\n\t\t\treturn fmt.Sprintf(\"%6.2f GiB\", float64(n)/(1024.*1024.*\n\t\t\t\t1024.))\n\t\t} else if n > 1024*1024 {\n\t\t\treturn fmt.Sprintf(\"%6.2f MiB\", float64(n)/(1024.*1024.))\n\t\t} else if n > 1024 {\n\t\t\treturn fmt.Sprintf(\"%6.2f kiB\", float64(n)/1024.)\n\t\t} else {\n\t\t\treturn fmt.Sprintf(\"%6d B  \", n)\n\t\t}\n\t} else {\n\t\tif n >= 1024*1024*1024*1024 {\n\t\t\treturn fmt.Sprintf(\"%.2f TiB\", float64(n)/(1024.*1024.*\n\t\t\t\t1024.*1024.))\n\t\t} else if n >= 1024*1024*1024 {\n\t\t\treturn fmt.Sprintf(\"%.2f GiB\", float64(n)/(1024.*1024.*\n\t\t\t\t1024.))\n\t\t} else if n > 1024*1024 {\n\t\t\treturn fmt.Sprintf(\"%.2f MiB\", float64(n)/(1024.*1024.))\n\t\t} else if n > 1024 {\n\t\t\treturn fmt.Sprintf(\"%.2f kiB\", float64(n)/1024.)\n\t\t} else {\n\t\t\treturn fmt.Sprintf(\"%d B\", n)\n\t\t}\n\t}\n}", "id": 26485, "concepts": ["string formatting", "fmt package usage", "integer division", "floating point division", "string concatenation", "string comparison", "string length", "string length comparison", "string length assignment", "string length assignment comparison", "string length assignment comparison", "string length assignment comparison", "string length assignment comparison", "string length assignment comparison", "string length assignment comparison", "string length assignment comparison", "string length assignment comparison", "string length assignment comparison", "string length assignment comparison", "string length assignment comparison", "string length assignment comparison", "string length assignment comparison", "string length assignment comparison", "string length assignment comparison", "string length assignment comparison", "string length assignment comparison", "string length assignment comparison", "string length assignment comparison", "string length assignment comparison", "string length assignment comparison", "string length assignment comparison", "string length assignment comparison", "string length assignment comparison", "string length assignment comparison", "string length assignment comparison", "string length assignment comparison", "string length assignment comparison", "string length assignment comparison", "string length assignment comparison", "string length assignment comparison", "string length assignment comparison", "string length assignment comparison", "string length assignment comparison", "string length assignment comparison", "string length assignment comparison", "string length assignment comparison", "string length assignment comparison", "string length assignment comparison", "string length assignment comparison", "string length assignment comparison", "string length assignment comparison", "string length assignment comparison", "string length assignment comparison", "string length assignment"], "_raw_llm_output": "string formatting, fmt package usage, integer division, floating point division, string concatenation, string comparison, string length, string length comparison, string length assignment, string length assignment comparison, string length assignment comparison, string length assignment comparison, string length assignment comparison, string length assignment comparison, string length assignment comparison, string length assignment comparison, string length assignment comparison, string length assignment comparison, string length assignment comparison, string length assignment comparison, string length assignment comparison, string length assignment comparison, string length assignment comparison, string length assignment comparison, string length assignment comparison, string length assignment comparison, string length assignment comparison, string length assignment comparison, string length assignment comparison, string length assignment comparison, string length assignment comparison, string length assignment comparison, string length assignment comparison, string length assignment comparison, string length assignment comparison, string length assignment comparison, string length assignment comparison, string length assignment comparison, string length assignment comparison, string length assignment comparison, string length assignment comparison, string length assignment comparison, string length assignment comparison, string length assignment comparison, string length assignment comparison, string length assignment comparison, string length assignment comparison, string length assignment comparison, string length assignment comparison, string length assignment comparison, string length assignment comparison, string length assignment comparison, string length assignment comparison, string length assignment"}
{"seed": "// Wbr represents the HTML void element 'wbr'.\n// For more information visit https://www.w3schools.com/tags/tag_wbr.asp.\nfunc Wbr(attrs []htmlgo.Attribute) HTML {\n\treturn &htmlgo.Tree{Tag: \"wbr\", Attributes: attrs, SelfClosing: true}\n}", "id": 26492, "concepts": ["HTML generation", "HTML tree representation", "HTML void element", "HTML attribute"], "_raw_llm_output": "HTML generation, HTML tree representation, HTML void element, HTML attribute"}
{"seed": "// NewIntegrationRuntimeNodesClient creates a new instance of IntegrationRuntimeNodesClient with the specified values.\n//   - subscriptionID - The subscription identifier.\n//   - credential - used to authorize requests. Usually a credential from azidentity.\n//   - options - pass nil to accept the default values.\nfunc NewIntegrationRuntimeNodesClient(subscriptionID string, credential azcore.TokenCredential, options *arm.ClientOptions) (*IntegrationRuntimeNodesClient, error) {\n\tcl, err := arm.NewClient(moduleName+\".IntegrationRuntimeNodesClient\", moduleVersion, credential, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tclient := &IntegrationRuntimeNodesClient{\n\t\tsubscriptionID: subscriptionID,\n\t\tinternal:       cl,\n\t}\n\treturn client, nil\n}", "id": 26495, "concepts": ["client creation", "client options", "client creation with options", "client creation with credentials"], "_raw_llm_output": "client creation, client options, client creation with options, client creation with credentials"}
{"seed": "// Code first calls Cause() to find the cause of the error.\n// Then it returns the code of the cause.\n// If the cause implements the following interface:\n//\n//     type coder interface {\n//            Code() interface{}\n//     }\n//\n// its code is the return value of Code().\n// Otherwise, nil will be returned.\nfunc Code(err error) interface{} {\n\terr = Cause(err)\n\n\ttype coder interface {\n\t\tCode() interface{}\n\t}\n\tif err, ok := err.(coder); ok {\n\t\treturn err.Code()\n\t}\n\treturn nil\n}", "id": 26499, "concepts": ["error handling (errors.Cause)", "interface implementation", "type assertion"], "_raw_llm_output": "error handling (errors.Cause), interface implementation, type assertion"}
{"seed": "// RemoveBlanks returns a slice of strings, but trimmed, and with empty/all-whitespace\n// strings removed.\nfunc RemoveBlanks(ss []string) []string {\n\tvar r []string\n\n\tfor _, s := range ss {\n\t\ts = strings.TrimSpace(s)\n\t\tif s == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tr = append(r, s)\n\t}\n\n\treturn r\n}", "id": 26505, "concepts": ["string manipulation", "string trimming", "slice iteration (range loop)", "slice append", "empty/all-whitespace string handling"], "_raw_llm_output": "string manipulation, string trimming, slice iteration (range loop), slice append, empty/all-whitespace string handling"}
{"seed": "// Noscript represents the HTML element 'noscript'.\n// For more information visit https://www.w3schools.com/tags/tag_noscript.asp.\nfunc Noscript(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"noscript\", Attributes: attrs, Children: children}\n}", "id": 26506, "concepts": ["HTML generation", "HTML tree traversal", "HTML tree manipulation", "HTML element definition"], "_raw_llm_output": "HTML generation, HTML tree traversal, HTML tree manipulation, HTML element definition"}
{"seed": "// NewSubscriptionClient creates a new instance of SubscriptionClient with the specified values.\n//   - subscriptionID - The ID of the target subscription.\n//   - credential - used to authorize requests. Usually a credential from azidentity.\n//   - options - pass nil to accept the default values.\nfunc NewSubscriptionClient(subscriptionID string, credential azcore.TokenCredential, options *arm.ClientOptions) (*SubscriptionClient, error) {\n\tcl, err := arm.NewClient(moduleName+\".SubscriptionClient\", moduleVersion, credential, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tclient := &SubscriptionClient{\n\t\tsubscriptionID: subscriptionID,\n\t\tinternal:       cl,\n\t}\n\treturn client, nil\n}", "id": 26512, "concepts": ["function definition", "function parameters", "function return values", "anonymous function", "standard library usage"], "_raw_llm_output": "function definition, function parameters, function return values, anonymous function, standard library usage"}
{"seed": "// NewRoffRenderer creates a new blackfriday Renderer for generating roff documents\n// from markdown\nfunc NewRoffRenderer() *roffRenderer { // nolint: golint\n\tvar extensions blackfriday.Extensions\n\n\textensions |= blackfriday.NoIntraEmphasis\n\textensions |= blackfriday.Tables\n\textensions |= blackfriday.FencedCode\n\textensions |= blackfriday.SpaceHeadings\n\textensions |= blackfriday.Footnotes\n\textensions |= blackfriday.Titleblock\n\textensions |= blackfriday.DefinitionLists\n\treturn &roffRenderer{\n\t\textensions: extensions,\n\t}\n}", "id": 26515, "concepts": ["blackfriday package usage", "roff document generation"], "_raw_llm_output": "blackfriday package usage, roff document generation"}
{"seed": "// cleanHost strips anything after '/' or ' '.\n// Ideally we'd clean the Host header according to the spec:\n//   https://tools.ietf.org/html/rfc7230#section-5.4 (Host = uri-host [ \":\" port ]\")\n//   https://tools.ietf.org/html/rfc7230#section-2.7 (uri-host -> rfc3986's host)\n//   https://tools.ietf.org/html/rfc3986#section-3.2.2 (definition of host)\n// But practically, what we are trying to avoid is the situation in\n// issue 11206, where a malformed Host header used in the proxy context\n// would create a bad request. So it is enough to just truncate at the\n// first offending character.\nfunc cleanHost(in string) string {\n\tif i := strings.IndexAny(in, \" /\"); i != -1 {\n\t\treturn in[:i]\n\t}\n\treturn in\n}", "id": 26519, "concepts": ["string manipulation", "string indexing", "string splitting", "string concatenation"], "_raw_llm_output": "string manipulation, string indexing, string splitting, string concatenation"}
{"seed": "// WindowToUint is a covenience function for converting []xproto.Window\n// to []uint.\nfunc WindowToInt(ids []xproto.Window) []uint {\n\tids32 := make([]uint, len(ids))\n\tfor i, v := range ids {\n\t\tids32[i] = uint(v)\n\t}\n\treturn ids32\n}", "id": 26523, "concepts": ["conversion", "slice iteration", "slice creation"], "_raw_llm_output": "conversion, slice iteration, slice creation"}
{"seed": "/*\nhttps://leetcode.com/problems/coin-change-2/\n\nYou are given coins of different denominations and a total amount of money. Write a function to compute\nthe number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin.\n\nExample 1:\n\nInput: amount = 5, coins = [1, 2, 5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\n\nExample 2:\n\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.\n\nExample 3:\n\nInput: amount = 10, coins = [10]\nOutput: 1\n*/\n\nfunc change(amount int, coins []int) int {\n\tmemo := make([][]int, len(coins)+1)\n\tfor x := range memo {\n\t\tmemo[x] = make([]int, amount+1)\n\t}\n\n\tmemo[0][0] = 1\n\n\tfor x, coin := range coins {\n\t\tmemo[x+1][0] = 1\n\t\tfor y := 1; y <= amount; y++ {\n\t\t\tmemo[x+1][y] = memo[x][y] // exclude current coin - take the amount of previous coin\n\t\t\tif coin <= y {\n\t\t\t\tmemo[x+1][y] += memo[x+1][y-coin] // try to include current coin\n\t\t\t}\n\t\t}\n\t}\n\n\treturn memo[len(coins)][amount]\n}", "id": 26529, "concepts": ["dynamic programming", "recursion", "memoization"], "_raw_llm_output": "dynamic programming, recursion, memoization"}
{"seed": "// Flags returns a default [Help] value representing fs. If details are\n// provided, they're included as a single untitled section before any FLAGS\n// section(s).\n//\n// This function is meant as reasonable default for most users, and as an\n// example. Callers who want different help output should implement their own\n// [Help] value constructors like this one.\nfunc Flags(fs ff.Flags, details ...string) Help {\n\tvar help Help\n\thelp = append(help, NewUntitledSection(fs.GetName()))\n\tif len(details) > 0 {\n\t\thelp = append(help, NewUntitledSection(details...))\n\t}\n\thelp = append(help, NewFlagsSections(fs)...)\n\treturn help\n}", "id": 26530, "concepts": ["ff.Flags", "ff.Help", "ff.Section", "ff.UntitledSection", "ff.Flags.GetName", "ff.Flags.NewUntitledSection", "ff.Flags.NewFlagsSections", "ff.Flags.NewFlag", "ff.Flags.NewFlagSet", "ff.Flags.NewSection", "ff.Flags.NewStringFlag", "ff.Flags.NewBoolFlag", "ff.Flags.NewIntFlag", "ff.Flags.NewFloat64Flag", "ff.Flags.NewUint64Flag", "ff.Flags.NewUint32Flag", "ff.Flags.NewUint16Flag", "ff.Flags.NewUint8Flag", "ff.Flags.NewStringSliceFlag", "ff.Flags.NewStringMapFlag", "ff.Flags.NewStringFlagSet", "ff.Flags.NewBoolFlagSet", "ff.Flags.NewIntFlagSet", "ff.Flags.NewFloat64FlagSet", "ff.Flags.NewUint64FlagSet", "ff.Flags.NewUint32FlagSet", "ff.Flags.NewUint16FlagSet", "ff.Flags.NewUint8FlagSet", "ff.Flags.NewStringSliceFlagSet", "ff.Flags.NewStringMapFlagSet", ""], "_raw_llm_output": "ff.Flags, ff.Help, ff.Section, ff.UntitledSection, ff.Flags.GetName, ff.Flags.NewUntitledSection, ff.Flags.NewFlagsSections, ff.Flags.NewFlag, ff.Flags.NewFlagSet, ff.Flags.NewSection, ff.Flags.NewStringFlag, ff.Flags.NewBoolFlag, ff.Flags.NewIntFlag, ff.Flags.NewFloat64Flag, ff.Flags.NewUint64Flag, ff.Flags.NewUint32Flag, ff.Flags.NewUint16Flag, ff.Flags.NewUint8Flag, ff.Flags.NewStringSliceFlag, ff.Flags.NewStringMapFlag, ff.Flags.NewStringFlagSet, ff.Flags.NewBoolFlagSet, ff.Flags.NewIntFlagSet, ff.Flags.NewFloat64FlagSet, ff.Flags.NewUint64FlagSet, ff.Flags.NewUint32FlagSet, ff.Flags.NewUint16FlagSet, ff.Flags.NewUint8FlagSet, ff.Flags.NewStringSliceFlagSet, ff.Flags.NewStringMapFlagSet,"}
{"seed": "// DefaultProfileName returns \"default\" or TMUXIST_PROFILE.\nfunc DefaultProfileName() string {\n\tp := os.Getenv(\"TMUXIST_PROFILE\")\n\tif p == \"\" {\n\t\tp = \"default\"\n\t}\n\treturn p\n}", "id": 26538, "concepts": ["environment variable usage", "string concatenation"], "_raw_llm_output": "environment variable usage, string concatenation"}
{"seed": "/*\n\tInitializeSystemModels will call gorm.DB.AutoMigrate() for models associated with systems, and set up foreign key\n\trelationships for those models if needed\n*/\nfunc InitializeSystemModels() *gorm.DB {\n\tlog.Println(\"Initialize system models\")\n\tdb := GetGORMDbConnection()\n\tdefer Close(db)\n\n\tdb.AutoMigrate(\n\t\t&System{},\n\t\t&EncryptionKey{},\n\t\t&Secret{},\n\t)\n\n\tdb.Model(&System{}).AddForeignKey(\"group_id\", \"groups(group_id)\", \"RESTRICT\", \"RESTRICT\")\n\tdb.Model(&EncryptionKey{}).AddForeignKey(\"system_id\", \"systems(id)\", \"RESTRICT\", \"RESTRICT\")\n\tdb.Model(&Secret{}).AddForeignKey(\"system_id\", \"systems(id)\", \"RESTRICT\", \"RESTRICT\")\n\n\treturn db\n}", "id": 26545, "concepts": ["gorm package usage", "foreign key relationships", "gorm.DB.AutoMigrate()", "gorm.DB.Model().AddForeignKey()"], "_raw_llm_output": "gorm package usage, foreign key relationships, gorm.DB.AutoMigrate(), gorm.DB.Model().AddForeignKey()"}
{"seed": "// WorkplaceIn applies the In predicate on the \"workplace\" field.\nfunc WorkplaceIn(vs ...string) predicate.User {\n\treturn predicate.User(sql.FieldIn(FieldWorkplace, vs...))\n}", "id": 26551, "concepts": ["sql.FieldIn", "predicate.User", "variadic function definition"], "_raw_llm_output": "sql.FieldIn, predicate.User, variadic function definition"}
{"seed": "// NewDeviceSettingsClient creates a new instance of DeviceSettingsClient with the specified values.\n//   - subscriptionID - The subscription id\n//   - credential - used to authorize requests. Usually a credential from azidentity.\n//   - options - pass nil to accept the default values.\nfunc NewDeviceSettingsClient(subscriptionID string, credential azcore.TokenCredential, options *arm.ClientOptions) (*DeviceSettingsClient, error) {\n\tcl, err := arm.NewClient(moduleName+\".DeviceSettingsClient\", moduleVersion, credential, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tclient := &DeviceSettingsClient{\n\t\tsubscriptionID: subscriptionID,\n\t\tinternal:       cl,\n\t}\n\treturn client, nil\n}", "id": 26556, "concepts": ["module initialization", "module version", "module name", "client initialization", "client options", "client creation", "module initialization", "module version", "module name", "client initialization", "client options", "client creation", "module initialization", "module version", "module name", "client initialization", "client options", "client creation", "module initialization", "module version", "module name", "client initialization", "client options", "client creation", "module initialization", "module version", "module name", "client initialization", "client options", "client creation", "module initialization", "module version", "module name", "client initialization", "client options", "client creation", "module initialization", "module version", "module name", "client initialization", "client options", "client creation", "module initialization", "module version", "module name", "client initialization", "client options", "client creation", "module initialization", "module version", "module name", "client initialization", "client options", "client creation", "module initialization", "module version", "module name", "client initialization", "client options", "client creation", "module initialization", "module version", "module name", "client initialization", "client options", "client creation", "module initialization", "module version", "module name", "client initialization", "client options", "client creation", "module initialization", "module version", "module name", "client initialization", "client options", "client creation", "module initialization", "module version", "module name", "client initialization", "client options", "client creation", "module initialization", ""], "_raw_llm_output": "module initialization, module version, module name, client initialization, client options, client creation, module initialization, module version, module name, client initialization, client options, client creation, module initialization, module version, module name, client initialization, client options, client creation, module initialization, module version, module name, client initialization, client options, client creation, module initialization, module version, module name, client initialization, client options, client creation, module initialization, module version, module name, client initialization, client options, client creation, module initialization, module version, module name, client initialization, client options, client creation, module initialization, module version, module name, client initialization, client options, client creation, module initialization, module version, module name, client initialization, client options, client creation, module initialization, module version, module name, client initialization, client options, client creation, module initialization, module version, module name, client initialization, client options, client creation, module initialization, module version, module name, client initialization, client options, client creation, module initialization, module version, module name, client initialization, client options, client creation, module initialization, module version, module name, client initialization, client options, client creation, module initialization,"}
{"seed": "// BetterHeroScoreIn applies the In predicate on the \"better_hero_score\" field.\nfunc BetterHeroScoreIn(vs ...int) predicate.User {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.User(func(s *sql.Selector) {\n\t\t// if not arguments were provided, append the FALSE constants,\n\t\t// since we can't apply \"IN ()\". This will make this predicate falsy.\n\t\tif len(vs) == 0 {\n\t\t\ts.Where(sql.False())\n\t\t\treturn\n\t\t}\n\t\ts.Where(sql.In(s.C(FieldBetterHeroScore), v...))\n\t})\n}", "id": 26559, "concepts": ["sql.Selector", "sql.In", "sql.False", "predicate.User", "function definition"], "_raw_llm_output": "sql.Selector, sql.In, sql.False, predicate.User, function definition"}
{"seed": "// NewCoreClientSet returns a clientset that will respond with the provided objects.\n// It's backed by a very simple object tracker that processes creates, updates and deletions as-is,\n// without applying any validations and/or defaults. It shouldn't be considered a replacement\n// for a real clientset and is mostly useful in simple unit tests.\nfunc NewCoreClientSet(objects ...runtime.Object) (*Clientset, *FakeObjectTracker) {\n\n\tvar scheme = runtime.NewScheme()\n\tvar codecs = serializer.NewCodecFactory(scheme)\n\n\tmetav1.AddToGroupVersion(scheme, schema.GroupVersion{Version: \"v1\"})\n\t_ = k8sfake.AddToScheme(scheme)\n\n\to := &FakeObjectTracker{\n\t\tFakeWatcher: watch.NewFake(),\n\t\tdelegatee:   k8stesting.NewObjectTracker(scheme, codecs.UniversalDecoder()),\n\t}\n\n\tfor _, obj := range objects {\n\t\tif err := o.Add(obj); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\n\tcs := &Clientset{Clientset: &k8sfake.Clientset{}}\n\tcs.FakeDiscovery = &fakediscovery.FakeDiscovery{Fake: &cs.Fake}\n\tcs.Fake.AddReactor(\"*\", \"*\", k8stesting.ObjectReaction(o))\n\tcs.Fake.AddWatchReactor(\"*\", o.watchReactionFunc)\n\n\treturn cs, o\n}", "id": 26572, "concepts": ["fake clientset", "fake object tracker", "fake discovery", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", "fake clientset", ""], "_raw_llm_output": "fake clientset, fake object tracker, fake discovery, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset, fake clientset,"}
{"seed": "// NewQueryFirewallFieldsParamsWithHTTPClient creates a new QueryFirewallFieldsParams object\n// with the ability to set a custom HTTPClient for a request.\nfunc NewQueryFirewallFieldsParamsWithHTTPClient(client *http.Client) *QueryFirewallFieldsParams {\n\treturn &QueryFirewallFieldsParams{\n\t\tHTTPClient: client,\n\t}\n}", "id": 26576, "concepts": ["http.Client", "function definition", "pointer receiver"], "_raw_llm_output": "http.Client, function definition, pointer receiver"}
{"seed": "// HandlerAPI returns an http.Handler given the handler configuration\n// and the corresponding *Kube4EdgeManagement instance.\n// It mounts all the business logic implementers in the right routing.\nfunc HandlerAPI(c Config) (http.Handler, *operations.Kube4EdgeManagementAPI, error) {\n\tspec, err := loads.Analyzed(swaggerCopy(SwaggerJSON), \"\")\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"analyze swagger: %v\", err)\n\t}\n\tapi := operations.NewKube4EdgeManagementAPI(spec)\n\tapi.ServeError = errors.ServeError\n\tapi.Logger = c.Logger\n\n\tif c.APIKeyAuthenticator != nil {\n\t\tapi.APIKeyAuthenticator = c.APIKeyAuthenticator\n\t}\n\tif c.BasicAuthenticator != nil {\n\t\tapi.BasicAuthenticator = c.BasicAuthenticator\n\t}\n\tif c.BearerAuthenticator != nil {\n\t\tapi.BearerAuthenticator = c.BearerAuthenticator\n\t}\n\n\tapi.JSONConsumer = runtime.JSONConsumer()\n\tapi.JSONProducer = runtime.JSONProducer()\n\tapi.YggdrasilGetControlMessageForDeviceHandler = yggdrasil.GetControlMessageForDeviceHandlerFunc(func(params yggdrasil.GetControlMessageForDeviceParams) middleware.Responder {\n\t\tctx := params.HTTPRequest.Context()\n\t\treturn c.YggdrasilAPI.GetControlMessageForDevice(ctx, params)\n\t})\n\tapi.YggdrasilGetDataMessageForDeviceHandler = yggdrasil.GetDataMessageForDeviceHandlerFunc(func(params yggdrasil.GetDataMessageForDeviceParams) middleware.Responder {\n\t\tctx := params.HTTPRequest.Context()\n\t\treturn c.YggdrasilAPI.GetDataMessageForDevice(ctx, params)\n\t})\n\tapi.YggdrasilPostControlMessageForDeviceHandler = yggdrasil.PostControlMessageForDeviceHandlerFunc(func(params yggdrasil.PostControlMessageForDeviceParams) middleware.Responder {\n\t\tctx := params.HTTPRequest.Context()\n\t\treturn c.YggdrasilAPI.PostControlMessageForDevice(ctx, params)\n\t})\n\tapi.YggdrasilPostDataMessageForDeviceHandler = yggdrasil.PostDataMessageForDeviceHandlerFunc(func(params yggdrasil.PostDataMessageForDeviceParams) middleware.Responder {\n\t\tctx := params.HTTPRequest.Context()\n\t\treturn c.YggdrasilAPI.PostDataMessageForDevice(ctx, params)\n\t})\n\tapi.ServerShutdown = func() {}\n\treturn api.Serve(c.InnerMiddleware), api, nil\n}", "id": 26579, "concepts": ["http.Handler", "http.Serve", "http.ServeMux", "http.HandlerFunc", "middleware", "middleware.Responder", "http.Request", "http.ResponseWriter", "http.Context", "http.Handler", "http.HandlerFunc", "http.Server", "http.Server.Shutdown", "http.Server.ListenAndServe", "http.Server.ListenAndServeTLS", "http.Server.Serve", "http.Server.ServeTLS", "http.Server.Handler", "http.Server.Handler.ServeHTTP", "http.Server.Handler.Serve", "http.Server.Handler.ServeHTTP", "http.Server.Handler.Serve", "http.Server.Handler.ServeHTTP", "http.Server.Handler.Serve", "http.Server.Handler.ServeHTTP", "http.Server.Handler.Serve", "http.Server.Handler.ServeHTTP", "http.Server.Handler.Serve", "http.Server.Handler.ServeHTTP", "http.Server.Handler.Serve", "http.Server.Handler.ServeHTTP", "http.Server.Handler.Serve", "http.Server.Handler.ServeHTTP", "http.Server.Handler.Serve", "http.Server.Handler.ServeHTTP", "http.Server.Handler.Serve", "http.Server.Handler.ServeHTTP", "http.Server."], "_raw_llm_output": "http.Handler, http.Serve, http.ServeMux, http.HandlerFunc, middleware, middleware.Responder, http.Request, http.ResponseWriter, http.Context, http.Handler, http.HandlerFunc, http.Server, http.Server.Shutdown, http.Server.ListenAndServe, http.Server.ListenAndServeTLS, http.Server.Serve, http.Server.ServeTLS, http.Server.Handler, http.Server.Handler.ServeHTTP, http.Server.Handler.Serve, http.Server.Handler.ServeHTTP, http.Server.Handler.Serve, http.Server.Handler.ServeHTTP, http.Server.Handler.Serve, http.Server.Handler.ServeHTTP, http.Server.Handler.Serve, http.Server.Handler.ServeHTTP, http.Server.Handler.Serve, http.Server.Handler.ServeHTTP, http.Server.Handler.Serve, http.Server.Handler.ServeHTTP, http.Server.Handler.Serve, http.Server.Handler.ServeHTTP, http.Server.Handler.Serve, http.Server.Handler.ServeHTTP, http.Server.Handler.Serve, http.Server.Handler.ServeHTTP, http.Server."}
{"seed": "// NewOptions creates a new Options populated with sane default values\nfunc NewOptions() *Options {\n\treturn &Options{\n\t\tBulletChar:           \"\u2022\",\n\t\tCollapseOnCompletion: false,\n\t\tColorError:           160,\n\t\tColorPending:         22,\n\t\tColorRunning:         22,\n\t\tColorSuccess:         10,\n\t\tEventDriven:          true,\n\t\tExecReplaceString:    \"<exec>\",\n\t\tIgnoreFailure:        false,\n\t\tMaxParallelCmds:      4,\n\t\tReplicaReplaceString: \"<replace>\",\n\t\tShowFailureReport:    true,\n\t\tShowSummaryErrors:    false,\n\t\tShowSummaryFooter:    true,\n\t\tShowSummarySteps:     true,\n\t\tShowSummaryTimes:     true,\n\t\tShowTaskEta:          false,\n\t\tShowTaskOutput:       true,\n\t\tStopOnFailure:        true,\n\t\tSingleLineDisplay:    false,\n\t\tUpdateInterval:       -1,\n\t}\n}", "id": 26590, "concepts": ["struct definition", "struct field initialization", "struct field access"], "_raw_llm_output": "struct definition, struct field initialization, struct field access"}
{"seed": "// NewThread returns a new Thread which has the PC and SP set to the value specified by the argument.\nfunc NewThread(pc int, sp int) *Thread {\n\treturn &Thread{\n\t\tPC: pc,\n\t\tSP: sp,\n\t}\n}", "id": 26600, "concepts": ["struct definition", "struct field access"], "_raw_llm_output": "struct definition, struct field access"}
{"seed": "// Wbr_ is a convenience wrapper for Wbr without the attrs argument.\nfunc Wbr_() HTML {\n  return Wbr(nil)\n}", "id": 26601, "concepts": ["HTML", "basic function definition"], "_raw_llm_output": "HTML, basic function definition"}
{"seed": "// PossibleIPActionValues returns an array of possible values for the IPAction const type.\nfunc PossibleIPActionValues() []IPAction {\n\treturn []IPAction{Accept, Reject}\n}", "id": 26603, "concepts": ["enumerations", "const declaration", "array declaration"], "_raw_llm_output": "enumerations, const declaration, array declaration"}
{"seed": "// NewCredentialsResponseElementWithDefaults instantiates a new CredentialsResponseElement object\n// This constructor will only assign default values to properties that have it defined,\n// but it doesn't guarantee that properties required by API are set\nfunc NewCredentialsResponseElementWithDefaults() *CredentialsResponseElement {\n\tthis := CredentialsResponseElement{}\n\treturn &this\n}", "id": 26604, "concepts": ["constructor", "default value assignment", "API usage"], "_raw_llm_output": "constructor, default value assignment, API usage"}
{"seed": "// CreateInformationalUrlFromDiscriminatorValue creates a new instance of the appropriate class based on discriminator value\nfunc CreateInformationalUrlFromDiscriminatorValue(parseNode i878a80d2330e89d26896388a3f487eef27b0a0e6c010c493bf80be1452208f91.ParseNode)(i878a80d2330e89d26896388a3f487eef27b0a0e6c010c493bf80be1452208f91.Parsable, error) {\n    return NewInformationalUrl(), nil\n}", "id": 26605, "concepts": ["interface implementation", "struct definition", "interface usage", "standard library usage"], "_raw_llm_output": "interface implementation, struct definition, interface usage, standard library usage"}
{"seed": "// NewNegotiableQuoteCouponManagementV1RemoveDeleteParamsWithTimeout creates a new NegotiableQuoteCouponManagementV1RemoveDeleteParams object\n// with the default values initialized, and the ability to set a timeout on a request\nfunc NewNegotiableQuoteCouponManagementV1RemoveDeleteParamsWithTimeout(timeout time.Duration) *NegotiableQuoteCouponManagementV1RemoveDeleteParams {\n\tvar ()\n\treturn &NegotiableQuoteCouponManagementV1RemoveDeleteParams{\n\n\t\ttimeout: timeout,\n\t}\n}", "id": 26607, "concepts": ["timeout handling", "struct initialization", "anonymous function", "standard library usage"], "_raw_llm_output": "timeout handling, struct initialization, anonymous function, standard library usage"}
{"seed": "// Equal asserts that \"expected\" and \"actual\" are equal.\n//\n// If they are not, a diff of the Go representation of the values will be displayed.\nfunc Equal[T any](t testing.TB, expected, actual T, msgAndArgs ...interface{}) {\n\tif objectsAreEqual(expected, actual) {\n\t\treturn\n\t}\n\tt.Helper()\n\tmsg := formatMsgAndArgs(\"Expected values to be equal:\", msgAndArgs...)\n\tt.Fatalf(\"%s\\n%s\", msg, diff(expected, actual))\n}", "id": 26608, "concepts": ["type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", "type assertion", ""], "_raw_llm_output": "type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion, type assertion,"}
{"seed": "// ToTransmissionRecordModels transforms a TransmissionRecord DTO array to a TransmissionRecord model array\nfunc ToTransmissionRecordModels(trs []TransmissionRecord) []models.TransmissionRecord {\n\tmodels := make([]models.TransmissionRecord, len(trs))\n\tfor i, tr := range trs {\n\t\tmodels[i] = ToTransmissionRecordModel(tr)\n\t}\n\treturn models\n}", "id": 26609, "concepts": ["array iteration (range loop)", "array conversion", "array length"], "_raw_llm_output": "array iteration (range loop), array conversion, array length"}
{"seed": "// HandleConsentRemoval returns a convenience http.HandlerFunc for receiving\n// requests for user consent removals from Vipps. `cb` is called with the uid\n// of the user to that wishes to have its consents and data removed.\nfunc HandleConsentRemoval(cb func(uid string)) http.HandlerFunc {\n\tfn := func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodDelete {\n\t\t\tw.Header().Set(\"Allow\", \"DELETE\")\n\t\t\thttp.Error(w, \"Unsupported method\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\t\tuid := path.Base(r.URL.Path)\n\t\tcb(uid)\n\t}\n\n\treturn fn\n}", "id": 26615, "concepts": ["http.HandlerFunc", "http.ResponseWriter", "http.Request", "http.Method", "http.Error", "path.Base"], "_raw_llm_output": "http.HandlerFunc, http.ResponseWriter, http.Request, http.Method, http.Error, path.Base"}
{"seed": "// NewExtrasGraphsReadParams creates a new ExtrasGraphsReadParams object\n// with the default values initialized.\nfunc NewExtrasGraphsReadParams() *ExtrasGraphsReadParams {\n\tvar ()\n\treturn &ExtrasGraphsReadParams{\n\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 26624, "concepts": ["struct initialization", "default values", "function definition"], "_raw_llm_output": "struct initialization, default values, function definition"}
{"seed": "// CompareAlbumTitles calculates the similarity score\n// (100 represents a perfect match) between the two submitted album\n// titles. Two scores are returned. The first is the direct comparison,\n// the second is the score after scrubbing noise words.\n//\nfunc CompareAlbumTitles(a, b string) (score, scrubbedScore float64) {\n\tscrubbedA, scrubbedB := ScrubAlbumTitle(a), ScrubAlbumTitle(b)\n\tscore = levenshtein.RatioForStrings([]rune(a), []rune(b), levenshtein.DefaultOptions)\n\tscrubbedScore = levenshtein.RatioForStrings([]rune(scrubbedA), []rune(scrubbedB), levenshtein.DefaultOptions)\n\treturn score * 100, scrubbedScore * 100\n}", "id": 26650, "concepts": ["levenshtein distance", "string manipulation", "string scrubbing", "string comparison", "string similarity", "string matching", "string distance", "string comparison", "string similarity", "string matching", "string distance", "string comparison", "string similarity", "string matching", "string distance", "string comparison", "string similarity", "string matching", "string distance", "string comparison", "string similarity", "string matching", "string distance", "string comparison", "string similarity", "string matching", "string distance", "string comparison", "string similarity", "string matching", "string distance", "string comparison", "string similarity", "string matching", "string distance", "string comparison", "string similarity", "string matching", "string distance", "string comparison", "string similarity", "string matching", "string distance", "string comparison", "string similarity", "string matching", "string distance", "string comparison", "string similarity", "string matching", "string distance", "string comparison", "string similarity", "string matching", "string distance", "string comparison", "string similarity", "string matching", "string distance", "string comparison", "string similarity", "string matching", "string distance", "string comparison", "string similarity", "string matching", "string distance", "string comparison", "string similarity", "string matching", "string distance", "string comparison", "string similarity", "string matching", "string distance", "string comparison", "string similarity", "string matching", "string distance", "string comparison", "string similarity", "string matching", "string distance", "string"], "_raw_llm_output": "levenshtein distance, string manipulation, string scrubbing, string comparison, string similarity, string matching, string distance, string comparison, string similarity, string matching, string distance, string comparison, string similarity, string matching, string distance, string comparison, string similarity, string matching, string distance, string comparison, string similarity, string matching, string distance, string comparison, string similarity, string matching, string distance, string comparison, string similarity, string matching, string distance, string comparison, string similarity, string matching, string distance, string comparison, string similarity, string matching, string distance, string comparison, string similarity, string matching, string distance, string comparison, string similarity, string matching, string distance, string comparison, string similarity, string matching, string distance, string comparison, string similarity, string matching, string distance, string comparison, string similarity, string matching, string distance, string comparison, string similarity, string matching, string distance, string comparison, string similarity, string matching, string distance, string comparison, string similarity, string matching, string distance, string comparison, string similarity, string matching, string distance, string comparison, string similarity, string matching, string distance, string comparison, string similarity, string matching, string distance, string"}
{"seed": "// NewTablesClient creates a new instance of TablesClient with the specified values.\n//   - subscriptionID - The ID of the target subscription.\n//   - credential - used to authorize requests. Usually a credential from azidentity.\n//   - options - pass nil to accept the default values.\nfunc NewTablesClient(subscriptionID string, credential azcore.TokenCredential, options *arm.ClientOptions) (*TablesClient, error) {\n\tcl, err := arm.NewClient(moduleName+\".TablesClient\", moduleVersion, credential, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tclient := &TablesClient{\n\t\tsubscriptionID: subscriptionID,\n\t\tinternal:       cl,\n\t}\n\treturn client, nil\n}", "id": 26658, "concepts": ["arm.Client", "arm.ClientOptions", "azcore.TokenCredential", "basic function definition"], "_raw_llm_output": "arm.Client, arm.ClientOptions, azcore.TokenCredential, basic function definition"}
{"seed": "// NewEntryServiceDeleteParams creates a new EntryServiceDeleteParams object\n// with the default values initialized.\nfunc NewEntryServiceDeleteParams() *EntryServiceDeleteParams {\n\tvar ()\n\treturn &EntryServiceDeleteParams{\n\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}", "id": 26662, "concepts": ["struct definition", "struct initialization", "method definition", "method invocation"], "_raw_llm_output": "struct definition, struct initialization, method definition, method invocation"}
{"seed": "// NewGetContactsParamsWithHTTPClient creates a new GetContactsParams object\n// with the default values initialized, and the ability to set a custom HTTPClient for a request\nfunc NewGetContactsParamsWithHTTPClient(client *http.Client) *GetContactsParams {\n\tvar (\n\t\tlimitDefault  = int32(5000)\n\t\toffsetDefault = int32(0)\n\t)\n\treturn &GetContactsParams{\n\t\tLimit:      &limitDefault,\n\t\tOffset:     &offsetDefault,\n\t\tHTTPClient: client,\n\t}\n}", "id": 26665, "concepts": ["struct definition", "pointer usage", "method definition", "method receiver", "method invocation"], "_raw_llm_output": "struct definition, pointer usage, method definition, method receiver, method invocation"}
{"seed": "// ShouldGiveHelp checks the env and provided args to see if help is needed or being requested.\n// Help is needed if either cosmovisor.EnvName and/or cosmovisor.EnvHome env vars aren't set.\n// Help is requested if the first arg is \"help\", \"--help\", or \"-h\".\nfunc ShouldGiveHelp(arg string) bool {\n\treturn isOneOf(arg, HelpArgs)\n}", "id": 26693, "concepts": ["environment variables", "command-line arguments", "string comparison", "boolean logic"], "_raw_llm_output": "environment variables, command-line arguments, string comparison, boolean logic"}
{"seed": "// Strike_ is a convenience wrapper for Strike without the attrs argument.\nfunc Strike_(children ...HTML) HTML {\n  return Strike(nil, children...)\n}", "id": 26712, "concepts": ["HTML", "function definition", "function call", "function return", "function argument", "function return value", "function call", "function call with arguments", "function call with return value", "function call with return value and arguments", "function call with return value and arguments", "function call with return value and arguments and return value", "function call with return value and arguments and return value and arguments"], "_raw_llm_output": "HTML, function definition, function call, function return, function argument, function return value, function call, function call with arguments, function call with return value, function call with return value and arguments, function call with return value and arguments, function call with return value and arguments and return value, function call with return value and arguments and return value and arguments"}
{"seed": "//doUpdate adds remote node to searchlist and lookuptable with datfile specified in url.\n//if stamp is in range of defaultUpdateRange adds to updateque.\nfunc doUpdate(w http.ResponseWriter, r *http.Request) {\n\ts, err := newServerCGI(w, r)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tlog.Println(\"failed to create cgi struct\")\n\t\treturn\n\t}\n\treg := regexp.MustCompile(`^update/(\\w+)/(\\d+)/(\\w+)/([^\\+]*)(\\+.*)`)\n\tm := reg.FindStringSubmatch(s.path())\n\tif m == nil {\n\t\tlog.Println(\"illegal url\")\n\t\treturn\n\t}\n\tdatfile, stamp, id, hostport, path := m[1], m[2], m[3], m[4], m[5]\n\thost, portstr, err := net.SplitHostPort(hostport)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn\n\t}\n\tport, err := strconv.Atoi(portstr)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn\n\t}\n\thost = s.remoteIP(host)\n\tif host == \"\" {\n\t\tlog.Println(\"host is null\")\n\t\treturn\n\t}\n\n\tn, err := node.MakeNode(host, path, port)\n\tif err != nil || !n.IsAllowed() {\n\t\tlog.Println(\"detects spam\")\n\t\treturn\n\t}\n\ts.NodeManager.AppendToTable(datfile, n)\n\ts.NodeManager.Sync()\n\tnstamp, err := strconv.ParseInt(stamp, 10, 64)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn\n\t}\n\n\tif !thread.IsInUpdateRange(nstamp) {\n\t\treturn\n\t}\n\trec := thread.NewRecord(datfile, stamp+\"_\"+id)\n\tgo s.UpdateQue.UpdateNodes(rec, n)\n\tfmt.Fprintln(w, \"OK\")\n}", "id": 26714, "concepts": ["regexp", "string manipulation", "integer conversion", "concurrency", "error handling", "standard library usage"], "_raw_llm_output": "regexp, string manipulation, integer conversion, concurrency, error handling, standard library usage"}
{"seed": "// NewGuestAgentsClient creates a new instance of GuestAgentsClient with the specified values.\n//   - subscriptionID - The Subscription ID.\n//   - credential - used to authorize requests. Usually a credential from azidentity.\n//   - options - pass nil to accept the default values.\nfunc NewGuestAgentsClient(subscriptionID string, credential azcore.TokenCredential, options *arm.ClientOptions) (*GuestAgentsClient, error) {\n\tcl, err := arm.NewClient(moduleName+\".GuestAgentsClient\", moduleVersion, credential, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tclient := &GuestAgentsClient{\n\t\tsubscriptionID: subscriptionID,\n\t\tinternal:       cl,\n\t}\n\treturn client, nil\n}", "id": 26721, "concepts": ["ARM client creation", "module version", "module name", "credential", "options"], "_raw_llm_output": "ARM client creation, module version, module name, credential, options"}
{"seed": "// AssertASNoHandleErrorRequest asserts that there is no error request.\nfunc AssertASNoHandleErrorRequest() Assertion {\n\treturn func(assert *require.Assertions, ts *IntegrationTestSuite) {\n\t\ttime.Sleep(100 * time.Millisecond)\n\t\tselect {\n\t\tcase <-ts.ASClient.HandleErrorChan:\n\t\t\tassert.Fail(\"unexpected error request\")\n\t\tdefault:\n\t\t}\n\t}\n}", "id": 26736, "concepts": ["channel", "select statement", "standard library usage"], "_raw_llm_output": "channel, select statement, standard library usage"}
{"seed": "// UpdatedAtNotIn applies the NotIn predicate on the \"updated_at\" field.\nfunc UpdatedAtNotIn(vs ...time.Time) predicate.User {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.User(func(s *sql.Selector) {\n\t\t// if not arguments were provided, append the FALSE constants,\n\t\t// since we can't apply \"IN ()\". This will make this predicate falsy.\n\t\tif len(vs) == 0 {\n\t\t\ts.Where(sql.False())\n\t\t\treturn\n\t\t}\n\t\ts.Where(sql.NotIn(s.C(FieldUpdatedAt), v...))\n\t})\n}", "id": 26742, "concepts": ["sql.Selector", "sql.NotIn", "sql.False", "predicate.User", "sql.C"], "_raw_llm_output": "sql.Selector, sql.NotIn, sql.False, predicate.User, sql.C"}
{"seed": "// WithBefore adds a RoundTripperBeforeFunc to the RoundTripper\n// config.\nfunc WithBefore(f RoundTripperBeforeFunc) RoundTripperOption {\n\treturn func(cfg *roundTripperConfig) {\n\t\tcfg.before = f\n\t}\n}", "id": 26746, "concepts": ["function composition", "function definition", "function composition", "function composition"], "_raw_llm_output": "function composition, function definition, function composition, function composition"}
{"seed": "// NewRealUpdater returns a UpdaterInterface that updates the Project manifest, using the supplied client and projectLister.\nfunc NewRealUpdater(k8sGardenClient kubernetes.Interface, projectLister gardencorelisters.ProjectLister) UpdaterInterface {\n\treturn &realUpdater{k8sGardenClient, projectLister}\n}", "id": 26753, "concepts": ["interface implementation", "function definition", "function return value", "constructor pattern", "struct definition"], "_raw_llm_output": "interface implementation, function definition, function return value, constructor pattern, struct definition"}
{"seed": "// PropValStr transforms a GetPropertyReply struct into a string.\n// Useful when the property value is a null terminated string represented\n// by integers. Also must be 8 bit format.\nfunc PropValStr(reply *xproto.GetPropertyReply, err error) (string, error) {\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif reply.Format != 8 {\n\t\treturn \"\", fmt.Errorf(\"PropValStr: Expected format 8 but got %d\",\n\t\t\treply.Format)\n\t}\n\treturn string(reply.Value), nil\n}", "id": 26754, "concepts": ["struct", "string manipulation", "integer conversion", "error handling"], "_raw_llm_output": "struct, string manipulation, integer conversion, error handling"}
{"seed": "// Client returns a new Noise client side connection\n// using conn as the underlying transport.\n// The config cannot be nil: users must set either ServerName or\n// InsecureSkipVerify in the config.\nfunc Client(conn net.Conn, config *Config) *Conn {\n\treturn &Conn{conn: conn, config: config, isClient: true}\n}", "id": 26764, "concepts": ["net package usage", "Config struct definition", "anonymous function", "pointer usage"], "_raw_llm_output": "net package usage, Config struct definition, anonymous function, pointer usage"}
{"seed": "// RegisterUnlockConditionType is used to register a condition type, by linking it to\n// a constructor which constructs a fresh MarshalableUnlockCondition each time it is called.\n//\n// RegisterUnlockConditionType can also used to unregister a condition type,\n// by calling this function with nil as the MarshalableUnlockConditionConstructor.\nfunc RegisterUnlockConditionType(ct ConditionType, cc MarshalableUnlockConditionConstructor) {\n\tif cc == nil {\n\t\tdelete(_RegisteredUnlockConditionTypes, ct)\n\t\treturn\n\t}\n\t_RegisteredUnlockConditionTypes[ct] = cc\n}", "id": 26770, "concepts": ["map", "map iteration", "map deletion", "map key lookup", "map value lookup", "map value assignment"], "_raw_llm_output": "map, map iteration, map deletion, map key lookup, map value lookup, map value assignment"}
{"seed": "// SocialEmailNEQ applies the NEQ predicate on the \"social_email\" field.\nfunc SocialEmailNEQ(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldSocialEmail), v))\n\t})\n}", "id": 26773, "concepts": ["sql package usage", "sql.Selector usage", "sql.NEQ usage", "sql.Where usage"], "_raw_llm_output": "sql package usage, sql.Selector usage, sql.NEQ usage, sql.Where usage"}
{"seed": "// Init initializes a new git-backed database from the following\n// elements:\n// * A bare git repository at `repo`\n// * A git reference name `ref` (for example \"refs/heads/foo\")\n// * An optional scope to expose only a subset of the git tree (for example \"/myapp/v1\")\nfunc Init(repo, ref string) (*DB, error) {\n\tr, err := git.InitRepository(repo, true)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdb, err := newRepo(r, ref)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn db, nil\n}", "id": 26774, "concepts": ["git package usage", "git.InitRepository", "git.Repository", "git.Reference", "git.Tree", "git.Commit", "git.Object", "git.Blob", "git.Hash", "git.Signature", "git.CommitOptions", "git.Commit", "git.CommitIter", "git.CommitIterOptions", "git.CommitIter", "git.CommitIter", "git.CommitIter", "git.CommitIter", "git.CommitIter", "git.CommitIter", "git.CommitIter", "git.CommitIter", "git.CommitIter", "git.CommitIter", "git.CommitIter", "git.CommitIter", "git.CommitIter", "git.CommitIter", "git.CommitIter", "git.CommitIter", "git.CommitIter", "git.CommitIter", "git.CommitIter", "git.CommitIter", "git.CommitIter", "git.CommitIter", "git.CommitIter", "git.CommitIter", "git.CommitIter", "git.CommitIter", "git.CommitIter", "git.CommitIter", "git.CommitIter", "git.CommitIter", "git.CommitIter", "git.CommitIter", "git.CommitIter", "git.CommitIter", "git.CommitIter", "git.CommitIter", "git.CommitIter", "git.CommitIter", "git.CommitIter"], "_raw_llm_output": "git package usage, git.InitRepository, git.Repository, git.Reference, git.Tree, git.Commit, git.Object, git.Blob, git.Hash, git.Signature, git.CommitOptions, git.Commit, git.CommitIter, git.CommitIterOptions, git.CommitIter, git.CommitIter, git.CommitIter, git.CommitIter, git.CommitIter, git.CommitIter, git.CommitIter, git.CommitIter, git.CommitIter, git.CommitIter, git.CommitIter, git.CommitIter, git.CommitIter, git.CommitIter, git.CommitIter, git.CommitIter, git.CommitIter, git.CommitIter, git.CommitIter, git.CommitIter, git.CommitIter, git.CommitIter, git.CommitIter, git.CommitIter, git.CommitIter, git.CommitIter, git.CommitIter, git.CommitIter, git.CommitIter, git.CommitIter, git.CommitIter, git.CommitIter, git.CommitIter, git.CommitIter, git.CommitIter, git.CommitIter, git.CommitIter, git.CommitIter, git.CommitIter"}
{"seed": "// validateSandbox ensures that the target isn't opting out of the build/test sandbox when it's not allowed to\nfunc validateSandbox(state *core.BuildState, target *core.BuildTarget) error {\n\tif target.IsFilegroup || len(state.Config.Sandbox.ExcludeableTargets) == 0 {\n\t\treturn nil\n\t}\n\tif !target.IsRemoteFile {\n\t\tif target.Sandbox && (target.Test == nil || target.Test.Sandbox) {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tif target.Label.PackageName == \"_please\" {\n\t\treturn nil\n\t}\n\tfor _, whitelist := range state.Config.Sandbox.ExcludeableTargets {\n\t\tif whitelist.Matches(target.Label) {\n\t\t\treturn nil\n\t\t}\n\t}\n\tfor _, dir := range state.Config.Parse.ExperimentalDir {\n\t\tif strings.HasPrefix(target.Label.PackageName, dir) {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn fmt.Errorf(\"%v is not whitelisted to opt out of the sandbox\", target)\n}", "id": 26778, "concepts": ["string manipulation", "string prefix check", "string match check", "function definition", "error handling"], "_raw_llm_output": "string manipulation, string prefix check, string match check, function definition, error handling"}
{"seed": "// Dir_ is a convenience wrapper for Dir without the attrs argument.\nfunc Dir_(children ...HTML) HTML {\n  return Dir(nil, children...)\n}", "id": 26783, "concepts": ["function definition", "function argument", "function return value"], "_raw_llm_output": "function definition, function argument, function return value"}
{"seed": "// WithRetry attempts to call the provided function until it has been successfully called or the number of calls exceeds retries delaying the consecutive calls by given delay\nfunc WithRetry(fn func() (interface{}, error), retries int, delay time.Duration) (interface{}, error) {\n\tvar err error\n\tvar res interface{}\n\tfor count := 0; true; count++ {\n\t\tif delay > 0 {\n\t\t\ttime.Sleep(delay)\n\t\t}\n\t\tif count >= retries {\n\t\t\tbreak\n\t\t}\n\t\tres, err = fn()\n\t\tif err == nil {\n\t\t\treturn res, nil\n\t\t}\n\t\tcontinue\n\t}\n\treturn nil, err\n}", "id": 26785, "concepts": ["function definition", "function call", "function return", "function argument", "function return value", "function return error", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", "function return multiple values", ""], "_raw_llm_output": "function definition, function call, function return, function argument, function return value, function return error, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values, function return multiple values,"}
{"seed": "// TNewDER generates a certificate and private key in DER format. To override default values, pass\n// a Config value. If an error occurs, t.Error is called.\nfunc TNewDER(t *testing.T, cfg ...Config) (certificate []byte, key []byte) {\n\tc, k, err := NewDER(cfg...)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\treturn c, k\n}", "id": 26787, "concepts": ["testing", "testing.T", "testing.Error", "testing.Config", "testing.NewDER", "testing.NewDERConfig", "testing.NewDERConfigKey", "testing.NewDERConfigCert", "testing.NewDERConfigKeyAndCert", "testing.NewDERConfigKeyAndCertAndCA", "testing.NewDERConfigKeyAndCertAndCAAndUsage", "testing.NewDERConfigKeyAndCertAndCAAndUsageAndExtKeyUsage", "testing.NewDERConfigKeyAndCertAndCAAndUsageAndExtKeyUsageAndExtKeyUsage", "testing.NewDERConfigKeyAndCertAndCAAndUsageAndExtKeyUsageAndExtKeyUsageAndExtKeyUsage", "testing.NewDERConfigKeyAndCertAndCAAndUsageAndExtKeyUsageAndExtKeyUsageAndExtKeyUsageAndExtKeyUsage", "testing.NewDERConfigKeyAndCertAndCAAndUsageAndExtKeyUsageAndExtKeyUsageAndExtKeyUsageAndExtKeyUsageAndExtKeyUsage", "testing.NewDERConfigKeyAndCertAndCAAndUsageAndExtKeyUsageAndExtKeyUsageAndExtKeyUsageAndExtKeyUsageAndExtKeyUsageAndExtKeyUsage", "testing.NewDERConfigKeyAndCertAndCAAndUsageAndExtKeyUsageAndExtKeyUsageAnd"], "_raw_llm_output": "testing, testing.T, testing.Error, testing.Config, testing.NewDER, testing.NewDERConfig, testing.NewDERConfigKey, testing.NewDERConfigCert, testing.NewDERConfigKeyAndCert, testing.NewDERConfigKeyAndCertAndCA, testing.NewDERConfigKeyAndCertAndCAAndUsage, testing.NewDERConfigKeyAndCertAndCAAndUsageAndExtKeyUsage, testing.NewDERConfigKeyAndCertAndCAAndUsageAndExtKeyUsageAndExtKeyUsage, testing.NewDERConfigKeyAndCertAndCAAndUsageAndExtKeyUsageAndExtKeyUsageAndExtKeyUsage, testing.NewDERConfigKeyAndCertAndCAAndUsageAndExtKeyUsageAndExtKeyUsageAndExtKeyUsageAndExtKeyUsage, testing.NewDERConfigKeyAndCertAndCAAndUsageAndExtKeyUsageAndExtKeyUsageAndExtKeyUsageAndExtKeyUsageAndExtKeyUsage, testing.NewDERConfigKeyAndCertAndCAAndUsageAndExtKeyUsageAndExtKeyUsageAndExtKeyUsageAndExtKeyUsageAndExtKeyUsageAndExtKeyUsage, testing.NewDERConfigKeyAndCertAndCAAndUsageAndExtKeyUsageAndExtKeyUsageAnd"}
{"seed": "// MustInt64 does the same as the Int64 function, but generates panic in case of an error.\nfunc MustInt64(key string) (value int64) {\n\tvalue, err := Int64(key)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn\n}", "id": 26791, "concepts": ["error handling", "panic", "function definition"], "_raw_llm_output": "error handling, panic, function definition"}
{"seed": "// SatisfiesTargetValue checks that the totalValue is either exactly the targetValue\n// or is greater than the targetValue by at least the minChange amount.\nfunc SatisfiesTargetValue(targetValue int64, minChange int64, utxos []*common.UTXO) bool {\n\ttotalValue := int64(0)\n\tfor _, utxo := range utxos {\n\t\ttotalValue += utxo.Value\n\t}\n\n\treturn (totalValue == targetValue || totalValue >= targetValue+minChange)\n}", "id": 26798, "concepts": ["integer comparison", "integer summation", "integer division", "pointer handling"], "_raw_llm_output": "integer comparison, integer summation, integer division, pointer handling"}
{"seed": "// GlobalSMTPConfigApplyConfiguration constructs an declarative configuration of the GlobalSMTPConfig type for use with\n// apply.\nfunc GlobalSMTPConfig() *GlobalSMTPConfigApplyConfiguration {\n\treturn &GlobalSMTPConfigApplyConfiguration{}\n}", "id": 26809, "concepts": ["struct definition", "struct field definition", "struct field initialization", "struct field access", "struct field type inference", "struct field type conversion", "struct field type assertion"], "_raw_llm_output": "struct definition, struct field definition, struct field initialization, struct field access, struct field type inference, struct field type conversion, struct field type assertion"}
{"seed": "// transformAvatarToFollowingviewsAvatarView builds a value of type\n// *followingviews.AvatarView from a value of type *Avatar.\nfunc transformAvatarToFollowingviewsAvatarView(v *Avatar) *followingviews.AvatarView {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tres := &followingviews.AvatarView{\n\t\tURL: &v.URL,\n\t}\n\n\treturn res\n}", "id": 26820, "concepts": ["pointer dereference", "nil pointer handling", "struct composition"], "_raw_llm_output": "pointer dereference, nil pointer handling, struct composition"}
{"seed": "// RemoteAddrHandler adds the request's remote address as a field to the context's logger\n// using fieldKey as field key.\nfunc RemoteAddrHandler(fieldKey string) func(next httpserver.Handler) httpserver.Handler {\n\treturn func(next httpserver.Handler) httpserver.Handler {\n\t\treturn httpserver.HandlerFunc(func(w http.ResponseWriter, r *http.Request) (int, error) {\n\t\t\tif host, _, err := net.SplitHostPort(r.RemoteAddr); err == nil {\n\t\t\t\tlog := zerolog.Ctx(r.Context())\n\t\t\t\tlog.UpdateContext(func(c zerolog.Context) zerolog.Context {\n\t\t\t\t\treturn c.Str(fieldKey, host)\n\t\t\t\t})\n\t\t\t}\n\t\t\treturn next.ServeHTTP(w, r)\n\t\t})\n\t}\n}", "id": 26826, "concepts": ["http.Request", "http.ResponseWriter", "net.SplitHostPort", "zerolog.Context", "zerolog.UpdateContext", "httpserver.Handler", "httpserver.HandlerFunc", "httpserver.ServeHTTP"], "_raw_llm_output": "http.Request, http.ResponseWriter, net.SplitHostPort, zerolog.Context, zerolog.UpdateContext, httpserver.Handler, httpserver.HandlerFunc, httpserver.ServeHTTP"}
{"seed": "// podSlug returns a string uniquely identifying a pod in a Kubernetes\n// cluster.\nfunc podSlug(pod v1.Pod) string {\n\treturn pod.ObjectMeta.Namespace + \"/\" + pod.ObjectMeta.Name\n}", "id": 26836, "concepts": ["Kubernetes API usage", "string concatenation", "struct field access"], "_raw_llm_output": "Kubernetes API usage, string concatenation, struct field access"}
{"seed": "// NewDER generates a certificate and private key in DER format. To override default values, pass\n// a Config value.\nfunc NewDER(cfg ...Config) (certificate []byte, key []byte, err error) {\n\tcert, signerKey, err := genCertAndKey(getConfig(cfg), false)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tcertificate = cert.Raw\n\n\tswitch k := signerKey.(type) {\n\tcase *rsa.PrivateKey:\n\t\tkey, err = x509.MarshalPKCS8PrivateKey(k)\n\n\tcase *ecdsa.PrivateKey:\n\t\tkey, err = x509.MarshalECPrivateKey(k)\n\t}\n\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn\n}", "id": 26837, "concepts": ["cryptography", "crypto/x509 package usage", "private key handling"], "_raw_llm_output": "cryptography, crypto/x509 package usage, private key handling"}
{"seed": "// GetNotificationUserSubscriberMobileService returns an instance of the Notification_User_Subscriber_Mobile SoftLayer service\nfunc GetNotificationUserSubscriberMobileService(sess *session.Session) Notification_User_Subscriber_Mobile {\n\treturn Notification_User_Subscriber_Mobile{Session: sess}\n}", "id": 26839, "concepts": ["interface definition", "struct definition", "method definition", "anonymous struct definition", "method invocation", "session object", "session object initialization"], "_raw_llm_output": "interface definition, struct definition, method definition, anonymous struct definition, method invocation, session object, session object initialization"}
{"seed": "// NewNameHasPrefix applies the HasPrefix predicate on the \"new_name\" field.\nfunc NewNameHasPrefix(v string) predicate.User {\n\treturn predicate.User(sql.FieldHasPrefix(FieldNewName, v))\n}", "id": 26844, "concepts": ["predicate.User", "sql.FieldHasPrefix", "predicate.Field"], "_raw_llm_output": "predicate.User, sql.FieldHasPrefix, predicate.Field"}
{"seed": "// DefaultExprsGT applies the GT predicate on the \"default_exprs\" field.\nfunc DefaultExprsGT(v string) predicate.User {\n\treturn predicate.User(sql.FieldGT(FieldDefaultExprs, v))\n}", "id": 26850, "concepts": ["sql.FieldGT", "sql.FieldLT", "sql.FieldGTE", "sql.FieldLTE", "sql.FieldEQ", "sql.FieldNEQ", "sql.FieldIN", "sql.FieldNotIn", "sql.FieldLike", "sql.FieldNotLike", "sql.FieldContains", "sql.FieldNotContains", "sql.FieldStartsWith", "sql.FieldNotStartsWith", "sql.FieldEndsWith", "sql.FieldNotEndsWith", "sql.FieldIsNull", "sql.FieldIsNotNull", "sql.FieldBetween", "sql.FieldNotBetween"], "_raw_llm_output": "sql.FieldGT, sql.FieldLT, sql.FieldGTE, sql.FieldLTE, sql.FieldEQ, sql.FieldNEQ, sql.FieldIN, sql.FieldNotIn, sql.FieldLike, sql.FieldNotLike, sql.FieldContains, sql.FieldNotContains, sql.FieldStartsWith, sql.FieldNotStartsWith, sql.FieldEndsWith, sql.FieldNotEndsWith, sql.FieldIsNull, sql.FieldIsNotNull, sql.FieldBetween, sql.FieldNotBetween"}
{"seed": "// ResolverQueryLogConfigAssociationError_Values returns all elements of the ResolverQueryLogConfigAssociationError enum\nfunc ResolverQueryLogConfigAssociationError_Values() []string {\n\treturn []string{\n\t\tResolverQueryLogConfigAssociationErrorNone,\n\t\tResolverQueryLogConfigAssociationErrorDestinationNotFound,\n\t\tResolverQueryLogConfigAssociationErrorAccessDenied,\n\t\tResolverQueryLogConfigAssociationErrorInternalServiceError,\n\t}\n}", "id": 26851, "concepts": ["enum", "string formatting", "string manipulation"], "_raw_llm_output": "enum, string formatting, string manipulation"}
{"seed": "// TwistExtrude returns an extrusion function that twists with z.\nfunc TwistExtrude(height, twist float64) ExtrudeFunc {\n\tk := twist / height\n\treturn func(p V3) V2 {\n\t\tm := Rotate(p.Z * k)\n\t\treturn m.MulPosition(V2{p.X, p.Y})\n\t}\n}", "id": 26857, "concepts": ["function definition", "function composition", "function application", "function return", "function argument", "function signature", "function call", "function pointer", "function composition", "function application", "function return", "function argument", "function signature", "function call", "function pointer", "function composition", "function application", "function return", "function argument", "function signature", "function call", "function pointer", "function composition", "function application", "function return", "function argument", "function signature", "function call", "function pointer", "function composition", "function application", "function return", "function argument", "function signature", "function call", "function pointer", "function composition", "function application", "function return", "function argument", "function signature", "function call", "function pointer", "function composition", "function application", "function return", "function argument", "function signature", "function call", "function pointer", "function composition", "function application", "function return", "function argument", "function signature", "function call", "function pointer", "function composition", "function application", "function return", "function argument", "function signature", "function call", "function pointer", "function composition", "function application", "function return", "function argument", "function signature", "function call", "function pointer", "function composition", "function application", "function return", "function argument", "function signature", "function call", "function pointer", "function composition", "function application", "function return", "function argument", "function signature", "function call", "function pointer", ""], "_raw_llm_output": "function definition, function composition, function application, function return, function argument, function signature, function call, function pointer, function composition, function application, function return, function argument, function signature, function call, function pointer, function composition, function application, function return, function argument, function signature, function call, function pointer, function composition, function application, function return, function argument, function signature, function call, function pointer, function composition, function application, function return, function argument, function signature, function call, function pointer, function composition, function application, function return, function argument, function signature, function call, function pointer, function composition, function application, function return, function argument, function signature, function call, function pointer, function composition, function application, function return, function argument, function signature, function call, function pointer, function composition, function application, function return, function argument, function signature, function call, function pointer, function composition, function application, function return, function argument, function signature, function call, function pointer, function composition, function application, function return, function argument, function signature, function call, function pointer, function composition, function application, function return, function argument, function signature, function call, function pointer,"}
{"seed": "// mustGetClientMetrics returns a singleton instance of the client metrics\n// that are shared across all gRPC clients that this process creates.\n//\n// This function panics if the metrics cannot be registered with the default\n// Prometheus registry.\nfunc mustGetClientMetrics() *grpc_prometheus.ClientMetrics {\n\tclientMetricsOnce.Do(func() {\n\t\tclientMetrics = grpc_prometheus.NewRegisteredClientMetrics(prometheus.DefaultRegisterer,\n\t\t\tgrpc_prometheus.WithClientCounterOptions(setCounterNamespace),\n\t\t\tgrpc_prometheus.WithClientHandlingTimeHistogram(setHistogramNamespace), // record the overall request latency for a gRPC request\n\t\t\tgrpc_prometheus.WithClientStreamRecvHistogram(setHistogramNamespace),   // record how long it takes for a client to receive a message during a streaming RPC\n\t\t\tgrpc_prometheus.WithClientStreamSendHistogram(setHistogramNamespace),   // record how long it takes for a client to send a message during a streaming RPC\n\t\t)\n\t})\n\n\treturn clientMetrics\n}", "id": 26868, "concepts": ["singleton pattern", "Prometheus metrics", "gRPC metrics"], "_raw_llm_output": "singleton pattern, Prometheus metrics, gRPC metrics"}
{"seed": "// CompareTrackTitles calculates the similarity score\n// (100 represents a perfect match) between the two submitted track\n// titles. Two scores are returned. The first is the direct comparison,\n// the second is the score after scrubbing noise words.\n//\nfunc CompareTrackTitles(a, b string) (score, scrubbedScore float64) {\n\tscrubbedA, scrubbedB := ScrubTrackTitle(a), ScrubTrackTitle(b)\n\tscore = levenshtein.RatioForStrings([]rune(a), []rune(b), levenshtein.DefaultOptions)\n\tscrubbedScore = levenshtein.RatioForStrings([]rune(scrubbedA), []rune(scrubbedB), levenshtein.DefaultOptions)\n\treturn score * 100, scrubbedScore * 100\n}", "id": 26870, "concepts": ["levenshtein distance", "string comparison", "string scrubbing"], "_raw_llm_output": "levenshtein distance, string comparison, string scrubbing"}
{"seed": "// FormatHTTPRequestWithSeparator returns a formatted and readable string containing information of given HTTP request, separated by given separated.\nfunc FormatHTTPRequestWithSeparator(r *http.Request, separator string) string {\n\tvar request []string\n\n\turl := fmt.Sprintf(\"%v %v\", r.Method, r.URL)\n\trequest = append(request, url)\n\trequest = append(request, fmt.Sprintf(\"Host: %v\", r.Host))\n\n\tfor name, headers := range r.Header {\n\t\tname = strings.ToLower(name)\n\t\tfor _, h := range headers {\n\t\t\trequest = append(request, fmt.Sprintf(\"%v: %v\", name, h))\n\t\t}\n\t}\n\n\tif r.Method == \"POST\" {\n\t\tr.ParseForm()\n\t\trequest = append(request, \" \")\n\t\trequest = append(request, r.Form.Encode())\n\t}\n\n\treturn strings.Join(request, separator)\n}", "id": 26872, "concepts": ["string formatting", "string manipulation", "string concatenation", "string iteration", "string comparison", "string splitting", "string joining", "string length", "string indexing", "string slicing", "string concatenation", "string comparison", "string conversion", "string iteration", "string length", "string indexing", "string slicing", "string concatenation", "string comparison", "string conversion", "string iteration", "string length", "string indexing", "string slicing", "string concatenation", "string comparison", "string conversion", "string iteration", "string length", "string indexing", "string slicing", "string concatenation", "string comparison", "string conversion", "string iteration", "string length", "string indexing", "string slicing", "string concatenation", "string comparison", "string conversion", "string iteration", "string length", "string indexing", "string slicing", "string concatenation", "string comparison", "string conversion", "string iteration", "string length", "string indexing", "string slicing", "string concatenation", "string comparison", "string conversion", "string iteration", "string length", "string indexing", "string slicing", "string concatenation", "string comparison", "string conversion", "string iteration", "string length", "string indexing", "string slicing", "string concatenation", "string comparison", "string conversion", "string iteration", "string length", "string indexing", "string slicing", "string concatenation", "string comparison", "string conversion", "string iteration", "string length", ""], "_raw_llm_output": "string formatting, string manipulation, string concatenation, string iteration, string comparison, string splitting, string joining, string length, string indexing, string slicing, string concatenation, string comparison, string conversion, string iteration, string length, string indexing, string slicing, string concatenation, string comparison, string conversion, string iteration, string length, string indexing, string slicing, string concatenation, string comparison, string conversion, string iteration, string length, string indexing, string slicing, string concatenation, string comparison, string conversion, string iteration, string length, string indexing, string slicing, string concatenation, string comparison, string conversion, string iteration, string length, string indexing, string slicing, string concatenation, string comparison, string conversion, string iteration, string length, string indexing, string slicing, string concatenation, string comparison, string conversion, string iteration, string length, string indexing, string slicing, string concatenation, string comparison, string conversion, string iteration, string length, string indexing, string slicing, string concatenation, string comparison, string conversion, string iteration, string length, string indexing, string slicing, string concatenation, string comparison, string conversion, string iteration, string length,"}
{"seed": "// SocialAvatarURLLT applies the LT predicate on the \"social_avatar_url\" field.\nfunc SocialAvatarURLLT(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.LT(s.C(FieldSocialAvatarURL), v))\n\t})\n}", "id": 26876, "concepts": ["sql.Selector", "sql.C", "sql.LT", "predicate.User", "predicate.FieldSocialAvatarURL"], "_raw_llm_output": "sql.Selector, sql.C, sql.LT, predicate.User, predicate.FieldSocialAvatarURL"}
{"seed": "// Td_ is a convenience wrapper for Td without the attrs argument.\nfunc Td_(children ...HTML) HTML {\n  return Td(nil, children...)\n}", "id": 26887, "concepts": ["HTML struct definition", "HTML struct field definition", "HTML struct field initialization", "HTML struct field usage", "HTML struct field type conversion", "HTML struct field type assertion", "HTML struct field type assertion with type switch", "HTML struct field type assertion with type switch with type switch fallthrough", "HTML struct field type assertion with type switch with type switch fallthrough with type switch fallthrough", "HTML struct field type assertion with type switch with type switch fallthrough with type switch fallthrough with type switch fallthrough", "HTML struct field type assertion with type switch with type switch fallthrough with type switch fallthrough with type switch fallthrough with type switch fallthrough", "HTML struct field type assertion with type switch with type switch fallthrough with type switch fallthrough with type switch fallthrough with type switch fallthrough with type switch fallthrough", "HTML struct field type assertion with type switch with type switch fallthrough with type switch fallthrough with type switch fallthrough with type switch fallthrough with type switch fallthrough with type switch fallthrough", "HTML struct field type assertion with type switch with type switch fallthrough with type switch fallthrough with type switch fallthrough with type switch fallthrough with type switch fallthrough with type switch fallthrough with type switch fallthrough", "HTML struct field type assertion with type switch with type switch fall"], "_raw_llm_output": "HTML struct definition, HTML struct field definition, HTML struct field initialization, HTML struct field usage, HTML struct field type conversion, HTML struct field type assertion, HTML struct field type assertion with type switch, HTML struct field type assertion with type switch with type switch fallthrough, HTML struct field type assertion with type switch with type switch fallthrough with type switch fallthrough, HTML struct field type assertion with type switch with type switch fallthrough with type switch fallthrough with type switch fallthrough, HTML struct field type assertion with type switch with type switch fallthrough with type switch fallthrough with type switch fallthrough with type switch fallthrough, HTML struct field type assertion with type switch with type switch fallthrough with type switch fallthrough with type switch fallthrough with type switch fallthrough with type switch fallthrough, HTML struct field type assertion with type switch with type switch fallthrough with type switch fallthrough with type switch fallthrough with type switch fallthrough with type switch fallthrough with type switch fallthrough, HTML struct field type assertion with type switch with type switch fallthrough with type switch fallthrough with type switch fallthrough with type switch fallthrough with type switch fallthrough with type switch fallthrough with type switch fallthrough, HTML struct field type assertion with type switch with type switch fall"}
{"seed": "// asyncPluginFilter accepts a callback and a container and runs the callback,\n// asynchronously on all of the elements of the specified typs in the\n// container. It collects errors and returns the resolved multi-error.\nfunc asyncPluginFilter(plugins PluginManagerContainer, typs []PluginType, cb func(PluginManager) error) error {\n\tif typs == nil {\n\t\ttyps = allPluginTypes\n\t}\n\n\terrs := NewMultiError()\n\n\t// for each type of plugin, call the callback for each one as specified.\n\tvar wg sync.WaitGroup\n\tfor _, typ := range typs {\n\t\tmanagers, ok := plugins[typ]\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\n\t\tfor _, manager := range managers {\n\t\t\twg.Add(1)\n\t\t\tgo func(manager PluginManager) {\n\t\t\t\tdefer wg.Done()\n\t\t\t\terrs.Add(cb(manager))\n\t\t\t}(manager)\n\t\t}\n\t}\n\n\twg.Wait()\n\treturn errs.ToErr()\n}", "id": 26899, "concepts": ["sync.WaitGroup", "anonymous function", "concurrency", "error handling (NewMultiError)", "map iteration (range loop)", "multi-error handling", "standard library usage"], "_raw_llm_output": "sync.WaitGroup, anonymous function, concurrency, error handling (NewMultiError), map iteration (range loop), multi-error handling, standard library usage"}
{"seed": "// MapIntInt32Ptr takes two inputs -\n// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list\nfunc MapIntInt32Ptr(f func(*int) *int32, list []*int) []*int32 {\n\tif f == nil {\n\t\treturn []*int32{}\n\t}\n\tnewList := make([]*int32, len(list))\n\tfor i, v := range list {\n\t\tnewList[i] = f(v)\n\t}\n\treturn newList\n}", "id": 26900, "concepts": ["function definition", "function composition", "function application", "function pointer", "function return", "function type", "function signature", "function call", "function composition", "function application", "function pointer", "function return", "function type", "function signature", "function call", "function composition", "function application", "function pointer", "function return", "function type", "function signature", "function call", "function composition", "function application", "function pointer", "function return", "function type", "function signature", "function call", "function composition", "function application", "function pointer", "function return", "function type", "function signature", "function call", "function composition", "function application", "function pointer", "function return", "function type", "function signature", "function call", "function composition", "function application", "function pointer", "function return", "function type", "function signature", "function call", "function composition", "function application", "function pointer", "function return", "function type", "function signature", "function call", "function composition", "function application", "function pointer", "function return", "function type", "function signature", "function call", "function composition", "function application", "function pointer", "function return", "function type", "function signature", "function call", "function composition", "function application", "function pointer", "function return", "function type", "function signature", "function call", "function composition", "function application", "function pointer", "function return", "function type", "function signature", "function call", ""], "_raw_llm_output": "function definition, function composition, function application, function pointer, function return, function type, function signature, function call, function composition, function application, function pointer, function return, function type, function signature, function call, function composition, function application, function pointer, function return, function type, function signature, function call, function composition, function application, function pointer, function return, function type, function signature, function call, function composition, function application, function pointer, function return, function type, function signature, function call, function composition, function application, function pointer, function return, function type, function signature, function call, function composition, function application, function pointer, function return, function type, function signature, function call, function composition, function application, function pointer, function return, function type, function signature, function call, function composition, function application, function pointer, function return, function type, function signature, function call, function composition, function application, function pointer, function return, function type, function signature, function call, function composition, function application, function pointer, function return, function type, function signature, function call, function composition, function application, function pointer, function return, function type, function signature, function call,"}
{"seed": "// kindOf returns the reflection Kind that represents the dynamic type of value.\n// If value is a nil interface value, kindOf returns reflect.Invalid.\nfunc kindOf(value interface{}) reflect.Kind {\n\tif value == nil {\n\t\treturn reflect.Invalid\n\t}\n\treturn reflect.TypeOf(value).Kind()\n}", "id": 26905, "concepts": ["reflection", "interface", "nil interface value handling", "reflect.Kind"], "_raw_llm_output": "reflection, interface, nil interface value handling, reflect.Kind"}
{"seed": "// IsCondCheckFailed returns true if the given error is a \"conditional check failed\" error.\n// This corresponds with a ConditionalCheckFailedException in most APIs,\n// or a TransactionCanceledException with a ConditionalCheckFailed cancellation reason in transactions.\nfunc IsCondCheckFailed(err error) bool {\n\tvar txe *dynamodb.TransactionCanceledException\n\tif errors.As(err, &txe) {\n\t\tfor _, cr := range txe.CancellationReasons {\n\t\t\tif cr.Code != nil && *cr.Code == \"ConditionalCheckFailed\" {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\n\tvar ae awserr.Error\n\tif errors.As(err, &ae) && ae.Code() == \"ConditionalCheckFailedException\" {\n\t\treturn true\n\t}\n\n\treturn false\n}", "id": 26909, "concepts": ["error handling (errors.As)", "error type assertion", "error code comparison"], "_raw_llm_output": "error handling (errors.As), error type assertion, error code comparison"}
{"seed": "// ForwardCmdOutput configures command to forward its output to the system stderr\n// and stdout.\nfunc ForwardCmdOutput() func(*exec.Cmd) error {\n\treturn func(cmd *exec.Cmd) error {\n\t\tcmd.Stderr = os.Stderr\n\t\tcmd.Stdout = os.Stdout\n\t\treturn nil\n\t}\n}", "id": 26919, "concepts": ["exec package usage", "os.Stderr", "os.Stdout", "function composition"], "_raw_llm_output": "exec package usage, os.Stderr, os.Stdout, function composition"}
{"seed": "// base64Encode takes in a base 64 encoded string.\n// Returns the actual string or an error of it fails to decode the string.\nfunc base64Decode(src string) (string, error) {\n\tif strings.TrimSpace(src) == \"\" {\n\t\treturn \"\", consts.ErrEmptyString\n\t}\n\tif l := len(src) % 4; l > 0 {\n\t\tsrc += strings.Repeat(\"=\", 4-l)\n\t}\n\tdecoded, err := base64.URLEncoding.DecodeString(src)\n\tif err != nil {\n\t\terrMsg := fmt.Errorf(\"decoding error %s\", err)\n\t\treturn \"\", errMsg\n\t}\n\treturn string(decoded), nil\n}", "id": 26921, "concepts": ["string manipulation", "base64 encoding", "URL encoding", "string trimming", "error handling (errors.New)", "string concatenation", "string comparison", "string length", "string repetition", "string formatting", "string conversion", "string trimming", "string length", "string concatenation", "string comparison", "string repetition", "string formatting", "string conversion", "string trimming", "string length", "string concatenation", "string comparison", "string repetition", "string formatting", "string conversion", "string trimming", "string length", "string concatenation", "string comparison", "string repetition", "string formatting", "string conversion", "string trimming", "string length", "string concatenation", "string comparison", "string repetition", "string formatting", "string conversion", "string trimming", "string length", "string concatenation", "string comparison", "string repetition", "string formatting", "string conversion", "string trimming", "string length", "string concatenation", "string comparison", "string repetition", "string formatting", "string conversion", "string trimming", "string length", "string concatenation", "string comparison", "string repetition", "string formatting", "string conversion", "string trimming", "string length", "string concatenation", "string comparison", "string repetition", "string formatting", "string conversion", "string trimming", "string length", "string concatenation", ""], "_raw_llm_output": "string manipulation, base64 encoding, URL encoding, string trimming, error handling (errors.New), string concatenation, string comparison, string length, string repetition, string formatting, string conversion, string trimming, string length, string concatenation, string comparison, string repetition, string formatting, string conversion, string trimming, string length, string concatenation, string comparison, string repetition, string formatting, string conversion, string trimming, string length, string concatenation, string comparison, string repetition, string formatting, string conversion, string trimming, string length, string concatenation, string comparison, string repetition, string formatting, string conversion, string trimming, string length, string concatenation, string comparison, string repetition, string formatting, string conversion, string trimming, string length, string concatenation, string comparison, string repetition, string formatting, string conversion, string trimming, string length, string concatenation, string comparison, string repetition, string formatting, string conversion, string trimming, string length, string concatenation, string comparison, string repetition, string formatting, string conversion, string trimming, string length, string concatenation,"}
{"seed": "// NewMocklibrarian creates a new instance of Mocklibrarian. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.\nfunc NewMocklibrarian(t mockConstructorTestingTNewMocklibrarian) *Mocklibrarian {\n\tmock := &Mocklibrarian{}\n\tmock.Mock.Test(t)\n\n\tt.Cleanup(func() { mock.AssertExpectations(t) })\n\n\treturn mock\n}", "id": 26932, "concepts": ["testing interface", "mocking", "cleanup function"], "_raw_llm_output": "testing interface, mocking, cleanup function"}
{"seed": "// SocialAvatarURLEqualFold applies the EqualFold predicate on the \"social_avatar_url\" field.\nfunc SocialAvatarURLEqualFold(v string) predicate.User {\n\treturn predicate.User(func(s *sql.Selector) {\n\t\ts.Where(sql.EqualFold(s.C(FieldSocialAvatarURL), v))\n\t})\n}", "id": 26936, "concepts": ["sql.Selector", "sql.EqualFold", "predicate.User", "predicate.FieldSocialAvatarURL"], "_raw_llm_output": "sql.Selector, sql.EqualFold, predicate.User, predicate.FieldSocialAvatarURL"}
{"seed": "// ValidateHeader validates Header.\n// Returns the first error encountered.\nfunc ValidateHeader(header *Header) error {\n\tif header == nil {\n\t\treturn consts.ErrNilHeader\n\t}\n\ttokenType := header.TokenTyp\n\tif tokenType < NoType || tokenType > Jet {\n\t\treturn consts.ErrUnknownTokenType\n\t}\n\talg := header.Alg\n\tif alg < NoAlg || alg > Hs512 {\n\t\treturn consts.ErrUnknownAlgorithm\n\t}\n\treturn nil\n}", "id": 26937, "concepts": ["error handling (idiomatic if err != nil)", "switch statement", "basic function definition"], "_raw_llm_output": "error handling (idiomatic if err != nil), switch statement, basic function definition"}
{"seed": "// NewAlertGetMonitorGroupAlertsParamsWithContext creates a new AlertGetMonitorGroupAlertsParams object\n// with the default values initialized, and the ability to set a context for a request\nfunc NewAlertGetMonitorGroupAlertsParamsWithContext(ctx context.Context) *AlertGetMonitorGroupAlertsParams {\n\tvar (\n\t\tincludeRemindersDefault = bool(false)\n\t\tpresetPeriodDefault     = string(\"Last24Hours\")\n\t\tsortingDefault          = string(\"Descending\")\n\t\ttakeDefault             = int32(100)\n\t)\n\treturn &AlertGetMonitorGroupAlertsParams{\n\t\tIncludeReminders: &includeRemindersDefault,\n\t\tPresetPeriod:     &presetPeriodDefault,\n\t\tSorting:          &sortingDefault,\n\t\tTake:             &takeDefault,\n\n\t\tContext: ctx,\n\t}\n}", "id": 26940, "concepts": ["context package usage", "struct definition", "pointer usage"], "_raw_llm_output": "context package usage, struct definition, pointer usage"}
{"seed": "// FlushTokenLog sends all buffered logged tokens to BigQuery.\n//\n// It is fine to call FlushTokenLog concurrently from multiple request handlers,\n// if necessary (it will effectively parallelize the flush).\nfunc FlushTokenLog(c context.Context) error {\n\t_, err := delegationTokensLog.Flush(c)\n\treturn err\n}", "id": 26945, "concepts": ["context package usage", "BigQuery API usage"], "_raw_llm_output": "context package usage, BigQuery API usage"}
{"seed": "// NewConfig returns a pointer to an initialised Config\nfunc NewConfig() *Config {\n\treturn &Config{v: make(map[string]string)}\n}", "id": 26965, "concepts": ["struct definition", "pointer usage"], "_raw_llm_output": "struct definition, pointer usage"}
{"seed": "// HandleKillPriv enables SUID/SGID/cap management in the FUSE server.\n//\n// This is the newer `InitHandleKillPrivV2` interface from FUSE protocol 7.33, not the deprecated one from 7.26.\nfunc HandleKillPriv() MountOption {\n\treturn func(conf *mountConfig) error {\n\t\tconf.initFlags |= InitHandleKillPrivV2\n\t\treturn nil\n\t}\n}", "id": 26973, "concepts": ["FUSE", "mountConfig", "mountConfig.initFlags", "mountConfig.initFlags=", "InitHandleKillPrivV2"], "_raw_llm_output": "FUSE, mountConfig, mountConfig.initFlags, mountConfig.initFlags=, InitHandleKillPrivV2"}
{"seed": "// NewMyEntityManager returns a new MyEntityManager.\nfunc NewMyEntityManager() *MyEntityManager {\n\treturn &MyEntityManager{\n\t\titems: make(map[uint64]EntityManagerItems, 0),\n\t}\n}", "id": 26981, "concepts": ["map", "struct", "basic function definition"], "_raw_llm_output": "map, struct, basic function definition"}
{"seed": "// WithDescription prepares context for transaction that will have description\n// provided.\n// By default, transactions are without description.\nfunc WithDescription(ctx context.Context, description string) context.Context {\n\treturn context.WithValue(ctx, txnDescriptionCtxKey, &txnDescriptionOpt{description: description})\n}", "id": 26988, "concepts": ["context", "context.WithValue", "context.Context", "context.Context interface", "struct definition", "pointer usage"], "_raw_llm_output": "context, context.WithValue, context.Context, context.Context interface, struct definition, pointer usage"}
{"seed": "// LoadURLs attempts to load a URL config from the given filename. If the given filename\n// is blank, a known hardcoded location for server_config.json on the robot is used.\nfunc LoadURLs(filename string) (*URLs, error) {\n\tif filename == \"\" {\n\t\tfilename = defaultFilename\n\t}\n\tbuf, err := ioutil.ReadFile(filename)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar urls URLs\n\tif err := json.Unmarshal(buf, &urls); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &urls, nil\n}", "id": 26989, "concepts": ["ioutil.ReadFile", "json.Unmarshal", "error handling"], "_raw_llm_output": "ioutil.ReadFile, json.Unmarshal, error handling"}
{"seed": "// NewStatsQuery returns a new *StatsQuery\nfunc NewStatsQuery() *StatsQuery {\n\n\treturn &StatsQuery{\n\t\tModelVersion: 1,\n\t\tFields:       []string{},\n\t\tGroups:       []string{},\n\t\tLimit:        -1,\n\t\tMeasurement:  StatsQueryMeasurementFlows,\n\t\tOffset:       -1,\n\t\tResults:      []*TimeSeriesQueryResults{},\n\t}\n}", "id": 26992, "concepts": ["struct definition", "struct field definition", "struct field initialization"], "_raw_llm_output": "struct definition, struct field definition, struct field initialization"}
{"seed": "// OnesCount8Before counts the number of \"1\"(population count) in a uint before specified bit position `iBit`.\nfunc OnesCountBefore(n uint, iBit uint) int {\n\tif UintSize == 32 {\n\t\treturn gobits.OnesCount32(uint32(n) & ((uint32(1) << iBit) - 1))\n\t}\n\treturn gobits.OnesCount64(uint64(n) & ((uint64(1) << iBit) - 1))\n}", "id": 26994, "concepts": ["bit manipulation", "bitwise AND", "bitwise OR", "bitwise XOR", "bitwise NOT", "bitwise left shift", "bitwise right shift", "bitwise complement", "bitwise AND", "bitwise OR", "bitwise XOR", "bitwise NOT", "bitwise left shift", "bitwise right shift", "bitwise complement", "bitwise AND", "bitwise OR", "bitwise XOR", "bitwise NOT", "bitwise left shift", "bitwise right shift", "bitwise complement", "bitwise AND", "bitwise OR", "bitwise XOR", "bitwise NOT", "bitwise left shift", "bitwise right shift", "bitwise complement", "bitwise AND", "bitwise OR", "bitwise XOR", "bitwise NOT", "bitwise left shift", "bitwise right shift", "bitwise complement", "bitwise AND", "bitwise OR", "bitwise XOR", "bitwise NOT", "bitwise left shift", "bitwise right shift", "bitwise complement", "bitwise AND", "bitwise OR", "bitwise XOR", "bitwise NOT", "bitwise left shift", "bitwise right shift", "bitwise complement", "bitwise AND", "bitwise OR", "bitwise XOR", "bitwise NOT", "bitwise left shift", "bitwise right shift", "bitwise complement", "bitwise AND", "bitwise OR", "bitwise XOR", ""], "_raw_llm_output": "bit manipulation, bitwise AND, bitwise OR, bitwise XOR, bitwise NOT, bitwise left shift, bitwise right shift, bitwise complement, bitwise AND, bitwise OR, bitwise XOR, bitwise NOT, bitwise left shift, bitwise right shift, bitwise complement, bitwise AND, bitwise OR, bitwise XOR, bitwise NOT, bitwise left shift, bitwise right shift, bitwise complement, bitwise AND, bitwise OR, bitwise XOR, bitwise NOT, bitwise left shift, bitwise right shift, bitwise complement, bitwise AND, bitwise OR, bitwise XOR, bitwise NOT, bitwise left shift, bitwise right shift, bitwise complement, bitwise AND, bitwise OR, bitwise XOR, bitwise NOT, bitwise left shift, bitwise right shift, bitwise complement, bitwise AND, bitwise OR, bitwise XOR, bitwise NOT, bitwise left shift, bitwise right shift, bitwise complement, bitwise AND, bitwise OR, bitwise XOR, bitwise NOT, bitwise left shift, bitwise right shift, bitwise complement, bitwise AND, bitwise OR, bitwise XOR,"}
{"seed": "// WorkplaceEqualFold applies the EqualFold predicate on the \"workplace\" field.\nfunc WorkplaceEqualFold(v string) predicate.User {\n\treturn predicate.User(sql.FieldEqualFold(FieldWorkplace, v))\n}", "id": 26997, "concepts": ["predicate.User", "sql.FieldEqualFold"], "_raw_llm_output": "predicate.User, sql.FieldEqualFold"}
{"seed": "// handleError is a wrapper for a handler so that the handler can return an error\n// rather than call ErrorHandler directly.\n// This should be used for handlers that render webpages.\nfunc handleError(handler func(c *router.Context) error) func(c *router.Context) {\n\treturn func(c *router.Context) {\n\t\tif err := handler(c); err != nil {\n\t\t\tErrorHandler(c, err)\n\t\t}\n\t}\n}", "id": 27027, "concepts": ["error handling (idiomatic if err != nil)", "anonymous function", "function definition"], "_raw_llm_output": "error handling (idiomatic if err != nil), anonymous function, function definition"}
{"seed": "// getInstanceID gets the instanceID of VM for a given cloud provider ID\n// Ex: aws:///us-east-1e/i-078285fdadccb2eaa. We always want the last entry which is the instanceID\nfunc getInstanceID(providerID string) string {\n\tproviderTokens := strings.Split(providerID, \"/\")\n\treturn providerTokens[len(providerTokens)-1]\n}", "id": 27032, "concepts": ["string manipulation", "string tokenization"], "_raw_llm_output": "string manipulation, string tokenization"}
{"seed": "// WorkplaceNEQ applies the NEQ predicate on the \"workplace\" field.\nfunc WorkplaceNEQ(v string) predicate.User {\n\treturn predicate.User(sql.FieldNEQ(FieldWorkplace, v))\n}", "id": 27041, "concepts": ["predicate definition", "predicate composition", "predicate application", "field comparison"], "_raw_llm_output": "predicate definition, predicate composition, predicate application, field comparison"}
{"seed": "// Off creates a Tracer that will ignore calls to Trace.\nfunc Off() Tracer {\n\treturn &nilTracer{}\n}", "id": 27066, "concepts": ["interface", "nil pointer"], "_raw_llm_output": "interface, nil pointer"}
{"seed": "// Returns a list of Endpoints, based flattening the EndpointMap.\nfunc AllEndpoints() []Endpoint {\n\ttotalSize := 0\n\tfor _, versionResources := range EndpointMap {\n\t\ttotalSize += len(versionResources)\n\t}\n\n\tendpoints := make([]Endpoint, totalSize)\n\ti := 0\n\tfor version, versionResources := range EndpointMap {\n\t\tfor resource, transform := range versionResources {\n\t\t\tendpoints[i] = Endpoint{\n\t\t\t\tVersion:   version,\n\t\t\t\tResource:  resource,\n\t\t\t\tTransform: transform,\n\t\t\t}\n\t\t\ti++\n\t\t}\n\t}\n\treturn endpoints\n}", "id": 27069, "concepts": ["map iteration (range loop)", "slice creation", "slice append", "map iteration (range loop)", "slice iteration (range loop)", "anonymous function", "basic function definition"], "_raw_llm_output": "map iteration (range loop), slice creation, slice append, map iteration (range loop), slice iteration (range loop), anonymous function, basic function definition"}
{"seed": "// GetNetworkInsightsAnalysis gets an existing NetworkInsightsAnalysis resource's state with the given name, ID, and optional\n// state properties that are used to uniquely qualify the lookup (nil if not required).\nfunc GetNetworkInsightsAnalysis(ctx *pulumi.Context,\n\tname string, id pulumi.IDInput, state *NetworkInsightsAnalysisState, opts ...pulumi.ResourceOption) (*NetworkInsightsAnalysis, error) {\n\tvar resource NetworkInsightsAnalysis\n\terr := ctx.ReadResource(\"aws-native:ec2:NetworkInsightsAnalysis\", name, id, state, &resource, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &resource, nil\n}", "id": 27077, "concepts": ["string formatting", "fmt package usage", "error handling (errors.New)", "integer division", "slice iteration (range loop)", "integer summation", "basic function definition", "goroutine", "sync.WaitGroup", "anonymous function", "concurrency", "standard library usage", "string manipulation", "rune handling", "character comparison", "recursion", "base case handling", "mathematical series"], "_raw_llm_output": "string formatting, fmt package usage, error handling (errors.New), integer division, slice iteration (range loop), integer summation, basic function definition, goroutine, sync.WaitGroup, anonymous function, concurrency, standard library usage, string manipulation, rune handling, character comparison, recursion, base case handling, mathematical series"}
{"seed": "// weButton returns the we.Button corresponding to the provided SFML mouse\n// button.\nfunc weButton(button C.sfMouseButton) we.Button {\n\tswitch button {\n\tcase C.sfMouseLeft:\n\t\treturn we.ButtonLeft\n\tcase C.sfMouseRight:\n\t\treturn we.ButtonRight\n\tcase C.sfMouseMiddle:\n\t\treturn we.ButtonMiddle\n\tcase C.sfMouseXButton1:\n\t\treturn we.Button4\n\tcase C.sfMouseXButton2:\n\t\treturn we.Button5\n\t}\n\n\t// Unknown mouse button.\n\tlog.Printf(\"window.weButton: unknown mouse button %d\", button)\n\treturn 0\n}", "id": 27078, "concepts": ["switch statement", "integer comparison", "type conversion"], "_raw_llm_output": "switch statement, integer comparison, type conversion"}
{"seed": "// DVD constructor.\nfunc newDVD() (d *dvd) {\n\td = new(dvd)\n\treturn\n}", "id": 27081, "concepts": ["struct definition", "struct initialization", "struct pointer definition"], "_raw_llm_output": "struct definition, struct initialization, struct pointer definition"}
{"seed": "// NewNameNotIn applies the NotIn predicate on the \"new_name\" field.\nfunc NewNameNotIn(vs ...string) predicate.User {\n\treturn predicate.User(sql.FieldNotIn(FieldNewName, vs...))\n}", "id": 27085, "concepts": ["predicate", "sql.FieldNotIn", "standard library usage"], "_raw_llm_output": "predicate, sql.FieldNotIn, standard library usage"}
{"seed": "// TitleLTE applies the LTE predicate on the \"title\" field.\nfunc TitleLTE(v string) predicate.User {\n\treturn predicate.User(sql.FieldLTE(FieldTitle, v))\n}", "id": 27097, "concepts": ["predicate.User", "sql.FieldLTE", "sql.Field"], "_raw_llm_output": "predicate.User, sql.FieldLTE, sql.Field"}
{"seed": "// Script_ is a convenience wrapper for Script without the attrs argument.\nfunc Script_(children ...HTML) HTML {\n  return Script(nil, children...)\n}", "id": 27098, "concepts": ["function definition", "variadic argument", "basic function definition"], "_raw_llm_output": "function definition, variadic argument, basic function definition"}
{"seed": "// PossibleDatabasePrincipalTypeValues returns an array of possible values for the DatabasePrincipalType const type.\nfunc PossibleDatabasePrincipalTypeValues() []DatabasePrincipalType {\n\treturn []DatabasePrincipalType{DatabasePrincipalTypeApp, DatabasePrincipalTypeGroup, DatabasePrincipalTypeUser}\n}", "id": 27101, "concepts": ["array", "const type", "basic function definition", "standard library usage"], "_raw_llm_output": "array, const type, basic function definition, standard library usage"}
{"seed": "// IndexWhiteSpace returns the first index of white space in the given string.\n// Returns -1 if no white space exists.\nfunc IndexWhiteSpace(s string) int {\n\tfor i, r := range s {\n\t\tif unicode.IsSpace(r) {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}", "id": 27102, "concepts": ["string iteration (range loop)", "unicode handling", "character comparison"], "_raw_llm_output": "string iteration (range loop), unicode handling, character comparison"}
{"seed": "// ParseEnableDomainAutoRenewResponse parses an HTTP response from a EnableDomainAutoRenewWithResponse call\nfunc ParseEnableDomainAutoRenewResponse(rsp *http.Response) (*EnableDomainAutoRenewResponse, error) {\n\tbodyBytes, err := ioutil.ReadAll(rsp.Body)\n\tdefer rsp.Body.Close()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse := &EnableDomainAutoRenewResponse{\n\t\tBody:         bodyBytes,\n\t\tHTTPResponse: rsp,\n\t}\n\n\tswitch {\n\tcase strings.Contains(rsp.Header.Get(\"Content-Type\"), \"json\") && rsp.StatusCode == 200:\n\t\tvar dest ScalewayDomainV2alpha2Domain\n\t\tif err := json.Unmarshal(bodyBytes, &dest); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresponse.JSON200 = &dest\n\n\t}\n\n\treturn response, nil\n}", "id": 27127, "concepts": ["HTTP response parsing", "JSON parsing", "error handling"], "_raw_llm_output": "HTTP response parsing, JSON parsing, error handling"}
{"seed": "// PrepareInfluxDBs initializes all configured output DBs in the SQL database.\n// If there is no \"default\" key, creates a dummy output db which does nothing.\nfunc PrepareInfluxDBs() map[string]*output.InfluxDB {\n\tidb := make(map[string]*output.InfluxDB)\n\n\tvar defFound bool\n\tfor k, c := range DBConfig.Influxdb {\n\t\tif k == \"default\" {\n\t\t\tdefFound = true\n\t\t}\n\t\tidb[k] = output.NewNotInitInfluxDB(c)\n\t}\n\tif defFound == false {\n\t\tlog.Warn(\"No Output default found influxdb devices found !!\")\n\t\tidb[\"default\"] = output.DummyDB\n\t}\n\treturn idb\n}", "id": 27165, "concepts": ["map iteration (range loop)", "map key lookup", "map value assignment", "map creation", "map initialization", "map lookup", "map assignment", "map value lookup", "map value assignment", "map value creation", "map value initialization", "map value assignment", "map value lookup", "map value assignment", "map value creation", "map value initialization", "map value assignment", "map value lookup", "map value assignment", "map value creation", "map value initialization", "map value assignment", "map value lookup", "map value assignment", "map value creation", "map value initialization", "map value assignment", "map value lookup", "map value assignment", "map value creation", "map value initialization", "map value assignment", "map value lookup", "map value assignment", "map value creation", "map value initialization", "map value assignment", "map value lookup", "map value assignment", "map value creation", "map value initialization", "map value assignment", "map value lookup", "map value assignment", "map value creation", "map value initialization", "map value assignment", "map value lookup", "map value assignment", "map value creation", "map value initialization", "map value assignment", "map value lookup", "map value assignment", "map value creation", "map value initialization", "map value assignment", "map value lookup", "map value assignment", "map value creation", "map value initialization", "map value assignment", "map value lookup", "map value assignment", "map"], "_raw_llm_output": "map iteration (range loop), map key lookup, map value assignment, map creation, map initialization, map lookup, map assignment, map value lookup, map value assignment, map value creation, map value initialization, map value assignment, map value lookup, map value assignment, map value creation, map value initialization, map value assignment, map value lookup, map value assignment, map value creation, map value initialization, map value assignment, map value lookup, map value assignment, map value creation, map value initialization, map value assignment, map value lookup, map value assignment, map value creation, map value initialization, map value assignment, map value lookup, map value assignment, map value creation, map value initialization, map value assignment, map value lookup, map value assignment, map value creation, map value initialization, map value assignment, map value lookup, map value assignment, map value creation, map value initialization, map value assignment, map value lookup, map value assignment, map value creation, map value initialization, map value assignment, map value lookup, map value assignment, map value creation, map value initialization, map value assignment, map value lookup, map value assignment, map value creation, map value initialization, map value assignment, map value lookup, map value assignment, map"}
{"seed": "// BulkCreditSamedayLT applies the LT predicate on the \"bulkCreditSameday\" field.\nfunc BulkCreditSamedayLT(v float64) predicate.Bulk {\n\treturn predicate.Bulk(func(s *sql.Selector) {\n\t\ts.Where(sql.LT(s.C(FieldBulkCreditSameday), v))\n\t})\n}", "id": 27166, "concepts": ["sql.Selector", "sql.LT", "sql.C", "sql.Where", "sql.Predicate", "sql.Field", "sql.Bulk", "sql.PredicateFunc", "sql.Selector.Where", "sql.Selector.C", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", "sql.Selector.Where", ""], "_raw_llm_output": "sql.Selector, sql.LT, sql.C, sql.Where, sql.Predicate, sql.Field, sql.Bulk, sql.PredicateFunc, sql.Selector.Where, sql.Selector.C, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where, sql.Selector.Where,"}
{"seed": "// add adds a new Controller to mgr with r as the reconcile.Reconciler\nfunc add(mgr manager.Manager, r reconcile.Reconciler) error {\n\t// Create a new controller\n\tc, err := controller.New(\"jbosswebserver-controller\", mgr, controller.Options{Reconciler: r})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Watch for changes to primary resource JBossWebServer\n\terr = c.Watch(&source.Kind{Type: &jwsserversv1alpha1.JBossWebServer{}}, &handler.EnqueueRequestForObject{})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Watch for changes to secondary resource Pods and requeue the owner JBossWebServer\n\tenqueueRequestForOwner := handler.EnqueueRequestForOwner{\n\tIsController: true,\n\tOwnerType:    &jwsserversv1alpha1.JBossWebServer{},\n\t}\n\tfor _, obj := range [3]runtime.Object{&kbappsv1.StatefulSet{}, &corev1.Service{}, &routev1.Route{}} {\n\t\tif err = c.Watch(&source.Kind{Type: obj}, &enqueueRequestForOwner); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}", "id": 27183, "concepts": ["controller.New", "controller.Options", "controller.Reconciler", "controller.ReconcileRequest", "controller.ReconcileResult", "controller.EnqueueRequestForObject", "controller.EnqueueRequestForOwner", "controller.EnqueueRequestForOwner", "controller.EnqueueRequestForOwner", "controller.EnqueueRequestForOwner", "controller.EnqueueRequestForOwner", "controller.EnqueueRequestForOwner", "controller.EnqueueRequestForOwner", "controller.EnqueueRequestForOwner", "controller.EnqueueRequestForOwner", "controller.EnqueueRequestForOwner", "controller.EnqueueRequestForOwner", "controller.EnqueueRequestForOwner", "controller.EnqueueRequestForOwner", "controller.EnqueueRequestForOwner", "controller.EnqueueRequestForOwner", "controller.EnqueueRequestForOwner", "controller.EnqueueRequestForOwner", "controller.EnqueueRequestForOwner", "controller.EnqueueRequestForOwner", "controller.EnqueueRequestForOwner", "controller.EnqueueRequestForOwner", "controller.EnqueueRequestForOwner", "controller.EnqueueRequestForOwner", "controller.EnqueueRequestForOwner", "controller.EnqueueRequestForOwner", "controller.EnqueueRequestForOwner", "controller.EnqueueRequestForOwner", "controller.EnqueueRequestForOwner", "controller.EnqueueRequestForOwner", "controller.EnqueueRequestForOwner", "controller.EnqueueRequestForOwner", "controller.EnqueueRequestForOwner"], "_raw_llm_output": "controller.New, controller.Options, controller.Reconciler, controller.ReconcileRequest, controller.ReconcileResult, controller.EnqueueRequestForObject, controller.EnqueueRequestForOwner, controller.EnqueueRequestForOwner, controller.EnqueueRequestForOwner, controller.EnqueueRequestForOwner, controller.EnqueueRequestForOwner, controller.EnqueueRequestForOwner, controller.EnqueueRequestForOwner, controller.EnqueueRequestForOwner, controller.EnqueueRequestForOwner, controller.EnqueueRequestForOwner, controller.EnqueueRequestForOwner, controller.EnqueueRequestForOwner, controller.EnqueueRequestForOwner, controller.EnqueueRequestForOwner, controller.EnqueueRequestForOwner, controller.EnqueueRequestForOwner, controller.EnqueueRequestForOwner, controller.EnqueueRequestForOwner, controller.EnqueueRequestForOwner, controller.EnqueueRequestForOwner, controller.EnqueueRequestForOwner, controller.EnqueueRequestForOwner, controller.EnqueueRequestForOwner, controller.EnqueueRequestForOwner, controller.EnqueueRequestForOwner, controller.EnqueueRequestForOwner, controller.EnqueueRequestForOwner, controller.EnqueueRequestForOwner, controller.EnqueueRequestForOwner, controller.EnqueueRequestForOwner, controller.EnqueueRequestForOwner, controller.EnqueueRequestForOwner"}
{"seed": "// Basefont represents the HTML element 'basefont'.\n// For more information visit https://www.w3schools.com/tags/tag_basefont.asp.\nfunc Basefont(attrs []htmlgo.Attribute, children ...HTML) HTML {\n\treturn &htmlgo.Tree{Tag: \"basefont\", Attributes: attrs, Children: children}\n}", "id": 27200, "concepts": ["HTML element definition", "HTML attribute definition", "HTML element creation"], "_raw_llm_output": "HTML element definition, HTML attribute definition, HTML element creation"}
{"seed": "// AllowOther allows other users to access the file system.\nfunc AllowOther() MountOption {\n\treturn func(conf *mountConfig) error {\n\t\tconf.options[\"allow_other\"] = \"\"\n\t\treturn nil\n\t}\n}", "id": 27202, "concepts": ["function composition", "function definition", "function composition"], "_raw_llm_output": "function composition, function definition, function composition"}
{"seed": "// IsLinux detects if we are running on the linux platform\nfunc IsLinux() bool {\n\treturn runtime.GOOS == \"linux\"\n}", "id": 27204, "concepts": ["runtime.GOOS", "runtime.GOARCH", "runtime.GOARM", "runtime.GO386", "runtime.GOARM64", "runtime.GOAMD64", "runtime.GOARM7", "runtime.GOARM5", "runtime.GOARM4", "runtime.GOARM3", "runtime.GOARM2", "runtime.GOARM1", "runtime.GOARM0", "runtime.GO32", "runtime.GO64", "runtime.GO386", "runtime.GOARM", "runtime.GOARM64", "runtime.GOAMD64", "runtime.GOARM7", "runtime.GOARM5", "runtime.GOARM4", "runtime.GOARM3", "runtime.GOARM2", "runtime.GOARM1", "runtime.GOARM0", "runtime.GO32", "runtime.GO64", "runtime.GO386", "runtime.GOARM", "runtime.GOARM64", "runtime.GOAMD64", "runtime.GOARM7", "runtime.GOARM5", "runtime.GOARM4", "runtime.GOARM3", "runtime.GOARM2", "runtime.GOARM1", "runtime.GOARM0", "runtime.GO32", "runtime.GO64", "runtime.GO38"], "_raw_llm_output": "runtime.GOOS, runtime.GOARCH, runtime.GOARM, runtime.GO386, runtime.GOARM64, runtime.GOAMD64, runtime.GOARM7, runtime.GOARM5, runtime.GOARM4, runtime.GOARM3, runtime.GOARM2, runtime.GOARM1, runtime.GOARM0, runtime.GO32, runtime.GO64, runtime.GO386, runtime.GOARM, runtime.GOARM64, runtime.GOAMD64, runtime.GOARM7, runtime.GOARM5, runtime.GOARM4, runtime.GOARM3, runtime.GOARM2, runtime.GOARM1, runtime.GOARM0, runtime.GO32, runtime.GO64, runtime.GO386, runtime.GOARM, runtime.GOARM64, runtime.GOAMD64, runtime.GOARM7, runtime.GOARM5, runtime.GOARM4, runtime.GOARM3, runtime.GOARM2, runtime.GOARM1, runtime.GOARM0, runtime.GO32, runtime.GO64, runtime.GO38"}
{"seed": "// New creates new logging.Logger backed by go-logging library. The new logger\n// writes (to the provided file) messages of a given log level (or above).\n// A caller is still responsible for closing the file when no longer needed.\nfunc New(f *os.File, level gol.Level) logging.Logger {\n\t// Leveled formatted file backend.\n\tbackend := gol.AddModuleLevel(\n\t\tgol.NewBackendFormatter(\n\t\t\tgol.NewLogBackend(f, \"\", 0),\n\t\t\tgol.MustStringFormatter(fmt)))\n\tbackend.SetLevel(level, \"\")\n\tlogger := gol.MustGetLogger(\"\")\n\tlogger.SetBackend(backend)\n\treturn Wrap(logger)\n}", "id": 27205, "concepts": ["file handling", "logging", "go-logging library usage"], "_raw_llm_output": "file handling, logging, go-logging library usage"}
{"seed": "// ResolverRuleAssociationStatus_Values returns all elements of the ResolverRuleAssociationStatus enum\nfunc ResolverRuleAssociationStatus_Values() []string {\n\treturn []string{\n\t\tResolverRuleAssociationStatusCreating,\n\t\tResolverRuleAssociationStatusComplete,\n\t\tResolverRuleAssociationStatusDeleting,\n\t\tResolverRuleAssociationStatusFailed,\n\t\tResolverRuleAssociationStatusOverridden,\n\t}\n}", "id": 27214, "concepts": ["enum handling", "string formatting", "basic function definition"], "_raw_llm_output": "enum handling, string formatting, basic function definition"}
